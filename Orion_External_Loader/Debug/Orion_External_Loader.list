
Orion_External_Loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000494  24000004  24000004  00010004  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .ARM          00000008  24000498  24000498  00010498  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init_array   00000004  240004a0  240004a0  000104a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  240004a4  240004a4  000104a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000074  240004a8  240004a8  000104a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000001e0  2400051c  2400051c  0001051c  2**2
                  ALLOC
  6 .text         00017098  240006fc  240006fc  000106fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .Dev_info     000000c8  24017794  24017794  00037794  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rodata       00000060  2401785c  2401785c  0002785c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 ._user_heap_stack 00000600  240178bc  240178bc  000278bc  2**0
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  0003785c  2**0
                  CONTENTS, READONLY
 11 .comment      00000043  00000000  00000000  0003788a  2**0
                  CONTENTS, READONLY
 12 .debug_line   0001bd72  00000000  00000000  000378cd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_line_str 00000157  00000000  00000000  0005363f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_info   00014cba  00000000  00000000  00053796  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 00003602  00000000  00000000  00068450  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000011c0  00000000  00000000  0006ba58  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    00158919  00000000  00000000  0006cc18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00038f3e  00000000  00000000  001c5531  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00000d25  00000000  00000000  001fe46f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00004b38  00000000  00000000  001ff194  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

240006fc <__do_global_dtors_aux>:
240006fc:	b510      	push	{r4, lr}
240006fe:	4c05      	ldr	r4, [pc, #20]	; (24000714 <__do_global_dtors_aux+0x18>)
24000700:	7823      	ldrb	r3, [r4, #0]
24000702:	b933      	cbnz	r3, 24000712 <__do_global_dtors_aux+0x16>
24000704:	4b04      	ldr	r3, [pc, #16]	; (24000718 <__do_global_dtors_aux+0x1c>)
24000706:	b113      	cbz	r3, 2400070e <__do_global_dtors_aux+0x12>
24000708:	4804      	ldr	r0, [pc, #16]	; (2400071c <__do_global_dtors_aux+0x20>)
2400070a:	f3af 8000 	nop.w
2400070e:	2301      	movs	r3, #1
24000710:	7023      	strb	r3, [r4, #0]
24000712:	bd10      	pop	{r4, pc}
24000714:	2400051c 	.word	0x2400051c
24000718:	00000000 	.word	0x00000000
2400071c:	24017778 	.word	0x24017778

24000720 <frame_dummy>:
24000720:	b508      	push	{r3, lr}
24000722:	4b03      	ldr	r3, [pc, #12]	; (24000730 <frame_dummy+0x10>)
24000724:	b11b      	cbz	r3, 2400072e <frame_dummy+0xe>
24000726:	4903      	ldr	r1, [pc, #12]	; (24000734 <frame_dummy+0x14>)
24000728:	4803      	ldr	r0, [pc, #12]	; (24000738 <frame_dummy+0x18>)
2400072a:	f3af 8000 	nop.w
2400072e:	bd08      	pop	{r3, pc}
24000730:	00000000 	.word	0x00000000
24000734:	24000520 	.word	0x24000520
24000738:	24017778 	.word	0x24017778

2400073c <_stack_init>:
2400073c:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
24000740:	4770      	bx	lr
24000742:	bf00      	nop

24000744 <_mainCRTStartup>:
24000744:	4b17      	ldr	r3, [pc, #92]	; (240007a4 <_mainCRTStartup+0x60>)
24000746:	2b00      	cmp	r3, #0
24000748:	bf08      	it	eq
2400074a:	4b13      	ldreq	r3, [pc, #76]	; (24000798 <_mainCRTStartup+0x54>)
2400074c:	469d      	mov	sp, r3
2400074e:	f7ff fff5 	bl	2400073c <_stack_init>
24000752:	2100      	movs	r1, #0
24000754:	468b      	mov	fp, r1
24000756:	460f      	mov	r7, r1
24000758:	4813      	ldr	r0, [pc, #76]	; (240007a8 <_mainCRTStartup+0x64>)
2400075a:	4a14      	ldr	r2, [pc, #80]	; (240007ac <_mainCRTStartup+0x68>)
2400075c:	1a12      	subs	r2, r2, r0
2400075e:	f016 fd66 	bl	2401722e <memset>
24000762:	4b0e      	ldr	r3, [pc, #56]	; (2400079c <_mainCRTStartup+0x58>)
24000764:	2b00      	cmp	r3, #0
24000766:	d000      	beq.n	2400076a <_mainCRTStartup+0x26>
24000768:	4798      	blx	r3
2400076a:	4b0d      	ldr	r3, [pc, #52]	; (240007a0 <_mainCRTStartup+0x5c>)
2400076c:	2b00      	cmp	r3, #0
2400076e:	d000      	beq.n	24000772 <_mainCRTStartup+0x2e>
24000770:	4798      	blx	r3
24000772:	2000      	movs	r0, #0
24000774:	2100      	movs	r1, #0
24000776:	0004      	movs	r4, r0
24000778:	000d      	movs	r5, r1
2400077a:	480d      	ldr	r0, [pc, #52]	; (240007b0 <_mainCRTStartup+0x6c>)
2400077c:	2800      	cmp	r0, #0
2400077e:	d002      	beq.n	24000786 <_mainCRTStartup+0x42>
24000780:	480c      	ldr	r0, [pc, #48]	; (240007b4 <_mainCRTStartup+0x70>)
24000782:	f3af 8000 	nop.w
24000786:	f016 fdfd 	bl	24017384 <__libc_init_array>
2400078a:	0020      	movs	r0, r4
2400078c:	0029      	movs	r1, r5
2400078e:	f000 fabf 	bl	24000d10 <main>
24000792:	f016 fbad 	bl	24016ef0 <exit>
24000796:	bf00      	nop
24000798:	00080000 	.word	0x00080000
	...
240007a8:	2400051c 	.word	0x2400051c
240007ac:	240006fc 	.word	0x240006fc
	...
240007b8:	240004a8 	.word	0x240004a8
240007bc:	240004a8 	.word	0x240004a8
240007c0:	2400051c 	.word	0x2400051c
240007c4:	2400051c 	.word	0x2400051c
240007c8:	240006fc 	.word	0x240006fc

240007cc <Init>:
 * @brief  System initialization.
 * @param  None
 * @retval  LOADER_OK = 1	: Operation succeeded
 * @retval  LOADER_FAIL = 0	: Operation failed
 */
int Init(void) {
240007cc:	b580      	push	{r7, lr}
240007ce:	b086      	sub	sp, #24
240007d0:	af00      	add	r7, sp, #0

	*(uint32_t*)0xE000EDF0=0xA05F0000; //enable interrupts in debug
240007d2:	4b26      	ldr	r3, [pc, #152]	; (2400086c <Init+0xa0>)
240007d4:	4a26      	ldr	r2, [pc, #152]	; (24000870 <Init+0xa4>)
240007d6:	601a      	str	r2, [r3, #0]
	                

	SystemInit();
240007d8:	f001 fa96 	bl	24001d08 <SystemInit>
 * change VTOR setting for other devices
 * SCB->VTOR = 0x20000000 | 0x200;
 *
 * */

	SCB->VTOR = 0x24000000 | 0x200;
240007dc:	4b25      	ldr	r3, [pc, #148]	; (24000874 <Init+0xa8>)
240007de:	4a26      	ldr	r2, [pc, #152]	; (24000878 <Init+0xac>)
240007e0:	609a      	str	r2, [r3, #8]
240007e2:	2300      	movs	r3, #0
240007e4:	613b      	str	r3, [r7, #16]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240007e6:	693b      	ldr	r3, [r7, #16]
240007e8:	f383 8810 	msr	PRIMASK, r3
}
240007ec:	bf00      	nop
	
	__set_PRIMASK(0); //enable interrupts
	
	HAL_Init();
240007ee:	f001 fcb7 	bl	24002160 <HAL_Init>

    SystemClock_Config();
240007f2:	f000 fb39 	bl	24000e68 <SystemClock_Config>

    MX_GPIO_Init();
240007f6:	f000 fa43 	bl	24000c80 <MX_GPIO_Init>
	
	__HAL_RCC_QSPI_FORCE_RESET();  //completely reset peripheral
240007fa:	4b20      	ldr	r3, [pc, #128]	; (2400087c <Init+0xb0>)
240007fc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
240007fe:	4a1f      	ldr	r2, [pc, #124]	; (2400087c <Init+0xb0>)
24000800:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
24000804:	67d3      	str	r3, [r2, #124]	; 0x7c
    __HAL_RCC_QSPI_RELEASE_RESET();
24000806:	4b1d      	ldr	r3, [pc, #116]	; (2400087c <Init+0xb0>)
24000808:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
2400080a:	4a1c      	ldr	r2, [pc, #112]	; (2400087c <Init+0xb0>)
2400080c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
24000810:	67d3      	str	r3, [r2, #124]	; 0x7c

	if (CSP_QUADSPI_Init() != HAL_OK)
24000812:	f000 fcf5 	bl	24001200 <CSP_QUADSPI_Init>
24000816:	4603      	mov	r3, r0
24000818:	2b00      	cmp	r3, #0
2400081a:	d007      	beq.n	2400082c <Init+0x60>
2400081c:	2301      	movs	r3, #1
2400081e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000820:	68fb      	ldr	r3, [r7, #12]
24000822:	f383 8810 	msr	PRIMASK, r3
}
24000826:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
24000828:	2300      	movs	r3, #0
2400082a:	e01a      	b.n	24000862 <Init+0x96>
	}


	if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
2400082c:	f000 ffa8 	bl	24001780 <CSP_QSPI_EnableMemoryMappedMode>
24000830:	4603      	mov	r3, r0
24000832:	2b00      	cmp	r3, #0
24000834:	d007      	beq.n	24000846 <Init+0x7a>
24000836:	2301      	movs	r3, #1
24000838:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400083a:	68bb      	ldr	r3, [r7, #8]
2400083c:	f383 8810 	msr	PRIMASK, r3
}
24000840:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
24000842:	2300      	movs	r3, #0
24000844:	e00d      	b.n	24000862 <Init+0x96>
	}
	
	/*Trigger read access before HAL_QSPI_Abort() otherwise abort functionality gets stuck*/
	uint32_t a = *(uint32_t*) 0x90000000;
24000846:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000
2400084a:	681b      	ldr	r3, [r3, #0]
2400084c:	617b      	str	r3, [r7, #20]
	a++;
2400084e:	697b      	ldr	r3, [r7, #20]
24000850:	3301      	adds	r3, #1
24000852:	617b      	str	r3, [r7, #20]
24000854:	2301      	movs	r3, #1
24000856:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000858:	687b      	ldr	r3, [r7, #4]
2400085a:	f383 8810 	msr	PRIMASK, r3
}
2400085e:	bf00      	nop

		__set_PRIMASK(1); //disable interrupts
		return LOADER_OK;
24000860:	2301      	movs	r3, #1
}
24000862:	4618      	mov	r0, r3
24000864:	3718      	adds	r7, #24
24000866:	46bd      	mov	sp, r7
24000868:	bd80      	pop	{r7, pc}
2400086a:	bf00      	nop
2400086c:	e000edf0 	.word	0xe000edf0
24000870:	a05f0000 	.word	0xa05f0000
24000874:	e000ed00 	.word	0xe000ed00
24000878:	24000200 	.word	0x24000200
2400087c:	58024400 	.word	0x58024400

24000880 <Write>:
 * @param   Size   : size of data
 * @param   buffer : pointer to data buffer
 * @retval  LOADER_OK = 1		: Operation succeeded
 * @retval  LOADER_FAIL = 0	: Operation failed
 */
int Write(uint32_t Address, uint32_t Size, uint8_t* buffer) {
24000880:	b580      	push	{r7, lr}
24000882:	b088      	sub	sp, #32
24000884:	af00      	add	r7, sp, #0
24000886:	60f8      	str	r0, [r7, #12]
24000888:	60b9      	str	r1, [r7, #8]
2400088a:	607a      	str	r2, [r7, #4]
2400088c:	2300      	movs	r3, #0
2400088e:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000890:	69fb      	ldr	r3, [r7, #28]
24000892:	f383 8810 	msr	PRIMASK, r3
}
24000896:	bf00      	nop

	__set_PRIMASK(0); //enable interrupts

	if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
24000898:	4815      	ldr	r0, [pc, #84]	; (240008f0 <Write+0x70>)
2400089a:	f011 ff54 	bl	24012746 <HAL_QSPI_Abort>
2400089e:	4603      	mov	r3, r0
240008a0:	2b00      	cmp	r3, #0
240008a2:	d007      	beq.n	240008b4 <Write+0x34>
240008a4:	2301      	movs	r3, #1
240008a6:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240008a8:	69bb      	ldr	r3, [r7, #24]
240008aa:	f383 8810 	msr	PRIMASK, r3
}
240008ae:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
240008b0:	2300      	movs	r3, #0
240008b2:	e019      	b.n	240008e8 <Write+0x68>
	}


	if (CSP_QSPI_WriteMemory((uint8_t*) buffer, (Address & (0x0fffffff)),Size) != HAL_OK)
240008b4:	68fb      	ldr	r3, [r7, #12]
240008b6:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
240008ba:	68ba      	ldr	r2, [r7, #8]
240008bc:	4619      	mov	r1, r3
240008be:	6878      	ldr	r0, [r7, #4]
240008c0:	f000 fed2 	bl	24001668 <CSP_QSPI_WriteMemory>
240008c4:	4603      	mov	r3, r0
240008c6:	2b00      	cmp	r3, #0
240008c8:	d007      	beq.n	240008da <Write+0x5a>
240008ca:	2301      	movs	r3, #1
240008cc:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240008ce:	697b      	ldr	r3, [r7, #20]
240008d0:	f383 8810 	msr	PRIMASK, r3
}
240008d4:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
240008d6:	2300      	movs	r3, #0
240008d8:	e006      	b.n	240008e8 <Write+0x68>
240008da:	2301      	movs	r3, #1
240008dc:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240008de:	693b      	ldr	r3, [r7, #16]
240008e0:	f383 8810 	msr	PRIMASK, r3
}
240008e4:	bf00      	nop
	}

	__set_PRIMASK(1); //disable interrupts
	return LOADER_OK;
240008e6:	2301      	movs	r3, #1
}
240008e8:	4618      	mov	r0, r3
240008ea:	3720      	adds	r7, #32
240008ec:	46bd      	mov	sp, r7
240008ee:	bd80      	pop	{r7, pc}
240008f0:	24000538 	.word	0x24000538

240008f4 <SectorErase>:
 * @param   EraseStartAddress :  erase start address
 * @param   EraseEndAddress   :  erase end address
 * @retval  LOADER_OK = 1		: Operation succeeded
 * @retval  LOADER_FAIL = 0	: Operation failed
 */
int SectorErase(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
240008f4:	b580      	push	{r7, lr}
240008f6:	b086      	sub	sp, #24
240008f8:	af00      	add	r7, sp, #0
240008fa:	6078      	str	r0, [r7, #4]
240008fc:	6039      	str	r1, [r7, #0]
240008fe:	2300      	movs	r3, #0
24000900:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000902:	697b      	ldr	r3, [r7, #20]
24000904:	f383 8810 	msr	PRIMASK, r3
}
24000908:	bf00      	nop

	__set_PRIMASK(0); //enable interrupts

	if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
2400090a:	4814      	ldr	r0, [pc, #80]	; (2400095c <SectorErase+0x68>)
2400090c:	f011 ff1b 	bl	24012746 <HAL_QSPI_Abort>
24000910:	4603      	mov	r3, r0
24000912:	2b00      	cmp	r3, #0
24000914:	d007      	beq.n	24000926 <SectorErase+0x32>
24000916:	2301      	movs	r3, #1
24000918:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400091a:	693b      	ldr	r3, [r7, #16]
2400091c:	f383 8810 	msr	PRIMASK, r3
}
24000920:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
24000922:	2300      	movs	r3, #0
24000924:	e015      	b.n	24000952 <SectorErase+0x5e>
	}


	if (CSP_QSPI_EraseSector(EraseStartAddress, EraseEndAddress) != HAL_OK)
24000926:	6839      	ldr	r1, [r7, #0]
24000928:	6878      	ldr	r0, [r7, #4]
2400092a:	f000 fe4b 	bl	240015c4 <CSP_QSPI_EraseSector>
2400092e:	4603      	mov	r3, r0
24000930:	2b00      	cmp	r3, #0
24000932:	d007      	beq.n	24000944 <SectorErase+0x50>
24000934:	2301      	movs	r3, #1
24000936:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000938:	68fb      	ldr	r3, [r7, #12]
2400093a:	f383 8810 	msr	PRIMASK, r3
}
2400093e:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
24000940:	2300      	movs	r3, #0
24000942:	e006      	b.n	24000952 <SectorErase+0x5e>
24000944:	2301      	movs	r3, #1
24000946:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000948:	68bb      	ldr	r3, [r7, #8]
2400094a:	f383 8810 	msr	PRIMASK, r3
}
2400094e:	bf00      	nop
	}

	__set_PRIMASK(1); //disable interrupts
	return LOADER_OK;
24000950:	2301      	movs	r3, #1
}
24000952:	4618      	mov	r0, r3
24000954:	3718      	adds	r7, #24
24000956:	46bd      	mov	sp, r7
24000958:	bd80      	pop	{r7, pc}
2400095a:	bf00      	nop
2400095c:	24000538 	.word	0x24000538

24000960 <MassErase>:
 *      none
 * outputs   :
 *     none
 * Note: Optional for all types of device
 */
int MassErase(void) {
24000960:	b580      	push	{r7, lr}
24000962:	b084      	sub	sp, #16
24000964:	af00      	add	r7, sp, #0
24000966:	2300      	movs	r3, #0
24000968:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400096a:	68fb      	ldr	r3, [r7, #12]
2400096c:	f383 8810 	msr	PRIMASK, r3
}
24000970:	bf00      	nop

	__set_PRIMASK(0); //enable interrupts

	if(HAL_QSPI_Abort(&hqspi) != HAL_OK)
24000972:	4813      	ldr	r0, [pc, #76]	; (240009c0 <MassErase+0x60>)
24000974:	f011 fee7 	bl	24012746 <HAL_QSPI_Abort>
24000978:	4603      	mov	r3, r0
2400097a:	2b00      	cmp	r3, #0
2400097c:	d007      	beq.n	2400098e <MassErase+0x2e>
2400097e:	2301      	movs	r3, #1
24000980:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000982:	68bb      	ldr	r3, [r7, #8]
24000984:	f383 8810 	msr	PRIMASK, r3
}
24000988:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
2400098a:	2300      	movs	r3, #0
2400098c:	e013      	b.n	240009b6 <MassErase+0x56>
	}


	if (CSP_QSPI_Erase_Chip() != HAL_OK)
2400098e:	f000 fc6f 	bl	24001270 <CSP_QSPI_Erase_Chip>
24000992:	4603      	mov	r3, r0
24000994:	2b00      	cmp	r3, #0
24000996:	d007      	beq.n	240009a8 <MassErase+0x48>
24000998:	2301      	movs	r3, #1
2400099a:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2400099c:	687b      	ldr	r3, [r7, #4]
2400099e:	f383 8810 	msr	PRIMASK, r3
}
240009a2:	bf00      	nop
	{
		 __set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
240009a4:	2300      	movs	r3, #0
240009a6:	e006      	b.n	240009b6 <MassErase+0x56>
240009a8:	2301      	movs	r3, #1
240009aa:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
240009ac:	683b      	ldr	r3, [r7, #0]
240009ae:	f383 8810 	msr	PRIMASK, r3
}
240009b2:	bf00      	nop
	}

	__set_PRIMASK(1); //disable interrupts
	return LOADER_OK;
240009b4:	2301      	movs	r3, #1
}
240009b6:	4618      	mov	r0, r3
240009b8:	3710      	adds	r7, #16
240009ba:	46bd      	mov	sp, r7
240009bc:	bd80      	pop	{r7, pc}
240009be:	bf00      	nop
240009c0:	24000538 	.word	0x24000538

240009c4 <CheckSum>:
 *      InitVal       : Initial CRC value
 * outputs   :
 *     R0             : Checksum value
 * Note: Optional for all types of device
 */
uint32_t CheckSum(uint32_t StartAddress, uint32_t Size, uint32_t InitVal) {
240009c4:	b480      	push	{r7}
240009c6:	b089      	sub	sp, #36	; 0x24
240009c8:	af00      	add	r7, sp, #0
240009ca:	60f8      	str	r0, [r7, #12]
240009cc:	60b9      	str	r1, [r7, #8]
240009ce:	607a      	str	r2, [r7, #4]
	uint8_t missalignementAddress = StartAddress % 4;
240009d0:	68fb      	ldr	r3, [r7, #12]
240009d2:	b2db      	uxtb	r3, r3
240009d4:	f003 0303 	and.w	r3, r3, #3
240009d8:	77fb      	strb	r3, [r7, #31]
	uint8_t missalignementSize = Size;
240009da:	68bb      	ldr	r3, [r7, #8]
240009dc:	77bb      	strb	r3, [r7, #30]
	int cnt;
	uint32_t Val;

	StartAddress -= StartAddress % 4;
240009de:	68fb      	ldr	r3, [r7, #12]
240009e0:	f023 0303 	bic.w	r3, r3, #3
240009e4:	60fb      	str	r3, [r7, #12]
	Size += (Size % 4 == 0) ? 0 : 4 - (Size % 4);
240009e6:	68bb      	ldr	r3, [r7, #8]
240009e8:	f003 0303 	and.w	r3, r3, #3
240009ec:	2b00      	cmp	r3, #0
240009ee:	d005      	beq.n	240009fc <CheckSum+0x38>
240009f0:	68bb      	ldr	r3, [r7, #8]
240009f2:	f003 0303 	and.w	r3, r3, #3
240009f6:	f1c3 0304 	rsb	r3, r3, #4
240009fa:	e000      	b.n	240009fe <CheckSum+0x3a>
240009fc:	2300      	movs	r3, #0
240009fe:	68ba      	ldr	r2, [r7, #8]
24000a00:	4413      	add	r3, r2
24000a02:	60bb      	str	r3, [r7, #8]

	for (cnt = 0; cnt < Size; cnt += 4) {
24000a04:	2300      	movs	r3, #0
24000a06:	61bb      	str	r3, [r7, #24]
24000a08:	e0b3      	b.n	24000b72 <CheckSum+0x1ae>
		Val = *(uint32_t*) StartAddress;
24000a0a:	68fb      	ldr	r3, [r7, #12]
24000a0c:	681b      	ldr	r3, [r3, #0]
24000a0e:	617b      	str	r3, [r7, #20]
		if (missalignementAddress) {
24000a10:	7ffb      	ldrb	r3, [r7, #31]
24000a12:	2b00      	cmp	r3, #0
24000a14:	d040      	beq.n	24000a98 <CheckSum+0xd4>
			switch (missalignementAddress) {
24000a16:	7ffb      	ldrb	r3, [r7, #31]
24000a18:	2b03      	cmp	r3, #3
24000a1a:	d032      	beq.n	24000a82 <CheckSum+0xbe>
24000a1c:	2b03      	cmp	r3, #3
24000a1e:	f300 80a2 	bgt.w	24000b66 <CheckSum+0x1a2>
24000a22:	2b01      	cmp	r3, #1
24000a24:	d002      	beq.n	24000a2c <CheckSum+0x68>
24000a26:	2b02      	cmp	r3, #2
24000a28:	d019      	beq.n	24000a5e <CheckSum+0x9a>
24000a2a:	e09c      	b.n	24000b66 <CheckSum+0x1a2>
			case 1:
				InitVal += (uint8_t) (Val >> 8 & 0xff);
24000a2c:	697b      	ldr	r3, [r7, #20]
24000a2e:	0a1b      	lsrs	r3, r3, #8
24000a30:	b2db      	uxtb	r3, r3
24000a32:	461a      	mov	r2, r3
24000a34:	687b      	ldr	r3, [r7, #4]
24000a36:	4413      	add	r3, r2
24000a38:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 16 & 0xff);
24000a3a:	697b      	ldr	r3, [r7, #20]
24000a3c:	0c1b      	lsrs	r3, r3, #16
24000a3e:	b2db      	uxtb	r3, r3
24000a40:	461a      	mov	r2, r3
24000a42:	687b      	ldr	r3, [r7, #4]
24000a44:	4413      	add	r3, r2
24000a46:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 24 & 0xff);
24000a48:	697b      	ldr	r3, [r7, #20]
24000a4a:	0e1b      	lsrs	r3, r3, #24
24000a4c:	b2db      	uxtb	r3, r3
24000a4e:	461a      	mov	r2, r3
24000a50:	687b      	ldr	r3, [r7, #4]
24000a52:	4413      	add	r3, r2
24000a54:	607b      	str	r3, [r7, #4]
				missalignementAddress -= 1;
24000a56:	7ffb      	ldrb	r3, [r7, #31]
24000a58:	3b01      	subs	r3, #1
24000a5a:	77fb      	strb	r3, [r7, #31]
				break;
24000a5c:	e083      	b.n	24000b66 <CheckSum+0x1a2>
			case 2:
				InitVal += (uint8_t) (Val >> 16 & 0xff);
24000a5e:	697b      	ldr	r3, [r7, #20]
24000a60:	0c1b      	lsrs	r3, r3, #16
24000a62:	b2db      	uxtb	r3, r3
24000a64:	461a      	mov	r2, r3
24000a66:	687b      	ldr	r3, [r7, #4]
24000a68:	4413      	add	r3, r2
24000a6a:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 24 & 0xff);
24000a6c:	697b      	ldr	r3, [r7, #20]
24000a6e:	0e1b      	lsrs	r3, r3, #24
24000a70:	b2db      	uxtb	r3, r3
24000a72:	461a      	mov	r2, r3
24000a74:	687b      	ldr	r3, [r7, #4]
24000a76:	4413      	add	r3, r2
24000a78:	607b      	str	r3, [r7, #4]
				missalignementAddress -= 2;
24000a7a:	7ffb      	ldrb	r3, [r7, #31]
24000a7c:	3b02      	subs	r3, #2
24000a7e:	77fb      	strb	r3, [r7, #31]
				break;
24000a80:	e071      	b.n	24000b66 <CheckSum+0x1a2>
			case 3:
				InitVal += (uint8_t) (Val >> 24 & 0xff);
24000a82:	697b      	ldr	r3, [r7, #20]
24000a84:	0e1b      	lsrs	r3, r3, #24
24000a86:	b2db      	uxtb	r3, r3
24000a88:	461a      	mov	r2, r3
24000a8a:	687b      	ldr	r3, [r7, #4]
24000a8c:	4413      	add	r3, r2
24000a8e:	607b      	str	r3, [r7, #4]
				missalignementAddress -= 3;
24000a90:	7ffb      	ldrb	r3, [r7, #31]
24000a92:	3b03      	subs	r3, #3
24000a94:	77fb      	strb	r3, [r7, #31]
				break;
24000a96:	e066      	b.n	24000b66 <CheckSum+0x1a2>
			}
		} else if ((Size - missalignementSize) % 4 && (Size - cnt) <= 4) {
24000a98:	7fbb      	ldrb	r3, [r7, #30]
24000a9a:	68ba      	ldr	r2, [r7, #8]
24000a9c:	1ad3      	subs	r3, r2, r3
24000a9e:	f003 0303 	and.w	r3, r3, #3
24000aa2:	2b00      	cmp	r3, #0
24000aa4:	d044      	beq.n	24000b30 <CheckSum+0x16c>
24000aa6:	69bb      	ldr	r3, [r7, #24]
24000aa8:	68ba      	ldr	r2, [r7, #8]
24000aaa:	1ad3      	subs	r3, r2, r3
24000aac:	2b04      	cmp	r3, #4
24000aae:	d83f      	bhi.n	24000b30 <CheckSum+0x16c>
			switch (Size - missalignementSize) {
24000ab0:	7fbb      	ldrb	r3, [r7, #30]
24000ab2:	68ba      	ldr	r2, [r7, #8]
24000ab4:	1ad3      	subs	r3, r2, r3
24000ab6:	2b03      	cmp	r3, #3
24000ab8:	d02f      	beq.n	24000b1a <CheckSum+0x156>
24000aba:	2b03      	cmp	r3, #3
24000abc:	d853      	bhi.n	24000b66 <CheckSum+0x1a2>
24000abe:	2b01      	cmp	r3, #1
24000ac0:	d002      	beq.n	24000ac8 <CheckSum+0x104>
24000ac2:	2b02      	cmp	r3, #2
24000ac4:	d018      	beq.n	24000af8 <CheckSum+0x134>
24000ac6:	e04e      	b.n	24000b66 <CheckSum+0x1a2>
			case 1:
				InitVal += (uint8_t) Val;
24000ac8:	697b      	ldr	r3, [r7, #20]
24000aca:	b2db      	uxtb	r3, r3
24000acc:	461a      	mov	r2, r3
24000ace:	687b      	ldr	r3, [r7, #4]
24000ad0:	4413      	add	r3, r2
24000ad2:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 8 & 0xff);
24000ad4:	697b      	ldr	r3, [r7, #20]
24000ad6:	0a1b      	lsrs	r3, r3, #8
24000ad8:	b2db      	uxtb	r3, r3
24000ada:	461a      	mov	r2, r3
24000adc:	687b      	ldr	r3, [r7, #4]
24000ade:	4413      	add	r3, r2
24000ae0:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 16 & 0xff);
24000ae2:	697b      	ldr	r3, [r7, #20]
24000ae4:	0c1b      	lsrs	r3, r3, #16
24000ae6:	b2db      	uxtb	r3, r3
24000ae8:	461a      	mov	r2, r3
24000aea:	687b      	ldr	r3, [r7, #4]
24000aec:	4413      	add	r3, r2
24000aee:	607b      	str	r3, [r7, #4]
				missalignementSize -= 1;
24000af0:	7fbb      	ldrb	r3, [r7, #30]
24000af2:	3b01      	subs	r3, #1
24000af4:	77bb      	strb	r3, [r7, #30]
				break;
24000af6:	e01a      	b.n	24000b2e <CheckSum+0x16a>
			case 2:
				InitVal += (uint8_t) Val;
24000af8:	697b      	ldr	r3, [r7, #20]
24000afa:	b2db      	uxtb	r3, r3
24000afc:	461a      	mov	r2, r3
24000afe:	687b      	ldr	r3, [r7, #4]
24000b00:	4413      	add	r3, r2
24000b02:	607b      	str	r3, [r7, #4]
				InitVal += (uint8_t) (Val >> 8 & 0xff);
24000b04:	697b      	ldr	r3, [r7, #20]
24000b06:	0a1b      	lsrs	r3, r3, #8
24000b08:	b2db      	uxtb	r3, r3
24000b0a:	461a      	mov	r2, r3
24000b0c:	687b      	ldr	r3, [r7, #4]
24000b0e:	4413      	add	r3, r2
24000b10:	607b      	str	r3, [r7, #4]
				missalignementSize -= 2;
24000b12:	7fbb      	ldrb	r3, [r7, #30]
24000b14:	3b02      	subs	r3, #2
24000b16:	77bb      	strb	r3, [r7, #30]
				break;
24000b18:	e009      	b.n	24000b2e <CheckSum+0x16a>
			case 3:
				InitVal += (uint8_t) Val;
24000b1a:	697b      	ldr	r3, [r7, #20]
24000b1c:	b2db      	uxtb	r3, r3
24000b1e:	461a      	mov	r2, r3
24000b20:	687b      	ldr	r3, [r7, #4]
24000b22:	4413      	add	r3, r2
24000b24:	607b      	str	r3, [r7, #4]
				missalignementSize -= 3;
24000b26:	7fbb      	ldrb	r3, [r7, #30]
24000b28:	3b03      	subs	r3, #3
24000b2a:	77bb      	strb	r3, [r7, #30]
				break;
24000b2c:	bf00      	nop
			switch (Size - missalignementSize) {
24000b2e:	e01a      	b.n	24000b66 <CheckSum+0x1a2>
			}
		} else {
			InitVal += (uint8_t) Val;
24000b30:	697b      	ldr	r3, [r7, #20]
24000b32:	b2db      	uxtb	r3, r3
24000b34:	461a      	mov	r2, r3
24000b36:	687b      	ldr	r3, [r7, #4]
24000b38:	4413      	add	r3, r2
24000b3a:	607b      	str	r3, [r7, #4]
			InitVal += (uint8_t) (Val >> 8 & 0xff);
24000b3c:	697b      	ldr	r3, [r7, #20]
24000b3e:	0a1b      	lsrs	r3, r3, #8
24000b40:	b2db      	uxtb	r3, r3
24000b42:	461a      	mov	r2, r3
24000b44:	687b      	ldr	r3, [r7, #4]
24000b46:	4413      	add	r3, r2
24000b48:	607b      	str	r3, [r7, #4]
			InitVal += (uint8_t) (Val >> 16 & 0xff);
24000b4a:	697b      	ldr	r3, [r7, #20]
24000b4c:	0c1b      	lsrs	r3, r3, #16
24000b4e:	b2db      	uxtb	r3, r3
24000b50:	461a      	mov	r2, r3
24000b52:	687b      	ldr	r3, [r7, #4]
24000b54:	4413      	add	r3, r2
24000b56:	607b      	str	r3, [r7, #4]
			InitVal += (uint8_t) (Val >> 24 & 0xff);
24000b58:	697b      	ldr	r3, [r7, #20]
24000b5a:	0e1b      	lsrs	r3, r3, #24
24000b5c:	b2db      	uxtb	r3, r3
24000b5e:	461a      	mov	r2, r3
24000b60:	687b      	ldr	r3, [r7, #4]
24000b62:	4413      	add	r3, r2
24000b64:	607b      	str	r3, [r7, #4]
		}
		StartAddress += 4;
24000b66:	68fb      	ldr	r3, [r7, #12]
24000b68:	3304      	adds	r3, #4
24000b6a:	60fb      	str	r3, [r7, #12]
	for (cnt = 0; cnt < Size; cnt += 4) {
24000b6c:	69bb      	ldr	r3, [r7, #24]
24000b6e:	3304      	adds	r3, #4
24000b70:	61bb      	str	r3, [r7, #24]
24000b72:	69bb      	ldr	r3, [r7, #24]
24000b74:	68ba      	ldr	r2, [r7, #8]
24000b76:	429a      	cmp	r2, r3
24000b78:	f63f af47 	bhi.w	24000a0a <CheckSum+0x46>
	}

	return (InitVal);
24000b7c:	687b      	ldr	r3, [r7, #4]
}
24000b7e:	4618      	mov	r0, r3
24000b80:	3724      	adds	r7, #36	; 0x24
24000b82:	46bd      	mov	sp, r7
24000b84:	f85d 7b04 	ldr.w	r7, [sp], #4
24000b88:	4770      	bx	lr

24000b8a <Verify>:
 * outputs   :
 *     R0             : Operation failed (address of failure)
 *     R1             : Checksum value
 * Note: Optional for all types of device
 */
uint64_t Verify(uint32_t MemoryAddr, uint32_t RAMBufferAddr, uint32_t Size,uint32_t missalignement){
24000b8a:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
24000b8e:	b08c      	sub	sp, #48	; 0x30
24000b90:	af00      	add	r7, sp, #0
24000b92:	60f8      	str	r0, [r7, #12]
24000b94:	60b9      	str	r1, [r7, #8]
24000b96:	607a      	str	r2, [r7, #4]
24000b98:	603b      	str	r3, [r7, #0]
24000b9a:	2300      	movs	r3, #0
24000b9c:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000b9e:	69fb      	ldr	r3, [r7, #28]
24000ba0:	f383 8810 	msr	PRIMASK, r3
}
24000ba4:	bf00      	nop

	__set_PRIMASK(0); //enable interrupts
	uint32_t VerifiedData = 0, InitVal = 0;
24000ba6:	2300      	movs	r3, #0
24000ba8:	62fb      	str	r3, [r7, #44]	; 0x2c
24000baa:	2300      	movs	r3, #0
24000bac:	62bb      	str	r3, [r7, #40]	; 0x28
	uint64_t checksum;
	Size *= 4;
24000bae:	687b      	ldr	r3, [r7, #4]
24000bb0:	009b      	lsls	r3, r3, #2
24000bb2:	607b      	str	r3, [r7, #4]

	if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK)
24000bb4:	f000 fde4 	bl	24001780 <CSP_QSPI_EnableMemoryMappedMode>
24000bb8:	4603      	mov	r3, r0
24000bba:	2b00      	cmp	r3, #0
24000bbc:	d00a      	beq.n	24000bd4 <Verify+0x4a>
24000bbe:	2301      	movs	r3, #1
24000bc0:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000bc2:	69bb      	ldr	r3, [r7, #24]
24000bc4:	f383 8810 	msr	PRIMASK, r3
}
24000bc8:	bf00      	nop
	{
		__set_PRIMASK(1); //disable interrupts
		return LOADER_FAIL;
24000bca:	f04f 0400 	mov.w	r4, #0
24000bce:	f04f 0500 	mov.w	r5, #0
24000bd2:	e04d      	b.n	24000c70 <Verify+0xe6>
	}

	checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
24000bd4:	683b      	ldr	r3, [r7, #0]
24000bd6:	f003 020f 	and.w	r2, r3, #15
24000bda:	68fb      	ldr	r3, [r7, #12]
24000bdc:	18d0      	adds	r0, r2, r3
			Size - ((missalignement >> 16) & 0xF), InitVal);
24000bde:	683b      	ldr	r3, [r7, #0]
24000be0:	0c1b      	lsrs	r3, r3, #16
24000be2:	f003 030f 	and.w	r3, r3, #15
	checksum = CheckSum((uint32_t) MemoryAddr + (missalignement & 0xf),
24000be6:	687a      	ldr	r2, [r7, #4]
24000be8:	1ad3      	subs	r3, r2, r3
24000bea:	6aba      	ldr	r2, [r7, #40]	; 0x28
24000bec:	4619      	mov	r1, r3
24000bee:	f7ff fee9 	bl	240009c4 <CheckSum>
24000bf2:	4603      	mov	r3, r0
24000bf4:	2200      	movs	r2, #0
24000bf6:	469a      	mov	sl, r3
24000bf8:	4693      	mov	fp, r2
24000bfa:	e9c7 ab08 	strd	sl, fp, [r7, #32]
	while (Size > VerifiedData) {
24000bfe:	e025      	b.n	24000c4c <Verify+0xc2>
		if (*(uint8_t*) MemoryAddr++
24000c00:	68fb      	ldr	r3, [r7, #12]
24000c02:	1c5a      	adds	r2, r3, #1
24000c04:	60fa      	str	r2, [r7, #12]
24000c06:	781a      	ldrb	r2, [r3, #0]
				!= *((uint8_t*) RAMBufferAddr + VerifiedData)){
24000c08:	6af9      	ldr	r1, [r7, #44]	; 0x2c
24000c0a:	68bb      	ldr	r3, [r7, #8]
24000c0c:	440b      	add	r3, r1
24000c0e:	781b      	ldrb	r3, [r3, #0]
		if (*(uint8_t*) MemoryAddr++
24000c10:	429a      	cmp	r2, r3
24000c12:	d018      	beq.n	24000c46 <Verify+0xbc>
24000c14:	2301      	movs	r3, #1
24000c16:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000c18:	697b      	ldr	r3, [r7, #20]
24000c1a:	f383 8810 	msr	PRIMASK, r3
}
24000c1e:	bf00      	nop
			__set_PRIMASK(1); //disable interrupts
			return ((checksum << 32) + (MemoryAddr + VerifiedData));
24000c20:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
24000c24:	f04f 0200 	mov.w	r2, #0
24000c28:	f04f 0300 	mov.w	r3, #0
24000c2c:	0003      	movs	r3, r0
24000c2e:	2200      	movs	r2, #0
24000c30:	68f8      	ldr	r0, [r7, #12]
24000c32:	6af9      	ldr	r1, [r7, #44]	; 0x2c
24000c34:	4401      	add	r1, r0
24000c36:	2000      	movs	r0, #0
24000c38:	4688      	mov	r8, r1
24000c3a:	4681      	mov	r9, r0
24000c3c:	eb12 0408 	adds.w	r4, r2, r8
24000c40:	eb43 0509 	adc.w	r5, r3, r9
24000c44:	e014      	b.n	24000c70 <Verify+0xe6>
		}
		VerifiedData++;
24000c46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24000c48:	3301      	adds	r3, #1
24000c4a:	62fb      	str	r3, [r7, #44]	; 0x2c
	while (Size > VerifiedData) {
24000c4c:	687a      	ldr	r2, [r7, #4]
24000c4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24000c50:	429a      	cmp	r2, r3
24000c52:	d8d5      	bhi.n	24000c00 <Verify+0x76>
24000c54:	2301      	movs	r3, #1
24000c56:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
24000c58:	693b      	ldr	r3, [r7, #16]
24000c5a:	f383 8810 	msr	PRIMASK, r3
}
24000c5e:	bf00      	nop
	}

	__set_PRIMASK(1); //disable interrupts
	return (checksum << 32);
24000c60:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
24000c64:	f04f 0400 	mov.w	r4, #0
24000c68:	f04f 0500 	mov.w	r5, #0
24000c6c:	0015      	movs	r5, r2
24000c6e:	2400      	movs	r4, #0
}
24000c70:	4622      	mov	r2, r4
24000c72:	462b      	mov	r3, r5
24000c74:	4610      	mov	r0, r2
24000c76:	4619      	mov	r1, r3
24000c78:	3730      	adds	r7, #48	; 0x30
24000c7a:	46bd      	mov	sp, r7
24000c7c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

24000c80 <MX_GPIO_Init>:
/** Configure pins
     PH0-OSC_IN (PH0)   ------> RCC_OSC_IN
     PH1-OSC_OUT (PH1)   ------> RCC_OSC_OUT
*/
void MX_GPIO_Init(void)
{
24000c80:	b480      	push	{r7}
24000c82:	b085      	sub	sp, #20
24000c84:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
24000c86:	4b21      	ldr	r3, [pc, #132]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000c88:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000c8c:	4a1f      	ldr	r2, [pc, #124]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000c8e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24000c92:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000c96:	4b1d      	ldr	r3, [pc, #116]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000c98:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000c9c:	f003 0380 	and.w	r3, r3, #128	; 0x80
24000ca0:	60fb      	str	r3, [r7, #12]
24000ca2:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
24000ca4:	4b19      	ldr	r3, [pc, #100]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000ca6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000caa:	4a18      	ldr	r2, [pc, #96]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000cac:	f043 0302 	orr.w	r3, r3, #2
24000cb0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000cb4:	4b15      	ldr	r3, [pc, #84]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000cb6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000cba:	f003 0302 	and.w	r3, r3, #2
24000cbe:	60bb      	str	r3, [r7, #8]
24000cc0:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOE_CLK_ENABLE();
24000cc2:	4b12      	ldr	r3, [pc, #72]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000cc4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000cc8:	4a10      	ldr	r2, [pc, #64]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000cca:	f043 0310 	orr.w	r3, r3, #16
24000cce:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000cd2:	4b0e      	ldr	r3, [pc, #56]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000cd4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000cd8:	f003 0310 	and.w	r3, r3, #16
24000cdc:	607b      	str	r3, [r7, #4]
24000cde:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
24000ce0:	4b0a      	ldr	r3, [pc, #40]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000ce2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000ce6:	4a09      	ldr	r2, [pc, #36]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000ce8:	f043 0304 	orr.w	r3, r3, #4
24000cec:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24000cf0:	4b06      	ldr	r3, [pc, #24]	; (24000d0c <MX_GPIO_Init+0x8c>)
24000cf2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24000cf6:	f003 0304 	and.w	r3, r3, #4
24000cfa:	603b      	str	r3, [r7, #0]
24000cfc:	683b      	ldr	r3, [r7, #0]

}
24000cfe:	bf00      	nop
24000d00:	3714      	adds	r7, #20
24000d02:	46bd      	mov	sp, r7
24000d04:	f85d 7b04 	ldr.w	r7, [sp], #4
24000d08:	4770      	bx	lr
24000d0a:	bf00      	nop
24000d0c:	58024400 	.word	0x58024400

24000d10 <main>:

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {
24000d10:	b580      	push	{r7, lr}
24000d12:	f5ad 5d80 	sub.w	sp, sp, #4096	; 0x1000
24000d16:	b082      	sub	sp, #8
24000d18:	af00      	add	r7, sp, #0
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
24000d1a:	f001 fa21 	bl	24002160 <HAL_Init>
	/* USER CODE BEGIN Init */

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();
24000d1e:	f000 f8a3 	bl	24000e68 <SystemClock_Config>
	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
24000d22:	f7ff ffad 	bl	24000c80 <MX_GPIO_Init>
	MX_QUADSPI_Init();
24000d26:	f000 f953 	bl	24000fd0 <MX_QUADSPI_Init>
	/* USER CODE BEGIN 2 */
	uint8_t buffer_test[MEMORY_SECTOR_SIZE];
	uint32_t var = 0;
24000d2a:	2300      	movs	r3, #0
24000d2c:	f241 0204 	movw	r2, #4100	; 0x1004
24000d30:	443a      	add	r2, r7
24000d32:	6013      	str	r3, [r2, #0]

	CSP_QUADSPI_Init();
24000d34:	f000 fa64 	bl	24001200 <CSP_QUADSPI_Init>

	for (var = 0; var < MEMORY_SECTOR_SIZE; var++) {
24000d38:	2300      	movs	r3, #0
24000d3a:	f241 0204 	movw	r2, #4100	; 0x1004
24000d3e:	443a      	add	r2, r7
24000d40:	6013      	str	r3, [r2, #0]
24000d42:	e017      	b.n	24000d74 <main+0x64>
		buffer_test[var] = (var & 0xff);
24000d44:	f241 0304 	movw	r3, #4100	; 0x1004
24000d48:	443b      	add	r3, r7
24000d4a:	681b      	ldr	r3, [r3, #0]
24000d4c:	b2da      	uxtb	r2, r3
24000d4e:	f107 0308 	add.w	r3, r7, #8
24000d52:	4619      	mov	r1, r3
24000d54:	f241 0304 	movw	r3, #4100	; 0x1004
24000d58:	443b      	add	r3, r7
24000d5a:	681b      	ldr	r3, [r3, #0]
24000d5c:	440b      	add	r3, r1
24000d5e:	3b04      	subs	r3, #4
24000d60:	701a      	strb	r2, [r3, #0]
	for (var = 0; var < MEMORY_SECTOR_SIZE; var++) {
24000d62:	f241 0304 	movw	r3, #4100	; 0x1004
24000d66:	443b      	add	r3, r7
24000d68:	681b      	ldr	r3, [r3, #0]
24000d6a:	3301      	adds	r3, #1
24000d6c:	f241 0204 	movw	r2, #4100	; 0x1004
24000d70:	443a      	add	r2, r7
24000d72:	6013      	str	r3, [r2, #0]
24000d74:	f241 0304 	movw	r3, #4100	; 0x1004
24000d78:	443b      	add	r3, r7
24000d7a:	681b      	ldr	r3, [r3, #0]
24000d7c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24000d80:	d3e0      	bcc.n	24000d44 <main+0x34>
	}

	for (var = 0; var < SECTORS_COUNT; var++) {
24000d82:	2300      	movs	r3, #0
24000d84:	f241 0204 	movw	r2, #4100	; 0x1004
24000d88:	443a      	add	r2, r7
24000d8a:	6013      	str	r3, [r2, #0]
24000d8c:	e030      	b.n	24000df0 <main+0xe0>

		if (CSP_QSPI_EraseSector(var * MEMORY_SECTOR_SIZE,
24000d8e:	f241 0304 	movw	r3, #4100	; 0x1004
24000d92:	443b      	add	r3, r7
24000d94:	681b      	ldr	r3, [r3, #0]
24000d96:	031a      	lsls	r2, r3, #12
				(var + 1) * MEMORY_SECTOR_SIZE - 1) != HAL_OK) {
24000d98:	f241 0304 	movw	r3, #4100	; 0x1004
24000d9c:	443b      	add	r3, r7
24000d9e:	681b      	ldr	r3, [r3, #0]
24000da0:	3301      	adds	r3, #1
24000da2:	031b      	lsls	r3, r3, #12
		if (CSP_QSPI_EraseSector(var * MEMORY_SECTOR_SIZE,
24000da4:	3b01      	subs	r3, #1
24000da6:	4619      	mov	r1, r3
24000da8:	4610      	mov	r0, r2
24000daa:	f000 fc0b 	bl	240015c4 <CSP_QSPI_EraseSector>
24000dae:	4603      	mov	r3, r0
24000db0:	2b00      	cmp	r3, #0
24000db2:	d000      	beq.n	24000db6 <main+0xa6>

			while (1)
24000db4:	e7fe      	b.n	24000db4 <main+0xa4>
				;  //breakpoint - error detected
		}

		if (CSP_QSPI_WriteMemory(buffer_test, var * MEMORY_SECTOR_SIZE,
24000db6:	f241 0304 	movw	r3, #4100	; 0x1004
24000dba:	443b      	add	r3, r7
24000dbc:	681b      	ldr	r3, [r3, #0]
24000dbe:	0319      	lsls	r1, r3, #12
24000dc0:	4b28      	ldr	r3, [pc, #160]	; (24000e64 <main+0x154>)
24000dc2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
24000dc6:	f103 0308 	add.w	r3, r3, #8
24000dca:	443b      	add	r3, r7
24000dcc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
24000dd0:	4618      	mov	r0, r3
24000dd2:	f000 fc49 	bl	24001668 <CSP_QSPI_WriteMemory>
24000dd6:	4603      	mov	r3, r0
24000dd8:	2b00      	cmp	r3, #0
24000dda:	d000      	beq.n	24000dde <main+0xce>
				sizeof(buffer_test)) != HAL_OK) {

			while (1)
24000ddc:	e7fe      	b.n	24000ddc <main+0xcc>
	for (var = 0; var < SECTORS_COUNT; var++) {
24000dde:	f241 0304 	movw	r3, #4100	; 0x1004
24000de2:	443b      	add	r3, r7
24000de4:	681b      	ldr	r3, [r3, #0]
24000de6:	3301      	adds	r3, #1
24000de8:	f241 0204 	movw	r2, #4100	; 0x1004
24000dec:	443a      	add	r2, r7
24000dee:	6013      	str	r3, [r2, #0]
24000df0:	f241 0304 	movw	r3, #4100	; 0x1004
24000df4:	443b      	add	r3, r7
24000df6:	681b      	ldr	r3, [r3, #0]
24000df8:	2b63      	cmp	r3, #99	; 0x63
24000dfa:	d9c8      	bls.n	24000d8e <main+0x7e>
				;  //breakpoint - error detected
		}

	}

	if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK) {
24000dfc:	f000 fcc0 	bl	24001780 <CSP_QSPI_EnableMemoryMappedMode>
24000e00:	4603      	mov	r3, r0
24000e02:	2b00      	cmp	r3, #0
24000e04:	d000      	beq.n	24000e08 <main+0xf8>

		while (1)
24000e06:	e7fe      	b.n	24000e06 <main+0xf6>
			; //breakpoint - error detected
	}

	for (var = 0; var < SECTORS_COUNT; var++) {
24000e08:	2300      	movs	r3, #0
24000e0a:	f241 0204 	movw	r2, #4100	; 0x1004
24000e0e:	443a      	add	r2, r7
24000e10:	6013      	str	r3, [r2, #0]
24000e12:	e01f      	b.n	24000e54 <main+0x144>
		if (memcmp(buffer_test,
				(uint8_t*) (0x90000000 + var * MEMORY_SECTOR_SIZE),
24000e14:	f241 0304 	movw	r3, #4100	; 0x1004
24000e18:	443b      	add	r3, r7
24000e1a:	681b      	ldr	r3, [r3, #0]
24000e1c:	f503 2310 	add.w	r3, r3, #589824	; 0x90000
24000e20:	031b      	lsls	r3, r3, #12
		if (memcmp(buffer_test,
24000e22:	4619      	mov	r1, r3
24000e24:	4b0f      	ldr	r3, [pc, #60]	; (24000e64 <main+0x154>)
24000e26:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
24000e2a:	f103 0308 	add.w	r3, r3, #8
24000e2e:	443b      	add	r3, r7
24000e30:	f44f 5280 	mov.w	r2, #4096	; 0x1000
24000e34:	4618      	mov	r0, r3
24000e36:	f016 f9ea 	bl	2401720e <memcmp>
24000e3a:	4603      	mov	r3, r0
24000e3c:	2b00      	cmp	r3, #0
24000e3e:	d000      	beq.n	24000e42 <main+0x132>
				MEMORY_SECTOR_SIZE) != HAL_OK) {
			while (1)
24000e40:	e7fe      	b.n	24000e40 <main+0x130>
	for (var = 0; var < SECTORS_COUNT; var++) {
24000e42:	f241 0304 	movw	r3, #4100	; 0x1004
24000e46:	443b      	add	r3, r7
24000e48:	681b      	ldr	r3, [r3, #0]
24000e4a:	3301      	adds	r3, #1
24000e4c:	f241 0204 	movw	r2, #4100	; 0x1004
24000e50:	443a      	add	r2, r7
24000e52:	6013      	str	r3, [r2, #0]
24000e54:	f241 0304 	movw	r3, #4100	; 0x1004
24000e58:	443b      	add	r3, r7
24000e5a:	681b      	ldr	r3, [r3, #0]
24000e5c:	2b63      	cmp	r3, #99	; 0x63
24000e5e:	d9d9      	bls.n	24000e14 <main+0x104>

	/* USER CODE END 2 */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1) {
24000e60:	e7fe      	b.n	24000e60 <main+0x150>
24000e62:	bf00      	nop
24000e64:	ffffeffc 	.word	0xffffeffc

24000e68 <SystemClock_Config>:

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void) {
24000e68:	b580      	push	{r7, lr}
24000e6a:	b09e      	sub	sp, #120	; 0x78
24000e6c:	af00      	add	r7, sp, #0
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
24000e6e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
24000e72:	224c      	movs	r2, #76	; 0x4c
24000e74:	2100      	movs	r1, #0
24000e76:	4618      	mov	r0, r3
24000e78:	f016 f9d9 	bl	2401722e <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
24000e7c:	f107 030c 	add.w	r3, r7, #12
24000e80:	2220      	movs	r2, #32
24000e82:	2100      	movs	r1, #0
24000e84:	4618      	mov	r0, r3
24000e86:	f016 f9d2 	bl	2401722e <memset>

	/** Supply configuration update enable
	 */
	HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
24000e8a:	2002      	movs	r0, #2
24000e8c:	f00f fe5e 	bl	24010b4c <HAL_PWREx_ConfigSupply>

	/** Configure the main internal regulator output voltage
	 */
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
24000e90:	2300      	movs	r3, #0
24000e92:	60bb      	str	r3, [r7, #8]
24000e94:	4b48      	ldr	r3, [pc, #288]	; (24000fb8 <SystemClock_Config+0x150>)
24000e96:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24000e98:	4a47      	ldr	r2, [pc, #284]	; (24000fb8 <SystemClock_Config+0x150>)
24000e9a:	f023 0301 	bic.w	r3, r3, #1
24000e9e:	62d3      	str	r3, [r2, #44]	; 0x2c
24000ea0:	4b45      	ldr	r3, [pc, #276]	; (24000fb8 <SystemClock_Config+0x150>)
24000ea2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24000ea4:	f003 0301 	and.w	r3, r3, #1
24000ea8:	60bb      	str	r3, [r7, #8]
24000eaa:	4b44      	ldr	r3, [pc, #272]	; (24000fbc <SystemClock_Config+0x154>)
24000eac:	699b      	ldr	r3, [r3, #24]
24000eae:	4a43      	ldr	r2, [pc, #268]	; (24000fbc <SystemClock_Config+0x154>)
24000eb0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
24000eb4:	6193      	str	r3, [r2, #24]
24000eb6:	4b41      	ldr	r3, [pc, #260]	; (24000fbc <SystemClock_Config+0x154>)
24000eb8:	699b      	ldr	r3, [r3, #24]
24000eba:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
24000ebe:	60bb      	str	r3, [r7, #8]
24000ec0:	68bb      	ldr	r3, [r7, #8]

	while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {
24000ec2:	bf00      	nop
24000ec4:	4b3d      	ldr	r3, [pc, #244]	; (24000fbc <SystemClock_Config+0x154>)
24000ec6:	699b      	ldr	r3, [r3, #24]
24000ec8:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24000ecc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24000ed0:	d1f8      	bne.n	24000ec4 <SystemClock_Config+0x5c>
	}

	__HAL_RCC_SYSCFG_CLK_ENABLE();
24000ed2:	4b3b      	ldr	r3, [pc, #236]	; (24000fc0 <SystemClock_Config+0x158>)
24000ed4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
24000ed8:	4a39      	ldr	r2, [pc, #228]	; (24000fc0 <SystemClock_Config+0x158>)
24000eda:	f043 0302 	orr.w	r3, r3, #2
24000ede:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
24000ee2:	4b37      	ldr	r3, [pc, #220]	; (24000fc0 <SystemClock_Config+0x158>)
24000ee4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
24000ee8:	f003 0302 	and.w	r3, r3, #2
24000eec:	607b      	str	r3, [r7, #4]
24000eee:	687b      	ldr	r3, [r7, #4]
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
24000ef0:	2300      	movs	r3, #0
24000ef2:	603b      	str	r3, [r7, #0]
24000ef4:	4b31      	ldr	r3, [pc, #196]	; (24000fbc <SystemClock_Config+0x154>)
24000ef6:	699b      	ldr	r3, [r3, #24]
24000ef8:	4a30      	ldr	r2, [pc, #192]	; (24000fbc <SystemClock_Config+0x154>)
24000efa:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
24000efe:	6193      	str	r3, [r2, #24]
24000f00:	4b2e      	ldr	r3, [pc, #184]	; (24000fbc <SystemClock_Config+0x154>)
24000f02:	699b      	ldr	r3, [r3, #24]
24000f04:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
24000f08:	603b      	str	r3, [r7, #0]
24000f0a:	4b2b      	ldr	r3, [pc, #172]	; (24000fb8 <SystemClock_Config+0x150>)
24000f0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24000f0e:	4a2a      	ldr	r2, [pc, #168]	; (24000fb8 <SystemClock_Config+0x150>)
24000f10:	f043 0301 	orr.w	r3, r3, #1
24000f14:	62d3      	str	r3, [r2, #44]	; 0x2c
24000f16:	4b28      	ldr	r3, [pc, #160]	; (24000fb8 <SystemClock_Config+0x150>)
24000f18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24000f1a:	f003 0301 	and.w	r3, r3, #1
24000f1e:	603b      	str	r3, [r7, #0]
24000f20:	683b      	ldr	r3, [r7, #0]

	while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {
24000f22:	bf00      	nop
24000f24:	4b25      	ldr	r3, [pc, #148]	; (24000fbc <SystemClock_Config+0x154>)
24000f26:	699b      	ldr	r3, [r3, #24]
24000f28:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24000f2c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24000f30:	d1f8      	bne.n	24000f24 <SystemClock_Config+0xbc>
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
24000f32:	2301      	movs	r3, #1
24000f34:	62fb      	str	r3, [r7, #44]	; 0x2c
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
24000f36:	f44f 3380 	mov.w	r3, #65536	; 0x10000
24000f3a:	633b      	str	r3, [r7, #48]	; 0x30
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
24000f3c:	2302      	movs	r3, #2
24000f3e:	653b      	str	r3, [r7, #80]	; 0x50
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
24000f40:	2302      	movs	r3, #2
24000f42:	657b      	str	r3, [r7, #84]	; 0x54
	RCC_OscInitStruct.PLL.PLLM = 3;
24000f44:	2303      	movs	r3, #3
24000f46:	65bb      	str	r3, [r7, #88]	; 0x58
	RCC_OscInitStruct.PLL.PLLN = 60;
24000f48:	233c      	movs	r3, #60	; 0x3c
24000f4a:	65fb      	str	r3, [r7, #92]	; 0x5c
	RCC_OscInitStruct.PLL.PLLP = 2;
24000f4c:	2302      	movs	r3, #2
24000f4e:	663b      	str	r3, [r7, #96]	; 0x60
	RCC_OscInitStruct.PLL.PLLQ = 2;
24000f50:	2302      	movs	r3, #2
24000f52:	667b      	str	r3, [r7, #100]	; 0x64
	RCC_OscInitStruct.PLL.PLLR = 2;
24000f54:	2302      	movs	r3, #2
24000f56:	66bb      	str	r3, [r7, #104]	; 0x68
	RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
24000f58:	230c      	movs	r3, #12
24000f5a:	66fb      	str	r3, [r7, #108]	; 0x6c
	RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
24000f5c:	2300      	movs	r3, #0
24000f5e:	673b      	str	r3, [r7, #112]	; 0x70
	RCC_OscInitStruct.PLL.PLLFRACN = 0;
24000f60:	2300      	movs	r3, #0
24000f62:	677b      	str	r3, [r7, #116]	; 0x74
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
24000f64:	f107 032c 	add.w	r3, r7, #44	; 0x2c
24000f68:	4618      	mov	r0, r3
24000f6a:	f012 f8c3 	bl	240130f4 <HAL_RCC_OscConfig>
24000f6e:	4603      	mov	r3, r0
24000f70:	2b00      	cmp	r3, #0
24000f72:	d001      	beq.n	24000f78 <SystemClock_Config+0x110>
		Error_Handler();
24000f74:	f000 f826 	bl	24000fc4 <Error_Handler>
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
24000f78:	233f      	movs	r3, #63	; 0x3f
24000f7a:	60fb      	str	r3, [r7, #12]
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_D3PCLK1
			| RCC_CLOCKTYPE_D1PCLK1;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
24000f7c:	2303      	movs	r3, #3
24000f7e:	613b      	str	r3, [r7, #16]
	RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
24000f80:	2300      	movs	r3, #0
24000f82:	617b      	str	r3, [r7, #20]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
24000f84:	2308      	movs	r3, #8
24000f86:	61bb      	str	r3, [r7, #24]
	RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
24000f88:	2340      	movs	r3, #64	; 0x40
24000f8a:	61fb      	str	r3, [r7, #28]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
24000f8c:	2340      	movs	r3, #64	; 0x40
24000f8e:	623b      	str	r3, [r7, #32]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
24000f90:	f44f 6380 	mov.w	r3, #1024	; 0x400
24000f94:	627b      	str	r3, [r7, #36]	; 0x24
	RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
24000f96:	2340      	movs	r3, #64	; 0x40
24000f98:	62bb      	str	r3, [r7, #40]	; 0x28

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
24000f9a:	f107 030c 	add.w	r3, r7, #12
24000f9e:	2104      	movs	r1, #4
24000fa0:	4618      	mov	r0, r3
24000fa2:	f012 fcd5 	bl	24013950 <HAL_RCC_ClockConfig>
24000fa6:	4603      	mov	r3, r0
24000fa8:	2b00      	cmp	r3, #0
24000faa:	d001      	beq.n	24000fb0 <SystemClock_Config+0x148>
		Error_Handler();
24000fac:	f000 f80a 	bl	24000fc4 <Error_Handler>
	}
}
24000fb0:	bf00      	nop
24000fb2:	3778      	adds	r7, #120	; 0x78
24000fb4:	46bd      	mov	sp, r7
24000fb6:	bd80      	pop	{r7, pc}
24000fb8:	58000400 	.word	0x58000400
24000fbc:	58024800 	.word	0x58024800
24000fc0:	58024400 	.word	0x58024400

24000fc4 <Error_Handler>:

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
24000fc4:	b480      	push	{r7}
24000fc6:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
24000fc8:	b672      	cpsid	i
}
24000fca:	bf00      	nop
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
24000fcc:	e7fe      	b.n	24000fcc <Error_Handler+0x8>
	...

24000fd0 <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
24000fd0:	b580      	push	{r7, lr}
24000fd2:	af00      	add	r7, sp, #0
  /* USER CODE END QUADSPI_Init 0 */

  /* USER CODE BEGIN QUADSPI_Init 1 */

  /* USER CODE END QUADSPI_Init 1 */
  hqspi.Instance = QUADSPI;
24000fd4:	4b12      	ldr	r3, [pc, #72]	; (24001020 <MX_QUADSPI_Init+0x50>)
24000fd6:	4a13      	ldr	r2, [pc, #76]	; (24001024 <MX_QUADSPI_Init+0x54>)
24000fd8:	601a      	str	r2, [r3, #0]
  hqspi.Init.ClockPrescaler = 1;
24000fda:	4b11      	ldr	r3, [pc, #68]	; (24001020 <MX_QUADSPI_Init+0x50>)
24000fdc:	2201      	movs	r2, #1
24000fde:	605a      	str	r2, [r3, #4]
  hqspi.Init.FifoThreshold = 4;
24000fe0:	4b0f      	ldr	r3, [pc, #60]	; (24001020 <MX_QUADSPI_Init+0x50>)
24000fe2:	2204      	movs	r2, #4
24000fe4:	609a      	str	r2, [r3, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
24000fe6:	4b0e      	ldr	r3, [pc, #56]	; (24001020 <MX_QUADSPI_Init+0x50>)
24000fe8:	2210      	movs	r2, #16
24000fea:	60da      	str	r2, [r3, #12]
  hqspi.Init.FlashSize = 23;
24000fec:	4b0c      	ldr	r3, [pc, #48]	; (24001020 <MX_QUADSPI_Init+0x50>)
24000fee:	2217      	movs	r2, #23
24000ff0:	611a      	str	r2, [r3, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
24000ff2:	4b0b      	ldr	r3, [pc, #44]	; (24001020 <MX_QUADSPI_Init+0x50>)
24000ff4:	2200      	movs	r2, #0
24000ff6:	615a      	str	r2, [r3, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_3;
24000ff8:	4b09      	ldr	r3, [pc, #36]	; (24001020 <MX_QUADSPI_Init+0x50>)
24000ffa:	2201      	movs	r2, #1
24000ffc:	619a      	str	r2, [r3, #24]
  hqspi.Init.FlashID = QSPI_FLASH_ID_2;
24000ffe:	4b08      	ldr	r3, [pc, #32]	; (24001020 <MX_QUADSPI_Init+0x50>)
24001000:	2280      	movs	r2, #128	; 0x80
24001002:	61da      	str	r2, [r3, #28]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
24001004:	4b06      	ldr	r3, [pc, #24]	; (24001020 <MX_QUADSPI_Init+0x50>)
24001006:	2200      	movs	r2, #0
24001008:	621a      	str	r2, [r3, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
2400100a:	4805      	ldr	r0, [pc, #20]	; (24001020 <MX_QUADSPI_Init+0x50>)
2400100c:	f010 fad4 	bl	240115b8 <HAL_QSPI_Init>
24001010:	4603      	mov	r3, r0
24001012:	2b00      	cmp	r3, #0
24001014:	d001      	beq.n	2400101a <MX_QUADSPI_Init+0x4a>
  {
    Error_Handler();
24001016:	f7ff ffd5 	bl	24000fc4 <Error_Handler>
  }
  /* USER CODE BEGIN QUADSPI_Init 2 */

  /* USER CODE END QUADSPI_Init 2 */

}
2400101a:	bf00      	nop
2400101c:	bd80      	pop	{r7, pc}
2400101e:	bf00      	nop
24001020:	24000538 	.word	0x24000538
24001024:	52005000 	.word	0x52005000

24001028 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
24001028:	b580      	push	{r7, lr}
2400102a:	b0ba      	sub	sp, #232	; 0xe8
2400102c:	af00      	add	r7, sp, #0
2400102e:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
24001030:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
24001034:	2200      	movs	r2, #0
24001036:	601a      	str	r2, [r3, #0]
24001038:	605a      	str	r2, [r3, #4]
2400103a:	609a      	str	r2, [r3, #8]
2400103c:	60da      	str	r2, [r3, #12]
2400103e:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
24001040:	f107 0318 	add.w	r3, r7, #24
24001044:	22bc      	movs	r2, #188	; 0xbc
24001046:	2100      	movs	r1, #0
24001048:	4618      	mov	r0, r3
2400104a:	f016 f8f0 	bl	2401722e <memset>
  if(qspiHandle->Instance==QUADSPI)
2400104e:	687b      	ldr	r3, [r7, #4]
24001050:	681b      	ldr	r3, [r3, #0]
24001052:	4a4e      	ldr	r2, [pc, #312]	; (2400118c <HAL_QSPI_MspInit+0x164>)
24001054:	4293      	cmp	r3, r2
24001056:	f040 8094 	bne.w	24001182 <HAL_QSPI_MspInit+0x15a>

  /* USER CODE END QUADSPI_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_QSPI;
2400105a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400105e:	61bb      	str	r3, [r7, #24]
    PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK;
24001060:	2300      	movs	r3, #0
24001062:	663b      	str	r3, [r7, #96]	; 0x60
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
24001064:	f107 0318 	add.w	r3, r7, #24
24001068:	4618      	mov	r0, r3
2400106a:	f013 f9d3 	bl	24014414 <HAL_RCCEx_PeriphCLKConfig>
2400106e:	4603      	mov	r3, r0
24001070:	2b00      	cmp	r3, #0
24001072:	d001      	beq.n	24001078 <HAL_QSPI_MspInit+0x50>
    {
      Error_Handler();
24001074:	f7ff ffa6 	bl	24000fc4 <Error_Handler>
    }

    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
24001078:	4b45      	ldr	r3, [pc, #276]	; (24001190 <HAL_QSPI_MspInit+0x168>)
2400107a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
2400107e:	4a44      	ldr	r2, [pc, #272]	; (24001190 <HAL_QSPI_MspInit+0x168>)
24001080:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
24001084:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
24001088:	4b41      	ldr	r3, [pc, #260]	; (24001190 <HAL_QSPI_MspInit+0x168>)
2400108a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
2400108e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
24001092:	617b      	str	r3, [r7, #20]
24001094:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOB_CLK_ENABLE();
24001096:	4b3e      	ldr	r3, [pc, #248]	; (24001190 <HAL_QSPI_MspInit+0x168>)
24001098:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
2400109c:	4a3c      	ldr	r2, [pc, #240]	; (24001190 <HAL_QSPI_MspInit+0x168>)
2400109e:	f043 0302 	orr.w	r3, r3, #2
240010a2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240010a6:	4b3a      	ldr	r3, [pc, #232]	; (24001190 <HAL_QSPI_MspInit+0x168>)
240010a8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240010ac:	f003 0302 	and.w	r3, r3, #2
240010b0:	613b      	str	r3, [r7, #16]
240010b2:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOE_CLK_ENABLE();
240010b4:	4b36      	ldr	r3, [pc, #216]	; (24001190 <HAL_QSPI_MspInit+0x168>)
240010b6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240010ba:	4a35      	ldr	r2, [pc, #212]	; (24001190 <HAL_QSPI_MspInit+0x168>)
240010bc:	f043 0310 	orr.w	r3, r3, #16
240010c0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240010c4:	4b32      	ldr	r3, [pc, #200]	; (24001190 <HAL_QSPI_MspInit+0x168>)
240010c6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240010ca:	f003 0310 	and.w	r3, r3, #16
240010ce:	60fb      	str	r3, [r7, #12]
240010d0:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
240010d2:	4b2f      	ldr	r3, [pc, #188]	; (24001190 <HAL_QSPI_MspInit+0x168>)
240010d4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240010d8:	4a2d      	ldr	r2, [pc, #180]	; (24001190 <HAL_QSPI_MspInit+0x168>)
240010da:	f043 0304 	orr.w	r3, r3, #4
240010de:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
240010e2:	4b2b      	ldr	r3, [pc, #172]	; (24001190 <HAL_QSPI_MspInit+0x168>)
240010e4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
240010e8:	f003 0304 	and.w	r3, r3, #4
240010ec:	60bb      	str	r3, [r7, #8]
240010ee:	68bb      	ldr	r3, [r7, #8]
    PE8     ------> QUADSPI_BK2_IO1
    PE9     ------> QUADSPI_BK2_IO2
    PE10     ------> QUADSPI_BK2_IO3
    PC11     ------> QUADSPI_BK2_NCS
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
240010f0:	2304      	movs	r3, #4
240010f2:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
240010f6:	2302      	movs	r3, #2
240010f8:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
240010fc:	2300      	movs	r3, #0
240010fe:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24001102:	2303      	movs	r3, #3
24001104:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24001108:	2309      	movs	r3, #9
2400110a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
2400110e:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
24001112:	4619      	mov	r1, r3
24001114:	481f      	ldr	r0, [pc, #124]	; (24001194 <HAL_QSPI_MspInit+0x16c>)
24001116:	f008 fb19 	bl	2400974c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
2400111a:	f44f 63f0 	mov.w	r3, #1920	; 0x780
2400111e:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24001122:	2302      	movs	r3, #2
24001124:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24001128:	2300      	movs	r3, #0
2400112a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2400112e:	2303      	movs	r3, #3
24001130:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
24001134:	230a      	movs	r3, #10
24001136:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
2400113a:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
2400113e:	4619      	mov	r1, r3
24001140:	4815      	ldr	r0, [pc, #84]	; (24001198 <HAL_QSPI_MspInit+0x170>)
24001142:	f008 fb03 	bl	2400974c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
24001146:	f44f 6300 	mov.w	r3, #2048	; 0x800
2400114a:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
2400114e:	2302      	movs	r3, #2
24001150:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24001154:	2300      	movs	r3, #0
24001156:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
2400115a:	2303      	movs	r3, #3
2400115c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
24001160:	2309      	movs	r3, #9
24001162:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
24001166:	f107 03d4 	add.w	r3, r7, #212	; 0xd4
2400116a:	4619      	mov	r1, r3
2400116c:	480b      	ldr	r0, [pc, #44]	; (2400119c <HAL_QSPI_MspInit+0x174>)
2400116e:	f008 faed 	bl	2400974c <HAL_GPIO_Init>

    /* QUADSPI interrupt Init */
    HAL_NVIC_SetPriority(QUADSPI_IRQn, 0, 0);
24001172:	2200      	movs	r2, #0
24001174:	2100      	movs	r1, #0
24001176:	205c      	movs	r0, #92	; 0x5c
24001178:	f001 feff 	bl	24002f7a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(QUADSPI_IRQn);
2400117c:	205c      	movs	r0, #92	; 0x5c
2400117e:	f001 ff16 	bl	24002fae <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
24001182:	bf00      	nop
24001184:	37e8      	adds	r7, #232	; 0xe8
24001186:	46bd      	mov	sp, r7
24001188:	bd80      	pop	{r7, pc}
2400118a:	bf00      	nop
2400118c:	52005000 	.word	0x52005000
24001190:	58024400 	.word	0x58024400
24001194:	58020400 	.word	0x58020400
24001198:	58021000 	.word	0x58021000
2400119c:	58020800 	.word	0x58020800

240011a0 <HAL_QSPI_MspDeInit>:

void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef* qspiHandle)
{
240011a0:	b580      	push	{r7, lr}
240011a2:	b082      	sub	sp, #8
240011a4:	af00      	add	r7, sp, #0
240011a6:	6078      	str	r0, [r7, #4]

  if(qspiHandle->Instance==QUADSPI)
240011a8:	687b      	ldr	r3, [r7, #4]
240011aa:	681b      	ldr	r3, [r3, #0]
240011ac:	4a0f      	ldr	r2, [pc, #60]	; (240011ec <HAL_QSPI_MspDeInit+0x4c>)
240011ae:	4293      	cmp	r3, r2
240011b0:	d118      	bne.n	240011e4 <HAL_QSPI_MspDeInit+0x44>
  {
  /* USER CODE BEGIN QUADSPI_MspDeInit 0 */

  /* USER CODE END QUADSPI_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_QSPI_CLK_DISABLE();
240011b2:	4b0f      	ldr	r3, [pc, #60]	; (240011f0 <HAL_QSPI_MspDeInit+0x50>)
240011b4:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
240011b8:	4a0d      	ldr	r2, [pc, #52]	; (240011f0 <HAL_QSPI_MspDeInit+0x50>)
240011ba:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
240011be:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
    PE8     ------> QUADSPI_BK2_IO1
    PE9     ------> QUADSPI_BK2_IO2
    PE10     ------> QUADSPI_BK2_IO3
    PC11     ------> QUADSPI_BK2_NCS
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_2);
240011c2:	2104      	movs	r1, #4
240011c4:	480b      	ldr	r0, [pc, #44]	; (240011f4 <HAL_QSPI_MspDeInit+0x54>)
240011c6:	f008 fc71 	bl	24009aac <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOE, GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10);
240011ca:	f44f 61f0 	mov.w	r1, #1920	; 0x780
240011ce:	480a      	ldr	r0, [pc, #40]	; (240011f8 <HAL_QSPI_MspDeInit+0x58>)
240011d0:	f008 fc6c 	bl	24009aac <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_11);
240011d4:	f44f 6100 	mov.w	r1, #2048	; 0x800
240011d8:	4808      	ldr	r0, [pc, #32]	; (240011fc <HAL_QSPI_MspDeInit+0x5c>)
240011da:	f008 fc67 	bl	24009aac <HAL_GPIO_DeInit>

    /* QUADSPI interrupt Deinit */
    HAL_NVIC_DisableIRQ(QUADSPI_IRQn);
240011de:	205c      	movs	r0, #92	; 0x5c
240011e0:	f001 fef3 	bl	24002fca <HAL_NVIC_DisableIRQ>
  /* USER CODE BEGIN QUADSPI_MspDeInit 1 */

  /* USER CODE END QUADSPI_MspDeInit 1 */
  }
}
240011e4:	bf00      	nop
240011e6:	3708      	adds	r7, #8
240011e8:	46bd      	mov	sp, r7
240011ea:	bd80      	pop	{r7, pc}
240011ec:	52005000 	.word	0x52005000
240011f0:	58024400 	.word	0x58024400
240011f4:	58020400 	.word	0x58020400
240011f8:	58021000 	.word	0x58021000
240011fc:	58020800 	.word	0x58020800

24001200 <CSP_QUADSPI_Init>:

/* USER CODE BEGIN 1 */

/* QUADSPI init function */
uint8_t CSP_QUADSPI_Init(void) {
24001200:	b580      	push	{r7, lr}
24001202:	af00      	add	r7, sp, #0
	//prepare QSPI peripheral for ST-Link Utility operations
	if (HAL_QSPI_DeInit(&hqspi) != HAL_OK) {
24001204:	4819      	ldr	r0, [pc, #100]	; (2400126c <CSP_QUADSPI_Init+0x6c>)
24001206:	f010 fa4b 	bl	240116a0 <HAL_QSPI_DeInit>
2400120a:	4603      	mov	r3, r0
2400120c:	2b00      	cmp	r3, #0
2400120e:	d001      	beq.n	24001214 <CSP_QUADSPI_Init+0x14>
		return HAL_ERROR;
24001210:	2301      	movs	r3, #1
24001212:	e028      	b.n	24001266 <CSP_QUADSPI_Init+0x66>
	}

	MX_QUADSPI_Init();
24001214:	f7ff fedc 	bl	24000fd0 <MX_QUADSPI_Init>

	if (QSPI_ResetChip() != HAL_OK) {
24001218:	f000 fae6 	bl	240017e8 <QSPI_ResetChip>
2400121c:	4603      	mov	r3, r0
2400121e:	2b00      	cmp	r3, #0
24001220:	d001      	beq.n	24001226 <CSP_QUADSPI_Init+0x26>
		return HAL_ERROR;
24001222:	2301      	movs	r3, #1
24001224:	e01f      	b.n	24001266 <CSP_QUADSPI_Init+0x66>
	}

	HAL_Delay(1);
24001226:	2001      	movs	r0, #1
24001228:	f001 f8d8 	bl	240023dc <HAL_Delay>

	if (QSPI_AutoPollingMemReady() != HAL_OK) {
2400122c:	f000 f85c 	bl	240012e8 <QSPI_AutoPollingMemReady>
24001230:	4603      	mov	r3, r0
24001232:	2b00      	cmp	r3, #0
24001234:	d001      	beq.n	2400123a <CSP_QUADSPI_Init+0x3a>
		return HAL_ERROR;
24001236:	2301      	movs	r3, #1
24001238:	e015      	b.n	24001266 <CSP_QUADSPI_Init+0x66>
	}

	if (QSPI_WriteEnable() != HAL_OK) {
2400123a:	f000 f88d 	bl	24001358 <QSPI_WriteEnable>
2400123e:	4603      	mov	r3, r0
24001240:	2b00      	cmp	r3, #0
24001242:	d001      	beq.n	24001248 <CSP_QUADSPI_Init+0x48>

		return HAL_ERROR;
24001244:	2301      	movs	r3, #1
24001246:	e00e      	b.n	24001266 <CSP_QUADSPI_Init+0x66>
	}

	if (QSPI_Configuration() != HAL_OK) {
24001248:	f000 f8d2 	bl	240013f0 <QSPI_Configuration>
2400124c:	4603      	mov	r3, r0
2400124e:	2b00      	cmp	r3, #0
24001250:	d001      	beq.n	24001256 <CSP_QUADSPI_Init+0x56>
		return HAL_ERROR;
24001252:	2301      	movs	r3, #1
24001254:	e007      	b.n	24001266 <CSP_QUADSPI_Init+0x66>
	}

	if (QSPI_AutoPollingMemReady() != HAL_OK) {
24001256:	f000 f847 	bl	240012e8 <QSPI_AutoPollingMemReady>
2400125a:	4603      	mov	r3, r0
2400125c:	2b00      	cmp	r3, #0
2400125e:	d001      	beq.n	24001264 <CSP_QUADSPI_Init+0x64>
		return HAL_ERROR;
24001260:	2301      	movs	r3, #1
24001262:	e000      	b.n	24001266 <CSP_QUADSPI_Init+0x66>
	}
	return HAL_OK;
24001264:	2300      	movs	r3, #0
}
24001266:	4618      	mov	r0, r3
24001268:	bd80      	pop	{r7, pc}
2400126a:	bf00      	nop
2400126c:	24000538 	.word	0x24000538

24001270 <CSP_QSPI_Erase_Chip>:


uint8_t CSP_QSPI_Erase_Chip(void) {
24001270:	b580      	push	{r7, lr}
24001272:	b08e      	sub	sp, #56	; 0x38
24001274:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;


	if (QSPI_WriteEnable() != HAL_OK) {
24001276:	f000 f86f 	bl	24001358 <QSPI_WriteEnable>
2400127a:	4603      	mov	r3, r0
2400127c:	2b00      	cmp	r3, #0
2400127e:	d001      	beq.n	24001284 <CSP_QSPI_Erase_Chip+0x14>
		return HAL_ERROR;
24001280:	2301      	movs	r3, #1
24001282:	e02b      	b.n	240012dc <CSP_QSPI_Erase_Chip+0x6c>
	}


	/* Erasing Sequence --------------------------------- */
	sCommand.Instruction = CHIP_ERASE_CMD;
24001284:	23c7      	movs	r3, #199	; 0xc7
24001286:	603b      	str	r3, [r7, #0]
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24001288:	f44f 7380 	mov.w	r3, #256	; 0x100
2400128c:	61bb      	str	r3, [r7, #24]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
2400128e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24001292:	60fb      	str	r3, [r7, #12]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001294:	2300      	movs	r3, #0
24001296:	623b      	str	r3, [r7, #32]
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001298:	2300      	movs	r3, #0
2400129a:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400129c:	2300      	movs	r3, #0
2400129e:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240012a0:	2300      	movs	r3, #0
240012a2:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
240012a4:	2300      	movs	r3, #0
240012a6:	61fb      	str	r3, [r7, #28]
	sCommand.Address = 0;
240012a8:	2300      	movs	r3, #0
240012aa:	607b      	str	r3, [r7, #4]
	sCommand.DataMode = QSPI_DATA_NONE;
240012ac:	2300      	movs	r3, #0
240012ae:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DummyCycles = 0;
240012b0:	2300      	movs	r3, #0
240012b2:	617b      	str	r3, [r7, #20]


	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
240012b4:	463b      	mov	r3, r7
240012b6:	f241 3288 	movw	r2, #5000	; 0x1388
240012ba:	4619      	mov	r1, r3
240012bc:	4809      	ldr	r0, [pc, #36]	; (240012e4 <CSP_QSPI_Erase_Chip+0x74>)
240012be:	f010 fbdd 	bl	24011a7c <HAL_QSPI_Command>
240012c2:	4603      	mov	r3, r0
240012c4:	2b00      	cmp	r3, #0
240012c6:	d001      	beq.n	240012cc <CSP_QSPI_Erase_Chip+0x5c>
			!= HAL_OK) {
		return HAL_ERROR;
240012c8:	2301      	movs	r3, #1
240012ca:	e007      	b.n	240012dc <CSP_QSPI_Erase_Chip+0x6c>
	}

	if (QSPI_AutoPollingMemReady() != HAL_OK) {
240012cc:	f000 f80c 	bl	240012e8 <QSPI_AutoPollingMemReady>
240012d0:	4603      	mov	r3, r0
240012d2:	2b00      	cmp	r3, #0
240012d4:	d001      	beq.n	240012da <CSP_QSPI_Erase_Chip+0x6a>
				return HAL_ERROR;
240012d6:	2301      	movs	r3, #1
240012d8:	e000      	b.n	240012dc <CSP_QSPI_Erase_Chip+0x6c>
			}

	return HAL_OK;
240012da:	2300      	movs	r3, #0
}
240012dc:	4618      	mov	r0, r3
240012de:	3738      	adds	r7, #56	; 0x38
240012e0:	46bd      	mov	sp, r7
240012e2:	bd80      	pop	{r7, pc}
240012e4:	24000538 	.word	0x24000538

240012e8 <QSPI_AutoPollingMemReady>:

uint8_t QSPI_AutoPollingMemReady(void) {
240012e8:	b580      	push	{r7, lr}
240012ea:	b094      	sub	sp, #80	; 0x50
240012ec:	af00      	add	r7, sp, #0

	QSPI_CommandTypeDef sCommand;
	 QSPI_AutoPollingTypeDef sConfig;

	/* Configure automatic polling mode to wait for memory ready ------ */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240012ee:	f44f 7380 	mov.w	r3, #256	; 0x100
240012f2:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Instruction = READ_FLAG_STATUS_REG_CMD;
240012f4:	2305      	movs	r3, #5
240012f6:	61bb      	str	r3, [r7, #24]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
240012f8:	2300      	movs	r3, #0
240012fa:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240012fc:	2300      	movs	r3, #0
240012fe:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DataMode = QSPI_DATA_1_LINE;
24001300:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24001304:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DummyCycles = 0;
24001306:	2300      	movs	r3, #0
24001308:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400130a:	2300      	movs	r3, #0
2400130c:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400130e:	2300      	movs	r3, #0
24001310:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001312:	2300      	movs	r3, #0
24001314:	64fb      	str	r3, [r7, #76]	; 0x4c

	sConfig.Match = 0x00;
24001316:	2300      	movs	r3, #0
24001318:	603b      	str	r3, [r7, #0]
	sConfig.Mask = 0x01;
2400131a:	2301      	movs	r3, #1
2400131c:	607b      	str	r3, [r7, #4]
	sConfig.MatchMode = QSPI_MATCH_MODE_AND;
2400131e:	2300      	movs	r3, #0
24001320:	613b      	str	r3, [r7, #16]
	sConfig.StatusBytesSize = 1;
24001322:	2301      	movs	r3, #1
24001324:	60fb      	str	r3, [r7, #12]
	sConfig.Interval = 0x10;
24001326:	2310      	movs	r3, #16
24001328:	60bb      	str	r3, [r7, #8]
	sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
2400132a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
2400132e:	617b      	str	r3, [r7, #20]

	if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,
24001330:	463a      	mov	r2, r7
24001332:	f107 0118 	add.w	r1, r7, #24
24001336:	f241 3388 	movw	r3, #5000	; 0x1388
2400133a:	4806      	ldr	r0, [pc, #24]	; (24001354 <QSPI_AutoPollingMemReady+0x6c>)
2400133c:	f011 f848 	bl	240123d0 <HAL_QSPI_AutoPolling>
24001340:	4603      	mov	r3, r0
24001342:	2b00      	cmp	r3, #0
24001344:	d001      	beq.n	2400134a <QSPI_AutoPollingMemReady+0x62>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
24001346:	2301      	movs	r3, #1
24001348:	e000      	b.n	2400134c <QSPI_AutoPollingMemReady+0x64>
	}

	return HAL_OK;
2400134a:	2300      	movs	r3, #0
}
2400134c:	4618      	mov	r0, r3
2400134e:	3750      	adds	r7, #80	; 0x50
24001350:	46bd      	mov	sp, r7
24001352:	bd80      	pop	{r7, pc}
24001354:	24000538 	.word	0x24000538

24001358 <QSPI_WriteEnable>:

static uint8_t QSPI_WriteEnable(void) {
24001358:	b580      	push	{r7, lr}
2400135a:	b094      	sub	sp, #80	; 0x50
2400135c:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	QSPI_AutoPollingTypeDef sConfig;

	QSPI_AutoPollingMemReady();
2400135e:	f7ff ffc3 	bl	240012e8 <QSPI_AutoPollingMemReady>

	/* Enable write operations ------------------------------------------ */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24001362:	f44f 7380 	mov.w	r3, #256	; 0x100
24001366:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Instruction = WRITE_ENABLE_CMD;
24001368:	2306      	movs	r3, #6
2400136a:	61bb      	str	r3, [r7, #24]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
2400136c:	2300      	movs	r3, #0
2400136e:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001370:	2300      	movs	r3, #0
24001372:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.DataMode = QSPI_DATA_NONE;
24001374:	2300      	movs	r3, #0
24001376:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.DummyCycles = 0;
24001378:	2300      	movs	r3, #0
2400137a:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400137c:	2300      	movs	r3, #0
2400137e:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24001380:	2300      	movs	r3, #0
24001382:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001384:	2300      	movs	r3, #0
24001386:	64fb      	str	r3, [r7, #76]	; 0x4c

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001388:	f107 0318 	add.w	r3, r7, #24
2400138c:	f241 3288 	movw	r2, #5000	; 0x1388
24001390:	4619      	mov	r1, r3
24001392:	4816      	ldr	r0, [pc, #88]	; (240013ec <QSPI_WriteEnable+0x94>)
24001394:	f010 fb72 	bl	24011a7c <HAL_QSPI_Command>
24001398:	4603      	mov	r3, r0
2400139a:	2b00      	cmp	r3, #0
2400139c:	d001      	beq.n	240013a2 <QSPI_WriteEnable+0x4a>
			!= HAL_OK) {
		return HAL_ERROR;
2400139e:	2301      	movs	r3, #1
240013a0:	e01f      	b.n	240013e2 <QSPI_WriteEnable+0x8a>
	}

	/* Configure automatic polling mode to wait for write enabling ---- */
	sConfig.Match = 0x02;
240013a2:	2302      	movs	r3, #2
240013a4:	603b      	str	r3, [r7, #0]
	sConfig.Mask = 0x02;
240013a6:	2302      	movs	r3, #2
240013a8:	607b      	str	r3, [r7, #4]
	sConfig.MatchMode = QSPI_MATCH_MODE_AND;
240013aa:	2300      	movs	r3, #0
240013ac:	613b      	str	r3, [r7, #16]
	sConfig.StatusBytesSize = 1;
240013ae:	2301      	movs	r3, #1
240013b0:	60fb      	str	r3, [r7, #12]
	sConfig.Interval = 0x10;
240013b2:	2310      	movs	r3, #16
240013b4:	60bb      	str	r3, [r7, #8]
	sConfig.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;
240013b6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
240013ba:	617b      	str	r3, [r7, #20]

	sCommand.Instruction = READ_STATUS_REG_CMD;
240013bc:	2305      	movs	r3, #5
240013be:	61bb      	str	r3, [r7, #24]
	sCommand.DataMode = QSPI_DATA_1_LINE;
240013c0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
240013c4:	63fb      	str	r3, [r7, #60]	; 0x3c
	if (HAL_QSPI_AutoPolling(&hqspi, &sCommand, &sConfig,
240013c6:	463a      	mov	r2, r7
240013c8:	f107 0118 	add.w	r1, r7, #24
240013cc:	f241 3388 	movw	r3, #5000	; 0x1388
240013d0:	4806      	ldr	r0, [pc, #24]	; (240013ec <QSPI_WriteEnable+0x94>)
240013d2:	f010 fffd 	bl	240123d0 <HAL_QSPI_AutoPolling>
240013d6:	4603      	mov	r3, r0
240013d8:	2b00      	cmp	r3, #0
240013da:	d001      	beq.n	240013e0 <QSPI_WriteEnable+0x88>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
240013dc:	2301      	movs	r3, #1
240013de:	e000      	b.n	240013e2 <QSPI_WriteEnable+0x8a>
	}

	return HAL_OK;
240013e0:	2300      	movs	r3, #0
}
240013e2:	4618      	mov	r0, r3
240013e4:	3750      	adds	r7, #80	; 0x50
240013e6:	46bd      	mov	sp, r7
240013e8:	bd80      	pop	{r7, pc}
240013ea:	bf00      	nop
240013ec:	24000538 	.word	0x24000538

240013f0 <QSPI_Configuration>:
/*Enable quad mode and set dummy cycles count*/
uint8_t QSPI_Configuration(void) {
240013f0:	b580      	push	{r7, lr}
240013f2:	b090      	sub	sp, #64	; 0x40
240013f4:	af00      	add	r7, sp, #0

	QSPI_CommandTypeDef sCommand;
	uint8_t test_buffer[4] = { 0 };
240013f6:	2300      	movs	r3, #0
240013f8:	607b      	str	r3, [r7, #4]
	/*read status register*/
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240013fa:	f44f 7380 	mov.w	r3, #256	; 0x100
240013fe:	623b      	str	r3, [r7, #32]
	sCommand.Instruction = READ_STATUS_REG_CMD;
24001400:	2305      	movs	r3, #5
24001402:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001404:	2300      	movs	r3, #0
24001406:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001408:	2300      	movs	r3, #0
2400140a:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DataMode = QSPI_DATA_1_LINE;
2400140c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24001410:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
24001412:	2300      	movs	r3, #0
24001414:	61fb      	str	r3, [r7, #28]
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001416:	2300      	movs	r3, #0
24001418:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400141a:	2300      	movs	r3, #0
2400141c:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2400141e:	2300      	movs	r3, #0
24001420:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.NbData = 1;
24001422:	2301      	movs	r3, #1
24001424:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001426:	f107 0308 	add.w	r3, r7, #8
2400142a:	f241 3288 	movw	r2, #5000	; 0x1388
2400142e:	4619      	mov	r1, r3
24001430:	4863      	ldr	r0, [pc, #396]	; (240015c0 <QSPI_Configuration+0x1d0>)
24001432:	f010 fb23 	bl	24011a7c <HAL_QSPI_Command>
24001436:	4603      	mov	r3, r0
24001438:	2b00      	cmp	r3, #0
2400143a:	d001      	beq.n	24001440 <QSPI_Configuration+0x50>
			!= HAL_OK) {
		return HAL_ERROR;
2400143c:	2301      	movs	r3, #1
2400143e:	e0ba      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}
	if (HAL_QSPI_Receive(&hqspi, test_buffer,
24001440:	1d3b      	adds	r3, r7, #4
24001442:	f241 3288 	movw	r2, #5000	; 0x1388
24001446:	4619      	mov	r1, r3
24001448:	485d      	ldr	r0, [pc, #372]	; (240015c0 <QSPI_Configuration+0x1d0>)
2400144a:	f010 fc6d 	bl	24011d28 <HAL_QSPI_Receive>
2400144e:	4603      	mov	r3, r0
24001450:	2b00      	cmp	r3, #0
24001452:	d001      	beq.n	24001458 <QSPI_Configuration+0x68>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
24001454:	2301      	movs	r3, #1
24001456:	e0ae      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}
	/*read configuration register*/
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24001458:	f44f 7380 	mov.w	r3, #256	; 0x100
2400145c:	623b      	str	r3, [r7, #32]
	sCommand.Instruction = READ_CONFIGURATION_REG_CMD;
2400145e:	2361      	movs	r3, #97	; 0x61
24001460:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001462:	2300      	movs	r3, #0
24001464:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001466:	2300      	movs	r3, #0
24001468:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DataMode = QSPI_DATA_1_LINE;
2400146a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400146e:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
24001470:	2300      	movs	r3, #0
24001472:	61fb      	str	r3, [r7, #28]
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001474:	2300      	movs	r3, #0
24001476:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24001478:	2300      	movs	r3, #0
2400147a:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2400147c:	2300      	movs	r3, #0
2400147e:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.NbData = 1;
24001480:	2301      	movs	r3, #1
24001482:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001484:	f107 0308 	add.w	r3, r7, #8
24001488:	f241 3288 	movw	r2, #5000	; 0x1388
2400148c:	4619      	mov	r1, r3
2400148e:	484c      	ldr	r0, [pc, #304]	; (240015c0 <QSPI_Configuration+0x1d0>)
24001490:	f010 faf4 	bl	24011a7c <HAL_QSPI_Command>
24001494:	4603      	mov	r3, r0
24001496:	2b00      	cmp	r3, #0
24001498:	d001      	beq.n	2400149e <QSPI_Configuration+0xae>
			!= HAL_OK) {
		return HAL_ERROR;
2400149a:	2301      	movs	r3, #1
2400149c:	e08b      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}
	if (HAL_QSPI_Receive(&hqspi, &(test_buffer[1]),
2400149e:	1d3b      	adds	r3, r7, #4
240014a0:	3301      	adds	r3, #1
240014a2:	f241 3288 	movw	r2, #5000	; 0x1388
240014a6:	4619      	mov	r1, r3
240014a8:	4845      	ldr	r0, [pc, #276]	; (240015c0 <QSPI_Configuration+0x1d0>)
240014aa:	f010 fc3d 	bl	24011d28 <HAL_QSPI_Receive>
240014ae:	4603      	mov	r3, r0
240014b0:	2b00      	cmp	r3, #0
240014b2:	d001      	beq.n	240014b8 <QSPI_Configuration+0xc8>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		return HAL_ERROR;
240014b4:	2301      	movs	r3, #1
240014b6:	e07e      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}
	/*modify buffer to enable quad mode*/
	test_buffer[0] |= 0x40;
240014b8:	793b      	ldrb	r3, [r7, #4]
240014ba:	f043 0340 	orr.w	r3, r3, #64	; 0x40
240014be:	b2db      	uxtb	r3, r3
240014c0:	713b      	strb	r3, [r7, #4]

	/*set dummy cycles*/
	test_buffer[1] = 0x40;
240014c2:	2340      	movs	r3, #64	; 0x40
240014c4:	717b      	strb	r3, [r7, #5]

	if (QSPI_WriteEnable() != HAL_OK) {
240014c6:	f7ff ff47 	bl	24001358 <QSPI_WriteEnable>
240014ca:	4603      	mov	r3, r0
240014cc:	2b00      	cmp	r3, #0
240014ce:	d001      	beq.n	240014d4 <QSPI_Configuration+0xe4>
		return HAL_ERROR;
240014d0:	2301      	movs	r3, #1
240014d2:	e070      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240014d4:	f44f 7380 	mov.w	r3, #256	; 0x100
240014d8:	623b      	str	r3, [r7, #32]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240014da:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240014de:	617b      	str	r3, [r7, #20]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240014e0:	2300      	movs	r3, #0
240014e2:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240014e4:	2300      	movs	r3, #0
240014e6:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240014e8:	2300      	movs	r3, #0
240014ea:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240014ec:	2300      	movs	r3, #0
240014ee:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.Instruction = WRITE_STATUS_REG_CMD;
240014f0:	2301      	movs	r3, #1
240014f2:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
240014f4:	2300      	movs	r3, #0
240014f6:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_1_LINE;
240014f8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
240014fc:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
240014fe:	2300      	movs	r3, #0
24001500:	61fb      	str	r3, [r7, #28]
	sCommand.NbData = 1;
24001502:	2301      	movs	r3, #1
24001504:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001506:	f107 0308 	add.w	r3, r7, #8
2400150a:	f241 3288 	movw	r2, #5000	; 0x1388
2400150e:	4619      	mov	r1, r3
24001510:	482b      	ldr	r0, [pc, #172]	; (240015c0 <QSPI_Configuration+0x1d0>)
24001512:	f010 fab3 	bl	24011a7c <HAL_QSPI_Command>
24001516:	4603      	mov	r3, r0
24001518:	2b00      	cmp	r3, #0
2400151a:	d001      	beq.n	24001520 <QSPI_Configuration+0x130>
			!= HAL_OK) {
		return HAL_ERROR;
2400151c:	2301      	movs	r3, #1
2400151e:	e04a      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}

	if (HAL_QSPI_Transmit(&hqspi, test_buffer,
24001520:	1d3b      	adds	r3, r7, #4
24001522:	f241 3288 	movw	r2, #5000	; 0x1388
24001526:	4619      	mov	r1, r3
24001528:	4825      	ldr	r0, [pc, #148]	; (240015c0 <QSPI_Configuration+0x1d0>)
2400152a:	f010 fb6b 	bl	24011c04 <HAL_QSPI_Transmit>
2400152e:	4603      	mov	r3, r0
24001530:	2b00      	cmp	r3, #0
24001532:	d003      	beq.n	2400153c <QSPI_Configuration+0x14c>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		Error_Handler();
24001534:	f7ff fd46 	bl	24000fc4 <Error_Handler>
		return HAL_ERROR;
24001538:	2301      	movs	r3, #1
2400153a:	e03c      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}

	if (QSPI_WriteEnable() != HAL_OK) {
2400153c:	f7ff ff0c 	bl	24001358 <QSPI_WriteEnable>
24001540:	4603      	mov	r3, r0
24001542:	2b00      	cmp	r3, #0
24001544:	d001      	beq.n	2400154a <QSPI_Configuration+0x15a>
		return HAL_ERROR;
24001546:	2301      	movs	r3, #1
24001548:	e035      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400154a:	f44f 7380 	mov.w	r3, #256	; 0x100
2400154e:	623b      	str	r3, [r7, #32]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24001550:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24001554:	617b      	str	r3, [r7, #20]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001556:	2300      	movs	r3, #0
24001558:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400155a:	2300      	movs	r3, #0
2400155c:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400155e:	2300      	movs	r3, #0
24001560:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001562:	2300      	movs	r3, #0
24001564:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.Instruction = WRITE_CONFIGURATION_REG_CMD;
24001566:	2365      	movs	r3, #101	; 0x65
24001568:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
2400156a:	2300      	movs	r3, #0
2400156c:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_1_LINE;
2400156e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
24001572:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
24001574:	2300      	movs	r3, #0
24001576:	61fb      	str	r3, [r7, #28]
	sCommand.NbData = 1;
24001578:	2301      	movs	r3, #1
2400157a:	633b      	str	r3, [r7, #48]	; 0x30

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2400157c:	f107 0308 	add.w	r3, r7, #8
24001580:	f241 3288 	movw	r2, #5000	; 0x1388
24001584:	4619      	mov	r1, r3
24001586:	480e      	ldr	r0, [pc, #56]	; (240015c0 <QSPI_Configuration+0x1d0>)
24001588:	f010 fa78 	bl	24011a7c <HAL_QSPI_Command>
2400158c:	4603      	mov	r3, r0
2400158e:	2b00      	cmp	r3, #0
24001590:	d001      	beq.n	24001596 <QSPI_Configuration+0x1a6>
			!= HAL_OK) {
		return HAL_ERROR;
24001592:	2301      	movs	r3, #1
24001594:	e00f      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}

	if (HAL_QSPI_Transmit(&hqspi, &(test_buffer[1]),
24001596:	1d3b      	adds	r3, r7, #4
24001598:	3301      	adds	r3, #1
2400159a:	f241 3288 	movw	r2, #5000	; 0x1388
2400159e:	4619      	mov	r1, r3
240015a0:	4807      	ldr	r0, [pc, #28]	; (240015c0 <QSPI_Configuration+0x1d0>)
240015a2:	f010 fb2f 	bl	24011c04 <HAL_QSPI_Transmit>
240015a6:	4603      	mov	r3, r0
240015a8:	2b00      	cmp	r3, #0
240015aa:	d003      	beq.n	240015b4 <QSPI_Configuration+0x1c4>
	HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
		Error_Handler();
240015ac:	f7ff fd0a 	bl	24000fc4 <Error_Handler>
		return HAL_ERROR;
240015b0:	2301      	movs	r3, #1
240015b2:	e000      	b.n	240015b6 <QSPI_Configuration+0x1c6>
	}
	return HAL_OK;
240015b4:	2300      	movs	r3, #0
}
240015b6:	4618      	mov	r0, r3
240015b8:	3740      	adds	r7, #64	; 0x40
240015ba:	46bd      	mov	sp, r7
240015bc:	bd80      	pop	{r7, pc}
240015be:	bf00      	nop
240015c0:	24000538 	.word	0x24000538

240015c4 <CSP_QSPI_EraseSector>:

uint8_t CSP_QSPI_EraseSector(uint32_t EraseStartAddress, uint32_t EraseEndAddress) {
240015c4:	b580      	push	{r7, lr}
240015c6:	b090      	sub	sp, #64	; 0x40
240015c8:	af00      	add	r7, sp, #0
240015ca:	6078      	str	r0, [r7, #4]
240015cc:	6039      	str	r1, [r7, #0]

	QSPI_CommandTypeDef sCommand;

	EraseStartAddress = EraseStartAddress
240015ce:	687a      	ldr	r2, [r7, #4]
240015d0:	4b23      	ldr	r3, [pc, #140]	; (24001660 <CSP_QSPI_EraseSector+0x9c>)
240015d2:	4013      	ands	r3, r2
240015d4:	607b      	str	r3, [r7, #4]
			- EraseStartAddress % MEMORY_SECTOR_SIZE;

	/* Erasing Sequence -------------------------------------------------- */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240015d6:	f44f 7380 	mov.w	r3, #256	; 0x100
240015da:	623b      	str	r3, [r7, #32]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240015dc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240015e0:	617b      	str	r3, [r7, #20]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240015e2:	2300      	movs	r3, #0
240015e4:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240015e6:	2300      	movs	r3, #0
240015e8:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240015ea:	2300      	movs	r3, #0
240015ec:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240015ee:	2300      	movs	r3, #0
240015f0:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.Instruction = SECTOR_ERASE_CMD;
240015f2:	2320      	movs	r3, #32
240015f4:	60bb      	str	r3, [r7, #8]
	sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
240015f6:	f44f 6380 	mov.w	r3, #1024	; 0x400
240015fa:	627b      	str	r3, [r7, #36]	; 0x24

	sCommand.DataMode = QSPI_DATA_NONE;
240015fc:	2300      	movs	r3, #0
240015fe:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.DummyCycles = 0;
24001600:	2300      	movs	r3, #0
24001602:	61fb      	str	r3, [r7, #28]

	while (EraseEndAddress >= EraseStartAddress) {
24001604:	e022      	b.n	2400164c <CSP_QSPI_EraseSector+0x88>
		sCommand.Address = (EraseStartAddress & 0x0FFFFFFF);
24001606:	687b      	ldr	r3, [r7, #4]
24001608:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
2400160c:	60fb      	str	r3, [r7, #12]

		if (QSPI_WriteEnable() != HAL_OK) {
2400160e:	f7ff fea3 	bl	24001358 <QSPI_WriteEnable>
24001612:	4603      	mov	r3, r0
24001614:	2b00      	cmp	r3, #0
24001616:	d001      	beq.n	2400161c <CSP_QSPI_EraseSector+0x58>
			return HAL_ERROR;
24001618:	2301      	movs	r3, #1
2400161a:	e01c      	b.n	24001656 <CSP_QSPI_EraseSector+0x92>
		}

		if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2400161c:	f107 0308 	add.w	r3, r7, #8
24001620:	f241 3288 	movw	r2, #5000	; 0x1388
24001624:	4619      	mov	r1, r3
24001626:	480f      	ldr	r0, [pc, #60]	; (24001664 <CSP_QSPI_EraseSector+0xa0>)
24001628:	f010 fa28 	bl	24011a7c <HAL_QSPI_Command>
2400162c:	4603      	mov	r3, r0
2400162e:	2b00      	cmp	r3, #0
24001630:	d001      	beq.n	24001636 <CSP_QSPI_EraseSector+0x72>
				!= HAL_OK) {
			return HAL_ERROR;
24001632:	2301      	movs	r3, #1
24001634:	e00f      	b.n	24001656 <CSP_QSPI_EraseSector+0x92>
		}
		EraseStartAddress += MEMORY_SECTOR_SIZE;
24001636:	687b      	ldr	r3, [r7, #4]
24001638:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
2400163c:	607b      	str	r3, [r7, #4]

		if (QSPI_AutoPollingMemReady() != HAL_OK) {
2400163e:	f7ff fe53 	bl	240012e8 <QSPI_AutoPollingMemReady>
24001642:	4603      	mov	r3, r0
24001644:	2b00      	cmp	r3, #0
24001646:	d001      	beq.n	2400164c <CSP_QSPI_EraseSector+0x88>
			return HAL_ERROR;
24001648:	2301      	movs	r3, #1
2400164a:	e004      	b.n	24001656 <CSP_QSPI_EraseSector+0x92>
	while (EraseEndAddress >= EraseStartAddress) {
2400164c:	683a      	ldr	r2, [r7, #0]
2400164e:	687b      	ldr	r3, [r7, #4]
24001650:	429a      	cmp	r2, r3
24001652:	d2d8      	bcs.n	24001606 <CSP_QSPI_EraseSector+0x42>
		}
	}

	return HAL_OK;
24001654:	2300      	movs	r3, #0
}
24001656:	4618      	mov	r0, r3
24001658:	3740      	adds	r7, #64	; 0x40
2400165a:	46bd      	mov	sp, r7
2400165c:	bd80      	pop	{r7, pc}
2400165e:	bf00      	nop
24001660:	fffff000 	.word	0xfffff000
24001664:	24000538 	.word	0x24000538

24001668 <CSP_QSPI_WriteMemory>:

uint8_t CSP_QSPI_WriteMemory(uint8_t* buffer, uint32_t address,uint32_t buffer_size) {
24001668:	b580      	push	{r7, lr}
2400166a:	b096      	sub	sp, #88	; 0x58
2400166c:	af00      	add	r7, sp, #0
2400166e:	60f8      	str	r0, [r7, #12]
24001670:	60b9      	str	r1, [r7, #8]
24001672:	607a      	str	r2, [r7, #4]

	QSPI_CommandTypeDef sCommand;
	uint32_t end_addr, current_size, current_addr;

	/* Calculation of the size between the write address and the end of the page */
	current_addr = 0;
24001674:	2300      	movs	r3, #0
24001676:	653b      	str	r3, [r7, #80]	; 0x50


	//
	while (current_addr <= address) {
24001678:	e003      	b.n	24001682 <CSP_QSPI_WriteMemory+0x1a>
		current_addr += MEMORY_PAGE_SIZE;
2400167a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
2400167c:	f503 7380 	add.w	r3, r3, #256	; 0x100
24001680:	653b      	str	r3, [r7, #80]	; 0x50
	while (current_addr <= address) {
24001682:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24001684:	68bb      	ldr	r3, [r7, #8]
24001686:	429a      	cmp	r2, r3
24001688:	d9f7      	bls.n	2400167a <CSP_QSPI_WriteMemory+0x12>
	}
	current_size = current_addr - address;
2400168a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
2400168c:	68bb      	ldr	r3, [r7, #8]
2400168e:	1ad3      	subs	r3, r2, r3
24001690:	657b      	str	r3, [r7, #84]	; 0x54

	/* Check if the size of the data is less than the remaining place in the page */
	if (current_size > buffer_size) {
24001692:	6d7a      	ldr	r2, [r7, #84]	; 0x54
24001694:	687b      	ldr	r3, [r7, #4]
24001696:	429a      	cmp	r2, r3
24001698:	d901      	bls.n	2400169e <CSP_QSPI_WriteMemory+0x36>
		current_size = buffer_size;
2400169a:	687b      	ldr	r3, [r7, #4]
2400169c:	657b      	str	r3, [r7, #84]	; 0x54
	}

	/* Initialize the adress variables */
	current_addr = address;
2400169e:	68bb      	ldr	r3, [r7, #8]
240016a0:	653b      	str	r3, [r7, #80]	; 0x50
	end_addr = address + buffer_size;
240016a2:	68ba      	ldr	r2, [r7, #8]
240016a4:	687b      	ldr	r3, [r7, #4]
240016a6:	4413      	add	r3, r2
240016a8:	64fb      	str	r3, [r7, #76]	; 0x4c

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240016aa:	f44f 7380 	mov.w	r3, #256	; 0x100
240016ae:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240016b0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240016b4:	623b      	str	r3, [r7, #32]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240016b6:	2300      	movs	r3, #0
240016b8:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240016ba:	2300      	movs	r3, #0
240016bc:	643b      	str	r3, [r7, #64]	; 0x40
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240016be:	2300      	movs	r3, #0
240016c0:	647b      	str	r3, [r7, #68]	; 0x44
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240016c2:	2300      	movs	r3, #0
240016c4:	64bb      	str	r3, [r7, #72]	; 0x48
	sCommand.Instruction = QUAD_IN_FAST_PROG_CMD;
240016c6:	2338      	movs	r3, #56	; 0x38
240016c8:	617b      	str	r3, [r7, #20]
	sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
240016ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
240016ce:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DataMode = QSPI_DATA_4_LINES;
240016d0:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
240016d4:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.NbData = buffer_size;
240016d6:	687b      	ldr	r3, [r7, #4]
240016d8:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.Address = address;
240016da:	68bb      	ldr	r3, [r7, #8]
240016dc:	61bb      	str	r3, [r7, #24]
	sCommand.DummyCycles = 0;
240016de:	2300      	movs	r3, #0
240016e0:	62bb      	str	r3, [r7, #40]	; 0x28

	/* Perform the write page by page */
	do {
		sCommand.Address = current_addr;
240016e2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
240016e4:	61bb      	str	r3, [r7, #24]
		sCommand.NbData = current_size;
240016e6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
240016e8:	63fb      	str	r3, [r7, #60]	; 0x3c

		if (current_size == 0) {
240016ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
240016ec:	2b00      	cmp	r3, #0
240016ee:	d101      	bne.n	240016f4 <CSP_QSPI_WriteMemory+0x8c>
			return HAL_OK;
240016f0:	2300      	movs	r3, #0
240016f2:	e03f      	b.n	24001774 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Enable write operations */
		if (QSPI_WriteEnable() != HAL_OK) {
240016f4:	f7ff fe30 	bl	24001358 <QSPI_WriteEnable>
240016f8:	4603      	mov	r3, r0
240016fa:	2b00      	cmp	r3, #0
240016fc:	d001      	beq.n	24001702 <CSP_QSPI_WriteMemory+0x9a>
			return HAL_ERROR;
240016fe:	2301      	movs	r3, #1
24001700:	e038      	b.n	24001774 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Configure the command */
		if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001702:	f107 0314 	add.w	r3, r7, #20
24001706:	f241 3288 	movw	r2, #5000	; 0x1388
2400170a:	4619      	mov	r1, r3
2400170c:	481b      	ldr	r0, [pc, #108]	; (2400177c <CSP_QSPI_WriteMemory+0x114>)
2400170e:	f010 f9b5 	bl	24011a7c <HAL_QSPI_Command>
24001712:	4603      	mov	r3, r0
24001714:	2b00      	cmp	r3, #0
24001716:	d001      	beq.n	2400171c <CSP_QSPI_WriteMemory+0xb4>
				!= HAL_OK) {

			return HAL_ERROR;
24001718:	2301      	movs	r3, #1
2400171a:	e02b      	b.n	24001774 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Transmission of the data */
		if (HAL_QSPI_Transmit(&hqspi, buffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
2400171c:	f241 3288 	movw	r2, #5000	; 0x1388
24001720:	68f9      	ldr	r1, [r7, #12]
24001722:	4816      	ldr	r0, [pc, #88]	; (2400177c <CSP_QSPI_WriteMemory+0x114>)
24001724:	f010 fa6e 	bl	24011c04 <HAL_QSPI_Transmit>
24001728:	4603      	mov	r3, r0
2400172a:	2b00      	cmp	r3, #0
2400172c:	d001      	beq.n	24001732 <CSP_QSPI_WriteMemory+0xca>

			return HAL_ERROR;
2400172e:	2301      	movs	r3, #1
24001730:	e020      	b.n	24001774 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Configure automatic polling mode to wait for end of program */
		if (QSPI_AutoPollingMemReady() != HAL_OK) {
24001732:	f7ff fdd9 	bl	240012e8 <QSPI_AutoPollingMemReady>
24001736:	4603      	mov	r3, r0
24001738:	2b00      	cmp	r3, #0
2400173a:	d001      	beq.n	24001740 <CSP_QSPI_WriteMemory+0xd8>
			return HAL_ERROR;
2400173c:	2301      	movs	r3, #1
2400173e:	e019      	b.n	24001774 <CSP_QSPI_WriteMemory+0x10c>
		}

		/* Update the address and size variables for next page programming */
		current_addr += current_size;
24001740:	6d3a      	ldr	r2, [r7, #80]	; 0x50
24001742:	6d7b      	ldr	r3, [r7, #84]	; 0x54
24001744:	4413      	add	r3, r2
24001746:	653b      	str	r3, [r7, #80]	; 0x50
		buffer += current_size;
24001748:	68fa      	ldr	r2, [r7, #12]
2400174a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
2400174c:	4413      	add	r3, r2
2400174e:	60fb      	str	r3, [r7, #12]
		current_size =
				((current_addr + MEMORY_PAGE_SIZE) > end_addr) ?
24001750:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24001752:	f503 7380 	add.w	r3, r3, #256	; 0x100
						(end_addr - current_addr) : MEMORY_PAGE_SIZE;
24001756:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
24001758:	429a      	cmp	r2, r3
2400175a:	d203      	bcs.n	24001764 <CSP_QSPI_WriteMemory+0xfc>
2400175c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
2400175e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
24001760:	1ad3      	subs	r3, r2, r3
24001762:	e001      	b.n	24001768 <CSP_QSPI_WriteMemory+0x100>
24001764:	f44f 7380 	mov.w	r3, #256	; 0x100
		current_size =
24001768:	657b      	str	r3, [r7, #84]	; 0x54
	} while (current_addr <= end_addr);
2400176a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
2400176c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
2400176e:	429a      	cmp	r2, r3
24001770:	d9b7      	bls.n	240016e2 <CSP_QSPI_WriteMemory+0x7a>

	return HAL_OK;
24001772:	2300      	movs	r3, #0

}
24001774:	4618      	mov	r0, r3
24001776:	3758      	adds	r7, #88	; 0x58
24001778:	46bd      	mov	sp, r7
2400177a:	bd80      	pop	{r7, pc}
2400177c:	24000538 	.word	0x24000538

24001780 <CSP_QSPI_EnableMemoryMappedMode>:


uint8_t CSP_QSPI_EnableMemoryMappedMode(void) {
24001780:	b580      	push	{r7, lr}
24001782:	b090      	sub	sp, #64	; 0x40
24001784:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	QSPI_MemoryMappedTypeDef sMemMappedCfg;

	/* Enable Memory-Mapped mode-------------------------------------------------- */

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
24001786:	f44f 7380 	mov.w	r3, #256	; 0x100
2400178a:	623b      	str	r3, [r7, #32]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
2400178c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24001790:	617b      	str	r3, [r7, #20]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001792:	2300      	movs	r3, #0
24001794:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001796:	2300      	movs	r3, #0
24001798:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400179a:	2300      	movs	r3, #0
2400179c:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2400179e:	2300      	movs	r3, #0
240017a0:	63fb      	str	r3, [r7, #60]	; 0x3c
	sCommand.AddressMode = QSPI_ADDRESS_1_LINE;
240017a2:	f44f 6380 	mov.w	r3, #1024	; 0x400
240017a6:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DataMode = QSPI_DATA_4_LINES;
240017a8:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
240017ac:	62fb      	str	r3, [r7, #44]	; 0x2c
	sCommand.NbData = 0;
240017ae:	2300      	movs	r3, #0
240017b0:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.Address = 0;
240017b2:	2300      	movs	r3, #0
240017b4:	60fb      	str	r3, [r7, #12]
	sCommand.Instruction = QUAD_OUT_FAST_READ_CMD;
240017b6:	236b      	movs	r3, #107	; 0x6b
240017b8:	60bb      	str	r3, [r7, #8]
	sCommand.DummyCycles = DUMMY_CLOCK_CYCLES_READ_QUAD;
240017ba:	2308      	movs	r3, #8
240017bc:	61fb      	str	r3, [r7, #28]

	sMemMappedCfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
240017be:	2300      	movs	r3, #0
240017c0:	607b      	str	r3, [r7, #4]

	if (HAL_QSPI_MemoryMapped(&hqspi, &sCommand, &sMemMappedCfg) != HAL_OK) {
240017c2:	463a      	mov	r2, r7
240017c4:	f107 0308 	add.w	r3, r7, #8
240017c8:	4619      	mov	r1, r3
240017ca:	4806      	ldr	r0, [pc, #24]	; (240017e4 <CSP_QSPI_EnableMemoryMappedMode+0x64>)
240017cc:	f010 feef 	bl	240125ae <HAL_QSPI_MemoryMapped>
240017d0:	4603      	mov	r3, r0
240017d2:	2b00      	cmp	r3, #0
240017d4:	d001      	beq.n	240017da <CSP_QSPI_EnableMemoryMappedMode+0x5a>
		return HAL_ERROR;
240017d6:	2301      	movs	r3, #1
240017d8:	e000      	b.n	240017dc <CSP_QSPI_EnableMemoryMappedMode+0x5c>
	}
	return HAL_OK;
240017da:	2300      	movs	r3, #0
}
240017dc:	4618      	mov	r0, r3
240017de:	3740      	adds	r7, #64	; 0x40
240017e0:	46bd      	mov	sp, r7
240017e2:	bd80      	pop	{r7, pc}
240017e4:	24000538 	.word	0x24000538

240017e8 <QSPI_ResetChip>:

/*Send reset in 1,2 and 4 lines*/
uint8_t QSPI_ResetChip() {
240017e8:	b580      	push	{r7, lr}
240017ea:	b090      	sub	sp, #64	; 0x40
240017ec:	af00      	add	r7, sp, #0
	QSPI_CommandTypeDef sCommand;
	uint32_t temp = 0;
240017ee:	2300      	movs	r3, #0
240017f0:	63fb      	str	r3, [r7, #60]	; 0x3c
	/* Erasing Sequence -------------------------------------------------- */
	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
240017f2:	f44f 7380 	mov.w	r3, #256	; 0x100
240017f6:	61fb      	str	r3, [r7, #28]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240017f8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240017fc:	613b      	str	r3, [r7, #16]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240017fe:	2300      	movs	r3, #0
24001800:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001802:	2300      	movs	r3, #0
24001804:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24001806:	2300      	movs	r3, #0
24001808:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2400180a:	2300      	movs	r3, #0
2400180c:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.Instruction = RESET_ENABLE_CMD;
2400180e:	2366      	movs	r3, #102	; 0x66
24001810:	607b      	str	r3, [r7, #4]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001812:	2300      	movs	r3, #0
24001814:	623b      	str	r3, [r7, #32]
	sCommand.Address = 0;
24001816:	2300      	movs	r3, #0
24001818:	60bb      	str	r3, [r7, #8]
	sCommand.DataMode = QSPI_DATA_NONE;
2400181a:	2300      	movs	r3, #0
2400181c:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DummyCycles = 0;
2400181e:	2300      	movs	r3, #0
24001820:	61bb      	str	r3, [r7, #24]

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001822:	1d3b      	adds	r3, r7, #4
24001824:	f241 3288 	movw	r2, #5000	; 0x1388
24001828:	4619      	mov	r1, r3
2400182a:	486f      	ldr	r0, [pc, #444]	; (240019e8 <QSPI_ResetChip+0x200>)
2400182c:	f010 f926 	bl	24011a7c <HAL_QSPI_Command>
24001830:	4603      	mov	r3, r0
24001832:	2b00      	cmp	r3, #0
24001834:	d001      	beq.n	2400183a <QSPI_ResetChip+0x52>
			!= HAL_OK) {
		return HAL_ERROR;
24001836:	2301      	movs	r3, #1
24001838:	e0d2      	b.n	240019e0 <QSPI_ResetChip+0x1f8>
	}
	for (temp = 0; temp < 0x2f; temp++) {
2400183a:	2300      	movs	r3, #0
2400183c:	63fb      	str	r3, [r7, #60]	; 0x3c
2400183e:	e003      	b.n	24001848 <QSPI_ResetChip+0x60>
		__NOP();
24001840:	bf00      	nop
	for (temp = 0; temp < 0x2f; temp++) {
24001842:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
24001844:	3301      	adds	r3, #1
24001846:	63fb      	str	r3, [r7, #60]	; 0x3c
24001848:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
2400184a:	2b2e      	cmp	r3, #46	; 0x2e
2400184c:	d9f8      	bls.n	24001840 <QSPI_ResetChip+0x58>
	}

	sCommand.InstructionMode = QSPI_INSTRUCTION_1_LINE;
2400184e:	f44f 7380 	mov.w	r3, #256	; 0x100
24001852:	61fb      	str	r3, [r7, #28]
	sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24001854:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24001858:	613b      	str	r3, [r7, #16]
	sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
2400185a:	2300      	movs	r3, #0
2400185c:	627b      	str	r3, [r7, #36]	; 0x24
	sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400185e:	2300      	movs	r3, #0
24001860:	633b      	str	r3, [r7, #48]	; 0x30
	sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24001862:	2300      	movs	r3, #0
24001864:	637b      	str	r3, [r7, #52]	; 0x34
	sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001866:	2300      	movs	r3, #0
24001868:	63bb      	str	r3, [r7, #56]	; 0x38
	sCommand.Instruction = RESET_EXECUTE_CMD;
2400186a:	2399      	movs	r3, #153	; 0x99
2400186c:	607b      	str	r3, [r7, #4]
	sCommand.AddressMode = QSPI_ADDRESS_NONE;
2400186e:	2300      	movs	r3, #0
24001870:	623b      	str	r3, [r7, #32]
	sCommand.Address = 0;
24001872:	2300      	movs	r3, #0
24001874:	60bb      	str	r3, [r7, #8]
	sCommand.DataMode = QSPI_DATA_NONE;
24001876:	2300      	movs	r3, #0
24001878:	62bb      	str	r3, [r7, #40]	; 0x28
	sCommand.DummyCycles = 0;
2400187a:	2300      	movs	r3, #0
2400187c:	61bb      	str	r3, [r7, #24]

	if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2400187e:	1d3b      	adds	r3, r7, #4
24001880:	f241 3288 	movw	r2, #5000	; 0x1388
24001884:	4619      	mov	r1, r3
24001886:	4858      	ldr	r0, [pc, #352]	; (240019e8 <QSPI_ResetChip+0x200>)
24001888:	f010 f8f8 	bl	24011a7c <HAL_QSPI_Command>
2400188c:	4603      	mov	r3, r0
2400188e:	2b00      	cmp	r3, #0
24001890:	d001      	beq.n	24001896 <QSPI_ResetChip+0xae>
			!= HAL_OK) {
		return HAL_ERROR;
24001892:	2301      	movs	r3, #1
24001894:	e0a4      	b.n	240019e0 <QSPI_ResetChip+0x1f8>
	}

	/* Erasing Sequence -------------------------------------------------- */
		sCommand.InstructionMode = QSPI_INSTRUCTION_2_LINES;
24001896:	f44f 7300 	mov.w	r3, #512	; 0x200
2400189a:	61fb      	str	r3, [r7, #28]
		sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
2400189c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240018a0:	613b      	str	r3, [r7, #16]
		sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240018a2:	2300      	movs	r3, #0
240018a4:	627b      	str	r3, [r7, #36]	; 0x24
		sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240018a6:	2300      	movs	r3, #0
240018a8:	633b      	str	r3, [r7, #48]	; 0x30
		sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240018aa:	2300      	movs	r3, #0
240018ac:	637b      	str	r3, [r7, #52]	; 0x34
		sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240018ae:	2300      	movs	r3, #0
240018b0:	63bb      	str	r3, [r7, #56]	; 0x38
		sCommand.Instruction = RESET_ENABLE_CMD;
240018b2:	2366      	movs	r3, #102	; 0x66
240018b4:	607b      	str	r3, [r7, #4]
		sCommand.AddressMode = QSPI_ADDRESS_NONE;
240018b6:	2300      	movs	r3, #0
240018b8:	623b      	str	r3, [r7, #32]
		sCommand.Address = 0;
240018ba:	2300      	movs	r3, #0
240018bc:	60bb      	str	r3, [r7, #8]
		sCommand.DataMode = QSPI_DATA_NONE;
240018be:	2300      	movs	r3, #0
240018c0:	62bb      	str	r3, [r7, #40]	; 0x28
		sCommand.DummyCycles = 0;
240018c2:	2300      	movs	r3, #0
240018c4:	61bb      	str	r3, [r7, #24]

		if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
240018c6:	1d3b      	adds	r3, r7, #4
240018c8:	f241 3288 	movw	r2, #5000	; 0x1388
240018cc:	4619      	mov	r1, r3
240018ce:	4846      	ldr	r0, [pc, #280]	; (240019e8 <QSPI_ResetChip+0x200>)
240018d0:	f010 f8d4 	bl	24011a7c <HAL_QSPI_Command>
240018d4:	4603      	mov	r3, r0
240018d6:	2b00      	cmp	r3, #0
240018d8:	d001      	beq.n	240018de <QSPI_ResetChip+0xf6>
				!= HAL_OK) {
			return HAL_ERROR;
240018da:	2301      	movs	r3, #1
240018dc:	e080      	b.n	240019e0 <QSPI_ResetChip+0x1f8>
		}
		for (temp = 0; temp < 0x2f; temp++) {
240018de:	2300      	movs	r3, #0
240018e0:	63fb      	str	r3, [r7, #60]	; 0x3c
240018e2:	e003      	b.n	240018ec <QSPI_ResetChip+0x104>
			__NOP();
240018e4:	bf00      	nop
		for (temp = 0; temp < 0x2f; temp++) {
240018e6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
240018e8:	3301      	adds	r3, #1
240018ea:	63fb      	str	r3, [r7, #60]	; 0x3c
240018ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
240018ee:	2b2e      	cmp	r3, #46	; 0x2e
240018f0:	d9f8      	bls.n	240018e4 <QSPI_ResetChip+0xfc>
		}

		sCommand.InstructionMode = QSPI_INSTRUCTION_2_LINES;
240018f2:	f44f 7300 	mov.w	r3, #512	; 0x200
240018f6:	61fb      	str	r3, [r7, #28]
		sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
240018f8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240018fc:	613b      	str	r3, [r7, #16]
		sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240018fe:	2300      	movs	r3, #0
24001900:	627b      	str	r3, [r7, #36]	; 0x24
		sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
24001902:	2300      	movs	r3, #0
24001904:	633b      	str	r3, [r7, #48]	; 0x30
		sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
24001906:	2300      	movs	r3, #0
24001908:	637b      	str	r3, [r7, #52]	; 0x34
		sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
2400190a:	2300      	movs	r3, #0
2400190c:	63bb      	str	r3, [r7, #56]	; 0x38
		sCommand.Instruction = RESET_EXECUTE_CMD;
2400190e:	2399      	movs	r3, #153	; 0x99
24001910:	607b      	str	r3, [r7, #4]
		sCommand.AddressMode = QSPI_ADDRESS_NONE;
24001912:	2300      	movs	r3, #0
24001914:	623b      	str	r3, [r7, #32]
		sCommand.Address = 0;
24001916:	2300      	movs	r3, #0
24001918:	60bb      	str	r3, [r7, #8]
		sCommand.DataMode = QSPI_DATA_NONE;
2400191a:	2300      	movs	r3, #0
2400191c:	62bb      	str	r3, [r7, #40]	; 0x28
		sCommand.DummyCycles = 0;
2400191e:	2300      	movs	r3, #0
24001920:	61bb      	str	r3, [r7, #24]

		if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
24001922:	1d3b      	adds	r3, r7, #4
24001924:	f241 3288 	movw	r2, #5000	; 0x1388
24001928:	4619      	mov	r1, r3
2400192a:	482f      	ldr	r0, [pc, #188]	; (240019e8 <QSPI_ResetChip+0x200>)
2400192c:	f010 f8a6 	bl	24011a7c <HAL_QSPI_Command>
24001930:	4603      	mov	r3, r0
24001932:	2b00      	cmp	r3, #0
24001934:	d001      	beq.n	2400193a <QSPI_ResetChip+0x152>
				!= HAL_OK) {
			return HAL_ERROR;
24001936:	2301      	movs	r3, #1
24001938:	e052      	b.n	240019e0 <QSPI_ResetChip+0x1f8>
		}


		/* Erasing Sequence -------------------------------------------------- */
			sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
2400193a:	f44f 7340 	mov.w	r3, #768	; 0x300
2400193e:	61fb      	str	r3, [r7, #28]
			sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
24001940:	f44f 5300 	mov.w	r3, #8192	; 0x2000
24001944:	613b      	str	r3, [r7, #16]
			sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
24001946:	2300      	movs	r3, #0
24001948:	627b      	str	r3, [r7, #36]	; 0x24
			sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
2400194a:	2300      	movs	r3, #0
2400194c:	633b      	str	r3, [r7, #48]	; 0x30
			sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
2400194e:	2300      	movs	r3, #0
24001950:	637b      	str	r3, [r7, #52]	; 0x34
			sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
24001952:	2300      	movs	r3, #0
24001954:	63bb      	str	r3, [r7, #56]	; 0x38
			sCommand.Instruction = RESET_ENABLE_CMD;
24001956:	2366      	movs	r3, #102	; 0x66
24001958:	607b      	str	r3, [r7, #4]
			sCommand.AddressMode = QSPI_ADDRESS_NONE;
2400195a:	2300      	movs	r3, #0
2400195c:	623b      	str	r3, [r7, #32]
			sCommand.Address = 0;
2400195e:	2300      	movs	r3, #0
24001960:	60bb      	str	r3, [r7, #8]
			sCommand.DataMode = QSPI_DATA_NONE;
24001962:	2300      	movs	r3, #0
24001964:	62bb      	str	r3, [r7, #40]	; 0x28
			sCommand.DummyCycles = 0;
24001966:	2300      	movs	r3, #0
24001968:	61bb      	str	r3, [r7, #24]

			if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
2400196a:	1d3b      	adds	r3, r7, #4
2400196c:	f241 3288 	movw	r2, #5000	; 0x1388
24001970:	4619      	mov	r1, r3
24001972:	481d      	ldr	r0, [pc, #116]	; (240019e8 <QSPI_ResetChip+0x200>)
24001974:	f010 f882 	bl	24011a7c <HAL_QSPI_Command>
24001978:	4603      	mov	r3, r0
2400197a:	2b00      	cmp	r3, #0
2400197c:	d001      	beq.n	24001982 <QSPI_ResetChip+0x19a>
					!= HAL_OK) {
				return HAL_ERROR;
2400197e:	2301      	movs	r3, #1
24001980:	e02e      	b.n	240019e0 <QSPI_ResetChip+0x1f8>
			}
			for (temp = 0; temp < 0x2f; temp++) {
24001982:	2300      	movs	r3, #0
24001984:	63fb      	str	r3, [r7, #60]	; 0x3c
24001986:	e003      	b.n	24001990 <QSPI_ResetChip+0x1a8>
				__NOP();
24001988:	bf00      	nop
			for (temp = 0; temp < 0x2f; temp++) {
2400198a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
2400198c:	3301      	adds	r3, #1
2400198e:	63fb      	str	r3, [r7, #60]	; 0x3c
24001990:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
24001992:	2b2e      	cmp	r3, #46	; 0x2e
24001994:	d9f8      	bls.n	24001988 <QSPI_ResetChip+0x1a0>
			}

			sCommand.InstructionMode = QSPI_INSTRUCTION_4_LINES;
24001996:	f44f 7340 	mov.w	r3, #768	; 0x300
2400199a:	61fb      	str	r3, [r7, #28]
			sCommand.AddressSize = QSPI_ADDRESS_24_BITS;
2400199c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
240019a0:	613b      	str	r3, [r7, #16]
			sCommand.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
240019a2:	2300      	movs	r3, #0
240019a4:	627b      	str	r3, [r7, #36]	; 0x24
			sCommand.DdrMode = QSPI_DDR_MODE_DISABLE;
240019a6:	2300      	movs	r3, #0
240019a8:	633b      	str	r3, [r7, #48]	; 0x30
			sCommand.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;
240019aa:	2300      	movs	r3, #0
240019ac:	637b      	str	r3, [r7, #52]	; 0x34
			sCommand.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;
240019ae:	2300      	movs	r3, #0
240019b0:	63bb      	str	r3, [r7, #56]	; 0x38
			sCommand.Instruction = RESET_EXECUTE_CMD;
240019b2:	2399      	movs	r3, #153	; 0x99
240019b4:	607b      	str	r3, [r7, #4]
			sCommand.AddressMode = QSPI_ADDRESS_NONE;
240019b6:	2300      	movs	r3, #0
240019b8:	623b      	str	r3, [r7, #32]
			sCommand.Address = 0;
240019ba:	2300      	movs	r3, #0
240019bc:	60bb      	str	r3, [r7, #8]
			sCommand.DataMode = QSPI_DATA_NONE;
240019be:	2300      	movs	r3, #0
240019c0:	62bb      	str	r3, [r7, #40]	; 0x28
			sCommand.DummyCycles = 0;
240019c2:	2300      	movs	r3, #0
240019c4:	61bb      	str	r3, [r7, #24]

			if (HAL_QSPI_Command(&hqspi, &sCommand, HAL_QPSI_TIMEOUT_DEFAULT_VALUE)
240019c6:	1d3b      	adds	r3, r7, #4
240019c8:	f241 3288 	movw	r2, #5000	; 0x1388
240019cc:	4619      	mov	r1, r3
240019ce:	4806      	ldr	r0, [pc, #24]	; (240019e8 <QSPI_ResetChip+0x200>)
240019d0:	f010 f854 	bl	24011a7c <HAL_QSPI_Command>
240019d4:	4603      	mov	r3, r0
240019d6:	2b00      	cmp	r3, #0
240019d8:	d001      	beq.n	240019de <QSPI_ResetChip+0x1f6>
					!= HAL_OK) {
				return HAL_ERROR;
240019da:	2301      	movs	r3, #1
240019dc:	e000      	b.n	240019e0 <QSPI_ResetChip+0x1f8>
			}


	return HAL_OK;
240019de:	2300      	movs	r3, #0
}
240019e0:	4618      	mov	r0, r3
240019e2:	3740      	adds	r7, #64	; 0x40
240019e4:	46bd      	mov	sp, r7
240019e6:	bd80      	pop	{r7, pc}
240019e8:	24000538 	.word	0x24000538

240019ec <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
240019ec:	b480      	push	{r7}
240019ee:	b083      	sub	sp, #12
240019f0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
240019f2:	4b0a      	ldr	r3, [pc, #40]	; (24001a1c <HAL_MspInit+0x30>)
240019f4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
240019f8:	4a08      	ldr	r2, [pc, #32]	; (24001a1c <HAL_MspInit+0x30>)
240019fa:	f043 0302 	orr.w	r3, r3, #2
240019fe:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
24001a02:	4b06      	ldr	r3, [pc, #24]	; (24001a1c <HAL_MspInit+0x30>)
24001a04:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
24001a08:	f003 0302 	and.w	r3, r3, #2
24001a0c:	607b      	str	r3, [r7, #4]
24001a0e:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
24001a10:	bf00      	nop
24001a12:	370c      	adds	r7, #12
24001a14:	46bd      	mov	sp, r7
24001a16:	f85d 7b04 	ldr.w	r7, [sp], #4
24001a1a:	4770      	bx	lr
24001a1c:	58024400 	.word	0x58024400

24001a20 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
24001a20:	b480      	push	{r7}
24001a22:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
24001a24:	e7fe      	b.n	24001a24 <NMI_Handler+0x4>

24001a26 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
24001a26:	b480      	push	{r7}
24001a28:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
24001a2a:	e7fe      	b.n	24001a2a <HardFault_Handler+0x4>

24001a2c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
24001a2c:	b480      	push	{r7}
24001a2e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
24001a30:	e7fe      	b.n	24001a30 <MemManage_Handler+0x4>

24001a32 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
24001a32:	b480      	push	{r7}
24001a34:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
24001a36:	e7fe      	b.n	24001a36 <BusFault_Handler+0x4>

24001a38 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
24001a38:	b480      	push	{r7}
24001a3a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
24001a3c:	e7fe      	b.n	24001a3c <UsageFault_Handler+0x4>

24001a3e <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
24001a3e:	b480      	push	{r7}
24001a40:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
24001a42:	bf00      	nop
24001a44:	46bd      	mov	sp, r7
24001a46:	f85d 7b04 	ldr.w	r7, [sp], #4
24001a4a:	4770      	bx	lr

24001a4c <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
24001a4c:	b480      	push	{r7}
24001a4e:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
24001a50:	bf00      	nop
24001a52:	46bd      	mov	sp, r7
24001a54:	f85d 7b04 	ldr.w	r7, [sp], #4
24001a58:	4770      	bx	lr

24001a5a <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
24001a5a:	b480      	push	{r7}
24001a5c:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
24001a5e:	bf00      	nop
24001a60:	46bd      	mov	sp, r7
24001a62:	f85d 7b04 	ldr.w	r7, [sp], #4
24001a66:	4770      	bx	lr

24001a68 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
24001a68:	b580      	push	{r7, lr}
24001a6a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
24001a6c:	f000 fc56 	bl	2400231c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
24001a70:	bf00      	nop
24001a72:	bd80      	pop	{r7, pc}

24001a74 <QUADSPI_IRQHandler>:

/**
  * @brief This function handles QUADSPI global interrupt.
  */
void QUADSPI_IRQHandler(void)
{
24001a74:	b580      	push	{r7, lr}
24001a76:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN QUADSPI_IRQn 0 */

  /* USER CODE END QUADSPI_IRQn 0 */
  HAL_QSPI_IRQHandler(&hqspi);
24001a78:	4802      	ldr	r0, [pc, #8]	; (24001a84 <QUADSPI_IRQHandler+0x10>)
24001a7a:	f00f fe45 	bl	24011708 <HAL_QSPI_IRQHandler>
  /* USER CODE BEGIN QUADSPI_IRQn 1 */

  /* USER CODE END QUADSPI_IRQn 1 */
}
24001a7e:	bf00      	nop
24001a80:	bd80      	pop	{r7, pc}
24001a82:	bf00      	nop
24001a84:	24000538 	.word	0x24000538

24001a88 <initialise_monitor_handles>:
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
24001a88:	b480      	push	{r7}
24001a8a:	af00      	add	r7, sp, #0
}
24001a8c:	bf00      	nop
24001a8e:	46bd      	mov	sp, r7
24001a90:	f85d 7b04 	ldr.w	r7, [sp], #4
24001a94:	4770      	bx	lr

24001a96 <_getpid>:

int _getpid(void)
{
24001a96:	b480      	push	{r7}
24001a98:	af00      	add	r7, sp, #0
	return 1;
24001a9a:	2301      	movs	r3, #1
}
24001a9c:	4618      	mov	r0, r3
24001a9e:	46bd      	mov	sp, r7
24001aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
24001aa4:	4770      	bx	lr

24001aa6 <_kill>:

int _kill(int pid, int sig)
{
24001aa6:	b580      	push	{r7, lr}
24001aa8:	b082      	sub	sp, #8
24001aaa:	af00      	add	r7, sp, #0
24001aac:	6078      	str	r0, [r7, #4]
24001aae:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
24001ab0:	f015 fc62 	bl	24017378 <__errno>
24001ab4:	4603      	mov	r3, r0
24001ab6:	2216      	movs	r2, #22
24001ab8:	601a      	str	r2, [r3, #0]
	return -1;
24001aba:	f04f 33ff 	mov.w	r3, #4294967295
}
24001abe:	4618      	mov	r0, r3
24001ac0:	3708      	adds	r7, #8
24001ac2:	46bd      	mov	sp, r7
24001ac4:	bd80      	pop	{r7, pc}

24001ac6 <_exit>:

void _exit (int status)
{
24001ac6:	b580      	push	{r7, lr}
24001ac8:	b082      	sub	sp, #8
24001aca:	af00      	add	r7, sp, #0
24001acc:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
24001ace:	f04f 31ff 	mov.w	r1, #4294967295
24001ad2:	6878      	ldr	r0, [r7, #4]
24001ad4:	f7ff ffe7 	bl	24001aa6 <_kill>
	while (1) {}		/* Make sure we hang here */
24001ad8:	e7fe      	b.n	24001ad8 <_exit+0x12>

24001ada <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
24001ada:	b580      	push	{r7, lr}
24001adc:	b086      	sub	sp, #24
24001ade:	af00      	add	r7, sp, #0
24001ae0:	60f8      	str	r0, [r7, #12]
24001ae2:	60b9      	str	r1, [r7, #8]
24001ae4:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
24001ae6:	2300      	movs	r3, #0
24001ae8:	617b      	str	r3, [r7, #20]
24001aea:	e00a      	b.n	24001b02 <_read+0x28>
	{
		*ptr++ = __io_getchar();
24001aec:	f3af 8000 	nop.w
24001af0:	4601      	mov	r1, r0
24001af2:	68bb      	ldr	r3, [r7, #8]
24001af4:	1c5a      	adds	r2, r3, #1
24001af6:	60ba      	str	r2, [r7, #8]
24001af8:	b2ca      	uxtb	r2, r1
24001afa:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
24001afc:	697b      	ldr	r3, [r7, #20]
24001afe:	3301      	adds	r3, #1
24001b00:	617b      	str	r3, [r7, #20]
24001b02:	697a      	ldr	r2, [r7, #20]
24001b04:	687b      	ldr	r3, [r7, #4]
24001b06:	429a      	cmp	r2, r3
24001b08:	dbf0      	blt.n	24001aec <_read+0x12>
	}

return len;
24001b0a:	687b      	ldr	r3, [r7, #4]
}
24001b0c:	4618      	mov	r0, r3
24001b0e:	3718      	adds	r7, #24
24001b10:	46bd      	mov	sp, r7
24001b12:	bd80      	pop	{r7, pc}

24001b14 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
24001b14:	b580      	push	{r7, lr}
24001b16:	b086      	sub	sp, #24
24001b18:	af00      	add	r7, sp, #0
24001b1a:	60f8      	str	r0, [r7, #12]
24001b1c:	60b9      	str	r1, [r7, #8]
24001b1e:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
24001b20:	2300      	movs	r3, #0
24001b22:	617b      	str	r3, [r7, #20]
24001b24:	e009      	b.n	24001b3a <_write+0x26>
	{
		__io_putchar(*ptr++);
24001b26:	68bb      	ldr	r3, [r7, #8]
24001b28:	1c5a      	adds	r2, r3, #1
24001b2a:	60ba      	str	r2, [r7, #8]
24001b2c:	781b      	ldrb	r3, [r3, #0]
24001b2e:	4618      	mov	r0, r3
24001b30:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
24001b34:	697b      	ldr	r3, [r7, #20]
24001b36:	3301      	adds	r3, #1
24001b38:	617b      	str	r3, [r7, #20]
24001b3a:	697a      	ldr	r2, [r7, #20]
24001b3c:	687b      	ldr	r3, [r7, #4]
24001b3e:	429a      	cmp	r2, r3
24001b40:	dbf1      	blt.n	24001b26 <_write+0x12>
	}
	return len;
24001b42:	687b      	ldr	r3, [r7, #4]
}
24001b44:	4618      	mov	r0, r3
24001b46:	3718      	adds	r7, #24
24001b48:	46bd      	mov	sp, r7
24001b4a:	bd80      	pop	{r7, pc}

24001b4c <_close>:

int _close(int file)
{
24001b4c:	b480      	push	{r7}
24001b4e:	b083      	sub	sp, #12
24001b50:	af00      	add	r7, sp, #0
24001b52:	6078      	str	r0, [r7, #4]
	return -1;
24001b54:	f04f 33ff 	mov.w	r3, #4294967295
}
24001b58:	4618      	mov	r0, r3
24001b5a:	370c      	adds	r7, #12
24001b5c:	46bd      	mov	sp, r7
24001b5e:	f85d 7b04 	ldr.w	r7, [sp], #4
24001b62:	4770      	bx	lr

24001b64 <_fstat>:


int _fstat(int file, struct stat *st)
{
24001b64:	b480      	push	{r7}
24001b66:	b083      	sub	sp, #12
24001b68:	af00      	add	r7, sp, #0
24001b6a:	6078      	str	r0, [r7, #4]
24001b6c:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
24001b6e:	683b      	ldr	r3, [r7, #0]
24001b70:	f44f 5200 	mov.w	r2, #8192	; 0x2000
24001b74:	605a      	str	r2, [r3, #4]
	return 0;
24001b76:	2300      	movs	r3, #0
}
24001b78:	4618      	mov	r0, r3
24001b7a:	370c      	adds	r7, #12
24001b7c:	46bd      	mov	sp, r7
24001b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
24001b82:	4770      	bx	lr

24001b84 <_isatty>:

int _isatty(int file)
{
24001b84:	b480      	push	{r7}
24001b86:	b083      	sub	sp, #12
24001b88:	af00      	add	r7, sp, #0
24001b8a:	6078      	str	r0, [r7, #4]
	return 1;
24001b8c:	2301      	movs	r3, #1
}
24001b8e:	4618      	mov	r0, r3
24001b90:	370c      	adds	r7, #12
24001b92:	46bd      	mov	sp, r7
24001b94:	f85d 7b04 	ldr.w	r7, [sp], #4
24001b98:	4770      	bx	lr

24001b9a <_lseek>:

int _lseek(int file, int ptr, int dir)
{
24001b9a:	b480      	push	{r7}
24001b9c:	b085      	sub	sp, #20
24001b9e:	af00      	add	r7, sp, #0
24001ba0:	60f8      	str	r0, [r7, #12]
24001ba2:	60b9      	str	r1, [r7, #8]
24001ba4:	607a      	str	r2, [r7, #4]
	return 0;
24001ba6:	2300      	movs	r3, #0
}
24001ba8:	4618      	mov	r0, r3
24001baa:	3714      	adds	r7, #20
24001bac:	46bd      	mov	sp, r7
24001bae:	f85d 7b04 	ldr.w	r7, [sp], #4
24001bb2:	4770      	bx	lr

24001bb4 <_open>:

int _open(char *path, int flags, ...)
{
24001bb4:	b40e      	push	{r1, r2, r3}
24001bb6:	b480      	push	{r7}
24001bb8:	b082      	sub	sp, #8
24001bba:	af00      	add	r7, sp, #0
24001bbc:	6078      	str	r0, [r7, #4]
	/* Pretend like we always fail */
	return -1;
24001bbe:	f04f 33ff 	mov.w	r3, #4294967295
}
24001bc2:	4618      	mov	r0, r3
24001bc4:	3708      	adds	r7, #8
24001bc6:	46bd      	mov	sp, r7
24001bc8:	f85d 7b04 	ldr.w	r7, [sp], #4
24001bcc:	b003      	add	sp, #12
24001bce:	4770      	bx	lr

24001bd0 <_wait>:

int _wait(int *status)
{
24001bd0:	b580      	push	{r7, lr}
24001bd2:	b082      	sub	sp, #8
24001bd4:	af00      	add	r7, sp, #0
24001bd6:	6078      	str	r0, [r7, #4]
	errno = ECHILD;
24001bd8:	f015 fbce 	bl	24017378 <__errno>
24001bdc:	4603      	mov	r3, r0
24001bde:	220a      	movs	r2, #10
24001be0:	601a      	str	r2, [r3, #0]
	return -1;
24001be2:	f04f 33ff 	mov.w	r3, #4294967295
}
24001be6:	4618      	mov	r0, r3
24001be8:	3708      	adds	r7, #8
24001bea:	46bd      	mov	sp, r7
24001bec:	bd80      	pop	{r7, pc}

24001bee <_unlink>:

int _unlink(char *name)
{
24001bee:	b580      	push	{r7, lr}
24001bf0:	b082      	sub	sp, #8
24001bf2:	af00      	add	r7, sp, #0
24001bf4:	6078      	str	r0, [r7, #4]
	errno = ENOENT;
24001bf6:	f015 fbbf 	bl	24017378 <__errno>
24001bfa:	4603      	mov	r3, r0
24001bfc:	2202      	movs	r2, #2
24001bfe:	601a      	str	r2, [r3, #0]
	return -1;
24001c00:	f04f 33ff 	mov.w	r3, #4294967295
}
24001c04:	4618      	mov	r0, r3
24001c06:	3708      	adds	r7, #8
24001c08:	46bd      	mov	sp, r7
24001c0a:	bd80      	pop	{r7, pc}

24001c0c <_times>:

int _times(struct tms *buf)
{
24001c0c:	b480      	push	{r7}
24001c0e:	b083      	sub	sp, #12
24001c10:	af00      	add	r7, sp, #0
24001c12:	6078      	str	r0, [r7, #4]
	return -1;
24001c14:	f04f 33ff 	mov.w	r3, #4294967295
}
24001c18:	4618      	mov	r0, r3
24001c1a:	370c      	adds	r7, #12
24001c1c:	46bd      	mov	sp, r7
24001c1e:	f85d 7b04 	ldr.w	r7, [sp], #4
24001c22:	4770      	bx	lr

24001c24 <_stat>:

int _stat(char *file, struct stat *st)
{
24001c24:	b480      	push	{r7}
24001c26:	b083      	sub	sp, #12
24001c28:	af00      	add	r7, sp, #0
24001c2a:	6078      	str	r0, [r7, #4]
24001c2c:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
24001c2e:	683b      	ldr	r3, [r7, #0]
24001c30:	f44f 5200 	mov.w	r2, #8192	; 0x2000
24001c34:	605a      	str	r2, [r3, #4]
	return 0;
24001c36:	2300      	movs	r3, #0
}
24001c38:	4618      	mov	r0, r3
24001c3a:	370c      	adds	r7, #12
24001c3c:	46bd      	mov	sp, r7
24001c3e:	f85d 7b04 	ldr.w	r7, [sp], #4
24001c42:	4770      	bx	lr

24001c44 <_link>:

int _link(char *old, char *new)
{
24001c44:	b580      	push	{r7, lr}
24001c46:	b082      	sub	sp, #8
24001c48:	af00      	add	r7, sp, #0
24001c4a:	6078      	str	r0, [r7, #4]
24001c4c:	6039      	str	r1, [r7, #0]
	errno = EMLINK;
24001c4e:	f015 fb93 	bl	24017378 <__errno>
24001c52:	4603      	mov	r3, r0
24001c54:	221f      	movs	r2, #31
24001c56:	601a      	str	r2, [r3, #0]
	return -1;
24001c58:	f04f 33ff 	mov.w	r3, #4294967295
}
24001c5c:	4618      	mov	r0, r3
24001c5e:	3708      	adds	r7, #8
24001c60:	46bd      	mov	sp, r7
24001c62:	bd80      	pop	{r7, pc}

24001c64 <_fork>:

int _fork(void)
{
24001c64:	b580      	push	{r7, lr}
24001c66:	af00      	add	r7, sp, #0
	errno = EAGAIN;
24001c68:	f015 fb86 	bl	24017378 <__errno>
24001c6c:	4603      	mov	r3, r0
24001c6e:	220b      	movs	r2, #11
24001c70:	601a      	str	r2, [r3, #0]
	return -1;
24001c72:	f04f 33ff 	mov.w	r3, #4294967295
}
24001c76:	4618      	mov	r0, r3
24001c78:	bd80      	pop	{r7, pc}

24001c7a <_execve>:

int _execve(char *name, char **argv, char **env)
{
24001c7a:	b580      	push	{r7, lr}
24001c7c:	b084      	sub	sp, #16
24001c7e:	af00      	add	r7, sp, #0
24001c80:	60f8      	str	r0, [r7, #12]
24001c82:	60b9      	str	r1, [r7, #8]
24001c84:	607a      	str	r2, [r7, #4]
	errno = ENOMEM;
24001c86:	f015 fb77 	bl	24017378 <__errno>
24001c8a:	4603      	mov	r3, r0
24001c8c:	220c      	movs	r2, #12
24001c8e:	601a      	str	r2, [r3, #0]
	return -1;
24001c90:	f04f 33ff 	mov.w	r3, #4294967295
}
24001c94:	4618      	mov	r0, r3
24001c96:	3710      	adds	r7, #16
24001c98:	46bd      	mov	sp, r7
24001c9a:	bd80      	pop	{r7, pc}

24001c9c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
24001c9c:	b580      	push	{r7, lr}
24001c9e:	b086      	sub	sp, #24
24001ca0:	af00      	add	r7, sp, #0
24001ca2:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
24001ca4:	4a14      	ldr	r2, [pc, #80]	; (24001cf8 <_sbrk+0x5c>)
24001ca6:	4b15      	ldr	r3, [pc, #84]	; (24001cfc <_sbrk+0x60>)
24001ca8:	1ad3      	subs	r3, r2, r3
24001caa:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
24001cac:	697b      	ldr	r3, [r7, #20]
24001cae:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
24001cb0:	4b13      	ldr	r3, [pc, #76]	; (24001d00 <_sbrk+0x64>)
24001cb2:	681b      	ldr	r3, [r3, #0]
24001cb4:	2b00      	cmp	r3, #0
24001cb6:	d102      	bne.n	24001cbe <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
24001cb8:	4b11      	ldr	r3, [pc, #68]	; (24001d00 <_sbrk+0x64>)
24001cba:	4a12      	ldr	r2, [pc, #72]	; (24001d04 <_sbrk+0x68>)
24001cbc:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
24001cbe:	4b10      	ldr	r3, [pc, #64]	; (24001d00 <_sbrk+0x64>)
24001cc0:	681a      	ldr	r2, [r3, #0]
24001cc2:	687b      	ldr	r3, [r7, #4]
24001cc4:	4413      	add	r3, r2
24001cc6:	693a      	ldr	r2, [r7, #16]
24001cc8:	429a      	cmp	r2, r3
24001cca:	d207      	bcs.n	24001cdc <_sbrk+0x40>
  {
    errno = ENOMEM;
24001ccc:	f015 fb54 	bl	24017378 <__errno>
24001cd0:	4603      	mov	r3, r0
24001cd2:	220c      	movs	r2, #12
24001cd4:	601a      	str	r2, [r3, #0]
    return (void *)-1;
24001cd6:	f04f 33ff 	mov.w	r3, #4294967295
24001cda:	e009      	b.n	24001cf0 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
24001cdc:	4b08      	ldr	r3, [pc, #32]	; (24001d00 <_sbrk+0x64>)
24001cde:	681b      	ldr	r3, [r3, #0]
24001ce0:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
24001ce2:	4b07      	ldr	r3, [pc, #28]	; (24001d00 <_sbrk+0x64>)
24001ce4:	681a      	ldr	r2, [r3, #0]
24001ce6:	687b      	ldr	r3, [r7, #4]
24001ce8:	4413      	add	r3, r2
24001cea:	4a05      	ldr	r2, [pc, #20]	; (24001d00 <_sbrk+0x64>)
24001cec:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
24001cee:	68fb      	ldr	r3, [r7, #12]
}
24001cf0:	4618      	mov	r0, r3
24001cf2:	3718      	adds	r7, #24
24001cf4:	46bd      	mov	sp, r7
24001cf6:	bd80      	pop	{r7, pc}
24001cf8:	24080004 	.word	0x24080004
24001cfc:	00000400 	.word	0x00000400
24001d00:	24000588 	.word	0x24000588
24001d04:	240178bc 	.word	0x240178bc

24001d08 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
24001d08:	b480      	push	{r7}
24001d0a:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
24001d0c:	4b37      	ldr	r3, [pc, #220]	; (24001dec <SystemInit+0xe4>)
24001d0e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24001d12:	4a36      	ldr	r2, [pc, #216]	; (24001dec <SystemInit+0xe4>)
24001d14:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
24001d18:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
24001d1c:	4b34      	ldr	r3, [pc, #208]	; (24001df0 <SystemInit+0xe8>)
24001d1e:	681b      	ldr	r3, [r3, #0]
24001d20:	f003 030f 	and.w	r3, r3, #15
24001d24:	2b06      	cmp	r3, #6
24001d26:	d807      	bhi.n	24001d38 <SystemInit+0x30>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
24001d28:	4b31      	ldr	r3, [pc, #196]	; (24001df0 <SystemInit+0xe8>)
24001d2a:	681b      	ldr	r3, [r3, #0]
24001d2c:	f023 030f 	bic.w	r3, r3, #15
24001d30:	4a2f      	ldr	r2, [pc, #188]	; (24001df0 <SystemInit+0xe8>)
24001d32:	f043 0307 	orr.w	r3, r3, #7
24001d36:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
24001d38:	4b2e      	ldr	r3, [pc, #184]	; (24001df4 <SystemInit+0xec>)
24001d3a:	681b      	ldr	r3, [r3, #0]
24001d3c:	4a2d      	ldr	r2, [pc, #180]	; (24001df4 <SystemInit+0xec>)
24001d3e:	f043 0301 	orr.w	r3, r3, #1
24001d42:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
24001d44:	4b2b      	ldr	r3, [pc, #172]	; (24001df4 <SystemInit+0xec>)
24001d46:	2200      	movs	r2, #0
24001d48:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
24001d4a:	4b2a      	ldr	r3, [pc, #168]	; (24001df4 <SystemInit+0xec>)
24001d4c:	681a      	ldr	r2, [r3, #0]
24001d4e:	4929      	ldr	r1, [pc, #164]	; (24001df4 <SystemInit+0xec>)
24001d50:	4b29      	ldr	r3, [pc, #164]	; (24001df8 <SystemInit+0xf0>)
24001d52:	4013      	ands	r3, r2
24001d54:	600b      	str	r3, [r1, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
24001d56:	4b26      	ldr	r3, [pc, #152]	; (24001df0 <SystemInit+0xe8>)
24001d58:	681b      	ldr	r3, [r3, #0]
24001d5a:	f003 0308 	and.w	r3, r3, #8
24001d5e:	2b00      	cmp	r3, #0
24001d60:	d007      	beq.n	24001d72 <SystemInit+0x6a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
24001d62:	4b23      	ldr	r3, [pc, #140]	; (24001df0 <SystemInit+0xe8>)
24001d64:	681b      	ldr	r3, [r3, #0]
24001d66:	f023 030f 	bic.w	r3, r3, #15
24001d6a:	4a21      	ldr	r2, [pc, #132]	; (24001df0 <SystemInit+0xe8>)
24001d6c:	f043 0307 	orr.w	r3, r3, #7
24001d70:	6013      	str	r3, [r2, #0]
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
24001d72:	4b20      	ldr	r3, [pc, #128]	; (24001df4 <SystemInit+0xec>)
24001d74:	2200      	movs	r2, #0
24001d76:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
24001d78:	4b1e      	ldr	r3, [pc, #120]	; (24001df4 <SystemInit+0xec>)
24001d7a:	2200      	movs	r2, #0
24001d7c:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
24001d7e:	4b1d      	ldr	r3, [pc, #116]	; (24001df4 <SystemInit+0xec>)
24001d80:	2200      	movs	r2, #0
24001d82:	621a      	str	r2, [r3, #32]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
24001d84:	4b1b      	ldr	r3, [pc, #108]	; (24001df4 <SystemInit+0xec>)
24001d86:	4a1d      	ldr	r2, [pc, #116]	; (24001dfc <SystemInit+0xf4>)
24001d88:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
24001d8a:	4b1a      	ldr	r3, [pc, #104]	; (24001df4 <SystemInit+0xec>)
24001d8c:	4a1c      	ldr	r2, [pc, #112]	; (24001e00 <SystemInit+0xf8>)
24001d8e:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
24001d90:	4b18      	ldr	r3, [pc, #96]	; (24001df4 <SystemInit+0xec>)
24001d92:	4a1c      	ldr	r2, [pc, #112]	; (24001e04 <SystemInit+0xfc>)
24001d94:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
24001d96:	4b17      	ldr	r3, [pc, #92]	; (24001df4 <SystemInit+0xec>)
24001d98:	2200      	movs	r2, #0
24001d9a:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
24001d9c:	4b15      	ldr	r3, [pc, #84]	; (24001df4 <SystemInit+0xec>)
24001d9e:	4a19      	ldr	r2, [pc, #100]	; (24001e04 <SystemInit+0xfc>)
24001da0:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
24001da2:	4b14      	ldr	r3, [pc, #80]	; (24001df4 <SystemInit+0xec>)
24001da4:	2200      	movs	r2, #0
24001da6:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
24001da8:	4b12      	ldr	r3, [pc, #72]	; (24001df4 <SystemInit+0xec>)
24001daa:	4a16      	ldr	r2, [pc, #88]	; (24001e04 <SystemInit+0xfc>)
24001dac:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
24001dae:	4b11      	ldr	r3, [pc, #68]	; (24001df4 <SystemInit+0xec>)
24001db0:	2200      	movs	r2, #0
24001db2:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
24001db4:	4b0f      	ldr	r3, [pc, #60]	; (24001df4 <SystemInit+0xec>)
24001db6:	681b      	ldr	r3, [r3, #0]
24001db8:	4a0e      	ldr	r2, [pc, #56]	; (24001df4 <SystemInit+0xec>)
24001dba:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24001dbe:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
24001dc0:	4b0c      	ldr	r3, [pc, #48]	; (24001df4 <SystemInit+0xec>)
24001dc2:	2200      	movs	r2, #0
24001dc4:	661a      	str	r2, [r3, #96]	; 0x60

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
24001dc6:	4b10      	ldr	r3, [pc, #64]	; (24001e08 <SystemInit+0x100>)
24001dc8:	681a      	ldr	r2, [r3, #0]
24001dca:	4b10      	ldr	r3, [pc, #64]	; (24001e0c <SystemInit+0x104>)
24001dcc:	4013      	ands	r3, r2
24001dce:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24001dd2:	d202      	bcs.n	24001dda <SystemInit+0xd2>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
24001dd4:	4b0e      	ldr	r3, [pc, #56]	; (24001e10 <SystemInit+0x108>)
24001dd6:	2201      	movs	r2, #1
24001dd8:	601a      	str	r2, [r3, #0]
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
24001dda:	4b0e      	ldr	r3, [pc, #56]	; (24001e14 <SystemInit+0x10c>)
24001ddc:	f243 02d2 	movw	r2, #12498	; 0x30d2
24001de0:	601a      	str	r2, [r3, #0]
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
24001de2:	bf00      	nop
24001de4:	46bd      	mov	sp, r7
24001de6:	f85d 7b04 	ldr.w	r7, [sp], #4
24001dea:	4770      	bx	lr
24001dec:	e000ed00 	.word	0xe000ed00
24001df0:	52002000 	.word	0x52002000
24001df4:	58024400 	.word	0x58024400
24001df8:	eaf6ed7f 	.word	0xeaf6ed7f
24001dfc:	02020200 	.word	0x02020200
24001e00:	01ff0000 	.word	0x01ff0000
24001e04:	01010280 	.word	0x01010280
24001e08:	5c001000 	.word	0x5c001000
24001e0c:	ffff0000 	.word	0xffff0000
24001e10:	51008108 	.word	0x51008108
24001e14:	52004000 	.word	0x52004000

24001e18 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
24001e18:	b480      	push	{r7}
24001e1a:	b08b      	sub	sp, #44	; 0x2c
24001e1c:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;


  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
24001e1e:	4bb1      	ldr	r3, [pc, #708]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001e20:	691b      	ldr	r3, [r3, #16]
24001e22:	f003 0338 	and.w	r3, r3, #56	; 0x38
24001e26:	2b18      	cmp	r3, #24
24001e28:	f200 812e 	bhi.w	24002088 <SystemCoreClockUpdate+0x270>
24001e2c:	a201      	add	r2, pc, #4	; (adr r2, 24001e34 <SystemCoreClockUpdate+0x1c>)
24001e2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24001e32:	bf00      	nop
24001e34:	24001e99 	.word	0x24001e99
24001e38:	24002089 	.word	0x24002089
24001e3c:	24002089 	.word	0x24002089
24001e40:	24002089 	.word	0x24002089
24001e44:	24002089 	.word	0x24002089
24001e48:	24002089 	.word	0x24002089
24001e4c:	24002089 	.word	0x24002089
24001e50:	24002089 	.word	0x24002089
24001e54:	24001ead 	.word	0x24001ead
24001e58:	24002089 	.word	0x24002089
24001e5c:	24002089 	.word	0x24002089
24001e60:	24002089 	.word	0x24002089
24001e64:	24002089 	.word	0x24002089
24001e68:	24002089 	.word	0x24002089
24001e6c:	24002089 	.word	0x24002089
24001e70:	24002089 	.word	0x24002089
24001e74:	24001eb3 	.word	0x24001eb3
24001e78:	24002089 	.word	0x24002089
24001e7c:	24002089 	.word	0x24002089
24001e80:	24002089 	.word	0x24002089
24001e84:	24002089 	.word	0x24002089
24001e88:	24002089 	.word	0x24002089
24001e8c:	24002089 	.word	0x24002089
24001e90:	24002089 	.word	0x24002089
24001e94:	24001eb9 	.word	0x24001eb9
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
24001e98:	4b92      	ldr	r3, [pc, #584]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001e9a:	681b      	ldr	r3, [r3, #0]
24001e9c:	08db      	lsrs	r3, r3, #3
24001e9e:	f003 0303 	and.w	r3, r3, #3
24001ea2:	4a91      	ldr	r2, [pc, #580]	; (240020e8 <SystemCoreClockUpdate+0x2d0>)
24001ea4:	fa22 f303 	lsr.w	r3, r2, r3
24001ea8:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001eaa:	e0f7      	b.n	2400209c <SystemCoreClockUpdate+0x284>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    common_system_clock = CSI_VALUE;
24001eac:	4b8f      	ldr	r3, [pc, #572]	; (240020ec <SystemCoreClockUpdate+0x2d4>)
24001eae:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001eb0:	e0f4      	b.n	2400209c <SystemCoreClockUpdate+0x284>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    common_system_clock = HSE_VALUE;
24001eb2:	4b8f      	ldr	r3, [pc, #572]	; (240020f0 <SystemCoreClockUpdate+0x2d8>)
24001eb4:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24001eb6:	e0f1      	b.n	2400209c <SystemCoreClockUpdate+0x284>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24001eb8:	4b8a      	ldr	r3, [pc, #552]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001eba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24001ebc:	f003 0303 	and.w	r3, r3, #3
24001ec0:	61fb      	str	r3, [r7, #28]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24001ec2:	4b88      	ldr	r3, [pc, #544]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001ec4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24001ec6:	091b      	lsrs	r3, r3, #4
24001ec8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24001ecc:	61bb      	str	r3, [r7, #24]
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24001ece:	4b85      	ldr	r3, [pc, #532]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001ed0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24001ed2:	f003 0301 	and.w	r3, r3, #1
24001ed6:	617b      	str	r3, [r7, #20]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24001ed8:	4b82      	ldr	r3, [pc, #520]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001eda:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24001edc:	08db      	lsrs	r3, r3, #3
24001ede:	f3c3 030c 	ubfx	r3, r3, #0, #13
24001ee2:	697a      	ldr	r2, [r7, #20]
24001ee4:	fb02 f303 	mul.w	r3, r2, r3
24001ee8:	ee07 3a90 	vmov	s15, r3
24001eec:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001ef0:	edc7 7a04 	vstr	s15, [r7, #16]

    if (pllm != 0U)
24001ef4:	69bb      	ldr	r3, [r7, #24]
24001ef6:	2b00      	cmp	r3, #0
24001ef8:	f000 80c3 	beq.w	24002082 <SystemCoreClockUpdate+0x26a>
24001efc:	69fb      	ldr	r3, [r7, #28]
24001efe:	2b02      	cmp	r3, #2
24001f00:	d059      	beq.n	24001fb6 <SystemCoreClockUpdate+0x19e>
24001f02:	69fb      	ldr	r3, [r7, #28]
24001f04:	2b02      	cmp	r3, #2
24001f06:	d878      	bhi.n	24001ffa <SystemCoreClockUpdate+0x1e2>
24001f08:	69fb      	ldr	r3, [r7, #28]
24001f0a:	2b00      	cmp	r3, #0
24001f0c:	d003      	beq.n	24001f16 <SystemCoreClockUpdate+0xfe>
24001f0e:	69fb      	ldr	r3, [r7, #28]
24001f10:	2b01      	cmp	r3, #1
24001f12:	d02e      	beq.n	24001f72 <SystemCoreClockUpdate+0x15a>
24001f14:	e071      	b.n	24001ffa <SystemCoreClockUpdate+0x1e2>
    {
      switch (pllsource)
      {
        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24001f16:	4b73      	ldr	r3, [pc, #460]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001f18:	681b      	ldr	r3, [r3, #0]
24001f1a:	08db      	lsrs	r3, r3, #3
24001f1c:	f003 0303 	and.w	r3, r3, #3
24001f20:	4a71      	ldr	r2, [pc, #452]	; (240020e8 <SystemCoreClockUpdate+0x2d0>)
24001f22:	fa22 f303 	lsr.w	r3, r2, r3
24001f26:	60fb      	str	r3, [r7, #12]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24001f28:	68fb      	ldr	r3, [r7, #12]
24001f2a:	ee07 3a90 	vmov	s15, r3
24001f2e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001f32:	69bb      	ldr	r3, [r7, #24]
24001f34:	ee07 3a90 	vmov	s15, r3
24001f38:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001f3c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24001f40:	4b68      	ldr	r3, [pc, #416]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001f42:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001f44:	f3c3 0308 	ubfx	r3, r3, #0, #9
24001f48:	ee07 3a90 	vmov	s15, r3
24001f4c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001f50:	ed97 6a04 	vldr	s12, [r7, #16]
24001f54:	eddf 5a67 	vldr	s11, [pc, #412]	; 240020f4 <SystemCoreClockUpdate+0x2dc>
24001f58:	eec6 7a25 	vdiv.f32	s15, s12, s11
24001f5c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24001f60:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24001f64:	ee77 7aa6 	vadd.f32	s15, s15, s13
24001f68:	ee67 7a27 	vmul.f32	s15, s14, s15
24001f6c:	edc7 7a08 	vstr	s15, [r7, #32]

        break;
24001f70:	e071      	b.n	24002056 <SystemCoreClockUpdate+0x23e>

        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24001f72:	69bb      	ldr	r3, [r7, #24]
24001f74:	ee07 3a90 	vmov	s15, r3
24001f78:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001f7c:	eddf 6a5e 	vldr	s13, [pc, #376]	; 240020f8 <SystemCoreClockUpdate+0x2e0>
24001f80:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24001f84:	4b57      	ldr	r3, [pc, #348]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001f86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001f88:	f3c3 0308 	ubfx	r3, r3, #0, #9
24001f8c:	ee07 3a90 	vmov	s15, r3
24001f90:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001f94:	ed97 6a04 	vldr	s12, [r7, #16]
24001f98:	eddf 5a56 	vldr	s11, [pc, #344]	; 240020f4 <SystemCoreClockUpdate+0x2dc>
24001f9c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24001fa0:	ee76 7aa7 	vadd.f32	s15, s13, s15
24001fa4:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24001fa8:	ee77 7aa6 	vadd.f32	s15, s15, s13
24001fac:	ee67 7a27 	vmul.f32	s15, s14, s15
24001fb0:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24001fb4:	e04f      	b.n	24002056 <SystemCoreClockUpdate+0x23e>

        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24001fb6:	69bb      	ldr	r3, [r7, #24]
24001fb8:	ee07 3a90 	vmov	s15, r3
24001fbc:	eef8 7a67 	vcvt.f32.u32	s15, s15
24001fc0:	eddf 6a4e 	vldr	s13, [pc, #312]	; 240020fc <SystemCoreClockUpdate+0x2e4>
24001fc4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24001fc8:	4b46      	ldr	r3, [pc, #280]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001fca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24001fcc:	f3c3 0308 	ubfx	r3, r3, #0, #9
24001fd0:	ee07 3a90 	vmov	s15, r3
24001fd4:	eef8 6a67 	vcvt.f32.u32	s13, s15
24001fd8:	ed97 6a04 	vldr	s12, [r7, #16]
24001fdc:	eddf 5a45 	vldr	s11, [pc, #276]	; 240020f4 <SystemCoreClockUpdate+0x2dc>
24001fe0:	eec6 7a25 	vdiv.f32	s15, s12, s11
24001fe4:	ee76 7aa7 	vadd.f32	s15, s13, s15
24001fe8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24001fec:	ee77 7aa6 	vadd.f32	s15, s15, s13
24001ff0:	ee67 7a27 	vmul.f32	s15, s14, s15
24001ff4:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24001ff8:	e02d      	b.n	24002056 <SystemCoreClockUpdate+0x23e>

      default:
          hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
24001ffa:	4b3a      	ldr	r3, [pc, #232]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24001ffc:	681b      	ldr	r3, [r3, #0]
24001ffe:	08db      	lsrs	r3, r3, #3
24002000:	f003 0303 	and.w	r3, r3, #3
24002004:	4a38      	ldr	r2, [pc, #224]	; (240020e8 <SystemCoreClockUpdate+0x2d0>)
24002006:	fa22 f303 	lsr.w	r3, r2, r3
2400200a:	60fb      	str	r3, [r7, #12]
          pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2400200c:	68fb      	ldr	r3, [r7, #12]
2400200e:	ee07 3a90 	vmov	s15, r3
24002012:	eef8 6a67 	vcvt.f32.u32	s13, s15
24002016:	69bb      	ldr	r3, [r7, #24]
24002018:	ee07 3a90 	vmov	s15, r3
2400201c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24002020:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24002024:	4b2f      	ldr	r3, [pc, #188]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24002026:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24002028:	f3c3 0308 	ubfx	r3, r3, #0, #9
2400202c:	ee07 3a90 	vmov	s15, r3
24002030:	eef8 6a67 	vcvt.f32.u32	s13, s15
24002034:	ed97 6a04 	vldr	s12, [r7, #16]
24002038:	eddf 5a2e 	vldr	s11, [pc, #184]	; 240020f4 <SystemCoreClockUpdate+0x2dc>
2400203c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24002040:	ee76 7aa7 	vadd.f32	s15, s13, s15
24002044:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24002048:	ee77 7aa6 	vadd.f32	s15, s15, s13
2400204c:	ee67 7a27 	vmul.f32	s15, s14, s15
24002050:	edc7 7a08 	vstr	s15, [r7, #32]
        break;
24002054:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
24002056:	4b23      	ldr	r3, [pc, #140]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
24002058:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400205a:	0a5b      	lsrs	r3, r3, #9
2400205c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24002060:	3301      	adds	r3, #1
24002062:	60bb      	str	r3, [r7, #8]
      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
24002064:	68bb      	ldr	r3, [r7, #8]
24002066:	ee07 3a90 	vmov	s15, r3
2400206a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
2400206e:	edd7 6a08 	vldr	s13, [r7, #32]
24002072:	eec6 7a87 	vdiv.f32	s15, s13, s14
24002076:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2400207a:	ee17 3a90 	vmov	r3, s15
2400207e:	627b      	str	r3, [r7, #36]	; 0x24
    }
    else
    {
      common_system_clock = 0U;
    }
    break;
24002080:	e00c      	b.n	2400209c <SystemCoreClockUpdate+0x284>
      common_system_clock = 0U;
24002082:	2300      	movs	r3, #0
24002084:	627b      	str	r3, [r7, #36]	; 0x24
    break;
24002086:	e009      	b.n	2400209c <SystemCoreClockUpdate+0x284>

  default:
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
24002088:	4b16      	ldr	r3, [pc, #88]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
2400208a:	681b      	ldr	r3, [r3, #0]
2400208c:	08db      	lsrs	r3, r3, #3
2400208e:	f003 0303 	and.w	r3, r3, #3
24002092:	4a15      	ldr	r2, [pc, #84]	; (240020e8 <SystemCoreClockUpdate+0x2d0>)
24002094:	fa22 f303 	lsr.w	r3, r2, r3
24002098:	627b      	str	r3, [r7, #36]	; 0x24
    break;
2400209a:	bf00      	nop
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];
2400209c:	4b11      	ldr	r3, [pc, #68]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
2400209e:	699b      	ldr	r3, [r3, #24]
240020a0:	0a1b      	lsrs	r3, r3, #8
240020a2:	f003 030f 	and.w	r3, r3, #15
240020a6:	4a16      	ldr	r2, [pc, #88]	; (24002100 <SystemCoreClockUpdate+0x2e8>)
240020a8:	5cd3      	ldrb	r3, [r2, r3]
240020aa:	607b      	str	r3, [r7, #4]

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;
240020ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
240020ae:	687b      	ldr	r3, [r7, #4]
240020b0:	fa22 f303 	lsr.w	r3, r2, r3
240020b4:	627b      	str	r3, [r7, #36]	; 0x24

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
240020b6:	4b0b      	ldr	r3, [pc, #44]	; (240020e4 <SystemCoreClockUpdate+0x2cc>)
240020b8:	699b      	ldr	r3, [r3, #24]
240020ba:	f003 030f 	and.w	r3, r3, #15
240020be:	4a10      	ldr	r2, [pc, #64]	; (24002100 <SystemCoreClockUpdate+0x2e8>)
240020c0:	5cd3      	ldrb	r3, [r2, r3]
240020c2:	f003 031f 	and.w	r3, r3, #31
240020c6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
240020c8:	fa22 f303 	lsr.w	r3, r2, r3
240020cc:	4a0d      	ldr	r2, [pc, #52]	; (24002104 <SystemCoreClockUpdate+0x2ec>)
240020ce:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
240020d0:	4a0d      	ldr	r2, [pc, #52]	; (24002108 <SystemCoreClockUpdate+0x2f0>)
240020d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240020d4:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */
}
240020d6:	bf00      	nop
240020d8:	372c      	adds	r7, #44	; 0x2c
240020da:	46bd      	mov	sp, r7
240020dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240020e0:	4770      	bx	lr
240020e2:	bf00      	nop
240020e4:	58024400 	.word	0x58024400
240020e8:	03d09000 	.word	0x03d09000
240020ec:	003d0900 	.word	0x003d0900
240020f0:	02dc6c00 	.word	0x02dc6c00
240020f4:	46000000 	.word	0x46000000
240020f8:	4a742400 	.word	0x4a742400
240020fc:	4c371b00 	.word	0x4c371b00
24002100:	240178a4 	.word	0x240178a4
24002104:	240004b4 	.word	0x240004b4
24002108:	240004b0 	.word	0x240004b0

2400210c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
2400210c:	f8df d034 	ldr.w	sp, [pc, #52]	; 24002144 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
24002110:	f7ff fdfa 	bl	24001d08 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
24002114:	480c      	ldr	r0, [pc, #48]	; (24002148 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
24002116:	490d      	ldr	r1, [pc, #52]	; (2400214c <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
24002118:	4a0d      	ldr	r2, [pc, #52]	; (24002150 <LoopFillZerobss+0x1a>)
  movs r3, #0
2400211a:	2300      	movs	r3, #0
  b LoopCopyDataInit
2400211c:	e002      	b.n	24002124 <LoopCopyDataInit>

2400211e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
2400211e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
24002120:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
24002122:	3304      	adds	r3, #4

24002124 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
24002124:	18c4      	adds	r4, r0, r3
  cmp r4, r1
24002126:	428c      	cmp	r4, r1
  bcc CopyDataInit
24002128:	d3f9      	bcc.n	2400211e <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
2400212a:	4a0a      	ldr	r2, [pc, #40]	; (24002154 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
2400212c:	4c0a      	ldr	r4, [pc, #40]	; (24002158 <LoopFillZerobss+0x22>)
  movs r3, #0
2400212e:	2300      	movs	r3, #0
  b LoopFillZerobss
24002130:	e001      	b.n	24002136 <LoopFillZerobss>

24002132 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
24002132:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
24002134:	3204      	adds	r2, #4

24002136 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
24002136:	42a2      	cmp	r2, r4
  bcc FillZerobss
24002138:	d3fb      	bcc.n	24002132 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
2400213a:	f015 f923 	bl	24017384 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
2400213e:	f7fe fde7 	bl	24000d10 <main>
  bx  lr
24002142:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
24002144:	24080004 	.word	0x24080004
  ldr r0, =_sdata
24002148:	240004a8 	.word	0x240004a8
  ldr r1, =_edata
2400214c:	2400051c 	.word	0x2400051c
  ldr r2, =_sidata
24002150:	240004a8 	.word	0x240004a8
  ldr r2, =_sbss
24002154:	2400051c 	.word	0x2400051c
  ldr r4, =_ebss
24002158:	240006fc 	.word	0x240006fc

2400215c <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
2400215c:	e7fe      	b.n	2400215c <ADC3_IRQHandler>
	...

24002160 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
24002160:	b580      	push	{r7, lr}
24002162:	b082      	sub	sp, #8
24002164:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
24002166:	2003      	movs	r0, #3
24002168:	f000 fefc 	bl	24002f64 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
2400216c:	f011 fe30 	bl	24013dd0 <HAL_RCC_GetSysClockFreq>
24002170:	4602      	mov	r2, r0
24002172:	4b15      	ldr	r3, [pc, #84]	; (240021c8 <HAL_Init+0x68>)
24002174:	699b      	ldr	r3, [r3, #24]
24002176:	0a1b      	lsrs	r3, r3, #8
24002178:	f003 030f 	and.w	r3, r3, #15
2400217c:	4913      	ldr	r1, [pc, #76]	; (240021cc <HAL_Init+0x6c>)
2400217e:	5ccb      	ldrb	r3, [r1, r3]
24002180:	f003 031f 	and.w	r3, r3, #31
24002184:	fa22 f303 	lsr.w	r3, r2, r3
24002188:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
2400218a:	4b0f      	ldr	r3, [pc, #60]	; (240021c8 <HAL_Init+0x68>)
2400218c:	699b      	ldr	r3, [r3, #24]
2400218e:	f003 030f 	and.w	r3, r3, #15
24002192:	4a0e      	ldr	r2, [pc, #56]	; (240021cc <HAL_Init+0x6c>)
24002194:	5cd3      	ldrb	r3, [r2, r3]
24002196:	f003 031f 	and.w	r3, r3, #31
2400219a:	687a      	ldr	r2, [r7, #4]
2400219c:	fa22 f303 	lsr.w	r3, r2, r3
240021a0:	4a0b      	ldr	r2, [pc, #44]	; (240021d0 <HAL_Init+0x70>)
240021a2:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
240021a4:	4a0b      	ldr	r2, [pc, #44]	; (240021d4 <HAL_Init+0x74>)
240021a6:	687b      	ldr	r3, [r7, #4]
240021a8:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
240021aa:	200f      	movs	r0, #15
240021ac:	f000 f880 	bl	240022b0 <HAL_InitTick>
240021b0:	4603      	mov	r3, r0
240021b2:	2b00      	cmp	r3, #0
240021b4:	d001      	beq.n	240021ba <HAL_Init+0x5a>
  {
    return HAL_ERROR;
240021b6:	2301      	movs	r3, #1
240021b8:	e002      	b.n	240021c0 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
240021ba:	f7ff fc17 	bl	240019ec <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
240021be:	2300      	movs	r3, #0
}
240021c0:	4618      	mov	r0, r3
240021c2:	3708      	adds	r7, #8
240021c4:	46bd      	mov	sp, r7
240021c6:	bd80      	pop	{r7, pc}
240021c8:	58024400 	.word	0x58024400
240021cc:	240178a4 	.word	0x240178a4
240021d0:	240004b4 	.word	0x240004b4
240021d4:	240004b0 	.word	0x240004b0

240021d8 <HAL_DeInit>:
  * @brief  This function de-Initializes common part of the HAL and stops the systick.
  *         This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
240021d8:	b580      	push	{r7, lr}
240021da:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_AHB3_FORCE_RESET();
240021dc:	4b26      	ldr	r3, [pc, #152]	; (24002278 <HAL_DeInit+0xa0>)
240021de:	4a27      	ldr	r2, [pc, #156]	; (2400227c <HAL_DeInit+0xa4>)
240021e0:	67da      	str	r2, [r3, #124]	; 0x7c
  __HAL_RCC_AHB3_RELEASE_RESET();
240021e2:	4b25      	ldr	r3, [pc, #148]	; (24002278 <HAL_DeInit+0xa0>)
240021e4:	2200      	movs	r2, #0
240021e6:	67da      	str	r2, [r3, #124]	; 0x7c

  __HAL_RCC_AHB1_FORCE_RESET();
240021e8:	4b23      	ldr	r3, [pc, #140]	; (24002278 <HAL_DeInit+0xa0>)
240021ea:	4a25      	ldr	r2, [pc, #148]	; (24002280 <HAL_DeInit+0xa8>)
240021ec:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __HAL_RCC_AHB1_RELEASE_RESET();
240021f0:	4b21      	ldr	r3, [pc, #132]	; (24002278 <HAL_DeInit+0xa0>)
240021f2:	2200      	movs	r2, #0
240021f4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  __HAL_RCC_AHB2_FORCE_RESET();
240021f8:	4b1f      	ldr	r3, [pc, #124]	; (24002278 <HAL_DeInit+0xa0>)
240021fa:	f240 2271 	movw	r2, #625	; 0x271
240021fe:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __HAL_RCC_AHB2_RELEASE_RESET();
24002202:	4b1d      	ldr	r3, [pc, #116]	; (24002278 <HAL_DeInit+0xa0>)
24002204:	2200      	movs	r2, #0
24002206:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_RCC_AHB4_FORCE_RESET();
2400220a:	4b1b      	ldr	r3, [pc, #108]	; (24002278 <HAL_DeInit+0xa0>)
2400220c:	4a1d      	ldr	r2, [pc, #116]	; (24002284 <HAL_DeInit+0xac>)
2400220e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 __HAL_RCC_AHB4_RELEASE_RESET();
24002212:	4b19      	ldr	r3, [pc, #100]	; (24002278 <HAL_DeInit+0xa0>)
24002214:	2200      	movs	r2, #0
24002216:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_RCC_APB3_FORCE_RESET();
2400221a:	4b17      	ldr	r3, [pc, #92]	; (24002278 <HAL_DeInit+0xa0>)
2400221c:	2218      	movs	r2, #24
2400221e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  __HAL_RCC_APB3_RELEASE_RESET();
24002222:	4b15      	ldr	r3, [pc, #84]	; (24002278 <HAL_DeInit+0xa0>)
24002224:	2200      	movs	r2, #0
24002226:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  __HAL_RCC_APB1L_FORCE_RESET();
2400222a:	4b13      	ldr	r3, [pc, #76]	; (24002278 <HAL_DeInit+0xa0>)
2400222c:	4a16      	ldr	r2, [pc, #88]	; (24002288 <HAL_DeInit+0xb0>)
2400222e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  __HAL_RCC_APB1L_RELEASE_RESET();
24002232:	4b11      	ldr	r3, [pc, #68]	; (24002278 <HAL_DeInit+0xa0>)
24002234:	2200      	movs	r2, #0
24002236:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  __HAL_RCC_APB1H_FORCE_RESET();
2400223a:	4b0f      	ldr	r3, [pc, #60]	; (24002278 <HAL_DeInit+0xa0>)
2400223c:	f44f 729b 	mov.w	r2, #310	; 0x136
24002240:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __HAL_RCC_APB1H_RELEASE_RESET();
24002244:	4b0c      	ldr	r3, [pc, #48]	; (24002278 <HAL_DeInit+0xa0>)
24002246:	2200      	movs	r2, #0
24002248:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

   __HAL_RCC_APB2_FORCE_RESET();
2400224c:	4b0a      	ldr	r3, [pc, #40]	; (24002278 <HAL_DeInit+0xa0>)
2400224e:	4a0f      	ldr	r2, [pc, #60]	; (2400228c <HAL_DeInit+0xb4>)
24002250:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
   __HAL_RCC_APB2_RELEASE_RESET();
24002254:	4b08      	ldr	r3, [pc, #32]	; (24002278 <HAL_DeInit+0xa0>)
24002256:	2200      	movs	r2, #0
24002258:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

  __HAL_RCC_APB4_FORCE_RESET();
2400225c:	4b06      	ldr	r3, [pc, #24]	; (24002278 <HAL_DeInit+0xa0>)
2400225e:	4a0c      	ldr	r2, [pc, #48]	; (24002290 <HAL_DeInit+0xb8>)
24002260:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  __HAL_RCC_APB4_RELEASE_RESET();
24002264:	4b04      	ldr	r3, [pc, #16]	; (24002278 <HAL_DeInit+0xa0>)
24002266:	2200      	movs	r2, #0
24002268:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

  /* De-Init the low level hardware */
  HAL_MspDeInit();
2400226c:	f000 f819 	bl	240022a2 <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
24002270:	2300      	movs	r3, #0
}
24002272:	4618      	mov	r0, r3
24002274:	bd80      	pop	{r7, pc}
24002276:	bf00      	nop
24002278:	58024400 	.word	0x58024400
2400227c:	00015031 	.word	0x00015031
24002280:	0a00c023 	.word	0x0a00c023
24002284:	032807ff 	.word	0x032807ff
24002288:	e8ffc3ff 	.word	0xe8ffc3ff
2400228c:	31d73033 	.word	0x31d73033
24002290:	0020deaa 	.word	0x0020deaa
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
24002294:	b480      	push	{r7}
24002296:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
24002298:	bf00      	nop
2400229a:	46bd      	mov	sp, r7
2400229c:	f85d 7b04 	ldr.w	r7, [sp], #4
240022a0:	4770      	bx	lr

240022a2 <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
240022a2:	b480      	push	{r7}
240022a4:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
240022a6:	bf00      	nop
240022a8:	46bd      	mov	sp, r7
240022aa:	f85d 7b04 	ldr.w	r7, [sp], #4
240022ae:	4770      	bx	lr

240022b0 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
240022b0:	b580      	push	{r7, lr}
240022b2:	b082      	sub	sp, #8
240022b4:	af00      	add	r7, sp, #0
240022b6:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
240022b8:	4b15      	ldr	r3, [pc, #84]	; (24002310 <HAL_InitTick+0x60>)
240022ba:	781b      	ldrb	r3, [r3, #0]
240022bc:	2b00      	cmp	r3, #0
240022be:	d101      	bne.n	240022c4 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
240022c0:	2301      	movs	r3, #1
240022c2:	e021      	b.n	24002308 <HAL_InitTick+0x58>
  }

    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
240022c4:	4b13      	ldr	r3, [pc, #76]	; (24002314 <HAL_InitTick+0x64>)
240022c6:	681a      	ldr	r2, [r3, #0]
240022c8:	4b11      	ldr	r3, [pc, #68]	; (24002310 <HAL_InitTick+0x60>)
240022ca:	781b      	ldrb	r3, [r3, #0]
240022cc:	4619      	mov	r1, r3
240022ce:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
240022d2:	fbb3 f3f1 	udiv	r3, r3, r1
240022d6:	fbb2 f3f3 	udiv	r3, r2, r3
240022da:	4618      	mov	r0, r3
240022dc:	f000 fe87 	bl	24002fee <HAL_SYSTICK_Config>
240022e0:	4603      	mov	r3, r0
240022e2:	2b00      	cmp	r3, #0
240022e4:	d001      	beq.n	240022ea <HAL_InitTick+0x3a>
    {
      return HAL_ERROR;
240022e6:	2301      	movs	r3, #1
240022e8:	e00e      	b.n	24002308 <HAL_InitTick+0x58>
    }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
240022ea:	687b      	ldr	r3, [r7, #4]
240022ec:	2b0f      	cmp	r3, #15
240022ee:	d80a      	bhi.n	24002306 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
240022f0:	2200      	movs	r2, #0
240022f2:	6879      	ldr	r1, [r7, #4]
240022f4:	f04f 30ff 	mov.w	r0, #4294967295
240022f8:	f000 fe3f 	bl	24002f7a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
240022fc:	4a06      	ldr	r2, [pc, #24]	; (24002318 <HAL_InitTick+0x68>)
240022fe:	687b      	ldr	r3, [r7, #4]
24002300:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
24002302:	2300      	movs	r3, #0
24002304:	e000      	b.n	24002308 <HAL_InitTick+0x58>
    return HAL_ERROR;
24002306:	2301      	movs	r3, #1
}
24002308:	4618      	mov	r0, r3
2400230a:	3708      	adds	r7, #8
2400230c:	46bd      	mov	sp, r7
2400230e:	bd80      	pop	{r7, pc}
24002310:	240004bc 	.word	0x240004bc
24002314:	240004b0 	.word	0x240004b0
24002318:	240004b8 	.word	0x240004b8

2400231c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
2400231c:	b480      	push	{r7}
2400231e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
24002320:	4b06      	ldr	r3, [pc, #24]	; (2400233c <HAL_IncTick+0x20>)
24002322:	781b      	ldrb	r3, [r3, #0]
24002324:	461a      	mov	r2, r3
24002326:	4b06      	ldr	r3, [pc, #24]	; (24002340 <HAL_IncTick+0x24>)
24002328:	681b      	ldr	r3, [r3, #0]
2400232a:	4413      	add	r3, r2
2400232c:	4a04      	ldr	r2, [pc, #16]	; (24002340 <HAL_IncTick+0x24>)
2400232e:	6013      	str	r3, [r2, #0]
}
24002330:	bf00      	nop
24002332:	46bd      	mov	sp, r7
24002334:	f85d 7b04 	ldr.w	r7, [sp], #4
24002338:	4770      	bx	lr
2400233a:	bf00      	nop
2400233c:	240004bc 	.word	0x240004bc
24002340:	2400058c 	.word	0x2400058c

24002344 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
24002344:	b480      	push	{r7}
24002346:	af00      	add	r7, sp, #0
  return uwTick;
24002348:	4b03      	ldr	r3, [pc, #12]	; (24002358 <HAL_GetTick+0x14>)
2400234a:	681b      	ldr	r3, [r3, #0]
}
2400234c:	4618      	mov	r0, r3
2400234e:	46bd      	mov	sp, r7
24002350:	f85d 7b04 	ldr.w	r7, [sp], #4
24002354:	4770      	bx	lr
24002356:	bf00      	nop
24002358:	2400058c 	.word	0x2400058c

2400235c <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
2400235c:	b480      	push	{r7}
2400235e:	af00      	add	r7, sp, #0
  return uwTickPrio;
24002360:	4b03      	ldr	r3, [pc, #12]	; (24002370 <HAL_GetTickPrio+0x14>)
24002362:	681b      	ldr	r3, [r3, #0]
}
24002364:	4618      	mov	r0, r3
24002366:	46bd      	mov	sp, r7
24002368:	f85d 7b04 	ldr.w	r7, [sp], #4
2400236c:	4770      	bx	lr
2400236e:	bf00      	nop
24002370:	240004b8 	.word	0x240004b8

24002374 <HAL_SetTickFreq>:
/**
  * @brief Set new tick Freq.
  * @retval Status
  */
HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
{
24002374:	b580      	push	{r7, lr}
24002376:	b084      	sub	sp, #16
24002378:	af00      	add	r7, sp, #0
2400237a:	4603      	mov	r3, r0
2400237c:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status  = HAL_OK;
2400237e:	2300      	movs	r3, #0
24002380:	73fb      	strb	r3, [r7, #15]
  HAL_TickFreqTypeDef prevTickFreq;

  assert_param(IS_TICKFREQ(Freq));

  if (uwTickFreq != Freq)
24002382:	4b0e      	ldr	r3, [pc, #56]	; (240023bc <HAL_SetTickFreq+0x48>)
24002384:	781b      	ldrb	r3, [r3, #0]
24002386:	79fa      	ldrb	r2, [r7, #7]
24002388:	429a      	cmp	r2, r3
2400238a:	d012      	beq.n	240023b2 <HAL_SetTickFreq+0x3e>
  {

    /* Back up uwTickFreq frequency */
    prevTickFreq = uwTickFreq;
2400238c:	4b0b      	ldr	r3, [pc, #44]	; (240023bc <HAL_SetTickFreq+0x48>)
2400238e:	781b      	ldrb	r3, [r3, #0]
24002390:	73bb      	strb	r3, [r7, #14]

    /* Update uwTickFreq global variable used by HAL_InitTick() */
    uwTickFreq = Freq;
24002392:	4a0a      	ldr	r2, [pc, #40]	; (240023bc <HAL_SetTickFreq+0x48>)
24002394:	79fb      	ldrb	r3, [r7, #7]
24002396:	7013      	strb	r3, [r2, #0]

    /* Apply the new tick Freq  */
    status = HAL_InitTick(uwTickPrio);
24002398:	4b09      	ldr	r3, [pc, #36]	; (240023c0 <HAL_SetTickFreq+0x4c>)
2400239a:	681b      	ldr	r3, [r3, #0]
2400239c:	4618      	mov	r0, r3
2400239e:	f7ff ff87 	bl	240022b0 <HAL_InitTick>
240023a2:	4603      	mov	r3, r0
240023a4:	73fb      	strb	r3, [r7, #15]
    if (status != HAL_OK)
240023a6:	7bfb      	ldrb	r3, [r7, #15]
240023a8:	2b00      	cmp	r3, #0
240023aa:	d002      	beq.n	240023b2 <HAL_SetTickFreq+0x3e>
    {
      /* Restore previous tick frequency */
      uwTickFreq = prevTickFreq;
240023ac:	4a03      	ldr	r2, [pc, #12]	; (240023bc <HAL_SetTickFreq+0x48>)
240023ae:	7bbb      	ldrb	r3, [r7, #14]
240023b0:	7013      	strb	r3, [r2, #0]
    }
  }

  return status;
240023b2:	7bfb      	ldrb	r3, [r7, #15]
}
240023b4:	4618      	mov	r0, r3
240023b6:	3710      	adds	r7, #16
240023b8:	46bd      	mov	sp, r7
240023ba:	bd80      	pop	{r7, pc}
240023bc:	240004bc 	.word	0x240004bc
240023c0:	240004b8 	.word	0x240004b8

240023c4 <HAL_GetTickFreq>:
/**
  * @brief Return tick frequency.
  * @retval tick period in Hz
  */
HAL_TickFreqTypeDef HAL_GetTickFreq(void)
{
240023c4:	b480      	push	{r7}
240023c6:	af00      	add	r7, sp, #0
  return uwTickFreq;
240023c8:	4b03      	ldr	r3, [pc, #12]	; (240023d8 <HAL_GetTickFreq+0x14>)
240023ca:	781b      	ldrb	r3, [r3, #0]
}
240023cc:	4618      	mov	r0, r3
240023ce:	46bd      	mov	sp, r7
240023d0:	f85d 7b04 	ldr.w	r7, [sp], #4
240023d4:	4770      	bx	lr
240023d6:	bf00      	nop
240023d8:	240004bc 	.word	0x240004bc

240023dc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
240023dc:	b580      	push	{r7, lr}
240023de:	b084      	sub	sp, #16
240023e0:	af00      	add	r7, sp, #0
240023e2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
240023e4:	f7ff ffae 	bl	24002344 <HAL_GetTick>
240023e8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
240023ea:	687b      	ldr	r3, [r7, #4]
240023ec:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
240023ee:	68fb      	ldr	r3, [r7, #12]
240023f0:	f1b3 3fff 	cmp.w	r3, #4294967295
240023f4:	d005      	beq.n	24002402 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
240023f6:	4b0a      	ldr	r3, [pc, #40]	; (24002420 <HAL_Delay+0x44>)
240023f8:	781b      	ldrb	r3, [r3, #0]
240023fa:	461a      	mov	r2, r3
240023fc:	68fb      	ldr	r3, [r7, #12]
240023fe:	4413      	add	r3, r2
24002400:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
24002402:	bf00      	nop
24002404:	f7ff ff9e 	bl	24002344 <HAL_GetTick>
24002408:	4602      	mov	r2, r0
2400240a:	68bb      	ldr	r3, [r7, #8]
2400240c:	1ad3      	subs	r3, r2, r3
2400240e:	68fa      	ldr	r2, [r7, #12]
24002410:	429a      	cmp	r2, r3
24002412:	d8f7      	bhi.n	24002404 <HAL_Delay+0x28>
  {
  }
}
24002414:	bf00      	nop
24002416:	bf00      	nop
24002418:	3710      	adds	r7, #16
2400241a:	46bd      	mov	sp, r7
2400241c:	bd80      	pop	{r7, pc}
2400241e:	bf00      	nop
24002420:	240004bc 	.word	0x240004bc

24002424 <HAL_SuspendTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
24002424:	b480      	push	{r7}
24002426:	af00      	add	r7, sp, #0
  /* Disable SysTick Interrupt */
  SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
24002428:	4b05      	ldr	r3, [pc, #20]	; (24002440 <HAL_SuspendTick+0x1c>)
2400242a:	681b      	ldr	r3, [r3, #0]
2400242c:	4a04      	ldr	r2, [pc, #16]	; (24002440 <HAL_SuspendTick+0x1c>)
2400242e:	f023 0302 	bic.w	r3, r3, #2
24002432:	6013      	str	r3, [r2, #0]
}
24002434:	bf00      	nop
24002436:	46bd      	mov	sp, r7
24002438:	f85d 7b04 	ldr.w	r7, [sp], #4
2400243c:	4770      	bx	lr
2400243e:	bf00      	nop
24002440:	e000e010 	.word	0xe000e010

24002444 <HAL_ResumeTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
24002444:	b480      	push	{r7}
24002446:	af00      	add	r7, sp, #0
  /* Enable SysTick Interrupt */
  SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
24002448:	4b05      	ldr	r3, [pc, #20]	; (24002460 <HAL_ResumeTick+0x1c>)
2400244a:	681b      	ldr	r3, [r3, #0]
2400244c:	4a04      	ldr	r2, [pc, #16]	; (24002460 <HAL_ResumeTick+0x1c>)
2400244e:	f043 0302 	orr.w	r3, r3, #2
24002452:	6013      	str	r3, [r2, #0]
}
24002454:	bf00      	nop
24002456:	46bd      	mov	sp, r7
24002458:	f85d 7b04 	ldr.w	r7, [sp], #4
2400245c:	4770      	bx	lr
2400245e:	bf00      	nop
24002460:	e000e010 	.word	0xe000e010

24002464 <HAL_GetHalVersion>:
/**
  * @brief  Returns the HAL revision
  * @retval version : 0xXYZR (8bits for each decimal, R for RC)
  */
uint32_t HAL_GetHalVersion(void)
{
24002464:	b480      	push	{r7}
24002466:	af00      	add	r7, sp, #0
 return __STM32H7xx_HAL_VERSION;
24002468:	4b02      	ldr	r3, [pc, #8]	; (24002474 <HAL_GetHalVersion+0x10>)
}
2400246a:	4618      	mov	r0, r3
2400246c:	46bd      	mov	sp, r7
2400246e:	f85d 7b04 	ldr.w	r7, [sp], #4
24002472:	4770      	bx	lr
24002474:	010b0000 	.word	0x010b0000

24002478 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
24002478:	b480      	push	{r7}
2400247a:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
2400247c:	4b03      	ldr	r3, [pc, #12]	; (2400248c <HAL_GetREVID+0x14>)
2400247e:	681b      	ldr	r3, [r3, #0]
24002480:	0c1b      	lsrs	r3, r3, #16
}
24002482:	4618      	mov	r0, r3
24002484:	46bd      	mov	sp, r7
24002486:	f85d 7b04 	ldr.w	r7, [sp], #4
2400248a:	4770      	bx	lr
2400248c:	5c001000 	.word	0x5c001000

24002490 <HAL_GetDEVID>:
/**
  * @brief  Returns the device identifier.
  * @retval Device identifier
  */
uint32_t HAL_GetDEVID(void)
{
24002490:	b480      	push	{r7}
24002492:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
24002494:	4b04      	ldr	r3, [pc, #16]	; (240024a8 <HAL_GetDEVID+0x18>)
24002496:	681b      	ldr	r3, [r3, #0]
24002498:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
2400249c:	4618      	mov	r0, r3
2400249e:	46bd      	mov	sp, r7
240024a0:	f85d 7b04 	ldr.w	r7, [sp], #4
240024a4:	4770      	bx	lr
240024a6:	bf00      	nop
240024a8:	5c001000 	.word	0x5c001000

240024ac <HAL_GetUIDw0>:
/**
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
240024ac:	b480      	push	{r7}
240024ae:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)UID_BASE)));
240024b0:	4b03      	ldr	r3, [pc, #12]	; (240024c0 <HAL_GetUIDw0+0x14>)
240024b2:	681b      	ldr	r3, [r3, #0]
}
240024b4:	4618      	mov	r0, r3
240024b6:	46bd      	mov	sp, r7
240024b8:	f85d 7b04 	ldr.w	r7, [sp], #4
240024bc:	4770      	bx	lr
240024be:	bf00      	nop
240024c0:	1ff1e800 	.word	0x1ff1e800

240024c4 <HAL_GetUIDw1>:
/**
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
240024c4:	b480      	push	{r7}
240024c6:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
240024c8:	4b03      	ldr	r3, [pc, #12]	; (240024d8 <HAL_GetUIDw1+0x14>)
240024ca:	681b      	ldr	r3, [r3, #0]
}
240024cc:	4618      	mov	r0, r3
240024ce:	46bd      	mov	sp, r7
240024d0:	f85d 7b04 	ldr.w	r7, [sp], #4
240024d4:	4770      	bx	lr
240024d6:	bf00      	nop
240024d8:	1ff1e804 	.word	0x1ff1e804

240024dc <HAL_GetUIDw2>:
/**
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
240024dc:	b480      	push	{r7}
240024de:	af00      	add	r7, sp, #0
  return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
240024e0:	4b03      	ldr	r3, [pc, #12]	; (240024f0 <HAL_GetUIDw2+0x14>)
240024e2:	681b      	ldr	r3, [r3, #0]
}
240024e4:	4618      	mov	r0, r3
240024e6:	46bd      	mov	sp, r7
240024e8:	f85d 7b04 	ldr.w	r7, [sp], #4
240024ec:	4770      	bx	lr
240024ee:	bf00      	nop
240024f0:	1ff1e808 	.word	0x1ff1e808

240024f4 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig>:
  *            @arg SYSCFG_VREFBUF_VOLTAGE_SCALE3: VREF_OUT4 around 1.5 V.
  *                                                This requires VDDA equal to or higher than 1.8 V.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
{
240024f4:	b480      	push	{r7}
240024f6:	b083      	sub	sp, #12
240024f8:	af00      	add	r7, sp, #0
240024fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
240024fc:	4b06      	ldr	r3, [pc, #24]	; (24002518 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
240024fe:	681b      	ldr	r3, [r3, #0]
24002500:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24002504:	4904      	ldr	r1, [pc, #16]	; (24002518 <HAL_SYSCFG_VREFBUF_VoltageScalingConfig+0x24>)
24002506:	687b      	ldr	r3, [r7, #4]
24002508:	4313      	orrs	r3, r2
2400250a:	600b      	str	r3, [r1, #0]
}
2400250c:	bf00      	nop
2400250e:	370c      	adds	r7, #12
24002510:	46bd      	mov	sp, r7
24002512:	f85d 7b04 	ldr.w	r7, [sp], #4
24002516:	4770      	bx	lr
24002518:	58003c00 	.word	0x58003c00

2400251c <HAL_SYSCFG_VREFBUF_HighImpedanceConfig>:
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_DISABLE: VREF+ pin is internally connect to VREFINT output.
  *            @arg SYSCFG_VREFBUF_HIGH_IMPEDANCE_ENABLE: VREF+ pin is high impedance.
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
{
2400251c:	b480      	push	{r7}
2400251e:	b083      	sub	sp, #12
24002520:	af00      	add	r7, sp, #0
24002522:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));

  MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
24002524:	4b06      	ldr	r3, [pc, #24]	; (24002540 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
24002526:	681b      	ldr	r3, [r3, #0]
24002528:	f023 0202 	bic.w	r2, r3, #2
2400252c:	4904      	ldr	r1, [pc, #16]	; (24002540 <HAL_SYSCFG_VREFBUF_HighImpedanceConfig+0x24>)
2400252e:	687b      	ldr	r3, [r7, #4]
24002530:	4313      	orrs	r3, r2
24002532:	600b      	str	r3, [r1, #0]
}
24002534:	bf00      	nop
24002536:	370c      	adds	r7, #12
24002538:	46bd      	mov	sp, r7
2400253a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400253e:	4770      	bx	lr
24002540:	58003c00 	.word	0x58003c00

24002544 <HAL_SYSCFG_VREFBUF_TrimmingConfig>:
/**
  * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).
  * @retval None
  */
void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
{
24002544:	b480      	push	{r7}
24002546:	b083      	sub	sp, #12
24002548:	af00      	add	r7, sp, #0
2400254a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));

  MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
2400254c:	4b06      	ldr	r3, [pc, #24]	; (24002568 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
2400254e:	685b      	ldr	r3, [r3, #4]
24002550:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
24002554:	4904      	ldr	r1, [pc, #16]	; (24002568 <HAL_SYSCFG_VREFBUF_TrimmingConfig+0x24>)
24002556:	687b      	ldr	r3, [r7, #4]
24002558:	4313      	orrs	r3, r2
2400255a:	604b      	str	r3, [r1, #4]
}
2400255c:	bf00      	nop
2400255e:	370c      	adds	r7, #12
24002560:	46bd      	mov	sp, r7
24002562:	f85d 7b04 	ldr.w	r7, [sp], #4
24002566:	4770      	bx	lr
24002568:	58003c00 	.word	0x58003c00

2400256c <HAL_SYSCFG_EnableVREFBUF>:
/**
  * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
  * @retval HAL_OK/HAL_TIMEOUT
  */
HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
{
2400256c:	b580      	push	{r7, lr}
2400256e:	b082      	sub	sp, #8
24002570:	af00      	add	r7, sp, #0
  uint32_t  tickstart;

  SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
24002572:	4b0f      	ldr	r3, [pc, #60]	; (240025b0 <HAL_SYSCFG_EnableVREFBUF+0x44>)
24002574:	681b      	ldr	r3, [r3, #0]
24002576:	4a0e      	ldr	r2, [pc, #56]	; (240025b0 <HAL_SYSCFG_EnableVREFBUF+0x44>)
24002578:	f043 0301 	orr.w	r3, r3, #1
2400257c:	6013      	str	r3, [r2, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
2400257e:	f7ff fee1 	bl	24002344 <HAL_GetTick>
24002582:	6078      	str	r0, [r7, #4]

  /* Wait for VRR bit  */
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24002584:	e008      	b.n	24002598 <HAL_SYSCFG_EnableVREFBUF+0x2c>
  {
    if((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
24002586:	f7ff fedd 	bl	24002344 <HAL_GetTick>
2400258a:	4602      	mov	r2, r0
2400258c:	687b      	ldr	r3, [r7, #4]
2400258e:	1ad3      	subs	r3, r2, r3
24002590:	2b0a      	cmp	r3, #10
24002592:	d901      	bls.n	24002598 <HAL_SYSCFG_EnableVREFBUF+0x2c>
    {
      return HAL_TIMEOUT;
24002594:	2303      	movs	r3, #3
24002596:	e006      	b.n	240025a6 <HAL_SYSCFG_EnableVREFBUF+0x3a>
  while(READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0UL)
24002598:	4b05      	ldr	r3, [pc, #20]	; (240025b0 <HAL_SYSCFG_EnableVREFBUF+0x44>)
2400259a:	681b      	ldr	r3, [r3, #0]
2400259c:	f003 0308 	and.w	r3, r3, #8
240025a0:	2b00      	cmp	r3, #0
240025a2:	d0f0      	beq.n	24002586 <HAL_SYSCFG_EnableVREFBUF+0x1a>
    }
  }

  return HAL_OK;
240025a4:	2300      	movs	r3, #0
}
240025a6:	4618      	mov	r0, r3
240025a8:	3708      	adds	r7, #8
240025aa:	46bd      	mov	sp, r7
240025ac:	bd80      	pop	{r7, pc}
240025ae:	bf00      	nop
240025b0:	58003c00 	.word	0x58003c00

240025b4 <HAL_SYSCFG_DisableVREFBUF>:
  * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
  *
  * @retval None
  */
void HAL_SYSCFG_DisableVREFBUF(void)
{
240025b4:	b480      	push	{r7}
240025b6:	af00      	add	r7, sp, #0
  CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
240025b8:	4b05      	ldr	r3, [pc, #20]	; (240025d0 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
240025ba:	681b      	ldr	r3, [r3, #0]
240025bc:	4a04      	ldr	r2, [pc, #16]	; (240025d0 <HAL_SYSCFG_DisableVREFBUF+0x1c>)
240025be:	f023 0301 	bic.w	r3, r3, #1
240025c2:	6013      	str	r3, [r2, #0]
}
240025c4:	bf00      	nop
240025c6:	46bd      	mov	sp, r7
240025c8:	f85d 7b04 	ldr.w	r7, [sp], #4
240025cc:	4770      	bx	lr
240025ce:	bf00      	nop
240025d0:	58003c00 	.word	0x58003c00

240025d4 <HAL_SYSCFG_ETHInterfaceSelect>:
  *   @arg SYSCFG_ETH_MII : Select the Media Independent Interface
  *   @arg SYSCFG_ETH_RMII: Select the Reduced Media Independent Interface
  * @retval None
  */
void HAL_SYSCFG_ETHInterfaceSelect(uint32_t SYSCFG_ETHInterface)
{
240025d4:	b480      	push	{r7}
240025d6:	b083      	sub	sp, #12
240025d8:	af00      	add	r7, sp, #0
240025da:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ETHERNET_CONFIG(SYSCFG_ETHInterface));

  MODIFY_REG(SYSCFG->PMCR, SYSCFG_PMCR_EPIS_SEL, (uint32_t)(SYSCFG_ETHInterface));
240025dc:	4b06      	ldr	r3, [pc, #24]	; (240025f8 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
240025de:	685b      	ldr	r3, [r3, #4]
240025e0:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
240025e4:	4904      	ldr	r1, [pc, #16]	; (240025f8 <HAL_SYSCFG_ETHInterfaceSelect+0x24>)
240025e6:	687b      	ldr	r3, [r7, #4]
240025e8:	4313      	orrs	r3, r2
240025ea:	604b      	str	r3, [r1, #4]
}
240025ec:	bf00      	nop
240025ee:	370c      	adds	r7, #12
240025f0:	46bd      	mov	sp, r7
240025f2:	f85d 7b04 	ldr.w	r7, [sp], #4
240025f6:	4770      	bx	lr
240025f8:	58000400 	.word	0x58000400

240025fc <HAL_SYSCFG_AnalogSwitchConfig>:
  *   @arg SYSCFG_SWITCH_PC3_CLOSE
  * @retval None
  */

void HAL_SYSCFG_AnalogSwitchConfig(uint32_t SYSCFG_AnalogSwitch , uint32_t SYSCFG_SwitchState )
{
240025fc:	b480      	push	{r7}
240025fe:	b083      	sub	sp, #12
24002600:	af00      	add	r7, sp, #0
24002602:	6078      	str	r0, [r7, #4]
24002604:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_ANALOG_SWITCH(SYSCFG_AnalogSwitch));
  assert_param(IS_SYSCFG_SWITCH_STATE(SYSCFG_SwitchState));

  MODIFY_REG(SYSCFG->PMCR, (uint32_t) SYSCFG_AnalogSwitch, (uint32_t)(SYSCFG_SwitchState));
24002606:	4b07      	ldr	r3, [pc, #28]	; (24002624 <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
24002608:	685a      	ldr	r2, [r3, #4]
2400260a:	687b      	ldr	r3, [r7, #4]
2400260c:	43db      	mvns	r3, r3
2400260e:	401a      	ands	r2, r3
24002610:	4904      	ldr	r1, [pc, #16]	; (24002624 <HAL_SYSCFG_AnalogSwitchConfig+0x28>)
24002612:	683b      	ldr	r3, [r7, #0]
24002614:	4313      	orrs	r3, r2
24002616:	604b      	str	r3, [r1, #4]
}
24002618:	bf00      	nop
2400261a:	370c      	adds	r7, #12
2400261c:	46bd      	mov	sp, r7
2400261e:	f85d 7b04 	ldr.w	r7, [sp], #4
24002622:	4770      	bx	lr
24002624:	58000400 	.word	0x58000400

24002628 <HAL_SYSCFG_EnableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_EnableBOOST(void)
{
24002628:	b480      	push	{r7}
2400262a:	af00      	add	r7, sp, #0
 SET_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
2400262c:	4b05      	ldr	r3, [pc, #20]	; (24002644 <HAL_SYSCFG_EnableBOOST+0x1c>)
2400262e:	685b      	ldr	r3, [r3, #4]
24002630:	4a04      	ldr	r2, [pc, #16]	; (24002644 <HAL_SYSCFG_EnableBOOST+0x1c>)
24002632:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24002636:	6053      	str	r3, [r2, #4]
}
24002638:	bf00      	nop
2400263a:	46bd      	mov	sp, r7
2400263c:	f85d 7b04 	ldr.w	r7, [sp], #4
24002640:	4770      	bx	lr
24002642:	bf00      	nop
24002644:	58000400 	.word	0x58000400

24002648 <HAL_SYSCFG_DisableBOOST>:
  *         when the supply voltage is below 2.7 V: in this case, the analog switch
  *         performance is the same on the full voltage range
  * @retval None
  */
void HAL_SYSCFG_DisableBOOST(void)
{
24002648:	b480      	push	{r7}
2400264a:	af00      	add	r7, sp, #0
 CLEAR_BIT(SYSCFG->PMCR, SYSCFG_PMCR_BOOSTEN) ;
2400264c:	4b05      	ldr	r3, [pc, #20]	; (24002664 <HAL_SYSCFG_DisableBOOST+0x1c>)
2400264e:	685b      	ldr	r3, [r3, #4]
24002650:	4a04      	ldr	r2, [pc, #16]	; (24002664 <HAL_SYSCFG_DisableBOOST+0x1c>)
24002652:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24002656:	6053      	str	r3, [r2, #4]
}
24002658:	bf00      	nop
2400265a:	46bd      	mov	sp, r7
2400265c:	f85d 7b04 	ldr.w	r7, [sp], #4
24002660:	4770      	bx	lr
24002662:	bf00      	nop
24002664:	58000400 	.word	0x58000400

24002668 <HAL_SYSCFG_CM7BootAddConfig>:
  *   @arg SYSCFG_BOOT_ADDR1:  Select the boot address1
  * @param  BootAddress :Specifies the CM7 Boot Address to be loaded in Address0 or Address1
  * @retval None
  */
void HAL_SYSCFG_CM7BootAddConfig(uint32_t BootRegister, uint32_t BootAddress)
{
24002668:	b480      	push	{r7}
2400266a:	b083      	sub	sp, #12
2400266c:	af00      	add	r7, sp, #0
2400266e:	6078      	str	r0, [r7, #4]
24002670:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_SYSCFG_BOOT_REGISTER(BootRegister));
  assert_param(IS_SYSCFG_BOOT_ADDRESS(BootAddress));
  if ( BootRegister == SYSCFG_BOOT_ADDR0 )
24002672:	687b      	ldr	r3, [r7, #4]
24002674:	2b00      	cmp	r3, #0
24002676:	d10b      	bne.n	24002690 <HAL_SYSCFG_CM7BootAddConfig+0x28>
  {
    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BCM7_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BCM7_ADD0_Pos));
#else
    MODIFY_REG(SYSCFG->UR2, SYSCFG_UR2_BOOT_ADD0, ((BootAddress >> 16) << SYSCFG_UR2_BOOT_ADD0_Pos));
24002678:	4b0e      	ldr	r3, [pc, #56]	; (240026b4 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
2400267a:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
2400267e:	b29a      	uxth	r2, r3
24002680:	683b      	ldr	r3, [r7, #0]
24002682:	0c1b      	lsrs	r3, r3, #16
24002684:	041b      	lsls	r3, r3, #16
24002686:	490b      	ldr	r1, [pc, #44]	; (240026b4 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24002688:	4313      	orrs	r3, r2
2400268a:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BCM7_ADD1, (BootAddress >> 16));
#else
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
#endif /*DUAL_CORE*/
  }
}
2400268e:	e00a      	b.n	240026a6 <HAL_SYSCFG_CM7BootAddConfig+0x3e>
    MODIFY_REG(SYSCFG->UR3, SYSCFG_UR3_BOOT_ADD1, (BootAddress >> 16));
24002690:	4b08      	ldr	r3, [pc, #32]	; (240026b4 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
24002692:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
24002696:	4b08      	ldr	r3, [pc, #32]	; (240026b8 <HAL_SYSCFG_CM7BootAddConfig+0x50>)
24002698:	4013      	ands	r3, r2
2400269a:	683a      	ldr	r2, [r7, #0]
2400269c:	0c12      	lsrs	r2, r2, #16
2400269e:	4905      	ldr	r1, [pc, #20]	; (240026b4 <HAL_SYSCFG_CM7BootAddConfig+0x4c>)
240026a0:	4313      	orrs	r3, r2
240026a2:	f8c1 330c 	str.w	r3, [r1, #780]	; 0x30c
}
240026a6:	bf00      	nop
240026a8:	370c      	adds	r7, #12
240026aa:	46bd      	mov	sp, r7
240026ac:	f85d 7b04 	ldr.w	r7, [sp], #4
240026b0:	4770      	bx	lr
240026b2:	bf00      	nop
240026b4:	58000400 	.word	0x58000400
240026b8:	ffff0000 	.word	0xffff0000

240026bc <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 1.62 to 2.0 V and from 2.7 to 3.6 V.
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
240026bc:	b480      	push	{r7}
240026be:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;
240026c0:	4b05      	ldr	r3, [pc, #20]	; (240026d8 <HAL_EnableCompensationCell+0x1c>)
240026c2:	6a1b      	ldr	r3, [r3, #32]
240026c4:	4a04      	ldr	r2, [pc, #16]	; (240026d8 <HAL_EnableCompensationCell+0x1c>)
240026c6:	f043 0301 	orr.w	r3, r3, #1
240026ca:	6213      	str	r3, [r2, #32]
}
240026cc:	bf00      	nop
240026ce:	46bd      	mov	sp, r7
240026d0:	f85d 7b04 	ldr.w	r7, [sp], #4
240026d4:	4770      	bx	lr
240026d6:	bf00      	nop
240026d8:	58000400 	.word	0x58000400

240026dc <HAL_DisableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 1.62 to 2.0 V and from 2.7 to 3.6 V.
  * @retval None
  */
void HAL_DisableCompensationCell(void)
{
240026dc:	b480      	push	{r7}
240026de:	af00      	add	r7, sp, #0
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN);
240026e0:	4b05      	ldr	r3, [pc, #20]	; (240026f8 <HAL_DisableCompensationCell+0x1c>)
240026e2:	6a1b      	ldr	r3, [r3, #32]
240026e4:	4a04      	ldr	r2, [pc, #16]	; (240026f8 <HAL_DisableCompensationCell+0x1c>)
240026e6:	f023 0301 	bic.w	r3, r3, #1
240026ea:	6213      	str	r3, [r2, #32]
}
240026ec:	bf00      	nop
240026ee:	46bd      	mov	sp, r7
240026f0:	f85d 7b04 	ldr.w	r7, [sp], #4
240026f4:	4770      	bx	lr
240026f6:	bf00      	nop
240026f8:	58000400 	.word	0x58000400

240026fc <HAL_SYSCFG_EnableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_EnableIOSpeedOptimize(void)
{
240026fc:	b480      	push	{r7}
240026fe:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24002700:	4b05      	ldr	r3, [pc, #20]	; (24002718 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
24002702:	6a1b      	ldr	r3, [r3, #32]
24002704:	4a04      	ldr	r2, [pc, #16]	; (24002718 <HAL_SYSCFG_EnableIOSpeedOptimize+0x1c>)
24002706:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2400270a:	6213      	str	r3, [r2, #32]
#else
  SET_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
2400270c:	bf00      	nop
2400270e:	46bd      	mov	sp, r7
24002710:	f85d 7b04 	ldr.w	r7, [sp], #4
24002714:	4770      	bx	lr
24002716:	bf00      	nop
24002718:	58000400 	.word	0x58000400

2400271c <HAL_SYSCFG_DisableIOSpeedOptimize>:
  *         used only if the product supply voltage is below 2.5 V. Setting this bit when VDD is
  *         higher than 2.5 V might be destructive.
  * @retval None
  */
void HAL_SYSCFG_DisableIOSpeedOptimize(void)
{
2400271c:	b480      	push	{r7}
2400271e:	af00      	add	r7, sp, #0
#if defined(SYSCFG_CCCSR_HSLV)
  CLEAR_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_HSLV);
24002720:	4b05      	ldr	r3, [pc, #20]	; (24002738 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
24002722:	6a1b      	ldr	r3, [r3, #32]
24002724:	4a04      	ldr	r2, [pc, #16]	; (24002738 <HAL_SYSCFG_DisableIOSpeedOptimize+0x1c>)
24002726:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400272a:	6213      	str	r3, [r2, #32]
#else
  CLEAR_BIT(SYSCFG->CCCSR, (SYSCFG_CCCSR_HSLV0| SYSCFG_CCCSR_HSLV1 | SYSCFG_CCCSR_HSLV2  | SYSCFG_CCCSR_HSLV3));
#endif   /* SYSCFG_CCCSR_HSLV */
}
2400272c:	bf00      	nop
2400272e:	46bd      	mov	sp, r7
24002730:	f85d 7b04 	ldr.w	r7, [sp], #4
24002734:	4770      	bx	lr
24002736:	bf00      	nop
24002738:	58000400 	.word	0x58000400

2400273c <HAL_SYSCFG_CompensationCodeSelect>:
  *   @arg SYSCFG_CELL_CODE : Select Code from the cell (available in the SYSCFG_CCVR)
  *   @arg SYSCFG_REGISTER_CODE: Select Code from the SYSCFG compensation cell code register (SYSCFG_CCCR)
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeSelect(uint32_t SYSCFG_CompCode)
{
2400273c:	b480      	push	{r7}
2400273e:	b083      	sub	sp, #12
24002740:	af00      	add	r7, sp, #0
24002742:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_SELECT(SYSCFG_CompCode));
  MODIFY_REG(SYSCFG->CCCSR, SYSCFG_CCCSR_CS, (uint32_t)(SYSCFG_CompCode));
24002744:	4b06      	ldr	r3, [pc, #24]	; (24002760 <HAL_SYSCFG_CompensationCodeSelect+0x24>)
24002746:	6a1b      	ldr	r3, [r3, #32]
24002748:	f023 0202 	bic.w	r2, r3, #2
2400274c:	4904      	ldr	r1, [pc, #16]	; (24002760 <HAL_SYSCFG_CompensationCodeSelect+0x24>)
2400274e:	687b      	ldr	r3, [r7, #4]
24002750:	4313      	orrs	r3, r2
24002752:	620b      	str	r3, [r1, #32]
}
24002754:	bf00      	nop
24002756:	370c      	adds	r7, #12
24002758:	46bd      	mov	sp, r7
2400275a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400275e:	4770      	bx	lr
24002760:	58000400 	.word	0x58000400

24002764 <HAL_SYSCFG_CompensationCodeConfig>:
  *         This code is applied to the I/O compensation cell when the CS bit of the
  *          SYSCFG_CMPCR is set
  * @retval None
  */
void HAL_SYSCFG_CompensationCodeConfig(uint32_t SYSCFG_PMOSCode, uint32_t SYSCFG_NMOSCode )
{
24002764:	b480      	push	{r7}
24002766:	b083      	sub	sp, #12
24002768:	af00      	add	r7, sp, #0
2400276a:	6078      	str	r0, [r7, #4]
2400276c:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_PMOSCode));
  assert_param(IS_SYSCFG_CODE_CONFIG(SYSCFG_NMOSCode));
  MODIFY_REG(SYSCFG->CCCR, SYSCFG_CCCR_NCC|SYSCFG_CCCR_PCC, (((uint32_t)(SYSCFG_PMOSCode)<< 4)|(uint32_t)(SYSCFG_NMOSCode)) );
2400276e:	4b08      	ldr	r3, [pc, #32]	; (24002790 <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24002770:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24002772:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
24002776:	687b      	ldr	r3, [r7, #4]
24002778:	0119      	lsls	r1, r3, #4
2400277a:	683b      	ldr	r3, [r7, #0]
2400277c:	430b      	orrs	r3, r1
2400277e:	4904      	ldr	r1, [pc, #16]	; (24002790 <HAL_SYSCFG_CompensationCodeConfig+0x2c>)
24002780:	4313      	orrs	r3, r2
24002782:	628b      	str	r3, [r1, #40]	; 0x28
}
24002784:	bf00      	nop
24002786:	370c      	adds	r7, #12
24002788:	46bd      	mov	sp, r7
2400278a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400278e:	4770      	bx	lr
24002790:	58000400 	.word	0x58000400

24002794 <HAL_DBGMCU_EnableDBGSleepMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
24002794:	b480      	push	{r7}
24002796:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
24002798:	4b05      	ldr	r3, [pc, #20]	; (240027b0 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
2400279a:	685b      	ldr	r3, [r3, #4]
2400279c:	4a04      	ldr	r2, [pc, #16]	; (240027b0 <HAL_DBGMCU_EnableDBGSleepMode+0x1c>)
2400279e:	f043 0301 	orr.w	r3, r3, #1
240027a2:	6053      	str	r3, [r2, #4]
}
240027a4:	bf00      	nop
240027a6:	46bd      	mov	sp, r7
240027a8:	f85d 7b04 	ldr.w	r7, [sp], #4
240027ac:	4770      	bx	lr
240027ae:	bf00      	nop
240027b0:	5c001000 	.word	0x5c001000

240027b4 <HAL_DBGMCU_DisableDBGSleepMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain SLEEP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
240027b4:	b480      	push	{r7}
240027b6:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEPD1);
240027b8:	4b05      	ldr	r3, [pc, #20]	; (240027d0 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
240027ba:	685b      	ldr	r3, [r3, #4]
240027bc:	4a04      	ldr	r2, [pc, #16]	; (240027d0 <HAL_DBGMCU_DisableDBGSleepMode+0x1c>)
240027be:	f023 0301 	bic.w	r3, r3, #1
240027c2:	6053      	str	r3, [r2, #4]
}
240027c4:	bf00      	nop
240027c6:	46bd      	mov	sp, r7
240027c8:	f85d 7b04 	ldr.w	r7, [sp], #4
240027cc:	4770      	bx	lr
240027ce:	bf00      	nop
240027d0:	5c001000 	.word	0x5c001000

240027d4 <HAL_DBGMCU_EnableDBGStopMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
240027d4:	b480      	push	{r7}
240027d6:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
240027d8:	4b05      	ldr	r3, [pc, #20]	; (240027f0 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
240027da:	685b      	ldr	r3, [r3, #4]
240027dc:	4a04      	ldr	r2, [pc, #16]	; (240027f0 <HAL_DBGMCU_EnableDBGStopMode+0x1c>)
240027de:	f043 0302 	orr.w	r3, r3, #2
240027e2:	6053      	str	r3, [r2, #4]
}
240027e4:	bf00      	nop
240027e6:	46bd      	mov	sp, r7
240027e8:	f85d 7b04 	ldr.w	r7, [sp], #4
240027ec:	4770      	bx	lr
240027ee:	bf00      	nop
240027f0:	5c001000 	.word	0x5c001000

240027f4 <HAL_DBGMCU_DisableDBGStopMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STOP mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
240027f4:	b480      	push	{r7}
240027f6:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOPD1);
240027f8:	4b05      	ldr	r3, [pc, #20]	; (24002810 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
240027fa:	685b      	ldr	r3, [r3, #4]
240027fc:	4a04      	ldr	r2, [pc, #16]	; (24002810 <HAL_DBGMCU_DisableDBGStopMode+0x1c>)
240027fe:	f023 0302 	bic.w	r3, r3, #2
24002802:	6053      	str	r3, [r2, #4]
}
24002804:	bf00      	nop
24002806:	46bd      	mov	sp, r7
24002808:	f85d 7b04 	ldr.w	r7, [sp], #4
2400280c:	4770      	bx	lr
2400280e:	bf00      	nop
24002810:	5c001000 	.word	0x5c001000

24002814 <HAL_DBGMCU_EnableDBGStandbyMode>:
/**
  * @brief  Enable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
24002814:	b480      	push	{r7}
24002816:	af00      	add	r7, sp, #0
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24002818:	4b05      	ldr	r3, [pc, #20]	; (24002830 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
2400281a:	685b      	ldr	r3, [r3, #4]
2400281c:	4a04      	ldr	r2, [pc, #16]	; (24002830 <HAL_DBGMCU_EnableDBGStandbyMode+0x1c>)
2400281e:	f043 0304 	orr.w	r3, r3, #4
24002822:	6053      	str	r3, [r2, #4]
}
24002824:	bf00      	nop
24002826:	46bd      	mov	sp, r7
24002828:	f85d 7b04 	ldr.w	r7, [sp], #4
2400282c:	4770      	bx	lr
2400282e:	bf00      	nop
24002830:	5c001000 	.word	0x5c001000

24002834 <HAL_DBGMCU_DisableDBGStandbyMode>:
/**
  * @brief  Disable the Debug Module during Domain1/CDomain STANDBY mode
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
24002834:	b480      	push	{r7}
24002836:	af00      	add	r7, sp, #0
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBYD1);
24002838:	4b05      	ldr	r3, [pc, #20]	; (24002850 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
2400283a:	685b      	ldr	r3, [r3, #4]
2400283c:	4a04      	ldr	r2, [pc, #16]	; (24002850 <HAL_DBGMCU_DisableDBGStandbyMode+0x1c>)
2400283e:	f023 0304 	bic.w	r3, r3, #4
24002842:	6053      	str	r3, [r2, #4]
}
24002844:	bf00      	nop
24002846:	46bd      	mov	sp, r7
24002848:	f85d 7b04 	ldr.w	r7, [sp], #4
2400284c:	4770      	bx	lr
2400284e:	bf00      	nop
24002850:	5c001000 	.word	0x5c001000

24002854 <HAL_SetFMCMemorySwappingConfig>:
  * @param  BankMapConfig: Defines the FMC Bank mapping configuration. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
24002854:	b480      	push	{r7}
24002856:	b083      	sub	sp, #12
24002858:	af00      	add	r7, sp, #0
2400285a:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
2400285c:	4b06      	ldr	r3, [pc, #24]	; (24002878 <HAL_SetFMCMemorySwappingConfig+0x24>)
2400285e:	681b      	ldr	r3, [r3, #0]
24002860:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
24002864:	4904      	ldr	r1, [pc, #16]	; (24002878 <HAL_SetFMCMemorySwappingConfig+0x24>)
24002866:	687b      	ldr	r3, [r7, #4]
24002868:	4313      	orrs	r3, r2
2400286a:	600b      	str	r3, [r1, #0]
}
2400286c:	bf00      	nop
2400286e:	370c      	adds	r7, #12
24002870:	46bd      	mov	sp, r7
24002872:	f85d 7b04 	ldr.w	r7, [sp], #4
24002876:	4770      	bx	lr
24002878:	52004000 	.word	0x52004000

2400287c <HAL_GetFMCMemorySwappingConfig>:
  * @brief  Get FMC Bank mapping mode.
  * @retval The FMC Bank mapping mode. This parameter can be
            FMC_SWAPBMAP_DISABLE, FMC_SWAPBMAP_SDRAM_SRAM, FMC_SWAPBMAP_SDRAMB2
*/
uint32_t HAL_GetFMCMemorySwappingConfig(void)
{
2400287c:	b480      	push	{r7}
2400287e:	af00      	add	r7, sp, #0
  return READ_BIT(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP);
24002880:	4b04      	ldr	r3, [pc, #16]	; (24002894 <HAL_GetFMCMemorySwappingConfig+0x18>)
24002882:	681b      	ldr	r3, [r3, #0]
24002884:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
}
24002888:	4618      	mov	r0, r3
2400288a:	46bd      	mov	sp, r7
2400288c:	f85d 7b04 	ldr.w	r7, [sp], #4
24002890:	4770      	bx	lr
24002892:	bf00      	nop
24002894:	52004000 	.word	0x52004000

24002898 <HAL_EXTI_EdgeConfig>:
  *   @arg EXTI_RISING_EDGE : Configurable line, with Rising edge trigger detection
  *   @arg EXTI_FALLING_EDGE: Configurable line, with Falling edge trigger detection
  * @retval None
  */
void HAL_EXTI_EdgeConfig(uint32_t EXTI_Line , uint32_t EXTI_Edge )
{
24002898:	b480      	push	{r7}
2400289a:	b083      	sub	sp, #12
2400289c:	af00      	add	r7, sp, #0
2400289e:	6078      	str	r0, [r7, #4]
240028a0:	6039      	str	r1, [r7, #0]
  /* Check the parameter */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));
  assert_param(IS_EXTI_EDGE_LINE(EXTI_Edge));

  /* Clear Rising Falling edge configuration */
  CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
240028a2:	687b      	ldr	r3, [r7, #4]
240028a4:	095b      	lsrs	r3, r3, #5
240028a6:	015a      	lsls	r2, r3, #5
240028a8:	4b2e      	ldr	r3, [pc, #184]	; (24002964 <HAL_EXTI_EdgeConfig+0xcc>)
240028aa:	4413      	add	r3, r2
240028ac:	6819      	ldr	r1, [r3, #0]
240028ae:	687b      	ldr	r3, [r7, #4]
240028b0:	f003 031f 	and.w	r3, r3, #31
240028b4:	2201      	movs	r2, #1
240028b6:	fa02 f303 	lsl.w	r3, r2, r3
240028ba:	43da      	mvns	r2, r3
240028bc:	687b      	ldr	r3, [r7, #4]
240028be:	095b      	lsrs	r3, r3, #5
240028c0:	0158      	lsls	r0, r3, #5
240028c2:	4b28      	ldr	r3, [pc, #160]	; (24002964 <HAL_EXTI_EdgeConfig+0xcc>)
240028c4:	4403      	add	r3, r0
240028c6:	4618      	mov	r0, r3
240028c8:	ea01 0302 	and.w	r3, r1, r2
240028cc:	6003      	str	r3, [r0, #0]
  CLEAR_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
240028ce:	687b      	ldr	r3, [r7, #4]
240028d0:	095b      	lsrs	r3, r3, #5
240028d2:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
240028d6:	015b      	lsls	r3, r3, #5
240028d8:	681a      	ldr	r2, [r3, #0]
240028da:	687b      	ldr	r3, [r7, #4]
240028dc:	f003 031f 	and.w	r3, r3, #31
240028e0:	2101      	movs	r1, #1
240028e2:	fa01 f303 	lsl.w	r3, r1, r3
240028e6:	43db      	mvns	r3, r3
240028e8:	6879      	ldr	r1, [r7, #4]
240028ea:	0949      	lsrs	r1, r1, #5
240028ec:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
240028f0:	0149      	lsls	r1, r1, #5
240028f2:	4013      	ands	r3, r2
240028f4:	600b      	str	r3, [r1, #0]

  if( (EXTI_Edge & EXTI_RISING_EDGE) == EXTI_RISING_EDGE)
240028f6:	683b      	ldr	r3, [r7, #0]
240028f8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
240028fc:	2b00      	cmp	r3, #0
240028fe:	d012      	beq.n	24002926 <HAL_EXTI_EdgeConfig+0x8e>
  {
   SET_BIT( *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002900:	687b      	ldr	r3, [r7, #4]
24002902:	095b      	lsrs	r3, r3, #5
24002904:	f103 7330 	add.w	r3, r3, #46137344	; 0x2c00000
24002908:	015b      	lsls	r3, r3, #5
2400290a:	681a      	ldr	r2, [r3, #0]
2400290c:	687b      	ldr	r3, [r7, #4]
2400290e:	f003 031f 	and.w	r3, r3, #31
24002912:	2101      	movs	r1, #1
24002914:	fa01 f303 	lsl.w	r3, r1, r3
24002918:	6879      	ldr	r1, [r7, #4]
2400291a:	0949      	lsrs	r1, r1, #5
2400291c:	f101 7130 	add.w	r1, r1, #46137344	; 0x2c00000
24002920:	0149      	lsls	r1, r1, #5
24002922:	4313      	orrs	r3, r2
24002924:	600b      	str	r3, [r1, #0]
  }
  if( (EXTI_Edge & EXTI_FALLING_EDGE) == EXTI_FALLING_EDGE)
24002926:	683b      	ldr	r3, [r7, #0]
24002928:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2400292c:	2b00      	cmp	r3, #0
2400292e:	d013      	beq.n	24002958 <HAL_EXTI_EdgeConfig+0xc0>
  {
   SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002930:	687b      	ldr	r3, [r7, #4]
24002932:	095b      	lsrs	r3, r3, #5
24002934:	015a      	lsls	r2, r3, #5
24002936:	4b0b      	ldr	r3, [pc, #44]	; (24002964 <HAL_EXTI_EdgeConfig+0xcc>)
24002938:	4413      	add	r3, r2
2400293a:	6819      	ldr	r1, [r3, #0]
2400293c:	687b      	ldr	r3, [r7, #4]
2400293e:	f003 031f 	and.w	r3, r3, #31
24002942:	2201      	movs	r2, #1
24002944:	409a      	lsls	r2, r3
24002946:	687b      	ldr	r3, [r7, #4]
24002948:	095b      	lsrs	r3, r3, #5
2400294a:	0158      	lsls	r0, r3, #5
2400294c:	4b05      	ldr	r3, [pc, #20]	; (24002964 <HAL_EXTI_EdgeConfig+0xcc>)
2400294e:	4403      	add	r3, r0
24002950:	4618      	mov	r0, r3
24002952:	ea41 0302 	orr.w	r3, r1, r2
24002956:	6003      	str	r3, [r0, #0]
  }
}
24002958:	bf00      	nop
2400295a:	370c      	adds	r7, #12
2400295c:	46bd      	mov	sp, r7
2400295e:	f85d 7b04 	ldr.w	r7, [sp], #4
24002962:	4770      	bx	lr
24002964:	58000004 	.word	0x58000004

24002968 <HAL_EXTI_GenerateSWInterrupt>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *          (EXTI_LINE0..EXTI_LINE21),EXTI_LINE49,EXTI_LINE51,EXTI_LINE82,EXTI_LINE84,EXTI_LINE85 and EXTI_LINE86.
  * @retval None
  */
void HAL_EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
24002968:	b480      	push	{r7}
2400296a:	b083      	sub	sp, #12
2400296c:	af00      	add	r7, sp, #0
2400296e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_HAL_EXTI_CONFIG_LINE(EXTI_Line));

  SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER1)) + ((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002970:	687b      	ldr	r3, [r7, #4]
24002972:	095b      	lsrs	r3, r3, #5
24002974:	015a      	lsls	r2, r3, #5
24002976:	4b0b      	ldr	r3, [pc, #44]	; (240029a4 <HAL_EXTI_GenerateSWInterrupt+0x3c>)
24002978:	4413      	add	r3, r2
2400297a:	6819      	ldr	r1, [r3, #0]
2400297c:	687b      	ldr	r3, [r7, #4]
2400297e:	f003 031f 	and.w	r3, r3, #31
24002982:	2201      	movs	r2, #1
24002984:	409a      	lsls	r2, r3
24002986:	687b      	ldr	r3, [r7, #4]
24002988:	095b      	lsrs	r3, r3, #5
2400298a:	0158      	lsls	r0, r3, #5
2400298c:	4b05      	ldr	r3, [pc, #20]	; (240029a4 <HAL_EXTI_GenerateSWInterrupt+0x3c>)
2400298e:	4403      	add	r3, r0
24002990:	4618      	mov	r0, r3
24002992:	ea41 0302 	orr.w	r3, r1, r2
24002996:	6003      	str	r3, [r0, #0]
}
24002998:	bf00      	nop
2400299a:	370c      	adds	r7, #12
2400299c:	46bd      	mov	sp, r7
2400299e:	f85d 7b04 	ldr.w	r7, [sp], #4
240029a2:	4770      	bx	lr
240029a4:	58000008 	.word	0x58000008

240029a8 <HAL_EXTI_D1_ClearFlag>:
  * @param   EXTI_Line: Specifies the EXTI LINE, it can be one of the following values,
  *         (EXTI_LINE0....EXTI_LINE87)excluding :line45, line81,line83 which are reserved
  * @retval None
  */
void HAL_EXTI_D1_ClearFlag(uint32_t EXTI_Line)
{
240029a8:	b480      	push	{r7}
240029aa:	b083      	sub	sp, #12
240029ac:	af00      	add	r7, sp, #0
240029ae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
 assert_param(IS_EXTI_D1_LINE(EXTI_Line));
 WRITE_REG(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->PR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
240029b0:	687b      	ldr	r3, [r7, #4]
240029b2:	f003 021f 	and.w	r2, r3, #31
240029b6:	687b      	ldr	r3, [r7, #4]
240029b8:	095b      	lsrs	r3, r3, #5
240029ba:	0119      	lsls	r1, r3, #4
240029bc:	4b05      	ldr	r3, [pc, #20]	; (240029d4 <HAL_EXTI_D1_ClearFlag+0x2c>)
240029be:	440b      	add	r3, r1
240029c0:	4619      	mov	r1, r3
240029c2:	2301      	movs	r3, #1
240029c4:	4093      	lsls	r3, r2
240029c6:	600b      	str	r3, [r1, #0]

}
240029c8:	bf00      	nop
240029ca:	370c      	adds	r7, #12
240029cc:	46bd      	mov	sp, r7
240029ce:	f85d 7b04 	ldr.w	r7, [sp], #4
240029d2:	4770      	bx	lr
240029d4:	58000088 	.word	0x58000088

240029d8 <HAL_EXTI_D1_EventInputConfig>:
  * @param   EXTI_LineCmd controls (Enable/Disable) the EXTI line.

  * @retval None
  */
void HAL_EXTI_D1_EventInputConfig(uint32_t EXTI_Line , uint32_t EXTI_Mode,  uint32_t EXTI_LineCmd )
{
240029d8:	b480      	push	{r7}
240029da:	b085      	sub	sp, #20
240029dc:	af00      	add	r7, sp, #0
240029de:	60f8      	str	r0, [r7, #12]
240029e0:	60b9      	str	r1, [r7, #8]
240029e2:	607a      	str	r2, [r7, #4]
  /* Check the parameter */
  assert_param(IS_EXTI_D1_LINE(EXTI_Line));
  assert_param(IS_EXTI_MODE_LINE(EXTI_Mode));

  if( (EXTI_Mode & EXTI_MODE_IT) == EXTI_MODE_IT)
240029e4:	68bb      	ldr	r3, [r7, #8]
240029e6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240029ea:	2b00      	cmp	r3, #0
240029ec:	d02d      	beq.n	24002a4a <HAL_EXTI_D1_EventInputConfig+0x72>
  {
     if( EXTI_LineCmd == 0UL)
240029ee:	687b      	ldr	r3, [r7, #4]
240029f0:	2b00      	cmp	r3, #0
240029f2:	d116      	bne.n	24002a22 <HAL_EXTI_D1_EventInputConfig+0x4a>
     {
       /* Clear EXTI line configuration */
        CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
240029f4:	68fb      	ldr	r3, [r7, #12]
240029f6:	095a      	lsrs	r2, r3, #5
240029f8:	4b30      	ldr	r3, [pc, #192]	; (24002abc <HAL_EXTI_D1_EventInputConfig+0xe4>)
240029fa:	4413      	add	r3, r2
240029fc:	011b      	lsls	r3, r3, #4
240029fe:	6819      	ldr	r1, [r3, #0]
24002a00:	68fb      	ldr	r3, [r7, #12]
24002a02:	f003 031f 	and.w	r3, r3, #31
24002a06:	2201      	movs	r2, #1
24002a08:	fa02 f303 	lsl.w	r3, r2, r3
24002a0c:	43da      	mvns	r2, r3
24002a0e:	68fb      	ldr	r3, [r7, #12]
24002a10:	0958      	lsrs	r0, r3, #5
24002a12:	4b2a      	ldr	r3, [pc, #168]	; (24002abc <HAL_EXTI_D1_EventInputConfig+0xe4>)
24002a14:	4403      	add	r3, r0
24002a16:	011b      	lsls	r3, r3, #4
24002a18:	4618      	mov	r0, r3
24002a1a:	ea01 0302 	and.w	r3, r1, r2
24002a1e:	6003      	str	r3, [r0, #0]
24002a20:	e013      	b.n	24002a4a <HAL_EXTI_D1_EventInputConfig+0x72>
     }
     else
     {
        SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI_D1->IMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002a22:	68fb      	ldr	r3, [r7, #12]
24002a24:	095a      	lsrs	r2, r3, #5
24002a26:	4b25      	ldr	r3, [pc, #148]	; (24002abc <HAL_EXTI_D1_EventInputConfig+0xe4>)
24002a28:	4413      	add	r3, r2
24002a2a:	011b      	lsls	r3, r3, #4
24002a2c:	6819      	ldr	r1, [r3, #0]
24002a2e:	68fb      	ldr	r3, [r7, #12]
24002a30:	f003 031f 	and.w	r3, r3, #31
24002a34:	2201      	movs	r2, #1
24002a36:	409a      	lsls	r2, r3
24002a38:	68fb      	ldr	r3, [r7, #12]
24002a3a:	0958      	lsrs	r0, r3, #5
24002a3c:	4b1f      	ldr	r3, [pc, #124]	; (24002abc <HAL_EXTI_D1_EventInputConfig+0xe4>)
24002a3e:	4403      	add	r3, r0
24002a40:	011b      	lsls	r3, r3, #4
24002a42:	4618      	mov	r0, r3
24002a44:	ea41 0302 	orr.w	r3, r1, r2
24002a48:	6003      	str	r3, [r0, #0]
     }
  }

  if( (EXTI_Mode & EXTI_MODE_EVT) == EXTI_MODE_EVT)
24002a4a:	68bb      	ldr	r3, [r7, #8]
24002a4c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24002a50:	2b00      	cmp	r3, #0
24002a52:	d02d      	beq.n	24002ab0 <HAL_EXTI_D1_EventInputConfig+0xd8>
  {
    if( EXTI_LineCmd == 0UL)
24002a54:	687b      	ldr	r3, [r7, #4]
24002a56:	2b00      	cmp	r3, #0
24002a58:	d116      	bne.n	24002a88 <HAL_EXTI_D1_EventInputConfig+0xb0>
    {
      /* Clear EXTI line configuration */
      CLEAR_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002a5a:	68fb      	ldr	r3, [r7, #12]
24002a5c:	095b      	lsrs	r3, r3, #5
24002a5e:	011a      	lsls	r2, r3, #4
24002a60:	4b17      	ldr	r3, [pc, #92]	; (24002ac0 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24002a62:	4413      	add	r3, r2
24002a64:	6819      	ldr	r1, [r3, #0]
24002a66:	68fb      	ldr	r3, [r7, #12]
24002a68:	f003 031f 	and.w	r3, r3, #31
24002a6c:	2201      	movs	r2, #1
24002a6e:	fa02 f303 	lsl.w	r3, r2, r3
24002a72:	43da      	mvns	r2, r3
24002a74:	68fb      	ldr	r3, [r7, #12]
24002a76:	095b      	lsrs	r3, r3, #5
24002a78:	0118      	lsls	r0, r3, #4
24002a7a:	4b11      	ldr	r3, [pc, #68]	; (24002ac0 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24002a7c:	4403      	add	r3, r0
24002a7e:	4618      	mov	r0, r3
24002a80:	ea01 0302 	and.w	r3, r1, r2
24002a84:	6003      	str	r3, [r0, #0]
    else
    {
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
    }
  }
}
24002a86:	e013      	b.n	24002ab0 <HAL_EXTI_D1_EventInputConfig+0xd8>
      SET_BIT(  *(__IO uint32_t *) (((uint32_t) &(EXTI_D1->EMR1)) + ((EXTI_Line >> 5 ) * 0x10UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002a88:	68fb      	ldr	r3, [r7, #12]
24002a8a:	095b      	lsrs	r3, r3, #5
24002a8c:	011a      	lsls	r2, r3, #4
24002a8e:	4b0c      	ldr	r3, [pc, #48]	; (24002ac0 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24002a90:	4413      	add	r3, r2
24002a92:	6819      	ldr	r1, [r3, #0]
24002a94:	68fb      	ldr	r3, [r7, #12]
24002a96:	f003 031f 	and.w	r3, r3, #31
24002a9a:	2201      	movs	r2, #1
24002a9c:	409a      	lsls	r2, r3
24002a9e:	68fb      	ldr	r3, [r7, #12]
24002aa0:	095b      	lsrs	r3, r3, #5
24002aa2:	0118      	lsls	r0, r3, #4
24002aa4:	4b06      	ldr	r3, [pc, #24]	; (24002ac0 <HAL_EXTI_D1_EventInputConfig+0xe8>)
24002aa6:	4403      	add	r3, r0
24002aa8:	4618      	mov	r0, r3
24002aaa:	ea41 0302 	orr.w	r3, r1, r2
24002aae:	6003      	str	r3, [r0, #0]
}
24002ab0:	bf00      	nop
24002ab2:	3714      	adds	r7, #20
24002ab4:	46bd      	mov	sp, r7
24002ab6:	f85d 7b04 	ldr.w	r7, [sp], #4
24002aba:	4770      	bx	lr
24002abc:	05800008 	.word	0x05800008
24002ac0:	58000084 	.word	0x58000084

24002ac4 <HAL_EXTI_D3_EventInputConfig>:
  *   @arg LPTIM4_OUT_CLEAR : LPTIM4 out selected as D3 domain pendclear source
  *   @arg LPTIM5_OUT_CLEAR : LPTIM5 out selected as D3 domain pendclear source
  * @retval None
  */
void HAL_EXTI_D3_EventInputConfig(uint32_t EXTI_Line, uint32_t EXTI_LineCmd , uint32_t EXTI_ClearSrc  )
{
24002ac4:	b480      	push	{r7}
24002ac6:	b087      	sub	sp, #28
24002ac8:	af00      	add	r7, sp, #0
24002aca:	60f8      	str	r0, [r7, #12]
24002acc:	60b9      	str	r1, [r7, #8]
24002ace:	607a      	str	r2, [r7, #4]

  /* Check the parameter */
  assert_param(IS_EXTI_D3_LINE(EXTI_Line));
  assert_param(IS_EXTI_D3_CLEAR(EXTI_ClearSrc));

  if( EXTI_LineCmd == 0UL)
24002ad0:	68bb      	ldr	r3, [r7, #8]
24002ad2:	2b00      	cmp	r3, #0
24002ad4:	d116      	bne.n	24002b04 <HAL_EXTI_D3_EventInputConfig+0x40>
  {
    /* Clear EXTI line configuration */
    CLEAR_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) + ((EXTI_Line >> 5 ) * 0x20UL)),(uint32_t)(1UL << (EXTI_Line & 0x1FUL)) );
24002ad6:	68fb      	ldr	r3, [r7, #12]
24002ad8:	095b      	lsrs	r3, r3, #5
24002ada:	015a      	lsls	r2, r3, #5
24002adc:	4b2a      	ldr	r3, [pc, #168]	; (24002b88 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24002ade:	4413      	add	r3, r2
24002ae0:	6819      	ldr	r1, [r3, #0]
24002ae2:	68fb      	ldr	r3, [r7, #12]
24002ae4:	f003 031f 	and.w	r3, r3, #31
24002ae8:	2201      	movs	r2, #1
24002aea:	fa02 f303 	lsl.w	r3, r2, r3
24002aee:	43da      	mvns	r2, r3
24002af0:	68fb      	ldr	r3, [r7, #12]
24002af2:	095b      	lsrs	r3, r3, #5
24002af4:	0158      	lsls	r0, r3, #5
24002af6:	4b24      	ldr	r3, [pc, #144]	; (24002b88 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24002af8:	4403      	add	r3, r0
24002afa:	4618      	mov	r0, r3
24002afc:	ea01 0302 	and.w	r3, r1, r2
24002b00:	6003      	str	r3, [r0, #0]
24002b02:	e013      	b.n	24002b2c <HAL_EXTI_D3_EventInputConfig+0x68>
  }
  else
  {
    SET_BIT(*(__IO uint32_t *) (((uint32_t) &(EXTI->D3PMR1)) +((EXTI_Line >> 5 ) * 0x20UL)), (uint32_t)(1UL << (EXTI_Line & 0x1FUL)));
24002b04:	68fb      	ldr	r3, [r7, #12]
24002b06:	095b      	lsrs	r3, r3, #5
24002b08:	015a      	lsls	r2, r3, #5
24002b0a:	4b1f      	ldr	r3, [pc, #124]	; (24002b88 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24002b0c:	4413      	add	r3, r2
24002b0e:	6819      	ldr	r1, [r3, #0]
24002b10:	68fb      	ldr	r3, [r7, #12]
24002b12:	f003 031f 	and.w	r3, r3, #31
24002b16:	2201      	movs	r2, #1
24002b18:	409a      	lsls	r2, r3
24002b1a:	68fb      	ldr	r3, [r7, #12]
24002b1c:	095b      	lsrs	r3, r3, #5
24002b1e:	0158      	lsls	r0, r3, #5
24002b20:	4b19      	ldr	r3, [pc, #100]	; (24002b88 <HAL_EXTI_D3_EventInputConfig+0xc4>)
24002b22:	4403      	add	r3, r0
24002b24:	4618      	mov	r0, r3
24002b26:	ea41 0302 	orr.w	r3, r1, r2
24002b2a:	6003      	str	r3, [r0, #0]
  }

  if(((EXTI_Line>>4)%2UL) == 0UL)
24002b2c:	68fb      	ldr	r3, [r7, #12]
24002b2e:	f003 0310 	and.w	r3, r3, #16
24002b32:	2b00      	cmp	r3, #0
24002b34:	d106      	bne.n	24002b44 <HAL_EXTI_D3_EventInputConfig+0x80>
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1L)) + ((EXTI_Line >> 5 ) * 0x20UL));
24002b36:	68fb      	ldr	r3, [r7, #12]
24002b38:	095b      	lsrs	r3, r3, #5
24002b3a:	015a      	lsls	r2, r3, #5
24002b3c:	4b13      	ldr	r3, [pc, #76]	; (24002b8c <HAL_EXTI_D3_EventInputConfig+0xc8>)
24002b3e:	4413      	add	r3, r2
24002b40:	617b      	str	r3, [r7, #20]
24002b42:	e005      	b.n	24002b50 <HAL_EXTI_D3_EventInputConfig+0x8c>
  }
  else
  {
    pRegv = (__IO uint32_t *) (((uint32_t) &(EXTI->D3PCR1H)) + ((EXTI_Line >> 5 ) * 0x20UL));
24002b44:	68fb      	ldr	r3, [r7, #12]
24002b46:	095b      	lsrs	r3, r3, #5
24002b48:	015a      	lsls	r2, r3, #5
24002b4a:	4b11      	ldr	r3, [pc, #68]	; (24002b90 <HAL_EXTI_D3_EventInputConfig+0xcc>)
24002b4c:	4413      	add	r3, r2
24002b4e:	617b      	str	r3, [r7, #20]
  }
  MODIFY_REG(*pRegv, (uint32_t)(3UL << ((EXTI_Line*2UL) & 0x1FUL)), (uint32_t)(EXTI_ClearSrc << ((EXTI_Line*2UL) & 0x1FUL)));
24002b50:	697b      	ldr	r3, [r7, #20]
24002b52:	681a      	ldr	r2, [r3, #0]
24002b54:	68fb      	ldr	r3, [r7, #12]
24002b56:	005b      	lsls	r3, r3, #1
24002b58:	f003 031e 	and.w	r3, r3, #30
24002b5c:	2103      	movs	r1, #3
24002b5e:	fa01 f303 	lsl.w	r3, r1, r3
24002b62:	43db      	mvns	r3, r3
24002b64:	401a      	ands	r2, r3
24002b66:	68fb      	ldr	r3, [r7, #12]
24002b68:	005b      	lsls	r3, r3, #1
24002b6a:	f003 031e 	and.w	r3, r3, #30
24002b6e:	6879      	ldr	r1, [r7, #4]
24002b70:	fa01 f303 	lsl.w	r3, r1, r3
24002b74:	431a      	orrs	r2, r3
24002b76:	697b      	ldr	r3, [r7, #20]
24002b78:	601a      	str	r2, [r3, #0]

}
24002b7a:	bf00      	nop
24002b7c:	371c      	adds	r7, #28
24002b7e:	46bd      	mov	sp, r7
24002b80:	f85d 7b04 	ldr.w	r7, [sp], #4
24002b84:	4770      	bx	lr
24002b86:	bf00      	nop
24002b88:	5800000c 	.word	0x5800000c
24002b8c:	58000010 	.word	0x58000010
24002b90:	58000014 	.word	0x58000014

24002b94 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
24002b94:	b480      	push	{r7}
24002b96:	b085      	sub	sp, #20
24002b98:	af00      	add	r7, sp, #0
24002b9a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
24002b9c:	687b      	ldr	r3, [r7, #4]
24002b9e:	f003 0307 	and.w	r3, r3, #7
24002ba2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
24002ba4:	4b0b      	ldr	r3, [pc, #44]	; (24002bd4 <__NVIC_SetPriorityGrouping+0x40>)
24002ba6:	68db      	ldr	r3, [r3, #12]
24002ba8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
24002baa:	68ba      	ldr	r2, [r7, #8]
24002bac:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
24002bb0:	4013      	ands	r3, r2
24002bb2:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
24002bb4:	68fb      	ldr	r3, [r7, #12]
24002bb6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
24002bb8:	68bb      	ldr	r3, [r7, #8]
24002bba:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
24002bbc:	4b06      	ldr	r3, [pc, #24]	; (24002bd8 <__NVIC_SetPriorityGrouping+0x44>)
24002bbe:	4313      	orrs	r3, r2
24002bc0:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
24002bc2:	4a04      	ldr	r2, [pc, #16]	; (24002bd4 <__NVIC_SetPriorityGrouping+0x40>)
24002bc4:	68bb      	ldr	r3, [r7, #8]
24002bc6:	60d3      	str	r3, [r2, #12]
}
24002bc8:	bf00      	nop
24002bca:	3714      	adds	r7, #20
24002bcc:	46bd      	mov	sp, r7
24002bce:	f85d 7b04 	ldr.w	r7, [sp], #4
24002bd2:	4770      	bx	lr
24002bd4:	e000ed00 	.word	0xe000ed00
24002bd8:	05fa0000 	.word	0x05fa0000

24002bdc <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
24002bdc:	b480      	push	{r7}
24002bde:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
24002be0:	4b04      	ldr	r3, [pc, #16]	; (24002bf4 <__NVIC_GetPriorityGrouping+0x18>)
24002be2:	68db      	ldr	r3, [r3, #12]
24002be4:	0a1b      	lsrs	r3, r3, #8
24002be6:	f003 0307 	and.w	r3, r3, #7
}
24002bea:	4618      	mov	r0, r3
24002bec:	46bd      	mov	sp, r7
24002bee:	f85d 7b04 	ldr.w	r7, [sp], #4
24002bf2:	4770      	bx	lr
24002bf4:	e000ed00 	.word	0xe000ed00

24002bf8 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
24002bf8:	b480      	push	{r7}
24002bfa:	b083      	sub	sp, #12
24002bfc:	af00      	add	r7, sp, #0
24002bfe:	4603      	mov	r3, r0
24002c00:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002c02:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002c06:	2b00      	cmp	r3, #0
24002c08:	db0b      	blt.n	24002c22 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24002c0a:	88fb      	ldrh	r3, [r7, #6]
24002c0c:	f003 021f 	and.w	r2, r3, #31
24002c10:	4907      	ldr	r1, [pc, #28]	; (24002c30 <__NVIC_EnableIRQ+0x38>)
24002c12:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002c16:	095b      	lsrs	r3, r3, #5
24002c18:	2001      	movs	r0, #1
24002c1a:	fa00 f202 	lsl.w	r2, r0, r2
24002c1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
24002c22:	bf00      	nop
24002c24:	370c      	adds	r7, #12
24002c26:	46bd      	mov	sp, r7
24002c28:	f85d 7b04 	ldr.w	r7, [sp], #4
24002c2c:	4770      	bx	lr
24002c2e:	bf00      	nop
24002c30:	e000e100 	.word	0xe000e100

24002c34 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
24002c34:	b480      	push	{r7}
24002c36:	b083      	sub	sp, #12
24002c38:	af00      	add	r7, sp, #0
24002c3a:	4603      	mov	r3, r0
24002c3c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002c3e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002c42:	2b00      	cmp	r3, #0
24002c44:	db12      	blt.n	24002c6c <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24002c46:	88fb      	ldrh	r3, [r7, #6]
24002c48:	f003 021f 	and.w	r2, r3, #31
24002c4c:	490a      	ldr	r1, [pc, #40]	; (24002c78 <__NVIC_DisableIRQ+0x44>)
24002c4e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002c52:	095b      	lsrs	r3, r3, #5
24002c54:	2001      	movs	r0, #1
24002c56:	fa00 f202 	lsl.w	r2, r0, r2
24002c5a:	3320      	adds	r3, #32
24002c5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
24002c60:	f3bf 8f4f 	dsb	sy
}
24002c64:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
24002c66:	f3bf 8f6f 	isb	sy
}
24002c6a:	bf00      	nop
    __DSB();
    __ISB();
  }
}
24002c6c:	bf00      	nop
24002c6e:	370c      	adds	r7, #12
24002c70:	46bd      	mov	sp, r7
24002c72:	f85d 7b04 	ldr.w	r7, [sp], #4
24002c76:	4770      	bx	lr
24002c78:	e000e100 	.word	0xe000e100

24002c7c <__NVIC_GetPendingIRQ>:
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
24002c7c:	b480      	push	{r7}
24002c7e:	b083      	sub	sp, #12
24002c80:	af00      	add	r7, sp, #0
24002c82:	4603      	mov	r3, r0
24002c84:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002c86:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002c8a:	2b00      	cmp	r3, #0
24002c8c:	db0e      	blt.n	24002cac <__NVIC_GetPendingIRQ+0x30>
  {
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24002c8e:	4a0b      	ldr	r2, [pc, #44]	; (24002cbc <__NVIC_GetPendingIRQ+0x40>)
24002c90:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002c94:	095b      	lsrs	r3, r3, #5
24002c96:	3340      	adds	r3, #64	; 0x40
24002c98:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24002c9c:	88fb      	ldrh	r3, [r7, #6]
24002c9e:	f003 031f 	and.w	r3, r3, #31
24002ca2:	fa22 f303 	lsr.w	r3, r2, r3
24002ca6:	f003 0301 	and.w	r3, r3, #1
24002caa:	e000      	b.n	24002cae <__NVIC_GetPendingIRQ+0x32>
  }
  else
  {
    return(0U);
24002cac:	2300      	movs	r3, #0
  }
}
24002cae:	4618      	mov	r0, r3
24002cb0:	370c      	adds	r7, #12
24002cb2:	46bd      	mov	sp, r7
24002cb4:	f85d 7b04 	ldr.w	r7, [sp], #4
24002cb8:	4770      	bx	lr
24002cba:	bf00      	nop
24002cbc:	e000e100 	.word	0xe000e100

24002cc0 <__NVIC_SetPendingIRQ>:
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
24002cc0:	b480      	push	{r7}
24002cc2:	b083      	sub	sp, #12
24002cc4:	af00      	add	r7, sp, #0
24002cc6:	4603      	mov	r3, r0
24002cc8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002cca:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002cce:	2b00      	cmp	r3, #0
24002cd0:	db0c      	blt.n	24002cec <__NVIC_SetPendingIRQ+0x2c>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24002cd2:	88fb      	ldrh	r3, [r7, #6]
24002cd4:	f003 021f 	and.w	r2, r3, #31
24002cd8:	4907      	ldr	r1, [pc, #28]	; (24002cf8 <__NVIC_SetPendingIRQ+0x38>)
24002cda:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002cde:	095b      	lsrs	r3, r3, #5
24002ce0:	2001      	movs	r0, #1
24002ce2:	fa00 f202 	lsl.w	r2, r0, r2
24002ce6:	3340      	adds	r3, #64	; 0x40
24002ce8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
24002cec:	bf00      	nop
24002cee:	370c      	adds	r7, #12
24002cf0:	46bd      	mov	sp, r7
24002cf2:	f85d 7b04 	ldr.w	r7, [sp], #4
24002cf6:	4770      	bx	lr
24002cf8:	e000e100 	.word	0xe000e100

24002cfc <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
24002cfc:	b480      	push	{r7}
24002cfe:	b083      	sub	sp, #12
24002d00:	af00      	add	r7, sp, #0
24002d02:	4603      	mov	r3, r0
24002d04:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002d06:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002d0a:	2b00      	cmp	r3, #0
24002d0c:	db0c      	blt.n	24002d28 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
24002d0e:	88fb      	ldrh	r3, [r7, #6]
24002d10:	f003 021f 	and.w	r2, r3, #31
24002d14:	4907      	ldr	r1, [pc, #28]	; (24002d34 <__NVIC_ClearPendingIRQ+0x38>)
24002d16:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002d1a:	095b      	lsrs	r3, r3, #5
24002d1c:	2001      	movs	r0, #1
24002d1e:	fa00 f202 	lsl.w	r2, r0, r2
24002d22:	3360      	adds	r3, #96	; 0x60
24002d24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
24002d28:	bf00      	nop
24002d2a:	370c      	adds	r7, #12
24002d2c:	46bd      	mov	sp, r7
24002d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
24002d32:	4770      	bx	lr
24002d34:	e000e100 	.word	0xe000e100

24002d38 <__NVIC_GetActive>:
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
24002d38:	b480      	push	{r7}
24002d3a:	b083      	sub	sp, #12
24002d3c:	af00      	add	r7, sp, #0
24002d3e:	4603      	mov	r3, r0
24002d40:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002d42:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002d46:	2b00      	cmp	r3, #0
24002d48:	db0e      	blt.n	24002d68 <__NVIC_GetActive+0x30>
  {
    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
24002d4a:	4a0b      	ldr	r2, [pc, #44]	; (24002d78 <__NVIC_GetActive+0x40>)
24002d4c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002d50:	095b      	lsrs	r3, r3, #5
24002d52:	3380      	adds	r3, #128	; 0x80
24002d54:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24002d58:	88fb      	ldrh	r3, [r7, #6]
24002d5a:	f003 031f 	and.w	r3, r3, #31
24002d5e:	fa22 f303 	lsr.w	r3, r2, r3
24002d62:	f003 0301 	and.w	r3, r3, #1
24002d66:	e000      	b.n	24002d6a <__NVIC_GetActive+0x32>
  }
  else
  {
    return(0U);
24002d68:	2300      	movs	r3, #0
  }
}
24002d6a:	4618      	mov	r0, r3
24002d6c:	370c      	adds	r7, #12
24002d6e:	46bd      	mov	sp, r7
24002d70:	f85d 7b04 	ldr.w	r7, [sp], #4
24002d74:	4770      	bx	lr
24002d76:	bf00      	nop
24002d78:	e000e100 	.word	0xe000e100

24002d7c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
24002d7c:	b480      	push	{r7}
24002d7e:	b083      	sub	sp, #12
24002d80:	af00      	add	r7, sp, #0
24002d82:	4603      	mov	r3, r0
24002d84:	6039      	str	r1, [r7, #0]
24002d86:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
24002d88:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002d8c:	2b00      	cmp	r3, #0
24002d8e:	db0a      	blt.n	24002da6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24002d90:	683b      	ldr	r3, [r7, #0]
24002d92:	b2da      	uxtb	r2, r3
24002d94:	490c      	ldr	r1, [pc, #48]	; (24002dc8 <__NVIC_SetPriority+0x4c>)
24002d96:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002d9a:	0112      	lsls	r2, r2, #4
24002d9c:	b2d2      	uxtb	r2, r2
24002d9e:	440b      	add	r3, r1
24002da0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
24002da4:	e00a      	b.n	24002dbc <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
24002da6:	683b      	ldr	r3, [r7, #0]
24002da8:	b2da      	uxtb	r2, r3
24002daa:	4908      	ldr	r1, [pc, #32]	; (24002dcc <__NVIC_SetPriority+0x50>)
24002dac:	88fb      	ldrh	r3, [r7, #6]
24002dae:	f003 030f 	and.w	r3, r3, #15
24002db2:	3b04      	subs	r3, #4
24002db4:	0112      	lsls	r2, r2, #4
24002db6:	b2d2      	uxtb	r2, r2
24002db8:	440b      	add	r3, r1
24002dba:	761a      	strb	r2, [r3, #24]
}
24002dbc:	bf00      	nop
24002dbe:	370c      	adds	r7, #12
24002dc0:	46bd      	mov	sp, r7
24002dc2:	f85d 7b04 	ldr.w	r7, [sp], #4
24002dc6:	4770      	bx	lr
24002dc8:	e000e100 	.word	0xe000e100
24002dcc:	e000ed00 	.word	0xe000ed00

24002dd0 <__NVIC_GetPriority>:
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{
24002dd0:	b480      	push	{r7}
24002dd2:	b083      	sub	sp, #12
24002dd4:	af00      	add	r7, sp, #0
24002dd6:	4603      	mov	r3, r0
24002dd8:	80fb      	strh	r3, [r7, #6]

  if ((int32_t)(IRQn) >= 0)
24002dda:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002dde:	2b00      	cmp	r3, #0
24002de0:	db09      	blt.n	24002df6 <__NVIC_GetPriority+0x26>
  {
    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]                >> (8U - __NVIC_PRIO_BITS)));
24002de2:	4a0d      	ldr	r2, [pc, #52]	; (24002e18 <__NVIC_GetPriority+0x48>)
24002de4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002de8:	4413      	add	r3, r2
24002dea:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
24002dee:	b2db      	uxtb	r3, r3
24002df0:	091b      	lsrs	r3, r3, #4
24002df2:	b2db      	uxtb	r3, r3
24002df4:	e009      	b.n	24002e0a <__NVIC_GetPriority+0x3a>
  }
  else
  {
    return(((uint32_t)SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
24002df6:	4a09      	ldr	r2, [pc, #36]	; (24002e1c <__NVIC_GetPriority+0x4c>)
24002df8:	88fb      	ldrh	r3, [r7, #6]
24002dfa:	f003 030f 	and.w	r3, r3, #15
24002dfe:	3b04      	subs	r3, #4
24002e00:	4413      	add	r3, r2
24002e02:	7e1b      	ldrb	r3, [r3, #24]
24002e04:	b2db      	uxtb	r3, r3
24002e06:	091b      	lsrs	r3, r3, #4
24002e08:	b2db      	uxtb	r3, r3
  }
}
24002e0a:	4618      	mov	r0, r3
24002e0c:	370c      	adds	r7, #12
24002e0e:	46bd      	mov	sp, r7
24002e10:	f85d 7b04 	ldr.w	r7, [sp], #4
24002e14:	4770      	bx	lr
24002e16:	bf00      	nop
24002e18:	e000e100 	.word	0xe000e100
24002e1c:	e000ed00 	.word	0xe000ed00

24002e20 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
24002e20:	b480      	push	{r7}
24002e22:	b089      	sub	sp, #36	; 0x24
24002e24:	af00      	add	r7, sp, #0
24002e26:	60f8      	str	r0, [r7, #12]
24002e28:	60b9      	str	r1, [r7, #8]
24002e2a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
24002e2c:	68fb      	ldr	r3, [r7, #12]
24002e2e:	f003 0307 	and.w	r3, r3, #7
24002e32:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24002e34:	69fb      	ldr	r3, [r7, #28]
24002e36:	f1c3 0307 	rsb	r3, r3, #7
24002e3a:	2b04      	cmp	r3, #4
24002e3c:	bf28      	it	cs
24002e3e:	2304      	movcs	r3, #4
24002e40:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24002e42:	69fb      	ldr	r3, [r7, #28]
24002e44:	3304      	adds	r3, #4
24002e46:	2b06      	cmp	r3, #6
24002e48:	d902      	bls.n	24002e50 <NVIC_EncodePriority+0x30>
24002e4a:	69fb      	ldr	r3, [r7, #28]
24002e4c:	3b03      	subs	r3, #3
24002e4e:	e000      	b.n	24002e52 <NVIC_EncodePriority+0x32>
24002e50:	2300      	movs	r3, #0
24002e52:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24002e54:	f04f 32ff 	mov.w	r2, #4294967295
24002e58:	69bb      	ldr	r3, [r7, #24]
24002e5a:	fa02 f303 	lsl.w	r3, r2, r3
24002e5e:	43da      	mvns	r2, r3
24002e60:	68bb      	ldr	r3, [r7, #8]
24002e62:	401a      	ands	r2, r3
24002e64:	697b      	ldr	r3, [r7, #20]
24002e66:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
24002e68:	f04f 31ff 	mov.w	r1, #4294967295
24002e6c:	697b      	ldr	r3, [r7, #20]
24002e6e:	fa01 f303 	lsl.w	r3, r1, r3
24002e72:	43d9      	mvns	r1, r3
24002e74:	687b      	ldr	r3, [r7, #4]
24002e76:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
24002e78:	4313      	orrs	r3, r2
         );
}
24002e7a:	4618      	mov	r0, r3
24002e7c:	3724      	adds	r7, #36	; 0x24
24002e7e:	46bd      	mov	sp, r7
24002e80:	f85d 7b04 	ldr.w	r7, [sp], #4
24002e84:	4770      	bx	lr

24002e86 <NVIC_DecodePriority>:
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
24002e86:	b480      	push	{r7}
24002e88:	b089      	sub	sp, #36	; 0x24
24002e8a:	af00      	add	r7, sp, #0
24002e8c:	60f8      	str	r0, [r7, #12]
24002e8e:	60b9      	str	r1, [r7, #8]
24002e90:	607a      	str	r2, [r7, #4]
24002e92:	603b      	str	r3, [r7, #0]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
24002e94:	68bb      	ldr	r3, [r7, #8]
24002e96:	f003 0307 	and.w	r3, r3, #7
24002e9a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
24002e9c:	69fb      	ldr	r3, [r7, #28]
24002e9e:	f1c3 0307 	rsb	r3, r3, #7
24002ea2:	2b04      	cmp	r3, #4
24002ea4:	bf28      	it	cs
24002ea6:	2304      	movcs	r3, #4
24002ea8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
24002eaa:	69fb      	ldr	r3, [r7, #28]
24002eac:	3304      	adds	r3, #4
24002eae:	2b06      	cmp	r3, #6
24002eb0:	d902      	bls.n	24002eb8 <NVIC_DecodePriority+0x32>
24002eb2:	69fb      	ldr	r3, [r7, #28]
24002eb4:	3b03      	subs	r3, #3
24002eb6:	e000      	b.n	24002eba <NVIC_DecodePriority+0x34>
24002eb8:	2300      	movs	r3, #0
24002eba:	617b      	str	r3, [r7, #20]

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
24002ebc:	68fa      	ldr	r2, [r7, #12]
24002ebe:	697b      	ldr	r3, [r7, #20]
24002ec0:	40da      	lsrs	r2, r3
24002ec2:	f04f 31ff 	mov.w	r1, #4294967295
24002ec6:	69bb      	ldr	r3, [r7, #24]
24002ec8:	fa01 f303 	lsl.w	r3, r1, r3
24002ecc:	43db      	mvns	r3, r3
24002ece:	401a      	ands	r2, r3
24002ed0:	687b      	ldr	r3, [r7, #4]
24002ed2:	601a      	str	r2, [r3, #0]
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
24002ed4:	f04f 32ff 	mov.w	r2, #4294967295
24002ed8:	697b      	ldr	r3, [r7, #20]
24002eda:	fa02 f303 	lsl.w	r3, r2, r3
24002ede:	43da      	mvns	r2, r3
24002ee0:	68fb      	ldr	r3, [r7, #12]
24002ee2:	401a      	ands	r2, r3
24002ee4:	683b      	ldr	r3, [r7, #0]
24002ee6:	601a      	str	r2, [r3, #0]
}
24002ee8:	bf00      	nop
24002eea:	3724      	adds	r7, #36	; 0x24
24002eec:	46bd      	mov	sp, r7
24002eee:	f85d 7b04 	ldr.w	r7, [sp], #4
24002ef2:	4770      	bx	lr

24002ef4 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
24002ef4:	b480      	push	{r7}
24002ef6:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
24002ef8:	f3bf 8f4f 	dsb	sy
}
24002efc:	bf00      	nop
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
24002efe:	4b06      	ldr	r3, [pc, #24]	; (24002f18 <__NVIC_SystemReset+0x24>)
24002f00:	68db      	ldr	r3, [r3, #12]
24002f02:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
24002f06:	4904      	ldr	r1, [pc, #16]	; (24002f18 <__NVIC_SystemReset+0x24>)
24002f08:	4b04      	ldr	r3, [pc, #16]	; (24002f1c <__NVIC_SystemReset+0x28>)
24002f0a:	4313      	orrs	r3, r2
24002f0c:	60cb      	str	r3, [r1, #12]
  __ASM volatile ("dsb 0xF":::"memory");
24002f0e:	f3bf 8f4f 	dsb	sy
}
24002f12:	bf00      	nop
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
24002f14:	bf00      	nop
24002f16:	e7fd      	b.n	24002f14 <__NVIC_SystemReset+0x20>
24002f18:	e000ed00 	.word	0xe000ed00
24002f1c:	05fa0004 	.word	0x05fa0004

24002f20 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
24002f20:	b580      	push	{r7, lr}
24002f22:	b082      	sub	sp, #8
24002f24:	af00      	add	r7, sp, #0
24002f26:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
24002f28:	687b      	ldr	r3, [r7, #4]
24002f2a:	3b01      	subs	r3, #1
24002f2c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24002f30:	d301      	bcc.n	24002f36 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
24002f32:	2301      	movs	r3, #1
24002f34:	e00f      	b.n	24002f56 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
24002f36:	4a0a      	ldr	r2, [pc, #40]	; (24002f60 <SysTick_Config+0x40>)
24002f38:	687b      	ldr	r3, [r7, #4]
24002f3a:	3b01      	subs	r3, #1
24002f3c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
24002f3e:	210f      	movs	r1, #15
24002f40:	f04f 30ff 	mov.w	r0, #4294967295
24002f44:	f7ff ff1a 	bl	24002d7c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
24002f48:	4b05      	ldr	r3, [pc, #20]	; (24002f60 <SysTick_Config+0x40>)
24002f4a:	2200      	movs	r2, #0
24002f4c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
24002f4e:	4b04      	ldr	r3, [pc, #16]	; (24002f60 <SysTick_Config+0x40>)
24002f50:	2207      	movs	r2, #7
24002f52:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
24002f54:	2300      	movs	r3, #0
}
24002f56:	4618      	mov	r0, r3
24002f58:	3708      	adds	r7, #8
24002f5a:	46bd      	mov	sp, r7
24002f5c:	bd80      	pop	{r7, pc}
24002f5e:	bf00      	nop
24002f60:	e000e010 	.word	0xe000e010

24002f64 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
24002f64:	b580      	push	{r7, lr}
24002f66:	b082      	sub	sp, #8
24002f68:	af00      	add	r7, sp, #0
24002f6a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
24002f6c:	6878      	ldr	r0, [r7, #4]
24002f6e:	f7ff fe11 	bl	24002b94 <__NVIC_SetPriorityGrouping>
}
24002f72:	bf00      	nop
24002f74:	3708      	adds	r7, #8
24002f76:	46bd      	mov	sp, r7
24002f78:	bd80      	pop	{r7, pc}

24002f7a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
24002f7a:	b580      	push	{r7, lr}
24002f7c:	b086      	sub	sp, #24
24002f7e:	af00      	add	r7, sp, #0
24002f80:	4603      	mov	r3, r0
24002f82:	60b9      	str	r1, [r7, #8]
24002f84:	607a      	str	r2, [r7, #4]
24002f86:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
24002f88:	f7ff fe28 	bl	24002bdc <__NVIC_GetPriorityGrouping>
24002f8c:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
24002f8e:	687a      	ldr	r2, [r7, #4]
24002f90:	68b9      	ldr	r1, [r7, #8]
24002f92:	6978      	ldr	r0, [r7, #20]
24002f94:	f7ff ff44 	bl	24002e20 <NVIC_EncodePriority>
24002f98:	4602      	mov	r2, r0
24002f9a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
24002f9e:	4611      	mov	r1, r2
24002fa0:	4618      	mov	r0, r3
24002fa2:	f7ff feeb 	bl	24002d7c <__NVIC_SetPriority>
}
24002fa6:	bf00      	nop
24002fa8:	3718      	adds	r7, #24
24002faa:	46bd      	mov	sp, r7
24002fac:	bd80      	pop	{r7, pc}

24002fae <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
24002fae:	b580      	push	{r7, lr}
24002fb0:	b082      	sub	sp, #8
24002fb2:	af00      	add	r7, sp, #0
24002fb4:	4603      	mov	r3, r0
24002fb6:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
24002fb8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002fbc:	4618      	mov	r0, r3
24002fbe:	f7ff fe1b 	bl	24002bf8 <__NVIC_EnableIRQ>
}
24002fc2:	bf00      	nop
24002fc4:	3708      	adds	r7, #8
24002fc6:	46bd      	mov	sp, r7
24002fc8:	bd80      	pop	{r7, pc}

24002fca <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
24002fca:	b580      	push	{r7, lr}
24002fcc:	b082      	sub	sp, #8
24002fce:	af00      	add	r7, sp, #0
24002fd0:	4603      	mov	r3, r0
24002fd2:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
24002fd4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24002fd8:	4618      	mov	r0, r3
24002fda:	f7ff fe2b 	bl	24002c34 <__NVIC_DisableIRQ>
}
24002fde:	bf00      	nop
24002fe0:	3708      	adds	r7, #8
24002fe2:	46bd      	mov	sp, r7
24002fe4:	bd80      	pop	{r7, pc}

24002fe6 <HAL_NVIC_SystemReset>:
/**
  * @brief  Initiates a system reset request to reset the MCU.
  * @retval None
  */
void HAL_NVIC_SystemReset(void)
{
24002fe6:	b580      	push	{r7, lr}
24002fe8:	af00      	add	r7, sp, #0
  /* System Reset */
  NVIC_SystemReset();
24002fea:	f7ff ff83 	bl	24002ef4 <__NVIC_SystemReset>

24002fee <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
24002fee:	b580      	push	{r7, lr}
24002ff0:	b082      	sub	sp, #8
24002ff2:	af00      	add	r7, sp, #0
24002ff4:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
24002ff6:	6878      	ldr	r0, [r7, #4]
24002ff8:	f7ff ff92 	bl	24002f20 <SysTick_Config>
24002ffc:	4603      	mov	r3, r0
}
24002ffe:	4618      	mov	r0, r3
24003000:	3708      	adds	r7, #8
24003002:	46bd      	mov	sp, r7
24003004:	bd80      	pop	{r7, pc}
	...

24003008 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
24003008:	b480      	push	{r7}
2400300a:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
2400300c:	f3bf 8f5f 	dmb	sy
}
24003010:	bf00      	nop
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
24003012:	4b07      	ldr	r3, [pc, #28]	; (24003030 <HAL_MPU_Disable+0x28>)
24003014:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24003016:	4a06      	ldr	r2, [pc, #24]	; (24003030 <HAL_MPU_Disable+0x28>)
24003018:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2400301c:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
2400301e:	4b05      	ldr	r3, [pc, #20]	; (24003034 <HAL_MPU_Disable+0x2c>)
24003020:	2200      	movs	r2, #0
24003022:	605a      	str	r2, [r3, #4]
}
24003024:	bf00      	nop
24003026:	46bd      	mov	sp, r7
24003028:	f85d 7b04 	ldr.w	r7, [sp], #4
2400302c:	4770      	bx	lr
2400302e:	bf00      	nop
24003030:	e000ed00 	.word	0xe000ed00
24003034:	e000ed90 	.word	0xe000ed90

24003038 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
24003038:	b480      	push	{r7}
2400303a:	b083      	sub	sp, #12
2400303c:	af00      	add	r7, sp, #0
2400303e:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
24003040:	4a0b      	ldr	r2, [pc, #44]	; (24003070 <HAL_MPU_Enable+0x38>)
24003042:	687b      	ldr	r3, [r7, #4]
24003044:	f043 0301 	orr.w	r3, r3, #1
24003048:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
2400304a:	4b0a      	ldr	r3, [pc, #40]	; (24003074 <HAL_MPU_Enable+0x3c>)
2400304c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400304e:	4a09      	ldr	r2, [pc, #36]	; (24003074 <HAL_MPU_Enable+0x3c>)
24003050:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24003054:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
24003056:	f3bf 8f4f 	dsb	sy
}
2400305a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
2400305c:	f3bf 8f6f 	isb	sy
}
24003060:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
24003062:	bf00      	nop
24003064:	370c      	adds	r7, #12
24003066:	46bd      	mov	sp, r7
24003068:	f85d 7b04 	ldr.w	r7, [sp], #4
2400306c:	4770      	bx	lr
2400306e:	bf00      	nop
24003070:	e000ed90 	.word	0xe000ed90
24003074:	e000ed00 	.word	0xe000ed00

24003078 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
24003078:	b480      	push	{r7}
2400307a:	b083      	sub	sp, #12
2400307c:	af00      	add	r7, sp, #0
2400307e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
24003080:	687b      	ldr	r3, [r7, #4]
24003082:	785a      	ldrb	r2, [r3, #1]
24003084:	4b1d      	ldr	r3, [pc, #116]	; (240030fc <HAL_MPU_ConfigRegion+0x84>)
24003086:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
24003088:	687b      	ldr	r3, [r7, #4]
2400308a:	781b      	ldrb	r3, [r3, #0]
2400308c:	2b00      	cmp	r3, #0
2400308e:	d029      	beq.n	240030e4 <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
24003090:	4a1a      	ldr	r2, [pc, #104]	; (240030fc <HAL_MPU_ConfigRegion+0x84>)
24003092:	687b      	ldr	r3, [r7, #4]
24003094:	685b      	ldr	r3, [r3, #4]
24003096:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
24003098:	687b      	ldr	r3, [r7, #4]
2400309a:	7b1b      	ldrb	r3, [r3, #12]
2400309c:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
2400309e:	687b      	ldr	r3, [r7, #4]
240030a0:	7adb      	ldrb	r3, [r3, #11]
240030a2:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
240030a4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
240030a6:	687b      	ldr	r3, [r7, #4]
240030a8:	7a9b      	ldrb	r3, [r3, #10]
240030aa:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
240030ac:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
240030ae:	687b      	ldr	r3, [r7, #4]
240030b0:	7b5b      	ldrb	r3, [r3, #13]
240030b2:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
240030b4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
240030b6:	687b      	ldr	r3, [r7, #4]
240030b8:	7b9b      	ldrb	r3, [r3, #14]
240030ba:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
240030bc:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
240030be:	687b      	ldr	r3, [r7, #4]
240030c0:	7bdb      	ldrb	r3, [r3, #15]
240030c2:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
240030c4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
240030c6:	687b      	ldr	r3, [r7, #4]
240030c8:	7a5b      	ldrb	r3, [r3, #9]
240030ca:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
240030cc:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
240030ce:	687b      	ldr	r3, [r7, #4]
240030d0:	7a1b      	ldrb	r3, [r3, #8]
240030d2:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
240030d4:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
240030d6:	687a      	ldr	r2, [r7, #4]
240030d8:	7812      	ldrb	r2, [r2, #0]
240030da:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
240030dc:	4a07      	ldr	r2, [pc, #28]	; (240030fc <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
240030de:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
240030e0:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
240030e2:	e005      	b.n	240030f0 <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
240030e4:	4b05      	ldr	r3, [pc, #20]	; (240030fc <HAL_MPU_ConfigRegion+0x84>)
240030e6:	2200      	movs	r2, #0
240030e8:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
240030ea:	4b04      	ldr	r3, [pc, #16]	; (240030fc <HAL_MPU_ConfigRegion+0x84>)
240030ec:	2200      	movs	r2, #0
240030ee:	611a      	str	r2, [r3, #16]
}
240030f0:	bf00      	nop
240030f2:	370c      	adds	r7, #12
240030f4:	46bd      	mov	sp, r7
240030f6:	f85d 7b04 	ldr.w	r7, [sp], #4
240030fa:	4770      	bx	lr
240030fc:	e000ed90 	.word	0xe000ed90

24003100 <HAL_NVIC_GetPriorityGrouping>:
/**
  * @brief  Gets the priority grouping field from the NVIC Interrupt Controller.
  * @retval Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field)
  */
uint32_t HAL_NVIC_GetPriorityGrouping(void)
{
24003100:	b580      	push	{r7, lr}
24003102:	af00      	add	r7, sp, #0
  /* Get the PRIGROUP[10:8] field value */
  return NVIC_GetPriorityGrouping();
24003104:	f7ff fd6a 	bl	24002bdc <__NVIC_GetPriorityGrouping>
24003108:	4603      	mov	r3, r0
}
2400310a:	4618      	mov	r0, r3
2400310c:	bd80      	pop	{r7, pc}

2400310e <HAL_NVIC_GetPriority>:
  * @param  pPreemptPriority Pointer on the Preemptive priority value (starting from 0).
  * @param  pSubPriority Pointer on the Subpriority value (starting from 0).
  * @retval None
  */
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
{
2400310e:	b580      	push	{r7, lr}
24003110:	b084      	sub	sp, #16
24003112:	af00      	add	r7, sp, #0
24003114:	60b9      	str	r1, [r7, #8]
24003116:	607a      	str	r2, [r7, #4]
24003118:	603b      	str	r3, [r7, #0]
2400311a:	4603      	mov	r3, r0
2400311c:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 /* Get priority for Cortex-M system or device specific interrupts */
  NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
2400311e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
24003122:	4618      	mov	r0, r3
24003124:	f7ff fe54 	bl	24002dd0 <__NVIC_GetPriority>
24003128:	683b      	ldr	r3, [r7, #0]
2400312a:	687a      	ldr	r2, [r7, #4]
2400312c:	68b9      	ldr	r1, [r7, #8]
2400312e:	f7ff feaa 	bl	24002e86 <NVIC_DecodePriority>
}
24003132:	bf00      	nop
24003134:	3710      	adds	r7, #16
24003136:	46bd      	mov	sp, r7
24003138:	bd80      	pop	{r7, pc}

2400313a <HAL_NVIC_SetPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
2400313a:	b580      	push	{r7, lr}
2400313c:	b082      	sub	sp, #8
2400313e:	af00      	add	r7, sp, #0
24003140:	4603      	mov	r3, r0
24003142:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Set interrupt pending */
  NVIC_SetPendingIRQ(IRQn);
24003144:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24003148:	4618      	mov	r0, r3
2400314a:	f7ff fdb9 	bl	24002cc0 <__NVIC_SetPendingIRQ>
}
2400314e:	bf00      	nop
24003150:	3708      	adds	r7, #8
24003152:	46bd      	mov	sp, r7
24003154:	bd80      	pop	{r7, pc}

24003156 <HAL_NVIC_GetPendingIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
24003156:	b580      	push	{r7, lr}
24003158:	b082      	sub	sp, #8
2400315a:	af00      	add	r7, sp, #0
2400315c:	4603      	mov	r3, r0
2400315e:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
24003160:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24003164:	4618      	mov	r0, r3
24003166:	f7ff fd89 	bl	24002c7c <__NVIC_GetPendingIRQ>
2400316a:	4603      	mov	r3, r0
}
2400316c:	4618      	mov	r0, r3
2400316e:	3708      	adds	r7, #8
24003170:	46bd      	mov	sp, r7
24003172:	bd80      	pop	{r7, pc}

24003174 <HAL_NVIC_ClearPendingIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
24003174:	b580      	push	{r7, lr}
24003176:	b082      	sub	sp, #8
24003178:	af00      	add	r7, sp, #0
2400317a:	4603      	mov	r3, r0
2400317c:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
2400317e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
24003182:	4618      	mov	r0, r3
24003184:	f7ff fdba 	bl	24002cfc <__NVIC_ClearPendingIRQ>
}
24003188:	bf00      	nop
2400318a:	3708      	adds	r7, #8
2400318c:	46bd      	mov	sp, r7
2400318e:	bd80      	pop	{r7, pc}

24003190 <HAL_NVIC_GetActive>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval status  - 0  Interrupt status is not pending.
  *                 - 1  Interrupt status is pending.
  */
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
{
24003190:	b580      	push	{r7, lr}
24003192:	b082      	sub	sp, #8
24003194:	af00      	add	r7, sp, #0
24003196:	4603      	mov	r3, r0
24003198:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Return 1 if active else 0 */
  return NVIC_GetActive(IRQn);
2400319a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
2400319e:	4618      	mov	r0, r3
240031a0:	f7ff fdca 	bl	24002d38 <__NVIC_GetActive>
240031a4:	4603      	mov	r3, r0
}
240031a6:	4618      	mov	r0, r3
240031a8:	3708      	adds	r7, #8
240031aa:	46bd      	mov	sp, r7
240031ac:	bd80      	pop	{r7, pc}
	...

240031b0 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
240031b0:	b480      	push	{r7}
240031b2:	b083      	sub	sp, #12
240031b4:	af00      	add	r7, sp, #0
240031b6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
240031b8:	687b      	ldr	r3, [r7, #4]
240031ba:	2b04      	cmp	r3, #4
240031bc:	d106      	bne.n	240031cc <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
240031be:	4b09      	ldr	r3, [pc, #36]	; (240031e4 <HAL_SYSTICK_CLKSourceConfig+0x34>)
240031c0:	681b      	ldr	r3, [r3, #0]
240031c2:	4a08      	ldr	r2, [pc, #32]	; (240031e4 <HAL_SYSTICK_CLKSourceConfig+0x34>)
240031c4:	f043 0304 	orr.w	r3, r3, #4
240031c8:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
  }
}
240031ca:	e005      	b.n	240031d8 <HAL_SYSTICK_CLKSourceConfig+0x28>
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
240031cc:	4b05      	ldr	r3, [pc, #20]	; (240031e4 <HAL_SYSTICK_CLKSourceConfig+0x34>)
240031ce:	681b      	ldr	r3, [r3, #0]
240031d0:	4a04      	ldr	r2, [pc, #16]	; (240031e4 <HAL_SYSTICK_CLKSourceConfig+0x34>)
240031d2:	f023 0304 	bic.w	r3, r3, #4
240031d6:	6013      	str	r3, [r2, #0]
}
240031d8:	bf00      	nop
240031da:	370c      	adds	r7, #12
240031dc:	46bd      	mov	sp, r7
240031de:	f85d 7b04 	ldr.w	r7, [sp], #4
240031e2:	4770      	bx	lr
240031e4:	e000e010 	.word	0xe000e010

240031e8 <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
240031e8:	b580      	push	{r7, lr}
240031ea:	af00      	add	r7, sp, #0
  HAL_SYSTICK_Callback();
240031ec:	f000 f802 	bl	240031f4 <HAL_SYSTICK_Callback>
}
240031f0:	bf00      	nop
240031f2:	bd80      	pop	{r7, pc}

240031f4 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
240031f4:	b480      	push	{r7}
240031f6:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_SYSTICK_Callback could be implemented in the user file
   */
}
240031f8:	bf00      	nop
240031fa:	46bd      	mov	sp, r7
240031fc:	f85d 7b04 	ldr.w	r7, [sp], #4
24003200:	4770      	bx	lr

24003202 <HAL_GetCurrentCPUID>:
/**
* @brief  Returns the current CPU ID.
* @retval CPU identifier
*/
uint32_t HAL_GetCurrentCPUID(void)
{
24003202:	b480      	push	{r7}
24003204:	af00      	add	r7, sp, #0
  return  CM7_CPUID;
24003206:	2303      	movs	r3, #3
}
24003208:	4618      	mov	r0, r3
2400320a:	46bd      	mov	sp, r7
2400320c:	f85d 7b04 	ldr.w	r7, [sp], #4
24003210:	4770      	bx	lr
	...

24003214 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
24003214:	b580      	push	{r7, lr}
24003216:	b086      	sub	sp, #24
24003218:	af00      	add	r7, sp, #0
2400321a:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
2400321c:	f7ff f892 	bl	24002344 <HAL_GetTick>
24003220:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003222:	687b      	ldr	r3, [r7, #4]
24003224:	2b00      	cmp	r3, #0
24003226:	d101      	bne.n	2400322c <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
24003228:	2301      	movs	r3, #1
2400322a:	e316      	b.n	2400385a <HAL_DMA_Init+0x646>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400322c:	687b      	ldr	r3, [r7, #4]
2400322e:	681b      	ldr	r3, [r3, #0]
24003230:	4a66      	ldr	r2, [pc, #408]	; (240033cc <HAL_DMA_Init+0x1b8>)
24003232:	4293      	cmp	r3, r2
24003234:	d04a      	beq.n	240032cc <HAL_DMA_Init+0xb8>
24003236:	687b      	ldr	r3, [r7, #4]
24003238:	681b      	ldr	r3, [r3, #0]
2400323a:	4a65      	ldr	r2, [pc, #404]	; (240033d0 <HAL_DMA_Init+0x1bc>)
2400323c:	4293      	cmp	r3, r2
2400323e:	d045      	beq.n	240032cc <HAL_DMA_Init+0xb8>
24003240:	687b      	ldr	r3, [r7, #4]
24003242:	681b      	ldr	r3, [r3, #0]
24003244:	4a63      	ldr	r2, [pc, #396]	; (240033d4 <HAL_DMA_Init+0x1c0>)
24003246:	4293      	cmp	r3, r2
24003248:	d040      	beq.n	240032cc <HAL_DMA_Init+0xb8>
2400324a:	687b      	ldr	r3, [r7, #4]
2400324c:	681b      	ldr	r3, [r3, #0]
2400324e:	4a62      	ldr	r2, [pc, #392]	; (240033d8 <HAL_DMA_Init+0x1c4>)
24003250:	4293      	cmp	r3, r2
24003252:	d03b      	beq.n	240032cc <HAL_DMA_Init+0xb8>
24003254:	687b      	ldr	r3, [r7, #4]
24003256:	681b      	ldr	r3, [r3, #0]
24003258:	4a60      	ldr	r2, [pc, #384]	; (240033dc <HAL_DMA_Init+0x1c8>)
2400325a:	4293      	cmp	r3, r2
2400325c:	d036      	beq.n	240032cc <HAL_DMA_Init+0xb8>
2400325e:	687b      	ldr	r3, [r7, #4]
24003260:	681b      	ldr	r3, [r3, #0]
24003262:	4a5f      	ldr	r2, [pc, #380]	; (240033e0 <HAL_DMA_Init+0x1cc>)
24003264:	4293      	cmp	r3, r2
24003266:	d031      	beq.n	240032cc <HAL_DMA_Init+0xb8>
24003268:	687b      	ldr	r3, [r7, #4]
2400326a:	681b      	ldr	r3, [r3, #0]
2400326c:	4a5d      	ldr	r2, [pc, #372]	; (240033e4 <HAL_DMA_Init+0x1d0>)
2400326e:	4293      	cmp	r3, r2
24003270:	d02c      	beq.n	240032cc <HAL_DMA_Init+0xb8>
24003272:	687b      	ldr	r3, [r7, #4]
24003274:	681b      	ldr	r3, [r3, #0]
24003276:	4a5c      	ldr	r2, [pc, #368]	; (240033e8 <HAL_DMA_Init+0x1d4>)
24003278:	4293      	cmp	r3, r2
2400327a:	d027      	beq.n	240032cc <HAL_DMA_Init+0xb8>
2400327c:	687b      	ldr	r3, [r7, #4]
2400327e:	681b      	ldr	r3, [r3, #0]
24003280:	4a5a      	ldr	r2, [pc, #360]	; (240033ec <HAL_DMA_Init+0x1d8>)
24003282:	4293      	cmp	r3, r2
24003284:	d022      	beq.n	240032cc <HAL_DMA_Init+0xb8>
24003286:	687b      	ldr	r3, [r7, #4]
24003288:	681b      	ldr	r3, [r3, #0]
2400328a:	4a59      	ldr	r2, [pc, #356]	; (240033f0 <HAL_DMA_Init+0x1dc>)
2400328c:	4293      	cmp	r3, r2
2400328e:	d01d      	beq.n	240032cc <HAL_DMA_Init+0xb8>
24003290:	687b      	ldr	r3, [r7, #4]
24003292:	681b      	ldr	r3, [r3, #0]
24003294:	4a57      	ldr	r2, [pc, #348]	; (240033f4 <HAL_DMA_Init+0x1e0>)
24003296:	4293      	cmp	r3, r2
24003298:	d018      	beq.n	240032cc <HAL_DMA_Init+0xb8>
2400329a:	687b      	ldr	r3, [r7, #4]
2400329c:	681b      	ldr	r3, [r3, #0]
2400329e:	4a56      	ldr	r2, [pc, #344]	; (240033f8 <HAL_DMA_Init+0x1e4>)
240032a0:	4293      	cmp	r3, r2
240032a2:	d013      	beq.n	240032cc <HAL_DMA_Init+0xb8>
240032a4:	687b      	ldr	r3, [r7, #4]
240032a6:	681b      	ldr	r3, [r3, #0]
240032a8:	4a54      	ldr	r2, [pc, #336]	; (240033fc <HAL_DMA_Init+0x1e8>)
240032aa:	4293      	cmp	r3, r2
240032ac:	d00e      	beq.n	240032cc <HAL_DMA_Init+0xb8>
240032ae:	687b      	ldr	r3, [r7, #4]
240032b0:	681b      	ldr	r3, [r3, #0]
240032b2:	4a53      	ldr	r2, [pc, #332]	; (24003400 <HAL_DMA_Init+0x1ec>)
240032b4:	4293      	cmp	r3, r2
240032b6:	d009      	beq.n	240032cc <HAL_DMA_Init+0xb8>
240032b8:	687b      	ldr	r3, [r7, #4]
240032ba:	681b      	ldr	r3, [r3, #0]
240032bc:	4a51      	ldr	r2, [pc, #324]	; (24003404 <HAL_DMA_Init+0x1f0>)
240032be:	4293      	cmp	r3, r2
240032c0:	d004      	beq.n	240032cc <HAL_DMA_Init+0xb8>
240032c2:	687b      	ldr	r3, [r7, #4]
240032c4:	681b      	ldr	r3, [r3, #0]
240032c6:	4a50      	ldr	r2, [pc, #320]	; (24003408 <HAL_DMA_Init+0x1f4>)
240032c8:	4293      	cmp	r3, r2
240032ca:	d101      	bne.n	240032d0 <HAL_DMA_Init+0xbc>
240032cc:	2301      	movs	r3, #1
240032ce:	e000      	b.n	240032d2 <HAL_DMA_Init+0xbe>
240032d0:	2300      	movs	r3, #0
240032d2:	2b00      	cmp	r3, #0
240032d4:	f000 813b 	beq.w	2400354e <HAL_DMA_Init+0x33a>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
240032d8:	687b      	ldr	r3, [r7, #4]
240032da:	2202      	movs	r2, #2
240032dc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
240032e0:	687b      	ldr	r3, [r7, #4]
240032e2:	2200      	movs	r2, #0
240032e4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
240032e8:	687b      	ldr	r3, [r7, #4]
240032ea:	681b      	ldr	r3, [r3, #0]
240032ec:	4a37      	ldr	r2, [pc, #220]	; (240033cc <HAL_DMA_Init+0x1b8>)
240032ee:	4293      	cmp	r3, r2
240032f0:	d04a      	beq.n	24003388 <HAL_DMA_Init+0x174>
240032f2:	687b      	ldr	r3, [r7, #4]
240032f4:	681b      	ldr	r3, [r3, #0]
240032f6:	4a36      	ldr	r2, [pc, #216]	; (240033d0 <HAL_DMA_Init+0x1bc>)
240032f8:	4293      	cmp	r3, r2
240032fa:	d045      	beq.n	24003388 <HAL_DMA_Init+0x174>
240032fc:	687b      	ldr	r3, [r7, #4]
240032fe:	681b      	ldr	r3, [r3, #0]
24003300:	4a34      	ldr	r2, [pc, #208]	; (240033d4 <HAL_DMA_Init+0x1c0>)
24003302:	4293      	cmp	r3, r2
24003304:	d040      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003306:	687b      	ldr	r3, [r7, #4]
24003308:	681b      	ldr	r3, [r3, #0]
2400330a:	4a33      	ldr	r2, [pc, #204]	; (240033d8 <HAL_DMA_Init+0x1c4>)
2400330c:	4293      	cmp	r3, r2
2400330e:	d03b      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003310:	687b      	ldr	r3, [r7, #4]
24003312:	681b      	ldr	r3, [r3, #0]
24003314:	4a31      	ldr	r2, [pc, #196]	; (240033dc <HAL_DMA_Init+0x1c8>)
24003316:	4293      	cmp	r3, r2
24003318:	d036      	beq.n	24003388 <HAL_DMA_Init+0x174>
2400331a:	687b      	ldr	r3, [r7, #4]
2400331c:	681b      	ldr	r3, [r3, #0]
2400331e:	4a30      	ldr	r2, [pc, #192]	; (240033e0 <HAL_DMA_Init+0x1cc>)
24003320:	4293      	cmp	r3, r2
24003322:	d031      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003324:	687b      	ldr	r3, [r7, #4]
24003326:	681b      	ldr	r3, [r3, #0]
24003328:	4a2e      	ldr	r2, [pc, #184]	; (240033e4 <HAL_DMA_Init+0x1d0>)
2400332a:	4293      	cmp	r3, r2
2400332c:	d02c      	beq.n	24003388 <HAL_DMA_Init+0x174>
2400332e:	687b      	ldr	r3, [r7, #4]
24003330:	681b      	ldr	r3, [r3, #0]
24003332:	4a2d      	ldr	r2, [pc, #180]	; (240033e8 <HAL_DMA_Init+0x1d4>)
24003334:	4293      	cmp	r3, r2
24003336:	d027      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003338:	687b      	ldr	r3, [r7, #4]
2400333a:	681b      	ldr	r3, [r3, #0]
2400333c:	4a2b      	ldr	r2, [pc, #172]	; (240033ec <HAL_DMA_Init+0x1d8>)
2400333e:	4293      	cmp	r3, r2
24003340:	d022      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003342:	687b      	ldr	r3, [r7, #4]
24003344:	681b      	ldr	r3, [r3, #0]
24003346:	4a2a      	ldr	r2, [pc, #168]	; (240033f0 <HAL_DMA_Init+0x1dc>)
24003348:	4293      	cmp	r3, r2
2400334a:	d01d      	beq.n	24003388 <HAL_DMA_Init+0x174>
2400334c:	687b      	ldr	r3, [r7, #4]
2400334e:	681b      	ldr	r3, [r3, #0]
24003350:	4a28      	ldr	r2, [pc, #160]	; (240033f4 <HAL_DMA_Init+0x1e0>)
24003352:	4293      	cmp	r3, r2
24003354:	d018      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003356:	687b      	ldr	r3, [r7, #4]
24003358:	681b      	ldr	r3, [r3, #0]
2400335a:	4a27      	ldr	r2, [pc, #156]	; (240033f8 <HAL_DMA_Init+0x1e4>)
2400335c:	4293      	cmp	r3, r2
2400335e:	d013      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003360:	687b      	ldr	r3, [r7, #4]
24003362:	681b      	ldr	r3, [r3, #0]
24003364:	4a25      	ldr	r2, [pc, #148]	; (240033fc <HAL_DMA_Init+0x1e8>)
24003366:	4293      	cmp	r3, r2
24003368:	d00e      	beq.n	24003388 <HAL_DMA_Init+0x174>
2400336a:	687b      	ldr	r3, [r7, #4]
2400336c:	681b      	ldr	r3, [r3, #0]
2400336e:	4a24      	ldr	r2, [pc, #144]	; (24003400 <HAL_DMA_Init+0x1ec>)
24003370:	4293      	cmp	r3, r2
24003372:	d009      	beq.n	24003388 <HAL_DMA_Init+0x174>
24003374:	687b      	ldr	r3, [r7, #4]
24003376:	681b      	ldr	r3, [r3, #0]
24003378:	4a22      	ldr	r2, [pc, #136]	; (24003404 <HAL_DMA_Init+0x1f0>)
2400337a:	4293      	cmp	r3, r2
2400337c:	d004      	beq.n	24003388 <HAL_DMA_Init+0x174>
2400337e:	687b      	ldr	r3, [r7, #4]
24003380:	681b      	ldr	r3, [r3, #0]
24003382:	4a21      	ldr	r2, [pc, #132]	; (24003408 <HAL_DMA_Init+0x1f4>)
24003384:	4293      	cmp	r3, r2
24003386:	d108      	bne.n	2400339a <HAL_DMA_Init+0x186>
24003388:	687b      	ldr	r3, [r7, #4]
2400338a:	681b      	ldr	r3, [r3, #0]
2400338c:	681a      	ldr	r2, [r3, #0]
2400338e:	687b      	ldr	r3, [r7, #4]
24003390:	681b      	ldr	r3, [r3, #0]
24003392:	f022 0201 	bic.w	r2, r2, #1
24003396:	601a      	str	r2, [r3, #0]
24003398:	e007      	b.n	240033aa <HAL_DMA_Init+0x196>
2400339a:	687b      	ldr	r3, [r7, #4]
2400339c:	681b      	ldr	r3, [r3, #0]
2400339e:	681a      	ldr	r2, [r3, #0]
240033a0:	687b      	ldr	r3, [r7, #4]
240033a2:	681b      	ldr	r3, [r3, #0]
240033a4:	f022 0201 	bic.w	r2, r2, #1
240033a8:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
240033aa:	e02f      	b.n	2400340c <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
240033ac:	f7fe ffca 	bl	24002344 <HAL_GetTick>
240033b0:	4602      	mov	r2, r0
240033b2:	693b      	ldr	r3, [r7, #16]
240033b4:	1ad3      	subs	r3, r2, r3
240033b6:	2b05      	cmp	r3, #5
240033b8:	d928      	bls.n	2400340c <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
240033ba:	687b      	ldr	r3, [r7, #4]
240033bc:	2220      	movs	r2, #32
240033be:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
240033c0:	687b      	ldr	r3, [r7, #4]
240033c2:	2203      	movs	r2, #3
240033c4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
240033c8:	2301      	movs	r3, #1
240033ca:	e246      	b.n	2400385a <HAL_DMA_Init+0x646>
240033cc:	40020010 	.word	0x40020010
240033d0:	40020028 	.word	0x40020028
240033d4:	40020040 	.word	0x40020040
240033d8:	40020058 	.word	0x40020058
240033dc:	40020070 	.word	0x40020070
240033e0:	40020088 	.word	0x40020088
240033e4:	400200a0 	.word	0x400200a0
240033e8:	400200b8 	.word	0x400200b8
240033ec:	40020410 	.word	0x40020410
240033f0:	40020428 	.word	0x40020428
240033f4:	40020440 	.word	0x40020440
240033f8:	40020458 	.word	0x40020458
240033fc:	40020470 	.word	0x40020470
24003400:	40020488 	.word	0x40020488
24003404:	400204a0 	.word	0x400204a0
24003408:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
2400340c:	687b      	ldr	r3, [r7, #4]
2400340e:	681b      	ldr	r3, [r3, #0]
24003410:	681b      	ldr	r3, [r3, #0]
24003412:	f003 0301 	and.w	r3, r3, #1
24003416:	2b00      	cmp	r3, #0
24003418:	d1c8      	bne.n	240033ac <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
2400341a:	687b      	ldr	r3, [r7, #4]
2400341c:	681b      	ldr	r3, [r3, #0]
2400341e:	681b      	ldr	r3, [r3, #0]
24003420:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
24003422:	697a      	ldr	r2, [r7, #20]
24003424:	4b83      	ldr	r3, [pc, #524]	; (24003634 <HAL_DMA_Init+0x420>)
24003426:	4013      	ands	r3, r2
24003428:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
2400342a:	687b      	ldr	r3, [r7, #4]
2400342c:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
2400342e:	687b      	ldr	r3, [r7, #4]
24003430:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
24003432:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
24003434:	687b      	ldr	r3, [r7, #4]
24003436:	691b      	ldr	r3, [r3, #16]
24003438:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
2400343a:	687b      	ldr	r3, [r7, #4]
2400343c:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
2400343e:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
24003440:	687b      	ldr	r3, [r7, #4]
24003442:	699b      	ldr	r3, [r3, #24]
24003444:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
24003446:	687b      	ldr	r3, [r7, #4]
24003448:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
2400344a:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
2400344c:	687b      	ldr	r3, [r7, #4]
2400344e:	6a1b      	ldr	r3, [r3, #32]
24003450:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
24003452:	697a      	ldr	r2, [r7, #20]
24003454:	4313      	orrs	r3, r2
24003456:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
24003458:	687b      	ldr	r3, [r7, #4]
2400345a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400345c:	2b04      	cmp	r3, #4
2400345e:	d107      	bne.n	24003470 <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
24003460:	687b      	ldr	r3, [r7, #4]
24003462:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24003464:	687b      	ldr	r3, [r7, #4]
24003466:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24003468:	4313      	orrs	r3, r2
2400346a:	697a      	ldr	r2, [r7, #20]
2400346c:	4313      	orrs	r3, r2
2400346e:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transferring data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
24003470:	4b71      	ldr	r3, [pc, #452]	; (24003638 <HAL_DMA_Init+0x424>)
24003472:	681a      	ldr	r2, [r3, #0]
24003474:	4b71      	ldr	r3, [pc, #452]	; (2400363c <HAL_DMA_Init+0x428>)
24003476:	4013      	ands	r3, r2
24003478:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400347c:	d328      	bcc.n	240034d0 <HAL_DMA_Init+0x2bc>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
2400347e:	687b      	ldr	r3, [r7, #4]
24003480:	685b      	ldr	r3, [r3, #4]
24003482:	2b28      	cmp	r3, #40	; 0x28
24003484:	d903      	bls.n	2400348e <HAL_DMA_Init+0x27a>
24003486:	687b      	ldr	r3, [r7, #4]
24003488:	685b      	ldr	r3, [r3, #4]
2400348a:	2b2e      	cmp	r3, #46	; 0x2e
2400348c:	d917      	bls.n	240034be <HAL_DMA_Init+0x2aa>
2400348e:	687b      	ldr	r3, [r7, #4]
24003490:	685b      	ldr	r3, [r3, #4]
24003492:	2b3e      	cmp	r3, #62	; 0x3e
24003494:	d903      	bls.n	2400349e <HAL_DMA_Init+0x28a>
24003496:	687b      	ldr	r3, [r7, #4]
24003498:	685b      	ldr	r3, [r3, #4]
2400349a:	2b42      	cmp	r3, #66	; 0x42
2400349c:	d90f      	bls.n	240034be <HAL_DMA_Init+0x2aa>
2400349e:	687b      	ldr	r3, [r7, #4]
240034a0:	685b      	ldr	r3, [r3, #4]
240034a2:	2b46      	cmp	r3, #70	; 0x46
240034a4:	d903      	bls.n	240034ae <HAL_DMA_Init+0x29a>
240034a6:	687b      	ldr	r3, [r7, #4]
240034a8:	685b      	ldr	r3, [r3, #4]
240034aa:	2b48      	cmp	r3, #72	; 0x48
240034ac:	d907      	bls.n	240034be <HAL_DMA_Init+0x2aa>
240034ae:	687b      	ldr	r3, [r7, #4]
240034b0:	685b      	ldr	r3, [r3, #4]
240034b2:	2b4e      	cmp	r3, #78	; 0x4e
240034b4:	d905      	bls.n	240034c2 <HAL_DMA_Init+0x2ae>
240034b6:	687b      	ldr	r3, [r7, #4]
240034b8:	685b      	ldr	r3, [r3, #4]
240034ba:	2b52      	cmp	r3, #82	; 0x52
240034bc:	d801      	bhi.n	240034c2 <HAL_DMA_Init+0x2ae>
240034be:	2301      	movs	r3, #1
240034c0:	e000      	b.n	240034c4 <HAL_DMA_Init+0x2b0>
240034c2:	2300      	movs	r3, #0
240034c4:	2b00      	cmp	r3, #0
240034c6:	d003      	beq.n	240034d0 <HAL_DMA_Init+0x2bc>
      {
        registerValue |= DMA_SxCR_TRBUFF;
240034c8:	697b      	ldr	r3, [r7, #20]
240034ca:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
240034ce:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
240034d0:	687b      	ldr	r3, [r7, #4]
240034d2:	681b      	ldr	r3, [r3, #0]
240034d4:	697a      	ldr	r2, [r7, #20]
240034d6:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
240034d8:	687b      	ldr	r3, [r7, #4]
240034da:	681b      	ldr	r3, [r3, #0]
240034dc:	695b      	ldr	r3, [r3, #20]
240034de:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
240034e0:	697b      	ldr	r3, [r7, #20]
240034e2:	f023 0307 	bic.w	r3, r3, #7
240034e6:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
240034e8:	687b      	ldr	r3, [r7, #4]
240034ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240034ec:	697a      	ldr	r2, [r7, #20]
240034ee:	4313      	orrs	r3, r2
240034f0:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
240034f2:	687b      	ldr	r3, [r7, #4]
240034f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240034f6:	2b04      	cmp	r3, #4
240034f8:	d117      	bne.n	2400352a <HAL_DMA_Init+0x316>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
240034fa:	687b      	ldr	r3, [r7, #4]
240034fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240034fe:	697a      	ldr	r2, [r7, #20]
24003500:	4313      	orrs	r3, r2
24003502:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
24003504:	687b      	ldr	r3, [r7, #4]
24003506:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24003508:	2b00      	cmp	r3, #0
2400350a:	d00e      	beq.n	2400352a <HAL_DMA_Init+0x316>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
2400350c:	6878      	ldr	r0, [r7, #4]
2400350e:	f003 fa95 	bl	24006a3c <DMA_CheckFifoParam>
24003512:	4603      	mov	r3, r0
24003514:	2b00      	cmp	r3, #0
24003516:	d008      	beq.n	2400352a <HAL_DMA_Init+0x316>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24003518:	687b      	ldr	r3, [r7, #4]
2400351a:	2240      	movs	r2, #64	; 0x40
2400351c:	655a      	str	r2, [r3, #84]	; 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
2400351e:	687b      	ldr	r3, [r7, #4]
24003520:	2201      	movs	r2, #1
24003522:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          return HAL_ERROR;
24003526:	2301      	movs	r3, #1
24003528:	e197      	b.n	2400385a <HAL_DMA_Init+0x646>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
2400352a:	687b      	ldr	r3, [r7, #4]
2400352c:	681b      	ldr	r3, [r3, #0]
2400352e:	697a      	ldr	r2, [r7, #20]
24003530:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24003532:	6878      	ldr	r0, [r7, #4]
24003534:	f003 f9d0 	bl	240068d8 <DMA_CalcBaseAndBitshift>
24003538:	4603      	mov	r3, r0
2400353a:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400353c:	687b      	ldr	r3, [r7, #4]
2400353e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003540:	f003 031f 	and.w	r3, r3, #31
24003544:	223f      	movs	r2, #63	; 0x3f
24003546:	409a      	lsls	r2, r3
24003548:	68bb      	ldr	r3, [r7, #8]
2400354a:	609a      	str	r2, [r3, #8]
2400354c:	e0cd      	b.n	240036ea <HAL_DMA_Init+0x4d6>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
2400354e:	687b      	ldr	r3, [r7, #4]
24003550:	681b      	ldr	r3, [r3, #0]
24003552:	4a3b      	ldr	r2, [pc, #236]	; (24003640 <HAL_DMA_Init+0x42c>)
24003554:	4293      	cmp	r3, r2
24003556:	d022      	beq.n	2400359e <HAL_DMA_Init+0x38a>
24003558:	687b      	ldr	r3, [r7, #4]
2400355a:	681b      	ldr	r3, [r3, #0]
2400355c:	4a39      	ldr	r2, [pc, #228]	; (24003644 <HAL_DMA_Init+0x430>)
2400355e:	4293      	cmp	r3, r2
24003560:	d01d      	beq.n	2400359e <HAL_DMA_Init+0x38a>
24003562:	687b      	ldr	r3, [r7, #4]
24003564:	681b      	ldr	r3, [r3, #0]
24003566:	4a38      	ldr	r2, [pc, #224]	; (24003648 <HAL_DMA_Init+0x434>)
24003568:	4293      	cmp	r3, r2
2400356a:	d018      	beq.n	2400359e <HAL_DMA_Init+0x38a>
2400356c:	687b      	ldr	r3, [r7, #4]
2400356e:	681b      	ldr	r3, [r3, #0]
24003570:	4a36      	ldr	r2, [pc, #216]	; (2400364c <HAL_DMA_Init+0x438>)
24003572:	4293      	cmp	r3, r2
24003574:	d013      	beq.n	2400359e <HAL_DMA_Init+0x38a>
24003576:	687b      	ldr	r3, [r7, #4]
24003578:	681b      	ldr	r3, [r3, #0]
2400357a:	4a35      	ldr	r2, [pc, #212]	; (24003650 <HAL_DMA_Init+0x43c>)
2400357c:	4293      	cmp	r3, r2
2400357e:	d00e      	beq.n	2400359e <HAL_DMA_Init+0x38a>
24003580:	687b      	ldr	r3, [r7, #4]
24003582:	681b      	ldr	r3, [r3, #0]
24003584:	4a33      	ldr	r2, [pc, #204]	; (24003654 <HAL_DMA_Init+0x440>)
24003586:	4293      	cmp	r3, r2
24003588:	d009      	beq.n	2400359e <HAL_DMA_Init+0x38a>
2400358a:	687b      	ldr	r3, [r7, #4]
2400358c:	681b      	ldr	r3, [r3, #0]
2400358e:	4a32      	ldr	r2, [pc, #200]	; (24003658 <HAL_DMA_Init+0x444>)
24003590:	4293      	cmp	r3, r2
24003592:	d004      	beq.n	2400359e <HAL_DMA_Init+0x38a>
24003594:	687b      	ldr	r3, [r7, #4]
24003596:	681b      	ldr	r3, [r3, #0]
24003598:	4a30      	ldr	r2, [pc, #192]	; (2400365c <HAL_DMA_Init+0x448>)
2400359a:	4293      	cmp	r3, r2
2400359c:	d101      	bne.n	240035a2 <HAL_DMA_Init+0x38e>
2400359e:	2301      	movs	r3, #1
240035a0:	e000      	b.n	240035a4 <HAL_DMA_Init+0x390>
240035a2:	2300      	movs	r3, #0
240035a4:	2b00      	cmp	r3, #0
240035a6:	f000 8097 	beq.w	240036d8 <HAL_DMA_Init+0x4c4>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
240035aa:	687b      	ldr	r3, [r7, #4]
240035ac:	681b      	ldr	r3, [r3, #0]
240035ae:	4a24      	ldr	r2, [pc, #144]	; (24003640 <HAL_DMA_Init+0x42c>)
240035b0:	4293      	cmp	r3, r2
240035b2:	d021      	beq.n	240035f8 <HAL_DMA_Init+0x3e4>
240035b4:	687b      	ldr	r3, [r7, #4]
240035b6:	681b      	ldr	r3, [r3, #0]
240035b8:	4a22      	ldr	r2, [pc, #136]	; (24003644 <HAL_DMA_Init+0x430>)
240035ba:	4293      	cmp	r3, r2
240035bc:	d01c      	beq.n	240035f8 <HAL_DMA_Init+0x3e4>
240035be:	687b      	ldr	r3, [r7, #4]
240035c0:	681b      	ldr	r3, [r3, #0]
240035c2:	4a21      	ldr	r2, [pc, #132]	; (24003648 <HAL_DMA_Init+0x434>)
240035c4:	4293      	cmp	r3, r2
240035c6:	d017      	beq.n	240035f8 <HAL_DMA_Init+0x3e4>
240035c8:	687b      	ldr	r3, [r7, #4]
240035ca:	681b      	ldr	r3, [r3, #0]
240035cc:	4a1f      	ldr	r2, [pc, #124]	; (2400364c <HAL_DMA_Init+0x438>)
240035ce:	4293      	cmp	r3, r2
240035d0:	d012      	beq.n	240035f8 <HAL_DMA_Init+0x3e4>
240035d2:	687b      	ldr	r3, [r7, #4]
240035d4:	681b      	ldr	r3, [r3, #0]
240035d6:	4a1e      	ldr	r2, [pc, #120]	; (24003650 <HAL_DMA_Init+0x43c>)
240035d8:	4293      	cmp	r3, r2
240035da:	d00d      	beq.n	240035f8 <HAL_DMA_Init+0x3e4>
240035dc:	687b      	ldr	r3, [r7, #4]
240035de:	681b      	ldr	r3, [r3, #0]
240035e0:	4a1c      	ldr	r2, [pc, #112]	; (24003654 <HAL_DMA_Init+0x440>)
240035e2:	4293      	cmp	r3, r2
240035e4:	d008      	beq.n	240035f8 <HAL_DMA_Init+0x3e4>
240035e6:	687b      	ldr	r3, [r7, #4]
240035e8:	681b      	ldr	r3, [r3, #0]
240035ea:	4a1b      	ldr	r2, [pc, #108]	; (24003658 <HAL_DMA_Init+0x444>)
240035ec:	4293      	cmp	r3, r2
240035ee:	d003      	beq.n	240035f8 <HAL_DMA_Init+0x3e4>
240035f0:	687b      	ldr	r3, [r7, #4]
240035f2:	681b      	ldr	r3, [r3, #0]
240035f4:	4a19      	ldr	r2, [pc, #100]	; (2400365c <HAL_DMA_Init+0x448>)
240035f6:	4293      	cmp	r3, r2
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
240035f8:	687b      	ldr	r3, [r7, #4]
240035fa:	2202      	movs	r2, #2
240035fc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
24003600:	687b      	ldr	r3, [r7, #4]
24003602:	2200      	movs	r2, #0
24003604:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
24003608:	687b      	ldr	r3, [r7, #4]
2400360a:	681b      	ldr	r3, [r3, #0]
2400360c:	681b      	ldr	r3, [r3, #0]
2400360e:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
24003610:	697a      	ldr	r2, [r7, #20]
24003612:	4b13      	ldr	r3, [pc, #76]	; (24003660 <HAL_DMA_Init+0x44c>)
24003614:	4013      	ands	r3, r2
24003616:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24003618:	687b      	ldr	r3, [r7, #4]
2400361a:	689b      	ldr	r3, [r3, #8]
2400361c:	2b40      	cmp	r3, #64	; 0x40
2400361e:	d021      	beq.n	24003664 <HAL_DMA_Init+0x450>
24003620:	687b      	ldr	r3, [r7, #4]
24003622:	689b      	ldr	r3, [r3, #8]
24003624:	2b80      	cmp	r3, #128	; 0x80
24003626:	d102      	bne.n	2400362e <HAL_DMA_Init+0x41a>
24003628:	f44f 4380 	mov.w	r3, #16384	; 0x4000
2400362c:	e01b      	b.n	24003666 <HAL_DMA_Init+0x452>
2400362e:	2300      	movs	r3, #0
24003630:	e019      	b.n	24003666 <HAL_DMA_Init+0x452>
24003632:	bf00      	nop
24003634:	fe10803f 	.word	0xfe10803f
24003638:	5c001000 	.word	0x5c001000
2400363c:	ffff0000 	.word	0xffff0000
24003640:	58025408 	.word	0x58025408
24003644:	5802541c 	.word	0x5802541c
24003648:	58025430 	.word	0x58025430
2400364c:	58025444 	.word	0x58025444
24003650:	58025458 	.word	0x58025458
24003654:	5802546c 	.word	0x5802546c
24003658:	58025480 	.word	0x58025480
2400365c:	58025494 	.word	0x58025494
24003660:	fffe000f 	.word	0xfffe000f
24003664:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
24003666:	687a      	ldr	r2, [r7, #4]
24003668:	68d2      	ldr	r2, [r2, #12]
2400366a:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
2400366c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
2400366e:	687b      	ldr	r3, [r7, #4]
24003670:	691b      	ldr	r3, [r3, #16]
24003672:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
24003674:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
24003676:	687b      	ldr	r3, [r7, #4]
24003678:	695b      	ldr	r3, [r3, #20]
2400367a:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
2400367c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
2400367e:	687b      	ldr	r3, [r7, #4]
24003680:	699b      	ldr	r3, [r3, #24]
24003682:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
24003684:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
24003686:	687b      	ldr	r3, [r7, #4]
24003688:	69db      	ldr	r3, [r3, #28]
2400368a:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
2400368c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
2400368e:	687b      	ldr	r3, [r7, #4]
24003690:	6a1b      	ldr	r3, [r3, #32]
24003692:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
24003694:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
24003696:	697a      	ldr	r2, [r7, #20]
24003698:	4313      	orrs	r3, r2
2400369a:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
2400369c:	687b      	ldr	r3, [r7, #4]
2400369e:	681b      	ldr	r3, [r3, #0]
240036a0:	697a      	ldr	r2, [r7, #20]
240036a2:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
240036a4:	687b      	ldr	r3, [r7, #4]
240036a6:	681b      	ldr	r3, [r3, #0]
240036a8:	461a      	mov	r2, r3
240036aa:	4b6e      	ldr	r3, [pc, #440]	; (24003864 <HAL_DMA_Init+0x650>)
240036ac:	4413      	add	r3, r2
240036ae:	4a6e      	ldr	r2, [pc, #440]	; (24003868 <HAL_DMA_Init+0x654>)
240036b0:	fba2 2303 	umull	r2, r3, r2, r3
240036b4:	091b      	lsrs	r3, r3, #4
240036b6:	009a      	lsls	r2, r3, #2
240036b8:	687b      	ldr	r3, [r7, #4]
240036ba:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
240036bc:	6878      	ldr	r0, [r7, #4]
240036be:	f003 f90b 	bl	240068d8 <DMA_CalcBaseAndBitshift>
240036c2:	4603      	mov	r3, r0
240036c4:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
240036c6:	687b      	ldr	r3, [r7, #4]
240036c8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240036ca:	f003 031f 	and.w	r3, r3, #31
240036ce:	2201      	movs	r2, #1
240036d0:	409a      	lsls	r2, r3
240036d2:	68fb      	ldr	r3, [r7, #12]
240036d4:	605a      	str	r2, [r3, #4]
240036d6:	e008      	b.n	240036ea <HAL_DMA_Init+0x4d6>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
240036d8:	687b      	ldr	r3, [r7, #4]
240036da:	2240      	movs	r2, #64	; 0x40
240036dc:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
240036de:	687b      	ldr	r3, [r7, #4]
240036e0:	2203      	movs	r2, #3
240036e2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    return HAL_ERROR;
240036e6:	2301      	movs	r3, #1
240036e8:	e0b7      	b.n	2400385a <HAL_DMA_Init+0x646>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240036ea:	687b      	ldr	r3, [r7, #4]
240036ec:	681b      	ldr	r3, [r3, #0]
240036ee:	4a5f      	ldr	r2, [pc, #380]	; (2400386c <HAL_DMA_Init+0x658>)
240036f0:	4293      	cmp	r3, r2
240036f2:	d072      	beq.n	240037da <HAL_DMA_Init+0x5c6>
240036f4:	687b      	ldr	r3, [r7, #4]
240036f6:	681b      	ldr	r3, [r3, #0]
240036f8:	4a5d      	ldr	r2, [pc, #372]	; (24003870 <HAL_DMA_Init+0x65c>)
240036fa:	4293      	cmp	r3, r2
240036fc:	d06d      	beq.n	240037da <HAL_DMA_Init+0x5c6>
240036fe:	687b      	ldr	r3, [r7, #4]
24003700:	681b      	ldr	r3, [r3, #0]
24003702:	4a5c      	ldr	r2, [pc, #368]	; (24003874 <HAL_DMA_Init+0x660>)
24003704:	4293      	cmp	r3, r2
24003706:	d068      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003708:	687b      	ldr	r3, [r7, #4]
2400370a:	681b      	ldr	r3, [r3, #0]
2400370c:	4a5a      	ldr	r2, [pc, #360]	; (24003878 <HAL_DMA_Init+0x664>)
2400370e:	4293      	cmp	r3, r2
24003710:	d063      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003712:	687b      	ldr	r3, [r7, #4]
24003714:	681b      	ldr	r3, [r3, #0]
24003716:	4a59      	ldr	r2, [pc, #356]	; (2400387c <HAL_DMA_Init+0x668>)
24003718:	4293      	cmp	r3, r2
2400371a:	d05e      	beq.n	240037da <HAL_DMA_Init+0x5c6>
2400371c:	687b      	ldr	r3, [r7, #4]
2400371e:	681b      	ldr	r3, [r3, #0]
24003720:	4a57      	ldr	r2, [pc, #348]	; (24003880 <HAL_DMA_Init+0x66c>)
24003722:	4293      	cmp	r3, r2
24003724:	d059      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003726:	687b      	ldr	r3, [r7, #4]
24003728:	681b      	ldr	r3, [r3, #0]
2400372a:	4a56      	ldr	r2, [pc, #344]	; (24003884 <HAL_DMA_Init+0x670>)
2400372c:	4293      	cmp	r3, r2
2400372e:	d054      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003730:	687b      	ldr	r3, [r7, #4]
24003732:	681b      	ldr	r3, [r3, #0]
24003734:	4a54      	ldr	r2, [pc, #336]	; (24003888 <HAL_DMA_Init+0x674>)
24003736:	4293      	cmp	r3, r2
24003738:	d04f      	beq.n	240037da <HAL_DMA_Init+0x5c6>
2400373a:	687b      	ldr	r3, [r7, #4]
2400373c:	681b      	ldr	r3, [r3, #0]
2400373e:	4a53      	ldr	r2, [pc, #332]	; (2400388c <HAL_DMA_Init+0x678>)
24003740:	4293      	cmp	r3, r2
24003742:	d04a      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003744:	687b      	ldr	r3, [r7, #4]
24003746:	681b      	ldr	r3, [r3, #0]
24003748:	4a51      	ldr	r2, [pc, #324]	; (24003890 <HAL_DMA_Init+0x67c>)
2400374a:	4293      	cmp	r3, r2
2400374c:	d045      	beq.n	240037da <HAL_DMA_Init+0x5c6>
2400374e:	687b      	ldr	r3, [r7, #4]
24003750:	681b      	ldr	r3, [r3, #0]
24003752:	4a50      	ldr	r2, [pc, #320]	; (24003894 <HAL_DMA_Init+0x680>)
24003754:	4293      	cmp	r3, r2
24003756:	d040      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003758:	687b      	ldr	r3, [r7, #4]
2400375a:	681b      	ldr	r3, [r3, #0]
2400375c:	4a4e      	ldr	r2, [pc, #312]	; (24003898 <HAL_DMA_Init+0x684>)
2400375e:	4293      	cmp	r3, r2
24003760:	d03b      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003762:	687b      	ldr	r3, [r7, #4]
24003764:	681b      	ldr	r3, [r3, #0]
24003766:	4a4d      	ldr	r2, [pc, #308]	; (2400389c <HAL_DMA_Init+0x688>)
24003768:	4293      	cmp	r3, r2
2400376a:	d036      	beq.n	240037da <HAL_DMA_Init+0x5c6>
2400376c:	687b      	ldr	r3, [r7, #4]
2400376e:	681b      	ldr	r3, [r3, #0]
24003770:	4a4b      	ldr	r2, [pc, #300]	; (240038a0 <HAL_DMA_Init+0x68c>)
24003772:	4293      	cmp	r3, r2
24003774:	d031      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003776:	687b      	ldr	r3, [r7, #4]
24003778:	681b      	ldr	r3, [r3, #0]
2400377a:	4a4a      	ldr	r2, [pc, #296]	; (240038a4 <HAL_DMA_Init+0x690>)
2400377c:	4293      	cmp	r3, r2
2400377e:	d02c      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003780:	687b      	ldr	r3, [r7, #4]
24003782:	681b      	ldr	r3, [r3, #0]
24003784:	4a48      	ldr	r2, [pc, #288]	; (240038a8 <HAL_DMA_Init+0x694>)
24003786:	4293      	cmp	r3, r2
24003788:	d027      	beq.n	240037da <HAL_DMA_Init+0x5c6>
2400378a:	687b      	ldr	r3, [r7, #4]
2400378c:	681b      	ldr	r3, [r3, #0]
2400378e:	4a47      	ldr	r2, [pc, #284]	; (240038ac <HAL_DMA_Init+0x698>)
24003790:	4293      	cmp	r3, r2
24003792:	d022      	beq.n	240037da <HAL_DMA_Init+0x5c6>
24003794:	687b      	ldr	r3, [r7, #4]
24003796:	681b      	ldr	r3, [r3, #0]
24003798:	4a45      	ldr	r2, [pc, #276]	; (240038b0 <HAL_DMA_Init+0x69c>)
2400379a:	4293      	cmp	r3, r2
2400379c:	d01d      	beq.n	240037da <HAL_DMA_Init+0x5c6>
2400379e:	687b      	ldr	r3, [r7, #4]
240037a0:	681b      	ldr	r3, [r3, #0]
240037a2:	4a44      	ldr	r2, [pc, #272]	; (240038b4 <HAL_DMA_Init+0x6a0>)
240037a4:	4293      	cmp	r3, r2
240037a6:	d018      	beq.n	240037da <HAL_DMA_Init+0x5c6>
240037a8:	687b      	ldr	r3, [r7, #4]
240037aa:	681b      	ldr	r3, [r3, #0]
240037ac:	4a42      	ldr	r2, [pc, #264]	; (240038b8 <HAL_DMA_Init+0x6a4>)
240037ae:	4293      	cmp	r3, r2
240037b0:	d013      	beq.n	240037da <HAL_DMA_Init+0x5c6>
240037b2:	687b      	ldr	r3, [r7, #4]
240037b4:	681b      	ldr	r3, [r3, #0]
240037b6:	4a41      	ldr	r2, [pc, #260]	; (240038bc <HAL_DMA_Init+0x6a8>)
240037b8:	4293      	cmp	r3, r2
240037ba:	d00e      	beq.n	240037da <HAL_DMA_Init+0x5c6>
240037bc:	687b      	ldr	r3, [r7, #4]
240037be:	681b      	ldr	r3, [r3, #0]
240037c0:	4a3f      	ldr	r2, [pc, #252]	; (240038c0 <HAL_DMA_Init+0x6ac>)
240037c2:	4293      	cmp	r3, r2
240037c4:	d009      	beq.n	240037da <HAL_DMA_Init+0x5c6>
240037c6:	687b      	ldr	r3, [r7, #4]
240037c8:	681b      	ldr	r3, [r3, #0]
240037ca:	4a3e      	ldr	r2, [pc, #248]	; (240038c4 <HAL_DMA_Init+0x6b0>)
240037cc:	4293      	cmp	r3, r2
240037ce:	d004      	beq.n	240037da <HAL_DMA_Init+0x5c6>
240037d0:	687b      	ldr	r3, [r7, #4]
240037d2:	681b      	ldr	r3, [r3, #0]
240037d4:	4a3c      	ldr	r2, [pc, #240]	; (240038c8 <HAL_DMA_Init+0x6b4>)
240037d6:	4293      	cmp	r3, r2
240037d8:	d101      	bne.n	240037de <HAL_DMA_Init+0x5ca>
240037da:	2301      	movs	r3, #1
240037dc:	e000      	b.n	240037e0 <HAL_DMA_Init+0x5cc>
240037de:	2300      	movs	r3, #0
240037e0:	2b00      	cmp	r3, #0
240037e2:	d032      	beq.n	2400384a <HAL_DMA_Init+0x636>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
240037e4:	6878      	ldr	r0, [r7, #4]
240037e6:	f003 f9a5 	bl	24006b34 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
240037ea:	687b      	ldr	r3, [r7, #4]
240037ec:	689b      	ldr	r3, [r3, #8]
240037ee:	2b80      	cmp	r3, #128	; 0x80
240037f0:	d102      	bne.n	240037f8 <HAL_DMA_Init+0x5e4>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
240037f2:	687b      	ldr	r3, [r7, #4]
240037f4:	2200      	movs	r2, #0
240037f6:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
240037f8:	687b      	ldr	r3, [r7, #4]
240037fa:	685a      	ldr	r2, [r3, #4]
240037fc:	687b      	ldr	r3, [r7, #4]
240037fe:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003800:	b2d2      	uxtb	r2, r2
24003802:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24003804:	687b      	ldr	r3, [r7, #4]
24003806:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24003808:	687a      	ldr	r2, [r7, #4]
2400380a:	6e92      	ldr	r2, [r2, #104]	; 0x68
2400380c:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
2400380e:	687b      	ldr	r3, [r7, #4]
24003810:	685b      	ldr	r3, [r3, #4]
24003812:	2b00      	cmp	r3, #0
24003814:	d010      	beq.n	24003838 <HAL_DMA_Init+0x624>
24003816:	687b      	ldr	r3, [r7, #4]
24003818:	685b      	ldr	r3, [r3, #4]
2400381a:	2b08      	cmp	r3, #8
2400381c:	d80c      	bhi.n	24003838 <HAL_DMA_Init+0x624>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
2400381e:	6878      	ldr	r0, [r7, #4]
24003820:	f003 fa22 	bl	24006c68 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
24003824:	687b      	ldr	r3, [r7, #4]
24003826:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003828:	2200      	movs	r2, #0
2400382a:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
2400382c:	687b      	ldr	r3, [r7, #4]
2400382e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003830:	687a      	ldr	r2, [r7, #4]
24003832:	6f52      	ldr	r2, [r2, #116]	; 0x74
24003834:	605a      	str	r2, [r3, #4]
24003836:	e008      	b.n	2400384a <HAL_DMA_Init+0x636>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
24003838:	687b      	ldr	r3, [r7, #4]
2400383a:	2200      	movs	r2, #0
2400383c:	66da      	str	r2, [r3, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
2400383e:	687b      	ldr	r3, [r7, #4]
24003840:	2200      	movs	r2, #0
24003842:	671a      	str	r2, [r3, #112]	; 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
24003844:	687b      	ldr	r3, [r7, #4]
24003846:	2200      	movs	r2, #0
24003848:	675a      	str	r2, [r3, #116]	; 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
2400384a:	687b      	ldr	r3, [r7, #4]
2400384c:	2200      	movs	r2, #0
2400384e:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
24003850:	687b      	ldr	r3, [r7, #4]
24003852:	2201      	movs	r2, #1
24003854:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
24003858:	2300      	movs	r3, #0
}
2400385a:	4618      	mov	r0, r3
2400385c:	3718      	adds	r7, #24
2400385e:	46bd      	mov	sp, r7
24003860:	bd80      	pop	{r7, pc}
24003862:	bf00      	nop
24003864:	a7fdabf8 	.word	0xa7fdabf8
24003868:	cccccccd 	.word	0xcccccccd
2400386c:	40020010 	.word	0x40020010
24003870:	40020028 	.word	0x40020028
24003874:	40020040 	.word	0x40020040
24003878:	40020058 	.word	0x40020058
2400387c:	40020070 	.word	0x40020070
24003880:	40020088 	.word	0x40020088
24003884:	400200a0 	.word	0x400200a0
24003888:	400200b8 	.word	0x400200b8
2400388c:	40020410 	.word	0x40020410
24003890:	40020428 	.word	0x40020428
24003894:	40020440 	.word	0x40020440
24003898:	40020458 	.word	0x40020458
2400389c:	40020470 	.word	0x40020470
240038a0:	40020488 	.word	0x40020488
240038a4:	400204a0 	.word	0x400204a0
240038a8:	400204b8 	.word	0x400204b8
240038ac:	58025408 	.word	0x58025408
240038b0:	5802541c 	.word	0x5802541c
240038b4:	58025430 	.word	0x58025430
240038b8:	58025444 	.word	0x58025444
240038bc:	58025458 	.word	0x58025458
240038c0:	5802546c 	.word	0x5802546c
240038c4:	58025480 	.word	0x58025480
240038c8:	58025494 	.word	0x58025494

240038cc <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
240038cc:	b580      	push	{r7, lr}
240038ce:	b084      	sub	sp, #16
240038d0:	af00      	add	r7, sp, #0
240038d2:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
240038d4:	687b      	ldr	r3, [r7, #4]
240038d6:	2b00      	cmp	r3, #0
240038d8:	d101      	bne.n	240038de <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
240038da:	2301      	movs	r3, #1
240038dc:	e1a8      	b.n	24003c30 <HAL_DMA_DeInit+0x364>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
240038de:	687b      	ldr	r3, [r7, #4]
240038e0:	681b      	ldr	r3, [r3, #0]
240038e2:	4a82      	ldr	r2, [pc, #520]	; (24003aec <HAL_DMA_DeInit+0x220>)
240038e4:	4293      	cmp	r3, r2
240038e6:	d04a      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
240038e8:	687b      	ldr	r3, [r7, #4]
240038ea:	681b      	ldr	r3, [r3, #0]
240038ec:	4a80      	ldr	r2, [pc, #512]	; (24003af0 <HAL_DMA_DeInit+0x224>)
240038ee:	4293      	cmp	r3, r2
240038f0:	d045      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
240038f2:	687b      	ldr	r3, [r7, #4]
240038f4:	681b      	ldr	r3, [r3, #0]
240038f6:	4a7f      	ldr	r2, [pc, #508]	; (24003af4 <HAL_DMA_DeInit+0x228>)
240038f8:	4293      	cmp	r3, r2
240038fa:	d040      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
240038fc:	687b      	ldr	r3, [r7, #4]
240038fe:	681b      	ldr	r3, [r3, #0]
24003900:	4a7d      	ldr	r2, [pc, #500]	; (24003af8 <HAL_DMA_DeInit+0x22c>)
24003902:	4293      	cmp	r3, r2
24003904:	d03b      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003906:	687b      	ldr	r3, [r7, #4]
24003908:	681b      	ldr	r3, [r3, #0]
2400390a:	4a7c      	ldr	r2, [pc, #496]	; (24003afc <HAL_DMA_DeInit+0x230>)
2400390c:	4293      	cmp	r3, r2
2400390e:	d036      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003910:	687b      	ldr	r3, [r7, #4]
24003912:	681b      	ldr	r3, [r3, #0]
24003914:	4a7a      	ldr	r2, [pc, #488]	; (24003b00 <HAL_DMA_DeInit+0x234>)
24003916:	4293      	cmp	r3, r2
24003918:	d031      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
2400391a:	687b      	ldr	r3, [r7, #4]
2400391c:	681b      	ldr	r3, [r3, #0]
2400391e:	4a79      	ldr	r2, [pc, #484]	; (24003b04 <HAL_DMA_DeInit+0x238>)
24003920:	4293      	cmp	r3, r2
24003922:	d02c      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003924:	687b      	ldr	r3, [r7, #4]
24003926:	681b      	ldr	r3, [r3, #0]
24003928:	4a77      	ldr	r2, [pc, #476]	; (24003b08 <HAL_DMA_DeInit+0x23c>)
2400392a:	4293      	cmp	r3, r2
2400392c:	d027      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
2400392e:	687b      	ldr	r3, [r7, #4]
24003930:	681b      	ldr	r3, [r3, #0]
24003932:	4a76      	ldr	r2, [pc, #472]	; (24003b0c <HAL_DMA_DeInit+0x240>)
24003934:	4293      	cmp	r3, r2
24003936:	d022      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003938:	687b      	ldr	r3, [r7, #4]
2400393a:	681b      	ldr	r3, [r3, #0]
2400393c:	4a74      	ldr	r2, [pc, #464]	; (24003b10 <HAL_DMA_DeInit+0x244>)
2400393e:	4293      	cmp	r3, r2
24003940:	d01d      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003942:	687b      	ldr	r3, [r7, #4]
24003944:	681b      	ldr	r3, [r3, #0]
24003946:	4a73      	ldr	r2, [pc, #460]	; (24003b14 <HAL_DMA_DeInit+0x248>)
24003948:	4293      	cmp	r3, r2
2400394a:	d018      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
2400394c:	687b      	ldr	r3, [r7, #4]
2400394e:	681b      	ldr	r3, [r3, #0]
24003950:	4a71      	ldr	r2, [pc, #452]	; (24003b18 <HAL_DMA_DeInit+0x24c>)
24003952:	4293      	cmp	r3, r2
24003954:	d013      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003956:	687b      	ldr	r3, [r7, #4]
24003958:	681b      	ldr	r3, [r3, #0]
2400395a:	4a70      	ldr	r2, [pc, #448]	; (24003b1c <HAL_DMA_DeInit+0x250>)
2400395c:	4293      	cmp	r3, r2
2400395e:	d00e      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003960:	687b      	ldr	r3, [r7, #4]
24003962:	681b      	ldr	r3, [r3, #0]
24003964:	4a6e      	ldr	r2, [pc, #440]	; (24003b20 <HAL_DMA_DeInit+0x254>)
24003966:	4293      	cmp	r3, r2
24003968:	d009      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
2400396a:	687b      	ldr	r3, [r7, #4]
2400396c:	681b      	ldr	r3, [r3, #0]
2400396e:	4a6d      	ldr	r2, [pc, #436]	; (24003b24 <HAL_DMA_DeInit+0x258>)
24003970:	4293      	cmp	r3, r2
24003972:	d004      	beq.n	2400397e <HAL_DMA_DeInit+0xb2>
24003974:	687b      	ldr	r3, [r7, #4]
24003976:	681b      	ldr	r3, [r3, #0]
24003978:	4a6b      	ldr	r2, [pc, #428]	; (24003b28 <HAL_DMA_DeInit+0x25c>)
2400397a:	4293      	cmp	r3, r2
2400397c:	d108      	bne.n	24003990 <HAL_DMA_DeInit+0xc4>
2400397e:	687b      	ldr	r3, [r7, #4]
24003980:	681b      	ldr	r3, [r3, #0]
24003982:	681a      	ldr	r2, [r3, #0]
24003984:	687b      	ldr	r3, [r7, #4]
24003986:	681b      	ldr	r3, [r3, #0]
24003988:	f022 0201 	bic.w	r2, r2, #1
2400398c:	601a      	str	r2, [r3, #0]
2400398e:	e007      	b.n	240039a0 <HAL_DMA_DeInit+0xd4>
24003990:	687b      	ldr	r3, [r7, #4]
24003992:	681b      	ldr	r3, [r3, #0]
24003994:	681a      	ldr	r2, [r3, #0]
24003996:	687b      	ldr	r3, [r7, #4]
24003998:	681b      	ldr	r3, [r3, #0]
2400399a:	f022 0201 	bic.w	r2, r2, #1
2400399e:	601a      	str	r2, [r3, #0]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240039a0:	687b      	ldr	r3, [r7, #4]
240039a2:	681b      	ldr	r3, [r3, #0]
240039a4:	4a51      	ldr	r2, [pc, #324]	; (24003aec <HAL_DMA_DeInit+0x220>)
240039a6:	4293      	cmp	r3, r2
240039a8:	d04a      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039aa:	687b      	ldr	r3, [r7, #4]
240039ac:	681b      	ldr	r3, [r3, #0]
240039ae:	4a50      	ldr	r2, [pc, #320]	; (24003af0 <HAL_DMA_DeInit+0x224>)
240039b0:	4293      	cmp	r3, r2
240039b2:	d045      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039b4:	687b      	ldr	r3, [r7, #4]
240039b6:	681b      	ldr	r3, [r3, #0]
240039b8:	4a4e      	ldr	r2, [pc, #312]	; (24003af4 <HAL_DMA_DeInit+0x228>)
240039ba:	4293      	cmp	r3, r2
240039bc:	d040      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039be:	687b      	ldr	r3, [r7, #4]
240039c0:	681b      	ldr	r3, [r3, #0]
240039c2:	4a4d      	ldr	r2, [pc, #308]	; (24003af8 <HAL_DMA_DeInit+0x22c>)
240039c4:	4293      	cmp	r3, r2
240039c6:	d03b      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039c8:	687b      	ldr	r3, [r7, #4]
240039ca:	681b      	ldr	r3, [r3, #0]
240039cc:	4a4b      	ldr	r2, [pc, #300]	; (24003afc <HAL_DMA_DeInit+0x230>)
240039ce:	4293      	cmp	r3, r2
240039d0:	d036      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039d2:	687b      	ldr	r3, [r7, #4]
240039d4:	681b      	ldr	r3, [r3, #0]
240039d6:	4a4a      	ldr	r2, [pc, #296]	; (24003b00 <HAL_DMA_DeInit+0x234>)
240039d8:	4293      	cmp	r3, r2
240039da:	d031      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039dc:	687b      	ldr	r3, [r7, #4]
240039de:	681b      	ldr	r3, [r3, #0]
240039e0:	4a48      	ldr	r2, [pc, #288]	; (24003b04 <HAL_DMA_DeInit+0x238>)
240039e2:	4293      	cmp	r3, r2
240039e4:	d02c      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039e6:	687b      	ldr	r3, [r7, #4]
240039e8:	681b      	ldr	r3, [r3, #0]
240039ea:	4a47      	ldr	r2, [pc, #284]	; (24003b08 <HAL_DMA_DeInit+0x23c>)
240039ec:	4293      	cmp	r3, r2
240039ee:	d027      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039f0:	687b      	ldr	r3, [r7, #4]
240039f2:	681b      	ldr	r3, [r3, #0]
240039f4:	4a45      	ldr	r2, [pc, #276]	; (24003b0c <HAL_DMA_DeInit+0x240>)
240039f6:	4293      	cmp	r3, r2
240039f8:	d022      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
240039fa:	687b      	ldr	r3, [r7, #4]
240039fc:	681b      	ldr	r3, [r3, #0]
240039fe:	4a44      	ldr	r2, [pc, #272]	; (24003b10 <HAL_DMA_DeInit+0x244>)
24003a00:	4293      	cmp	r3, r2
24003a02:	d01d      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
24003a04:	687b      	ldr	r3, [r7, #4]
24003a06:	681b      	ldr	r3, [r3, #0]
24003a08:	4a42      	ldr	r2, [pc, #264]	; (24003b14 <HAL_DMA_DeInit+0x248>)
24003a0a:	4293      	cmp	r3, r2
24003a0c:	d018      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
24003a0e:	687b      	ldr	r3, [r7, #4]
24003a10:	681b      	ldr	r3, [r3, #0]
24003a12:	4a41      	ldr	r2, [pc, #260]	; (24003b18 <HAL_DMA_DeInit+0x24c>)
24003a14:	4293      	cmp	r3, r2
24003a16:	d013      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
24003a18:	687b      	ldr	r3, [r7, #4]
24003a1a:	681b      	ldr	r3, [r3, #0]
24003a1c:	4a3f      	ldr	r2, [pc, #252]	; (24003b1c <HAL_DMA_DeInit+0x250>)
24003a1e:	4293      	cmp	r3, r2
24003a20:	d00e      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
24003a22:	687b      	ldr	r3, [r7, #4]
24003a24:	681b      	ldr	r3, [r3, #0]
24003a26:	4a3e      	ldr	r2, [pc, #248]	; (24003b20 <HAL_DMA_DeInit+0x254>)
24003a28:	4293      	cmp	r3, r2
24003a2a:	d009      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
24003a2c:	687b      	ldr	r3, [r7, #4]
24003a2e:	681b      	ldr	r3, [r3, #0]
24003a30:	4a3c      	ldr	r2, [pc, #240]	; (24003b24 <HAL_DMA_DeInit+0x258>)
24003a32:	4293      	cmp	r3, r2
24003a34:	d004      	beq.n	24003a40 <HAL_DMA_DeInit+0x174>
24003a36:	687b      	ldr	r3, [r7, #4]
24003a38:	681b      	ldr	r3, [r3, #0]
24003a3a:	4a3b      	ldr	r2, [pc, #236]	; (24003b28 <HAL_DMA_DeInit+0x25c>)
24003a3c:	4293      	cmp	r3, r2
24003a3e:	d101      	bne.n	24003a44 <HAL_DMA_DeInit+0x178>
24003a40:	2301      	movs	r3, #1
24003a42:	e000      	b.n	24003a46 <HAL_DMA_DeInit+0x17a>
24003a44:	2300      	movs	r3, #0
24003a46:	2b00      	cmp	r3, #0
24003a48:	d025      	beq.n	24003a96 <HAL_DMA_DeInit+0x1ca>
  {
    /* Reset DMA Streamx control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
24003a4a:	687b      	ldr	r3, [r7, #4]
24003a4c:	681b      	ldr	r3, [r3, #0]
24003a4e:	2200      	movs	r2, #0
24003a50:	601a      	str	r2, [r3, #0]

    /* Reset DMA Streamx number of data to transfer register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
24003a52:	687b      	ldr	r3, [r7, #4]
24003a54:	681b      	ldr	r3, [r3, #0]
24003a56:	2200      	movs	r2, #0
24003a58:	605a      	str	r2, [r3, #4]

    /* Reset DMA Streamx peripheral address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
24003a5a:	687b      	ldr	r3, [r7, #4]
24003a5c:	681b      	ldr	r3, [r3, #0]
24003a5e:	2200      	movs	r2, #0
24003a60:	609a      	str	r2, [r3, #8]

    /* Reset DMA Streamx memory 0 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
24003a62:	687b      	ldr	r3, [r7, #4]
24003a64:	681b      	ldr	r3, [r3, #0]
24003a66:	2200      	movs	r2, #0
24003a68:	60da      	str	r2, [r3, #12]

    /* Reset DMA Streamx memory 1 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
24003a6a:	687b      	ldr	r3, [r7, #4]
24003a6c:	681b      	ldr	r3, [r3, #0]
24003a6e:	2200      	movs	r2, #0
24003a70:	611a      	str	r2, [r3, #16]

    /* Reset DMA Streamx FIFO control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
24003a72:	687b      	ldr	r3, [r7, #4]
24003a74:	681b      	ldr	r3, [r3, #0]
24003a76:	2221      	movs	r2, #33	; 0x21
24003a78:	615a      	str	r2, [r3, #20]

    /* Get DMA steam Base Address */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24003a7a:	6878      	ldr	r0, [r7, #4]
24003a7c:	f002 ff2c 	bl	240068d8 <DMA_CalcBaseAndBitshift>
24003a80:	4603      	mov	r3, r0
24003a82:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24003a84:	687b      	ldr	r3, [r7, #4]
24003a86:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003a88:	f003 031f 	and.w	r3, r3, #31
24003a8c:	223f      	movs	r2, #63	; 0x3f
24003a8e:	409a      	lsls	r2, r3
24003a90:	68bb      	ldr	r3, [r7, #8]
24003a92:	609a      	str	r2, [r3, #8]
24003a94:	e081      	b.n	24003b9a <HAL_DMA_DeInit+0x2ce>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
24003a96:	687b      	ldr	r3, [r7, #4]
24003a98:	681b      	ldr	r3, [r3, #0]
24003a9a:	4a24      	ldr	r2, [pc, #144]	; (24003b2c <HAL_DMA_DeInit+0x260>)
24003a9c:	4293      	cmp	r3, r2
24003a9e:	d022      	beq.n	24003ae6 <HAL_DMA_DeInit+0x21a>
24003aa0:	687b      	ldr	r3, [r7, #4]
24003aa2:	681b      	ldr	r3, [r3, #0]
24003aa4:	4a22      	ldr	r2, [pc, #136]	; (24003b30 <HAL_DMA_DeInit+0x264>)
24003aa6:	4293      	cmp	r3, r2
24003aa8:	d01d      	beq.n	24003ae6 <HAL_DMA_DeInit+0x21a>
24003aaa:	687b      	ldr	r3, [r7, #4]
24003aac:	681b      	ldr	r3, [r3, #0]
24003aae:	4a21      	ldr	r2, [pc, #132]	; (24003b34 <HAL_DMA_DeInit+0x268>)
24003ab0:	4293      	cmp	r3, r2
24003ab2:	d018      	beq.n	24003ae6 <HAL_DMA_DeInit+0x21a>
24003ab4:	687b      	ldr	r3, [r7, #4]
24003ab6:	681b      	ldr	r3, [r3, #0]
24003ab8:	4a1f      	ldr	r2, [pc, #124]	; (24003b38 <HAL_DMA_DeInit+0x26c>)
24003aba:	4293      	cmp	r3, r2
24003abc:	d013      	beq.n	24003ae6 <HAL_DMA_DeInit+0x21a>
24003abe:	687b      	ldr	r3, [r7, #4]
24003ac0:	681b      	ldr	r3, [r3, #0]
24003ac2:	4a1e      	ldr	r2, [pc, #120]	; (24003b3c <HAL_DMA_DeInit+0x270>)
24003ac4:	4293      	cmp	r3, r2
24003ac6:	d00e      	beq.n	24003ae6 <HAL_DMA_DeInit+0x21a>
24003ac8:	687b      	ldr	r3, [r7, #4]
24003aca:	681b      	ldr	r3, [r3, #0]
24003acc:	4a1c      	ldr	r2, [pc, #112]	; (24003b40 <HAL_DMA_DeInit+0x274>)
24003ace:	4293      	cmp	r3, r2
24003ad0:	d009      	beq.n	24003ae6 <HAL_DMA_DeInit+0x21a>
24003ad2:	687b      	ldr	r3, [r7, #4]
24003ad4:	681b      	ldr	r3, [r3, #0]
24003ad6:	4a1b      	ldr	r2, [pc, #108]	; (24003b44 <HAL_DMA_DeInit+0x278>)
24003ad8:	4293      	cmp	r3, r2
24003ada:	d004      	beq.n	24003ae6 <HAL_DMA_DeInit+0x21a>
24003adc:	687b      	ldr	r3, [r7, #4]
24003ade:	681b      	ldr	r3, [r3, #0]
24003ae0:	4a19      	ldr	r2, [pc, #100]	; (24003b48 <HAL_DMA_DeInit+0x27c>)
24003ae2:	4293      	cmp	r3, r2
24003ae4:	d132      	bne.n	24003b4c <HAL_DMA_DeInit+0x280>
24003ae6:	2301      	movs	r3, #1
24003ae8:	e031      	b.n	24003b4e <HAL_DMA_DeInit+0x282>
24003aea:	bf00      	nop
24003aec:	40020010 	.word	0x40020010
24003af0:	40020028 	.word	0x40020028
24003af4:	40020040 	.word	0x40020040
24003af8:	40020058 	.word	0x40020058
24003afc:	40020070 	.word	0x40020070
24003b00:	40020088 	.word	0x40020088
24003b04:	400200a0 	.word	0x400200a0
24003b08:	400200b8 	.word	0x400200b8
24003b0c:	40020410 	.word	0x40020410
24003b10:	40020428 	.word	0x40020428
24003b14:	40020440 	.word	0x40020440
24003b18:	40020458 	.word	0x40020458
24003b1c:	40020470 	.word	0x40020470
24003b20:	40020488 	.word	0x40020488
24003b24:	400204a0 	.word	0x400204a0
24003b28:	400204b8 	.word	0x400204b8
24003b2c:	58025408 	.word	0x58025408
24003b30:	5802541c 	.word	0x5802541c
24003b34:	58025430 	.word	0x58025430
24003b38:	58025444 	.word	0x58025444
24003b3c:	58025458 	.word	0x58025458
24003b40:	5802546c 	.word	0x5802546c
24003b44:	58025480 	.word	0x58025480
24003b48:	58025494 	.word	0x58025494
24003b4c:	2300      	movs	r3, #0
24003b4e:	2b00      	cmp	r3, #0
24003b50:	d021      	beq.n	24003b96 <HAL_DMA_DeInit+0x2ca>
  {
    /* Reset DMA Channel control register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
24003b52:	687b      	ldr	r3, [r7, #4]
24003b54:	681b      	ldr	r3, [r3, #0]
24003b56:	2200      	movs	r2, #0
24003b58:	601a      	str	r2, [r3, #0]

    /* Reset DMA Channel Number of Data to Transfer register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
24003b5a:	687b      	ldr	r3, [r7, #4]
24003b5c:	681b      	ldr	r3, [r3, #0]
24003b5e:	2200      	movs	r2, #0
24003b60:	605a      	str	r2, [r3, #4]

    /* Reset DMA Channel peripheral address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
24003b62:	687b      	ldr	r3, [r7, #4]
24003b64:	681b      	ldr	r3, [r3, #0]
24003b66:	2200      	movs	r2, #0
24003b68:	609a      	str	r2, [r3, #8]

    /* Reset DMA Channel memory 0 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
24003b6a:	687b      	ldr	r3, [r7, #4]
24003b6c:	681b      	ldr	r3, [r3, #0]
24003b6e:	2200      	movs	r2, #0
24003b70:	60da      	str	r2, [r3, #12]

    /* Reset DMA Channel memory 1 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
24003b72:	687b      	ldr	r3, [r7, #4]
24003b74:	681b      	ldr	r3, [r3, #0]
24003b76:	2200      	movs	r2, #0
24003b78:	611a      	str	r2, [r3, #16]

    /* Get DMA steam Base Address */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
24003b7a:	6878      	ldr	r0, [r7, #4]
24003b7c:	f002 feac 	bl	240068d8 <DMA_CalcBaseAndBitshift>
24003b80:	4603      	mov	r3, r0
24003b82:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags at correct offset within the register */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24003b84:	687b      	ldr	r3, [r7, #4]
24003b86:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24003b88:	f003 031f 	and.w	r3, r3, #31
24003b8c:	2201      	movs	r2, #1
24003b8e:	409a      	lsls	r2, r3
24003b90:	68fb      	ldr	r3, [r7, #12]
24003b92:	605a      	str	r2, [r3, #4]
24003b94:	e001      	b.n	24003b9a <HAL_DMA_DeInit+0x2ce>
  }
  else
  {
    /* Return error status */
    return HAL_ERROR;
24003b96:	2301      	movs	r3, #1
24003b98:	e04a      	b.n	24003c30 <HAL_DMA_DeInit+0x364>
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
#endif /* BDMA1 */
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
24003b9a:	6878      	ldr	r0, [r7, #4]
24003b9c:	f002 ffca 	bl	24006b34 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->DMAmuxChannel != 0U)
24003ba0:	687b      	ldr	r3, [r7, #4]
24003ba2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003ba4:	2b00      	cmp	r3, #0
24003ba6:	d008      	beq.n	24003bba <HAL_DMA_DeInit+0x2ee>
    {
      /* Resett he DMAMUX channel that corresponds to the DMA stream */
      hdma->DMAmuxChannel->CCR = 0U;
24003ba8:	687b      	ldr	r3, [r7, #4]
24003baa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24003bac:	2200      	movs	r2, #0
24003bae:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24003bb0:	687b      	ldr	r3, [r7, #4]
24003bb2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24003bb4:	687a      	ldr	r2, [r7, #4]
24003bb6:	6e92      	ldr	r2, [r2, #104]	; 0x68
24003bb8:	605a      	str	r2, [r3, #4]
    }

    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
24003bba:	687b      	ldr	r3, [r7, #4]
24003bbc:	685b      	ldr	r3, [r3, #4]
24003bbe:	2b00      	cmp	r3, #0
24003bc0:	d00f      	beq.n	24003be2 <HAL_DMA_DeInit+0x316>
24003bc2:	687b      	ldr	r3, [r7, #4]
24003bc4:	685b      	ldr	r3, [r3, #4]
24003bc6:	2b08      	cmp	r3, #8
24003bc8:	d80b      	bhi.n	24003be2 <HAL_DMA_DeInit+0x316>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
24003bca:	6878      	ldr	r0, [r7, #4]
24003bcc:	f003 f84c 	bl	24006c68 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
24003bd0:	687b      	ldr	r3, [r7, #4]
24003bd2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24003bd4:	2200      	movs	r2, #0
24003bd6:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24003bd8:	687b      	ldr	r3, [r7, #4]
24003bda:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24003bdc:	687a      	ldr	r2, [r7, #4]
24003bde:	6f52      	ldr	r2, [r2, #116]	; 0x74
24003be0:	605a      	str	r2, [r3, #4]
    }

    hdma->DMAmuxRequestGen = 0U;
24003be2:	687b      	ldr	r3, [r7, #4]
24003be4:	2200      	movs	r2, #0
24003be6:	66da      	str	r2, [r3, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatus = 0U;
24003be8:	687b      	ldr	r3, [r7, #4]
24003bea:	2200      	movs	r2, #0
24003bec:	671a      	str	r2, [r3, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 0U;
24003bee:	687b      	ldr	r3, [r7, #4]
24003bf0:	2200      	movs	r2, #0
24003bf2:	675a      	str	r2, [r3, #116]	; 0x74
  }


  /* Clean callbacks */
  hdma->XferCpltCallback       = NULL;
24003bf4:	687b      	ldr	r3, [r7, #4]
24003bf6:	2200      	movs	r2, #0
24003bf8:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback   = NULL;
24003bfa:	687b      	ldr	r3, [r7, #4]
24003bfc:	2200      	movs	r2, #0
24003bfe:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback     = NULL;
24003c00:	687b      	ldr	r3, [r7, #4]
24003c02:	2200      	movs	r2, #0
24003c04:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
24003c06:	687b      	ldr	r3, [r7, #4]
24003c08:	2200      	movs	r2, #0
24003c0a:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback      = NULL;
24003c0c:	687b      	ldr	r3, [r7, #4]
24003c0e:	2200      	movs	r2, #0
24003c10:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback      = NULL;
24003c12:	687b      	ldr	r3, [r7, #4]
24003c14:	2200      	movs	r2, #0
24003c16:	651a      	str	r2, [r3, #80]	; 0x50

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24003c18:	687b      	ldr	r3, [r7, #4]
24003c1a:	2200      	movs	r2, #0
24003c1c:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
24003c1e:	687b      	ldr	r3, [r7, #4]
24003c20:	2200      	movs	r2, #0
24003c22:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24003c26:	687b      	ldr	r3, [r7, #4]
24003c28:	2200      	movs	r2, #0
24003c2a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
24003c2e:	2300      	movs	r3, #0
}
24003c30:	4618      	mov	r0, r3
24003c32:	3710      	adds	r7, #16
24003c34:	46bd      	mov	sp, r7
24003c36:	bd80      	pop	{r7, pc}

24003c38 <HAL_DMA_Start>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24003c38:	b580      	push	{r7, lr}
24003c3a:	b086      	sub	sp, #24
24003c3c:	af00      	add	r7, sp, #0
24003c3e:	60f8      	str	r0, [r7, #12]
24003c40:	60b9      	str	r1, [r7, #8]
24003c42:	607a      	str	r2, [r7, #4]
24003c44:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24003c46:	2300      	movs	r3, #0
24003c48:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003c4a:	68fb      	ldr	r3, [r7, #12]
24003c4c:	2b00      	cmp	r3, #0
24003c4e:	d101      	bne.n	24003c54 <HAL_DMA_Start+0x1c>
  {
    return HAL_ERROR;
24003c50:	2301      	movs	r3, #1
24003c52:	e0ec      	b.n	24003e2e <HAL_DMA_Start+0x1f6>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24003c54:	68fb      	ldr	r3, [r7, #12]
24003c56:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24003c5a:	2b01      	cmp	r3, #1
24003c5c:	d101      	bne.n	24003c62 <HAL_DMA_Start+0x2a>
24003c5e:	2302      	movs	r3, #2
24003c60:	e0e5      	b.n	24003e2e <HAL_DMA_Start+0x1f6>
24003c62:	68fb      	ldr	r3, [r7, #12]
24003c64:	2201      	movs	r2, #1
24003c66:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24003c6a:	68fb      	ldr	r3, [r7, #12]
24003c6c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24003c70:	b2db      	uxtb	r3, r3
24003c72:	2b01      	cmp	r3, #1
24003c74:	f040 80d0 	bne.w	24003e18 <HAL_DMA_Start+0x1e0>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24003c78:	68fb      	ldr	r3, [r7, #12]
24003c7a:	2202      	movs	r2, #2
24003c7c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24003c80:	68fb      	ldr	r3, [r7, #12]
24003c82:	2200      	movs	r2, #0
24003c84:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
24003c86:	68fb      	ldr	r3, [r7, #12]
24003c88:	681b      	ldr	r3, [r3, #0]
24003c8a:	4a6b      	ldr	r2, [pc, #428]	; (24003e38 <HAL_DMA_Start+0x200>)
24003c8c:	4293      	cmp	r3, r2
24003c8e:	d04a      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003c90:	68fb      	ldr	r3, [r7, #12]
24003c92:	681b      	ldr	r3, [r3, #0]
24003c94:	4a69      	ldr	r2, [pc, #420]	; (24003e3c <HAL_DMA_Start+0x204>)
24003c96:	4293      	cmp	r3, r2
24003c98:	d045      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003c9a:	68fb      	ldr	r3, [r7, #12]
24003c9c:	681b      	ldr	r3, [r3, #0]
24003c9e:	4a68      	ldr	r2, [pc, #416]	; (24003e40 <HAL_DMA_Start+0x208>)
24003ca0:	4293      	cmp	r3, r2
24003ca2:	d040      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003ca4:	68fb      	ldr	r3, [r7, #12]
24003ca6:	681b      	ldr	r3, [r3, #0]
24003ca8:	4a66      	ldr	r2, [pc, #408]	; (24003e44 <HAL_DMA_Start+0x20c>)
24003caa:	4293      	cmp	r3, r2
24003cac:	d03b      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003cae:	68fb      	ldr	r3, [r7, #12]
24003cb0:	681b      	ldr	r3, [r3, #0]
24003cb2:	4a65      	ldr	r2, [pc, #404]	; (24003e48 <HAL_DMA_Start+0x210>)
24003cb4:	4293      	cmp	r3, r2
24003cb6:	d036      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003cb8:	68fb      	ldr	r3, [r7, #12]
24003cba:	681b      	ldr	r3, [r3, #0]
24003cbc:	4a63      	ldr	r2, [pc, #396]	; (24003e4c <HAL_DMA_Start+0x214>)
24003cbe:	4293      	cmp	r3, r2
24003cc0:	d031      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003cc2:	68fb      	ldr	r3, [r7, #12]
24003cc4:	681b      	ldr	r3, [r3, #0]
24003cc6:	4a62      	ldr	r2, [pc, #392]	; (24003e50 <HAL_DMA_Start+0x218>)
24003cc8:	4293      	cmp	r3, r2
24003cca:	d02c      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003ccc:	68fb      	ldr	r3, [r7, #12]
24003cce:	681b      	ldr	r3, [r3, #0]
24003cd0:	4a60      	ldr	r2, [pc, #384]	; (24003e54 <HAL_DMA_Start+0x21c>)
24003cd2:	4293      	cmp	r3, r2
24003cd4:	d027      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003cd6:	68fb      	ldr	r3, [r7, #12]
24003cd8:	681b      	ldr	r3, [r3, #0]
24003cda:	4a5f      	ldr	r2, [pc, #380]	; (24003e58 <HAL_DMA_Start+0x220>)
24003cdc:	4293      	cmp	r3, r2
24003cde:	d022      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003ce0:	68fb      	ldr	r3, [r7, #12]
24003ce2:	681b      	ldr	r3, [r3, #0]
24003ce4:	4a5d      	ldr	r2, [pc, #372]	; (24003e5c <HAL_DMA_Start+0x224>)
24003ce6:	4293      	cmp	r3, r2
24003ce8:	d01d      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003cea:	68fb      	ldr	r3, [r7, #12]
24003cec:	681b      	ldr	r3, [r3, #0]
24003cee:	4a5c      	ldr	r2, [pc, #368]	; (24003e60 <HAL_DMA_Start+0x228>)
24003cf0:	4293      	cmp	r3, r2
24003cf2:	d018      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003cf4:	68fb      	ldr	r3, [r7, #12]
24003cf6:	681b      	ldr	r3, [r3, #0]
24003cf8:	4a5a      	ldr	r2, [pc, #360]	; (24003e64 <HAL_DMA_Start+0x22c>)
24003cfa:	4293      	cmp	r3, r2
24003cfc:	d013      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003cfe:	68fb      	ldr	r3, [r7, #12]
24003d00:	681b      	ldr	r3, [r3, #0]
24003d02:	4a59      	ldr	r2, [pc, #356]	; (24003e68 <HAL_DMA_Start+0x230>)
24003d04:	4293      	cmp	r3, r2
24003d06:	d00e      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003d08:	68fb      	ldr	r3, [r7, #12]
24003d0a:	681b      	ldr	r3, [r3, #0]
24003d0c:	4a57      	ldr	r2, [pc, #348]	; (24003e6c <HAL_DMA_Start+0x234>)
24003d0e:	4293      	cmp	r3, r2
24003d10:	d009      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003d12:	68fb      	ldr	r3, [r7, #12]
24003d14:	681b      	ldr	r3, [r3, #0]
24003d16:	4a56      	ldr	r2, [pc, #344]	; (24003e70 <HAL_DMA_Start+0x238>)
24003d18:	4293      	cmp	r3, r2
24003d1a:	d004      	beq.n	24003d26 <HAL_DMA_Start+0xee>
24003d1c:	68fb      	ldr	r3, [r7, #12]
24003d1e:	681b      	ldr	r3, [r3, #0]
24003d20:	4a54      	ldr	r2, [pc, #336]	; (24003e74 <HAL_DMA_Start+0x23c>)
24003d22:	4293      	cmp	r3, r2
24003d24:	d108      	bne.n	24003d38 <HAL_DMA_Start+0x100>
24003d26:	68fb      	ldr	r3, [r7, #12]
24003d28:	681b      	ldr	r3, [r3, #0]
24003d2a:	681a      	ldr	r2, [r3, #0]
24003d2c:	68fb      	ldr	r3, [r7, #12]
24003d2e:	681b      	ldr	r3, [r3, #0]
24003d30:	f022 0201 	bic.w	r2, r2, #1
24003d34:	601a      	str	r2, [r3, #0]
24003d36:	e007      	b.n	24003d48 <HAL_DMA_Start+0x110>
24003d38:	68fb      	ldr	r3, [r7, #12]
24003d3a:	681b      	ldr	r3, [r3, #0]
24003d3c:	681a      	ldr	r2, [r3, #0]
24003d3e:	68fb      	ldr	r3, [r7, #12]
24003d40:	681b      	ldr	r3, [r3, #0]
24003d42:	f022 0201 	bic.w	r2, r2, #1
24003d46:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24003d48:	683b      	ldr	r3, [r7, #0]
24003d4a:	687a      	ldr	r2, [r7, #4]
24003d4c:	68b9      	ldr	r1, [r7, #8]
24003d4e:	68f8      	ldr	r0, [r7, #12]
24003d50:	f002 fc16 	bl	24006580 <DMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
24003d54:	68fb      	ldr	r3, [r7, #12]
24003d56:	681b      	ldr	r3, [r3, #0]
24003d58:	4a37      	ldr	r2, [pc, #220]	; (24003e38 <HAL_DMA_Start+0x200>)
24003d5a:	4293      	cmp	r3, r2
24003d5c:	d04a      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003d5e:	68fb      	ldr	r3, [r7, #12]
24003d60:	681b      	ldr	r3, [r3, #0]
24003d62:	4a36      	ldr	r2, [pc, #216]	; (24003e3c <HAL_DMA_Start+0x204>)
24003d64:	4293      	cmp	r3, r2
24003d66:	d045      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003d68:	68fb      	ldr	r3, [r7, #12]
24003d6a:	681b      	ldr	r3, [r3, #0]
24003d6c:	4a34      	ldr	r2, [pc, #208]	; (24003e40 <HAL_DMA_Start+0x208>)
24003d6e:	4293      	cmp	r3, r2
24003d70:	d040      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003d72:	68fb      	ldr	r3, [r7, #12]
24003d74:	681b      	ldr	r3, [r3, #0]
24003d76:	4a33      	ldr	r2, [pc, #204]	; (24003e44 <HAL_DMA_Start+0x20c>)
24003d78:	4293      	cmp	r3, r2
24003d7a:	d03b      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003d7c:	68fb      	ldr	r3, [r7, #12]
24003d7e:	681b      	ldr	r3, [r3, #0]
24003d80:	4a31      	ldr	r2, [pc, #196]	; (24003e48 <HAL_DMA_Start+0x210>)
24003d82:	4293      	cmp	r3, r2
24003d84:	d036      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003d86:	68fb      	ldr	r3, [r7, #12]
24003d88:	681b      	ldr	r3, [r3, #0]
24003d8a:	4a30      	ldr	r2, [pc, #192]	; (24003e4c <HAL_DMA_Start+0x214>)
24003d8c:	4293      	cmp	r3, r2
24003d8e:	d031      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003d90:	68fb      	ldr	r3, [r7, #12]
24003d92:	681b      	ldr	r3, [r3, #0]
24003d94:	4a2e      	ldr	r2, [pc, #184]	; (24003e50 <HAL_DMA_Start+0x218>)
24003d96:	4293      	cmp	r3, r2
24003d98:	d02c      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003d9a:	68fb      	ldr	r3, [r7, #12]
24003d9c:	681b      	ldr	r3, [r3, #0]
24003d9e:	4a2d      	ldr	r2, [pc, #180]	; (24003e54 <HAL_DMA_Start+0x21c>)
24003da0:	4293      	cmp	r3, r2
24003da2:	d027      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003da4:	68fb      	ldr	r3, [r7, #12]
24003da6:	681b      	ldr	r3, [r3, #0]
24003da8:	4a2b      	ldr	r2, [pc, #172]	; (24003e58 <HAL_DMA_Start+0x220>)
24003daa:	4293      	cmp	r3, r2
24003dac:	d022      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003dae:	68fb      	ldr	r3, [r7, #12]
24003db0:	681b      	ldr	r3, [r3, #0]
24003db2:	4a2a      	ldr	r2, [pc, #168]	; (24003e5c <HAL_DMA_Start+0x224>)
24003db4:	4293      	cmp	r3, r2
24003db6:	d01d      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003db8:	68fb      	ldr	r3, [r7, #12]
24003dba:	681b      	ldr	r3, [r3, #0]
24003dbc:	4a28      	ldr	r2, [pc, #160]	; (24003e60 <HAL_DMA_Start+0x228>)
24003dbe:	4293      	cmp	r3, r2
24003dc0:	d018      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003dc2:	68fb      	ldr	r3, [r7, #12]
24003dc4:	681b      	ldr	r3, [r3, #0]
24003dc6:	4a27      	ldr	r2, [pc, #156]	; (24003e64 <HAL_DMA_Start+0x22c>)
24003dc8:	4293      	cmp	r3, r2
24003dca:	d013      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003dcc:	68fb      	ldr	r3, [r7, #12]
24003dce:	681b      	ldr	r3, [r3, #0]
24003dd0:	4a25      	ldr	r2, [pc, #148]	; (24003e68 <HAL_DMA_Start+0x230>)
24003dd2:	4293      	cmp	r3, r2
24003dd4:	d00e      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003dd6:	68fb      	ldr	r3, [r7, #12]
24003dd8:	681b      	ldr	r3, [r3, #0]
24003dda:	4a24      	ldr	r2, [pc, #144]	; (24003e6c <HAL_DMA_Start+0x234>)
24003ddc:	4293      	cmp	r3, r2
24003dde:	d009      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003de0:	68fb      	ldr	r3, [r7, #12]
24003de2:	681b      	ldr	r3, [r3, #0]
24003de4:	4a22      	ldr	r2, [pc, #136]	; (24003e70 <HAL_DMA_Start+0x238>)
24003de6:	4293      	cmp	r3, r2
24003de8:	d004      	beq.n	24003df4 <HAL_DMA_Start+0x1bc>
24003dea:	68fb      	ldr	r3, [r7, #12]
24003dec:	681b      	ldr	r3, [r3, #0]
24003dee:	4a21      	ldr	r2, [pc, #132]	; (24003e74 <HAL_DMA_Start+0x23c>)
24003df0:	4293      	cmp	r3, r2
24003df2:	d108      	bne.n	24003e06 <HAL_DMA_Start+0x1ce>
24003df4:	68fb      	ldr	r3, [r7, #12]
24003df6:	681b      	ldr	r3, [r3, #0]
24003df8:	681a      	ldr	r2, [r3, #0]
24003dfa:	68fb      	ldr	r3, [r7, #12]
24003dfc:	681b      	ldr	r3, [r3, #0]
24003dfe:	f042 0201 	orr.w	r2, r2, #1
24003e02:	601a      	str	r2, [r3, #0]
24003e04:	e012      	b.n	24003e2c <HAL_DMA_Start+0x1f4>
24003e06:	68fb      	ldr	r3, [r7, #12]
24003e08:	681b      	ldr	r3, [r3, #0]
24003e0a:	681a      	ldr	r2, [r3, #0]
24003e0c:	68fb      	ldr	r3, [r7, #12]
24003e0e:	681b      	ldr	r3, [r3, #0]
24003e10:	f042 0201 	orr.w	r2, r2, #1
24003e14:	601a      	str	r2, [r3, #0]
24003e16:	e009      	b.n	24003e2c <HAL_DMA_Start+0x1f4>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24003e18:	68fb      	ldr	r3, [r7, #12]
24003e1a:	f44f 6200 	mov.w	r2, #2048	; 0x800
24003e1e:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
24003e20:	68fb      	ldr	r3, [r7, #12]
24003e22:	2200      	movs	r2, #0
24003e24:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Return error status */
    status = HAL_ERROR;
24003e28:	2301      	movs	r3, #1
24003e2a:	75fb      	strb	r3, [r7, #23]
  }
  return status;
24003e2c:	7dfb      	ldrb	r3, [r7, #23]
}
24003e2e:	4618      	mov	r0, r3
24003e30:	3718      	adds	r7, #24
24003e32:	46bd      	mov	sp, r7
24003e34:	bd80      	pop	{r7, pc}
24003e36:	bf00      	nop
24003e38:	40020010 	.word	0x40020010
24003e3c:	40020028 	.word	0x40020028
24003e40:	40020040 	.word	0x40020040
24003e44:	40020058 	.word	0x40020058
24003e48:	40020070 	.word	0x40020070
24003e4c:	40020088 	.word	0x40020088
24003e50:	400200a0 	.word	0x400200a0
24003e54:	400200b8 	.word	0x400200b8
24003e58:	40020410 	.word	0x40020410
24003e5c:	40020428 	.word	0x40020428
24003e60:	40020440 	.word	0x40020440
24003e64:	40020458 	.word	0x40020458
24003e68:	40020470 	.word	0x40020470
24003e6c:	40020488 	.word	0x40020488
24003e70:	400204a0 	.word	0x400204a0
24003e74:	400204b8 	.word	0x400204b8

24003e78 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24003e78:	b580      	push	{r7, lr}
24003e7a:	b086      	sub	sp, #24
24003e7c:	af00      	add	r7, sp, #0
24003e7e:	60f8      	str	r0, [r7, #12]
24003e80:	60b9      	str	r1, [r7, #8]
24003e82:	607a      	str	r2, [r7, #4]
24003e84:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24003e86:	2300      	movs	r3, #0
24003e88:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24003e8a:	68fb      	ldr	r3, [r7, #12]
24003e8c:	2b00      	cmp	r3, #0
24003e8e:	d101      	bne.n	24003e94 <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
24003e90:	2301      	movs	r3, #1
24003e92:	e226      	b.n	240042e2 <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
24003e94:	68fb      	ldr	r3, [r7, #12]
24003e96:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24003e9a:	2b01      	cmp	r3, #1
24003e9c:	d101      	bne.n	24003ea2 <HAL_DMA_Start_IT+0x2a>
24003e9e:	2302      	movs	r3, #2
24003ea0:	e21f      	b.n	240042e2 <HAL_DMA_Start_IT+0x46a>
24003ea2:	68fb      	ldr	r3, [r7, #12]
24003ea4:	2201      	movs	r2, #1
24003ea6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24003eaa:	68fb      	ldr	r3, [r7, #12]
24003eac:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24003eb0:	b2db      	uxtb	r3, r3
24003eb2:	2b01      	cmp	r3, #1
24003eb4:	f040 820a 	bne.w	240042cc <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
24003eb8:	68fb      	ldr	r3, [r7, #12]
24003eba:	2202      	movs	r2, #2
24003ebc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24003ec0:	68fb      	ldr	r3, [r7, #12]
24003ec2:	2200      	movs	r2, #0
24003ec4:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
24003ec6:	68fb      	ldr	r3, [r7, #12]
24003ec8:	681b      	ldr	r3, [r3, #0]
24003eca:	4a68      	ldr	r2, [pc, #416]	; (2400406c <HAL_DMA_Start_IT+0x1f4>)
24003ecc:	4293      	cmp	r3, r2
24003ece:	d04a      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003ed0:	68fb      	ldr	r3, [r7, #12]
24003ed2:	681b      	ldr	r3, [r3, #0]
24003ed4:	4a66      	ldr	r2, [pc, #408]	; (24004070 <HAL_DMA_Start_IT+0x1f8>)
24003ed6:	4293      	cmp	r3, r2
24003ed8:	d045      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003eda:	68fb      	ldr	r3, [r7, #12]
24003edc:	681b      	ldr	r3, [r3, #0]
24003ede:	4a65      	ldr	r2, [pc, #404]	; (24004074 <HAL_DMA_Start_IT+0x1fc>)
24003ee0:	4293      	cmp	r3, r2
24003ee2:	d040      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003ee4:	68fb      	ldr	r3, [r7, #12]
24003ee6:	681b      	ldr	r3, [r3, #0]
24003ee8:	4a63      	ldr	r2, [pc, #396]	; (24004078 <HAL_DMA_Start_IT+0x200>)
24003eea:	4293      	cmp	r3, r2
24003eec:	d03b      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003eee:	68fb      	ldr	r3, [r7, #12]
24003ef0:	681b      	ldr	r3, [r3, #0]
24003ef2:	4a62      	ldr	r2, [pc, #392]	; (2400407c <HAL_DMA_Start_IT+0x204>)
24003ef4:	4293      	cmp	r3, r2
24003ef6:	d036      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003ef8:	68fb      	ldr	r3, [r7, #12]
24003efa:	681b      	ldr	r3, [r3, #0]
24003efc:	4a60      	ldr	r2, [pc, #384]	; (24004080 <HAL_DMA_Start_IT+0x208>)
24003efe:	4293      	cmp	r3, r2
24003f00:	d031      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f02:	68fb      	ldr	r3, [r7, #12]
24003f04:	681b      	ldr	r3, [r3, #0]
24003f06:	4a5f      	ldr	r2, [pc, #380]	; (24004084 <HAL_DMA_Start_IT+0x20c>)
24003f08:	4293      	cmp	r3, r2
24003f0a:	d02c      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f0c:	68fb      	ldr	r3, [r7, #12]
24003f0e:	681b      	ldr	r3, [r3, #0]
24003f10:	4a5d      	ldr	r2, [pc, #372]	; (24004088 <HAL_DMA_Start_IT+0x210>)
24003f12:	4293      	cmp	r3, r2
24003f14:	d027      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f16:	68fb      	ldr	r3, [r7, #12]
24003f18:	681b      	ldr	r3, [r3, #0]
24003f1a:	4a5c      	ldr	r2, [pc, #368]	; (2400408c <HAL_DMA_Start_IT+0x214>)
24003f1c:	4293      	cmp	r3, r2
24003f1e:	d022      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f20:	68fb      	ldr	r3, [r7, #12]
24003f22:	681b      	ldr	r3, [r3, #0]
24003f24:	4a5a      	ldr	r2, [pc, #360]	; (24004090 <HAL_DMA_Start_IT+0x218>)
24003f26:	4293      	cmp	r3, r2
24003f28:	d01d      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f2a:	68fb      	ldr	r3, [r7, #12]
24003f2c:	681b      	ldr	r3, [r3, #0]
24003f2e:	4a59      	ldr	r2, [pc, #356]	; (24004094 <HAL_DMA_Start_IT+0x21c>)
24003f30:	4293      	cmp	r3, r2
24003f32:	d018      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f34:	68fb      	ldr	r3, [r7, #12]
24003f36:	681b      	ldr	r3, [r3, #0]
24003f38:	4a57      	ldr	r2, [pc, #348]	; (24004098 <HAL_DMA_Start_IT+0x220>)
24003f3a:	4293      	cmp	r3, r2
24003f3c:	d013      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f3e:	68fb      	ldr	r3, [r7, #12]
24003f40:	681b      	ldr	r3, [r3, #0]
24003f42:	4a56      	ldr	r2, [pc, #344]	; (2400409c <HAL_DMA_Start_IT+0x224>)
24003f44:	4293      	cmp	r3, r2
24003f46:	d00e      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f48:	68fb      	ldr	r3, [r7, #12]
24003f4a:	681b      	ldr	r3, [r3, #0]
24003f4c:	4a54      	ldr	r2, [pc, #336]	; (240040a0 <HAL_DMA_Start_IT+0x228>)
24003f4e:	4293      	cmp	r3, r2
24003f50:	d009      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f52:	68fb      	ldr	r3, [r7, #12]
24003f54:	681b      	ldr	r3, [r3, #0]
24003f56:	4a53      	ldr	r2, [pc, #332]	; (240040a4 <HAL_DMA_Start_IT+0x22c>)
24003f58:	4293      	cmp	r3, r2
24003f5a:	d004      	beq.n	24003f66 <HAL_DMA_Start_IT+0xee>
24003f5c:	68fb      	ldr	r3, [r7, #12]
24003f5e:	681b      	ldr	r3, [r3, #0]
24003f60:	4a51      	ldr	r2, [pc, #324]	; (240040a8 <HAL_DMA_Start_IT+0x230>)
24003f62:	4293      	cmp	r3, r2
24003f64:	d108      	bne.n	24003f78 <HAL_DMA_Start_IT+0x100>
24003f66:	68fb      	ldr	r3, [r7, #12]
24003f68:	681b      	ldr	r3, [r3, #0]
24003f6a:	681a      	ldr	r2, [r3, #0]
24003f6c:	68fb      	ldr	r3, [r7, #12]
24003f6e:	681b      	ldr	r3, [r3, #0]
24003f70:	f022 0201 	bic.w	r2, r2, #1
24003f74:	601a      	str	r2, [r3, #0]
24003f76:	e007      	b.n	24003f88 <HAL_DMA_Start_IT+0x110>
24003f78:	68fb      	ldr	r3, [r7, #12]
24003f7a:	681b      	ldr	r3, [r3, #0]
24003f7c:	681a      	ldr	r2, [r3, #0]
24003f7e:	68fb      	ldr	r3, [r7, #12]
24003f80:	681b      	ldr	r3, [r3, #0]
24003f82:	f022 0201 	bic.w	r2, r2, #1
24003f86:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
24003f88:	683b      	ldr	r3, [r7, #0]
24003f8a:	687a      	ldr	r2, [r7, #4]
24003f8c:	68b9      	ldr	r1, [r7, #8]
24003f8e:	68f8      	ldr	r0, [r7, #12]
24003f90:	f002 faf6 	bl	24006580 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24003f94:	68fb      	ldr	r3, [r7, #12]
24003f96:	681b      	ldr	r3, [r3, #0]
24003f98:	4a34      	ldr	r2, [pc, #208]	; (2400406c <HAL_DMA_Start_IT+0x1f4>)
24003f9a:	4293      	cmp	r3, r2
24003f9c:	d04a      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003f9e:	68fb      	ldr	r3, [r7, #12]
24003fa0:	681b      	ldr	r3, [r3, #0]
24003fa2:	4a33      	ldr	r2, [pc, #204]	; (24004070 <HAL_DMA_Start_IT+0x1f8>)
24003fa4:	4293      	cmp	r3, r2
24003fa6:	d045      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fa8:	68fb      	ldr	r3, [r7, #12]
24003faa:	681b      	ldr	r3, [r3, #0]
24003fac:	4a31      	ldr	r2, [pc, #196]	; (24004074 <HAL_DMA_Start_IT+0x1fc>)
24003fae:	4293      	cmp	r3, r2
24003fb0:	d040      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fb2:	68fb      	ldr	r3, [r7, #12]
24003fb4:	681b      	ldr	r3, [r3, #0]
24003fb6:	4a30      	ldr	r2, [pc, #192]	; (24004078 <HAL_DMA_Start_IT+0x200>)
24003fb8:	4293      	cmp	r3, r2
24003fba:	d03b      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fbc:	68fb      	ldr	r3, [r7, #12]
24003fbe:	681b      	ldr	r3, [r3, #0]
24003fc0:	4a2e      	ldr	r2, [pc, #184]	; (2400407c <HAL_DMA_Start_IT+0x204>)
24003fc2:	4293      	cmp	r3, r2
24003fc4:	d036      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fc6:	68fb      	ldr	r3, [r7, #12]
24003fc8:	681b      	ldr	r3, [r3, #0]
24003fca:	4a2d      	ldr	r2, [pc, #180]	; (24004080 <HAL_DMA_Start_IT+0x208>)
24003fcc:	4293      	cmp	r3, r2
24003fce:	d031      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fd0:	68fb      	ldr	r3, [r7, #12]
24003fd2:	681b      	ldr	r3, [r3, #0]
24003fd4:	4a2b      	ldr	r2, [pc, #172]	; (24004084 <HAL_DMA_Start_IT+0x20c>)
24003fd6:	4293      	cmp	r3, r2
24003fd8:	d02c      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fda:	68fb      	ldr	r3, [r7, #12]
24003fdc:	681b      	ldr	r3, [r3, #0]
24003fde:	4a2a      	ldr	r2, [pc, #168]	; (24004088 <HAL_DMA_Start_IT+0x210>)
24003fe0:	4293      	cmp	r3, r2
24003fe2:	d027      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fe4:	68fb      	ldr	r3, [r7, #12]
24003fe6:	681b      	ldr	r3, [r3, #0]
24003fe8:	4a28      	ldr	r2, [pc, #160]	; (2400408c <HAL_DMA_Start_IT+0x214>)
24003fea:	4293      	cmp	r3, r2
24003fec:	d022      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003fee:	68fb      	ldr	r3, [r7, #12]
24003ff0:	681b      	ldr	r3, [r3, #0]
24003ff2:	4a27      	ldr	r2, [pc, #156]	; (24004090 <HAL_DMA_Start_IT+0x218>)
24003ff4:	4293      	cmp	r3, r2
24003ff6:	d01d      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24003ff8:	68fb      	ldr	r3, [r7, #12]
24003ffa:	681b      	ldr	r3, [r3, #0]
24003ffc:	4a25      	ldr	r2, [pc, #148]	; (24004094 <HAL_DMA_Start_IT+0x21c>)
24003ffe:	4293      	cmp	r3, r2
24004000:	d018      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24004002:	68fb      	ldr	r3, [r7, #12]
24004004:	681b      	ldr	r3, [r3, #0]
24004006:	4a24      	ldr	r2, [pc, #144]	; (24004098 <HAL_DMA_Start_IT+0x220>)
24004008:	4293      	cmp	r3, r2
2400400a:	d013      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
2400400c:	68fb      	ldr	r3, [r7, #12]
2400400e:	681b      	ldr	r3, [r3, #0]
24004010:	4a22      	ldr	r2, [pc, #136]	; (2400409c <HAL_DMA_Start_IT+0x224>)
24004012:	4293      	cmp	r3, r2
24004014:	d00e      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24004016:	68fb      	ldr	r3, [r7, #12]
24004018:	681b      	ldr	r3, [r3, #0]
2400401a:	4a21      	ldr	r2, [pc, #132]	; (240040a0 <HAL_DMA_Start_IT+0x228>)
2400401c:	4293      	cmp	r3, r2
2400401e:	d009      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
24004020:	68fb      	ldr	r3, [r7, #12]
24004022:	681b      	ldr	r3, [r3, #0]
24004024:	4a1f      	ldr	r2, [pc, #124]	; (240040a4 <HAL_DMA_Start_IT+0x22c>)
24004026:	4293      	cmp	r3, r2
24004028:	d004      	beq.n	24004034 <HAL_DMA_Start_IT+0x1bc>
2400402a:	68fb      	ldr	r3, [r7, #12]
2400402c:	681b      	ldr	r3, [r3, #0]
2400402e:	4a1e      	ldr	r2, [pc, #120]	; (240040a8 <HAL_DMA_Start_IT+0x230>)
24004030:	4293      	cmp	r3, r2
24004032:	d101      	bne.n	24004038 <HAL_DMA_Start_IT+0x1c0>
24004034:	2301      	movs	r3, #1
24004036:	e000      	b.n	2400403a <HAL_DMA_Start_IT+0x1c2>
24004038:	2300      	movs	r3, #0
2400403a:	2b00      	cmp	r3, #0
2400403c:	d036      	beq.n	240040ac <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
2400403e:	68fb      	ldr	r3, [r7, #12]
24004040:	681b      	ldr	r3, [r3, #0]
24004042:	681b      	ldr	r3, [r3, #0]
24004044:	f023 021e 	bic.w	r2, r3, #30
24004048:	68fb      	ldr	r3, [r7, #12]
2400404a:	681b      	ldr	r3, [r3, #0]
2400404c:	f042 0216 	orr.w	r2, r2, #22
24004050:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
24004052:	68fb      	ldr	r3, [r7, #12]
24004054:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24004056:	2b00      	cmp	r3, #0
24004058:	d03e      	beq.n	240040d8 <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
2400405a:	68fb      	ldr	r3, [r7, #12]
2400405c:	681b      	ldr	r3, [r3, #0]
2400405e:	681a      	ldr	r2, [r3, #0]
24004060:	68fb      	ldr	r3, [r7, #12]
24004062:	681b      	ldr	r3, [r3, #0]
24004064:	f042 0208 	orr.w	r2, r2, #8
24004068:	601a      	str	r2, [r3, #0]
2400406a:	e035      	b.n	240040d8 <HAL_DMA_Start_IT+0x260>
2400406c:	40020010 	.word	0x40020010
24004070:	40020028 	.word	0x40020028
24004074:	40020040 	.word	0x40020040
24004078:	40020058 	.word	0x40020058
2400407c:	40020070 	.word	0x40020070
24004080:	40020088 	.word	0x40020088
24004084:	400200a0 	.word	0x400200a0
24004088:	400200b8 	.word	0x400200b8
2400408c:	40020410 	.word	0x40020410
24004090:	40020428 	.word	0x40020428
24004094:	40020440 	.word	0x40020440
24004098:	40020458 	.word	0x40020458
2400409c:	40020470 	.word	0x40020470
240040a0:	40020488 	.word	0x40020488
240040a4:	400204a0 	.word	0x400204a0
240040a8:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
240040ac:	68fb      	ldr	r3, [r7, #12]
240040ae:	681b      	ldr	r3, [r3, #0]
240040b0:	681b      	ldr	r3, [r3, #0]
240040b2:	f023 020e 	bic.w	r2, r3, #14
240040b6:	68fb      	ldr	r3, [r7, #12]
240040b8:	681b      	ldr	r3, [r3, #0]
240040ba:	f042 020a 	orr.w	r2, r2, #10
240040be:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
240040c0:	68fb      	ldr	r3, [r7, #12]
240040c2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240040c4:	2b00      	cmp	r3, #0
240040c6:	d007      	beq.n	240040d8 <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
240040c8:	68fb      	ldr	r3, [r7, #12]
240040ca:	681b      	ldr	r3, [r3, #0]
240040cc:	681a      	ldr	r2, [r3, #0]
240040ce:	68fb      	ldr	r3, [r7, #12]
240040d0:	681b      	ldr	r3, [r3, #0]
240040d2:	f042 0204 	orr.w	r2, r2, #4
240040d6:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240040d8:	68fb      	ldr	r3, [r7, #12]
240040da:	681b      	ldr	r3, [r3, #0]
240040dc:	4a83      	ldr	r2, [pc, #524]	; (240042ec <HAL_DMA_Start_IT+0x474>)
240040de:	4293      	cmp	r3, r2
240040e0:	d072      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
240040e2:	68fb      	ldr	r3, [r7, #12]
240040e4:	681b      	ldr	r3, [r3, #0]
240040e6:	4a82      	ldr	r2, [pc, #520]	; (240042f0 <HAL_DMA_Start_IT+0x478>)
240040e8:	4293      	cmp	r3, r2
240040ea:	d06d      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
240040ec:	68fb      	ldr	r3, [r7, #12]
240040ee:	681b      	ldr	r3, [r3, #0]
240040f0:	4a80      	ldr	r2, [pc, #512]	; (240042f4 <HAL_DMA_Start_IT+0x47c>)
240040f2:	4293      	cmp	r3, r2
240040f4:	d068      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
240040f6:	68fb      	ldr	r3, [r7, #12]
240040f8:	681b      	ldr	r3, [r3, #0]
240040fa:	4a7f      	ldr	r2, [pc, #508]	; (240042f8 <HAL_DMA_Start_IT+0x480>)
240040fc:	4293      	cmp	r3, r2
240040fe:	d063      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004100:	68fb      	ldr	r3, [r7, #12]
24004102:	681b      	ldr	r3, [r3, #0]
24004104:	4a7d      	ldr	r2, [pc, #500]	; (240042fc <HAL_DMA_Start_IT+0x484>)
24004106:	4293      	cmp	r3, r2
24004108:	d05e      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
2400410a:	68fb      	ldr	r3, [r7, #12]
2400410c:	681b      	ldr	r3, [r3, #0]
2400410e:	4a7c      	ldr	r2, [pc, #496]	; (24004300 <HAL_DMA_Start_IT+0x488>)
24004110:	4293      	cmp	r3, r2
24004112:	d059      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004114:	68fb      	ldr	r3, [r7, #12]
24004116:	681b      	ldr	r3, [r3, #0]
24004118:	4a7a      	ldr	r2, [pc, #488]	; (24004304 <HAL_DMA_Start_IT+0x48c>)
2400411a:	4293      	cmp	r3, r2
2400411c:	d054      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
2400411e:	68fb      	ldr	r3, [r7, #12]
24004120:	681b      	ldr	r3, [r3, #0]
24004122:	4a79      	ldr	r2, [pc, #484]	; (24004308 <HAL_DMA_Start_IT+0x490>)
24004124:	4293      	cmp	r3, r2
24004126:	d04f      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004128:	68fb      	ldr	r3, [r7, #12]
2400412a:	681b      	ldr	r3, [r3, #0]
2400412c:	4a77      	ldr	r2, [pc, #476]	; (2400430c <HAL_DMA_Start_IT+0x494>)
2400412e:	4293      	cmp	r3, r2
24004130:	d04a      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004132:	68fb      	ldr	r3, [r7, #12]
24004134:	681b      	ldr	r3, [r3, #0]
24004136:	4a76      	ldr	r2, [pc, #472]	; (24004310 <HAL_DMA_Start_IT+0x498>)
24004138:	4293      	cmp	r3, r2
2400413a:	d045      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
2400413c:	68fb      	ldr	r3, [r7, #12]
2400413e:	681b      	ldr	r3, [r3, #0]
24004140:	4a74      	ldr	r2, [pc, #464]	; (24004314 <HAL_DMA_Start_IT+0x49c>)
24004142:	4293      	cmp	r3, r2
24004144:	d040      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004146:	68fb      	ldr	r3, [r7, #12]
24004148:	681b      	ldr	r3, [r3, #0]
2400414a:	4a73      	ldr	r2, [pc, #460]	; (24004318 <HAL_DMA_Start_IT+0x4a0>)
2400414c:	4293      	cmp	r3, r2
2400414e:	d03b      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004150:	68fb      	ldr	r3, [r7, #12]
24004152:	681b      	ldr	r3, [r3, #0]
24004154:	4a71      	ldr	r2, [pc, #452]	; (2400431c <HAL_DMA_Start_IT+0x4a4>)
24004156:	4293      	cmp	r3, r2
24004158:	d036      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
2400415a:	68fb      	ldr	r3, [r7, #12]
2400415c:	681b      	ldr	r3, [r3, #0]
2400415e:	4a70      	ldr	r2, [pc, #448]	; (24004320 <HAL_DMA_Start_IT+0x4a8>)
24004160:	4293      	cmp	r3, r2
24004162:	d031      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004164:	68fb      	ldr	r3, [r7, #12]
24004166:	681b      	ldr	r3, [r3, #0]
24004168:	4a6e      	ldr	r2, [pc, #440]	; (24004324 <HAL_DMA_Start_IT+0x4ac>)
2400416a:	4293      	cmp	r3, r2
2400416c:	d02c      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
2400416e:	68fb      	ldr	r3, [r7, #12]
24004170:	681b      	ldr	r3, [r3, #0]
24004172:	4a6d      	ldr	r2, [pc, #436]	; (24004328 <HAL_DMA_Start_IT+0x4b0>)
24004174:	4293      	cmp	r3, r2
24004176:	d027      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004178:	68fb      	ldr	r3, [r7, #12]
2400417a:	681b      	ldr	r3, [r3, #0]
2400417c:	4a6b      	ldr	r2, [pc, #428]	; (2400432c <HAL_DMA_Start_IT+0x4b4>)
2400417e:	4293      	cmp	r3, r2
24004180:	d022      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004182:	68fb      	ldr	r3, [r7, #12]
24004184:	681b      	ldr	r3, [r3, #0]
24004186:	4a6a      	ldr	r2, [pc, #424]	; (24004330 <HAL_DMA_Start_IT+0x4b8>)
24004188:	4293      	cmp	r3, r2
2400418a:	d01d      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
2400418c:	68fb      	ldr	r3, [r7, #12]
2400418e:	681b      	ldr	r3, [r3, #0]
24004190:	4a68      	ldr	r2, [pc, #416]	; (24004334 <HAL_DMA_Start_IT+0x4bc>)
24004192:	4293      	cmp	r3, r2
24004194:	d018      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
24004196:	68fb      	ldr	r3, [r7, #12]
24004198:	681b      	ldr	r3, [r3, #0]
2400419a:	4a67      	ldr	r2, [pc, #412]	; (24004338 <HAL_DMA_Start_IT+0x4c0>)
2400419c:	4293      	cmp	r3, r2
2400419e:	d013      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
240041a0:	68fb      	ldr	r3, [r7, #12]
240041a2:	681b      	ldr	r3, [r3, #0]
240041a4:	4a65      	ldr	r2, [pc, #404]	; (2400433c <HAL_DMA_Start_IT+0x4c4>)
240041a6:	4293      	cmp	r3, r2
240041a8:	d00e      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
240041aa:	68fb      	ldr	r3, [r7, #12]
240041ac:	681b      	ldr	r3, [r3, #0]
240041ae:	4a64      	ldr	r2, [pc, #400]	; (24004340 <HAL_DMA_Start_IT+0x4c8>)
240041b0:	4293      	cmp	r3, r2
240041b2:	d009      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
240041b4:	68fb      	ldr	r3, [r7, #12]
240041b6:	681b      	ldr	r3, [r3, #0]
240041b8:	4a62      	ldr	r2, [pc, #392]	; (24004344 <HAL_DMA_Start_IT+0x4cc>)
240041ba:	4293      	cmp	r3, r2
240041bc:	d004      	beq.n	240041c8 <HAL_DMA_Start_IT+0x350>
240041be:	68fb      	ldr	r3, [r7, #12]
240041c0:	681b      	ldr	r3, [r3, #0]
240041c2:	4a61      	ldr	r2, [pc, #388]	; (24004348 <HAL_DMA_Start_IT+0x4d0>)
240041c4:	4293      	cmp	r3, r2
240041c6:	d101      	bne.n	240041cc <HAL_DMA_Start_IT+0x354>
240041c8:	2301      	movs	r3, #1
240041ca:	e000      	b.n	240041ce <HAL_DMA_Start_IT+0x356>
240041cc:	2300      	movs	r3, #0
240041ce:	2b00      	cmp	r3, #0
240041d0:	d01a      	beq.n	24004208 <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
240041d2:	68fb      	ldr	r3, [r7, #12]
240041d4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240041d6:	681b      	ldr	r3, [r3, #0]
240041d8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240041dc:	2b00      	cmp	r3, #0
240041de:	d007      	beq.n	240041f0 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
240041e0:	68fb      	ldr	r3, [r7, #12]
240041e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240041e4:	681a      	ldr	r2, [r3, #0]
240041e6:	68fb      	ldr	r3, [r7, #12]
240041e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240041ea:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240041ee:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
240041f0:	68fb      	ldr	r3, [r7, #12]
240041f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240041f4:	2b00      	cmp	r3, #0
240041f6:	d007      	beq.n	24004208 <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
240041f8:	68fb      	ldr	r3, [r7, #12]
240041fa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240041fc:	681a      	ldr	r2, [r3, #0]
240041fe:	68fb      	ldr	r3, [r7, #12]
24004200:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004202:	f442 7280 	orr.w	r2, r2, #256	; 0x100
24004206:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
24004208:	68fb      	ldr	r3, [r7, #12]
2400420a:	681b      	ldr	r3, [r3, #0]
2400420c:	4a37      	ldr	r2, [pc, #220]	; (240042ec <HAL_DMA_Start_IT+0x474>)
2400420e:	4293      	cmp	r3, r2
24004210:	d04a      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004212:	68fb      	ldr	r3, [r7, #12]
24004214:	681b      	ldr	r3, [r3, #0]
24004216:	4a36      	ldr	r2, [pc, #216]	; (240042f0 <HAL_DMA_Start_IT+0x478>)
24004218:	4293      	cmp	r3, r2
2400421a:	d045      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
2400421c:	68fb      	ldr	r3, [r7, #12]
2400421e:	681b      	ldr	r3, [r3, #0]
24004220:	4a34      	ldr	r2, [pc, #208]	; (240042f4 <HAL_DMA_Start_IT+0x47c>)
24004222:	4293      	cmp	r3, r2
24004224:	d040      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004226:	68fb      	ldr	r3, [r7, #12]
24004228:	681b      	ldr	r3, [r3, #0]
2400422a:	4a33      	ldr	r2, [pc, #204]	; (240042f8 <HAL_DMA_Start_IT+0x480>)
2400422c:	4293      	cmp	r3, r2
2400422e:	d03b      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004230:	68fb      	ldr	r3, [r7, #12]
24004232:	681b      	ldr	r3, [r3, #0]
24004234:	4a31      	ldr	r2, [pc, #196]	; (240042fc <HAL_DMA_Start_IT+0x484>)
24004236:	4293      	cmp	r3, r2
24004238:	d036      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
2400423a:	68fb      	ldr	r3, [r7, #12]
2400423c:	681b      	ldr	r3, [r3, #0]
2400423e:	4a30      	ldr	r2, [pc, #192]	; (24004300 <HAL_DMA_Start_IT+0x488>)
24004240:	4293      	cmp	r3, r2
24004242:	d031      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004244:	68fb      	ldr	r3, [r7, #12]
24004246:	681b      	ldr	r3, [r3, #0]
24004248:	4a2e      	ldr	r2, [pc, #184]	; (24004304 <HAL_DMA_Start_IT+0x48c>)
2400424a:	4293      	cmp	r3, r2
2400424c:	d02c      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
2400424e:	68fb      	ldr	r3, [r7, #12]
24004250:	681b      	ldr	r3, [r3, #0]
24004252:	4a2d      	ldr	r2, [pc, #180]	; (24004308 <HAL_DMA_Start_IT+0x490>)
24004254:	4293      	cmp	r3, r2
24004256:	d027      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004258:	68fb      	ldr	r3, [r7, #12]
2400425a:	681b      	ldr	r3, [r3, #0]
2400425c:	4a2b      	ldr	r2, [pc, #172]	; (2400430c <HAL_DMA_Start_IT+0x494>)
2400425e:	4293      	cmp	r3, r2
24004260:	d022      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004262:	68fb      	ldr	r3, [r7, #12]
24004264:	681b      	ldr	r3, [r3, #0]
24004266:	4a2a      	ldr	r2, [pc, #168]	; (24004310 <HAL_DMA_Start_IT+0x498>)
24004268:	4293      	cmp	r3, r2
2400426a:	d01d      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
2400426c:	68fb      	ldr	r3, [r7, #12]
2400426e:	681b      	ldr	r3, [r3, #0]
24004270:	4a28      	ldr	r2, [pc, #160]	; (24004314 <HAL_DMA_Start_IT+0x49c>)
24004272:	4293      	cmp	r3, r2
24004274:	d018      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004276:	68fb      	ldr	r3, [r7, #12]
24004278:	681b      	ldr	r3, [r3, #0]
2400427a:	4a27      	ldr	r2, [pc, #156]	; (24004318 <HAL_DMA_Start_IT+0x4a0>)
2400427c:	4293      	cmp	r3, r2
2400427e:	d013      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004280:	68fb      	ldr	r3, [r7, #12]
24004282:	681b      	ldr	r3, [r3, #0]
24004284:	4a25      	ldr	r2, [pc, #148]	; (2400431c <HAL_DMA_Start_IT+0x4a4>)
24004286:	4293      	cmp	r3, r2
24004288:	d00e      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
2400428a:	68fb      	ldr	r3, [r7, #12]
2400428c:	681b      	ldr	r3, [r3, #0]
2400428e:	4a24      	ldr	r2, [pc, #144]	; (24004320 <HAL_DMA_Start_IT+0x4a8>)
24004290:	4293      	cmp	r3, r2
24004292:	d009      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
24004294:	68fb      	ldr	r3, [r7, #12]
24004296:	681b      	ldr	r3, [r3, #0]
24004298:	4a22      	ldr	r2, [pc, #136]	; (24004324 <HAL_DMA_Start_IT+0x4ac>)
2400429a:	4293      	cmp	r3, r2
2400429c:	d004      	beq.n	240042a8 <HAL_DMA_Start_IT+0x430>
2400429e:	68fb      	ldr	r3, [r7, #12]
240042a0:	681b      	ldr	r3, [r3, #0]
240042a2:	4a21      	ldr	r2, [pc, #132]	; (24004328 <HAL_DMA_Start_IT+0x4b0>)
240042a4:	4293      	cmp	r3, r2
240042a6:	d108      	bne.n	240042ba <HAL_DMA_Start_IT+0x442>
240042a8:	68fb      	ldr	r3, [r7, #12]
240042aa:	681b      	ldr	r3, [r3, #0]
240042ac:	681a      	ldr	r2, [r3, #0]
240042ae:	68fb      	ldr	r3, [r7, #12]
240042b0:	681b      	ldr	r3, [r3, #0]
240042b2:	f042 0201 	orr.w	r2, r2, #1
240042b6:	601a      	str	r2, [r3, #0]
240042b8:	e012      	b.n	240042e0 <HAL_DMA_Start_IT+0x468>
240042ba:	68fb      	ldr	r3, [r7, #12]
240042bc:	681b      	ldr	r3, [r3, #0]
240042be:	681a      	ldr	r2, [r3, #0]
240042c0:	68fb      	ldr	r3, [r7, #12]
240042c2:	681b      	ldr	r3, [r3, #0]
240042c4:	f042 0201 	orr.w	r2, r2, #1
240042c8:	601a      	str	r2, [r3, #0]
240042ca:	e009      	b.n	240042e0 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240042cc:	68fb      	ldr	r3, [r7, #12]
240042ce:	f44f 6200 	mov.w	r2, #2048	; 0x800
240042d2:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
240042d4:	68fb      	ldr	r3, [r7, #12]
240042d6:	2200      	movs	r2, #0
240042d8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Return error status */
    status = HAL_ERROR;
240042dc:	2301      	movs	r3, #1
240042de:	75fb      	strb	r3, [r7, #23]
  }

  return status;
240042e0:	7dfb      	ldrb	r3, [r7, #23]
}
240042e2:	4618      	mov	r0, r3
240042e4:	3718      	adds	r7, #24
240042e6:	46bd      	mov	sp, r7
240042e8:	bd80      	pop	{r7, pc}
240042ea:	bf00      	nop
240042ec:	40020010 	.word	0x40020010
240042f0:	40020028 	.word	0x40020028
240042f4:	40020040 	.word	0x40020040
240042f8:	40020058 	.word	0x40020058
240042fc:	40020070 	.word	0x40020070
24004300:	40020088 	.word	0x40020088
24004304:	400200a0 	.word	0x400200a0
24004308:	400200b8 	.word	0x400200b8
2400430c:	40020410 	.word	0x40020410
24004310:	40020428 	.word	0x40020428
24004314:	40020440 	.word	0x40020440
24004318:	40020458 	.word	0x40020458
2400431c:	40020470 	.word	0x40020470
24004320:	40020488 	.word	0x40020488
24004324:	400204a0 	.word	0x400204a0
24004328:	400204b8 	.word	0x400204b8
2400432c:	58025408 	.word	0x58025408
24004330:	5802541c 	.word	0x5802541c
24004334:	58025430 	.word	0x58025430
24004338:	58025444 	.word	0x58025444
2400433c:	58025458 	.word	0x58025458
24004340:	5802546c 	.word	0x5802546c
24004344:	58025480 	.word	0x58025480
24004348:	58025494 	.word	0x58025494

2400434c <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
2400434c:	b580      	push	{r7, lr}
2400434e:	b086      	sub	sp, #24
24004350:	af00      	add	r7, sp, #0
24004352:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;
  const __IO uint32_t *enableRegister;

  uint32_t tickstart = HAL_GetTick();
24004354:	f7fd fff6 	bl	24002344 <HAL_GetTick>
24004358:	6138      	str	r0, [r7, #16]

 /* Check the DMA peripheral handle */
  if(hdma == NULL)
2400435a:	687b      	ldr	r3, [r7, #4]
2400435c:	2b00      	cmp	r3, #0
2400435e:	d101      	bne.n	24004364 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
24004360:	2301      	movs	r3, #1
24004362:	e2dc      	b.n	2400491e <HAL_DMA_Abort+0x5d2>
  }

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
24004364:	687b      	ldr	r3, [r7, #4]
24004366:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400436a:	b2db      	uxtb	r3, r3
2400436c:	2b02      	cmp	r3, #2
2400436e:	d008      	beq.n	24004382 <HAL_DMA_Abort+0x36>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24004370:	687b      	ldr	r3, [r7, #4]
24004372:	2280      	movs	r2, #128	; 0x80
24004374:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24004376:	687b      	ldr	r3, [r7, #4]
24004378:	2200      	movs	r2, #0
2400437a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
2400437e:	2301      	movs	r3, #1
24004380:	e2cd      	b.n	2400491e <HAL_DMA_Abort+0x5d2>
  }
  else
  {
    /* Disable all the transfer interrupts */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004382:	687b      	ldr	r3, [r7, #4]
24004384:	681b      	ldr	r3, [r3, #0]
24004386:	4a76      	ldr	r2, [pc, #472]	; (24004560 <HAL_DMA_Abort+0x214>)
24004388:	4293      	cmp	r3, r2
2400438a:	d04a      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
2400438c:	687b      	ldr	r3, [r7, #4]
2400438e:	681b      	ldr	r3, [r3, #0]
24004390:	4a74      	ldr	r2, [pc, #464]	; (24004564 <HAL_DMA_Abort+0x218>)
24004392:	4293      	cmp	r3, r2
24004394:	d045      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
24004396:	687b      	ldr	r3, [r7, #4]
24004398:	681b      	ldr	r3, [r3, #0]
2400439a:	4a73      	ldr	r2, [pc, #460]	; (24004568 <HAL_DMA_Abort+0x21c>)
2400439c:	4293      	cmp	r3, r2
2400439e:	d040      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043a0:	687b      	ldr	r3, [r7, #4]
240043a2:	681b      	ldr	r3, [r3, #0]
240043a4:	4a71      	ldr	r2, [pc, #452]	; (2400456c <HAL_DMA_Abort+0x220>)
240043a6:	4293      	cmp	r3, r2
240043a8:	d03b      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043aa:	687b      	ldr	r3, [r7, #4]
240043ac:	681b      	ldr	r3, [r3, #0]
240043ae:	4a70      	ldr	r2, [pc, #448]	; (24004570 <HAL_DMA_Abort+0x224>)
240043b0:	4293      	cmp	r3, r2
240043b2:	d036      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043b4:	687b      	ldr	r3, [r7, #4]
240043b6:	681b      	ldr	r3, [r3, #0]
240043b8:	4a6e      	ldr	r2, [pc, #440]	; (24004574 <HAL_DMA_Abort+0x228>)
240043ba:	4293      	cmp	r3, r2
240043bc:	d031      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043be:	687b      	ldr	r3, [r7, #4]
240043c0:	681b      	ldr	r3, [r3, #0]
240043c2:	4a6d      	ldr	r2, [pc, #436]	; (24004578 <HAL_DMA_Abort+0x22c>)
240043c4:	4293      	cmp	r3, r2
240043c6:	d02c      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043c8:	687b      	ldr	r3, [r7, #4]
240043ca:	681b      	ldr	r3, [r3, #0]
240043cc:	4a6b      	ldr	r2, [pc, #428]	; (2400457c <HAL_DMA_Abort+0x230>)
240043ce:	4293      	cmp	r3, r2
240043d0:	d027      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043d2:	687b      	ldr	r3, [r7, #4]
240043d4:	681b      	ldr	r3, [r3, #0]
240043d6:	4a6a      	ldr	r2, [pc, #424]	; (24004580 <HAL_DMA_Abort+0x234>)
240043d8:	4293      	cmp	r3, r2
240043da:	d022      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043dc:	687b      	ldr	r3, [r7, #4]
240043de:	681b      	ldr	r3, [r3, #0]
240043e0:	4a68      	ldr	r2, [pc, #416]	; (24004584 <HAL_DMA_Abort+0x238>)
240043e2:	4293      	cmp	r3, r2
240043e4:	d01d      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043e6:	687b      	ldr	r3, [r7, #4]
240043e8:	681b      	ldr	r3, [r3, #0]
240043ea:	4a67      	ldr	r2, [pc, #412]	; (24004588 <HAL_DMA_Abort+0x23c>)
240043ec:	4293      	cmp	r3, r2
240043ee:	d018      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043f0:	687b      	ldr	r3, [r7, #4]
240043f2:	681b      	ldr	r3, [r3, #0]
240043f4:	4a65      	ldr	r2, [pc, #404]	; (2400458c <HAL_DMA_Abort+0x240>)
240043f6:	4293      	cmp	r3, r2
240043f8:	d013      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
240043fa:	687b      	ldr	r3, [r7, #4]
240043fc:	681b      	ldr	r3, [r3, #0]
240043fe:	4a64      	ldr	r2, [pc, #400]	; (24004590 <HAL_DMA_Abort+0x244>)
24004400:	4293      	cmp	r3, r2
24004402:	d00e      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
24004404:	687b      	ldr	r3, [r7, #4]
24004406:	681b      	ldr	r3, [r3, #0]
24004408:	4a62      	ldr	r2, [pc, #392]	; (24004594 <HAL_DMA_Abort+0x248>)
2400440a:	4293      	cmp	r3, r2
2400440c:	d009      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
2400440e:	687b      	ldr	r3, [r7, #4]
24004410:	681b      	ldr	r3, [r3, #0]
24004412:	4a61      	ldr	r2, [pc, #388]	; (24004598 <HAL_DMA_Abort+0x24c>)
24004414:	4293      	cmp	r3, r2
24004416:	d004      	beq.n	24004422 <HAL_DMA_Abort+0xd6>
24004418:	687b      	ldr	r3, [r7, #4]
2400441a:	681b      	ldr	r3, [r3, #0]
2400441c:	4a5f      	ldr	r2, [pc, #380]	; (2400459c <HAL_DMA_Abort+0x250>)
2400441e:	4293      	cmp	r3, r2
24004420:	d101      	bne.n	24004426 <HAL_DMA_Abort+0xda>
24004422:	2301      	movs	r3, #1
24004424:	e000      	b.n	24004428 <HAL_DMA_Abort+0xdc>
24004426:	2300      	movs	r3, #0
24004428:	2b00      	cmp	r3, #0
2400442a:	d013      	beq.n	24004454 <HAL_DMA_Abort+0x108>
    {
       /* Disable DMA All Interrupts  */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
2400442c:	687b      	ldr	r3, [r7, #4]
2400442e:	681b      	ldr	r3, [r3, #0]
24004430:	681a      	ldr	r2, [r3, #0]
24004432:	687b      	ldr	r3, [r7, #4]
24004434:	681b      	ldr	r3, [r3, #0]
24004436:	f022 021e 	bic.w	r2, r2, #30
2400443a:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
2400443c:	687b      	ldr	r3, [r7, #4]
2400443e:	681b      	ldr	r3, [r3, #0]
24004440:	695a      	ldr	r2, [r3, #20]
24004442:	687b      	ldr	r3, [r7, #4]
24004444:	681b      	ldr	r3, [r3, #0]
24004446:	f022 0280 	bic.w	r2, r2, #128	; 0x80
2400444a:	615a      	str	r2, [r3, #20]

      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
2400444c:	687b      	ldr	r3, [r7, #4]
2400444e:	681b      	ldr	r3, [r3, #0]
24004450:	617b      	str	r3, [r7, #20]
24004452:	e00a      	b.n	2400446a <HAL_DMA_Abort+0x11e>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
24004454:	687b      	ldr	r3, [r7, #4]
24004456:	681b      	ldr	r3, [r3, #0]
24004458:	681a      	ldr	r2, [r3, #0]
2400445a:	687b      	ldr	r3, [r7, #4]
2400445c:	681b      	ldr	r3, [r3, #0]
2400445e:	f022 020e 	bic.w	r2, r2, #14
24004462:	601a      	str	r2, [r3, #0]

      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
24004464:	687b      	ldr	r3, [r7, #4]
24004466:	681b      	ldr	r3, [r3, #0]
24004468:	617b      	str	r3, [r7, #20]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400446a:	687b      	ldr	r3, [r7, #4]
2400446c:	681b      	ldr	r3, [r3, #0]
2400446e:	4a3c      	ldr	r2, [pc, #240]	; (24004560 <HAL_DMA_Abort+0x214>)
24004470:	4293      	cmp	r3, r2
24004472:	d072      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004474:	687b      	ldr	r3, [r7, #4]
24004476:	681b      	ldr	r3, [r3, #0]
24004478:	4a3a      	ldr	r2, [pc, #232]	; (24004564 <HAL_DMA_Abort+0x218>)
2400447a:	4293      	cmp	r3, r2
2400447c:	d06d      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
2400447e:	687b      	ldr	r3, [r7, #4]
24004480:	681b      	ldr	r3, [r3, #0]
24004482:	4a39      	ldr	r2, [pc, #228]	; (24004568 <HAL_DMA_Abort+0x21c>)
24004484:	4293      	cmp	r3, r2
24004486:	d068      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004488:	687b      	ldr	r3, [r7, #4]
2400448a:	681b      	ldr	r3, [r3, #0]
2400448c:	4a37      	ldr	r2, [pc, #220]	; (2400456c <HAL_DMA_Abort+0x220>)
2400448e:	4293      	cmp	r3, r2
24004490:	d063      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004492:	687b      	ldr	r3, [r7, #4]
24004494:	681b      	ldr	r3, [r3, #0]
24004496:	4a36      	ldr	r2, [pc, #216]	; (24004570 <HAL_DMA_Abort+0x224>)
24004498:	4293      	cmp	r3, r2
2400449a:	d05e      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
2400449c:	687b      	ldr	r3, [r7, #4]
2400449e:	681b      	ldr	r3, [r3, #0]
240044a0:	4a34      	ldr	r2, [pc, #208]	; (24004574 <HAL_DMA_Abort+0x228>)
240044a2:	4293      	cmp	r3, r2
240044a4:	d059      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044a6:	687b      	ldr	r3, [r7, #4]
240044a8:	681b      	ldr	r3, [r3, #0]
240044aa:	4a33      	ldr	r2, [pc, #204]	; (24004578 <HAL_DMA_Abort+0x22c>)
240044ac:	4293      	cmp	r3, r2
240044ae:	d054      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044b0:	687b      	ldr	r3, [r7, #4]
240044b2:	681b      	ldr	r3, [r3, #0]
240044b4:	4a31      	ldr	r2, [pc, #196]	; (2400457c <HAL_DMA_Abort+0x230>)
240044b6:	4293      	cmp	r3, r2
240044b8:	d04f      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044ba:	687b      	ldr	r3, [r7, #4]
240044bc:	681b      	ldr	r3, [r3, #0]
240044be:	4a30      	ldr	r2, [pc, #192]	; (24004580 <HAL_DMA_Abort+0x234>)
240044c0:	4293      	cmp	r3, r2
240044c2:	d04a      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044c4:	687b      	ldr	r3, [r7, #4]
240044c6:	681b      	ldr	r3, [r3, #0]
240044c8:	4a2e      	ldr	r2, [pc, #184]	; (24004584 <HAL_DMA_Abort+0x238>)
240044ca:	4293      	cmp	r3, r2
240044cc:	d045      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044ce:	687b      	ldr	r3, [r7, #4]
240044d0:	681b      	ldr	r3, [r3, #0]
240044d2:	4a2d      	ldr	r2, [pc, #180]	; (24004588 <HAL_DMA_Abort+0x23c>)
240044d4:	4293      	cmp	r3, r2
240044d6:	d040      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044d8:	687b      	ldr	r3, [r7, #4]
240044da:	681b      	ldr	r3, [r3, #0]
240044dc:	4a2b      	ldr	r2, [pc, #172]	; (2400458c <HAL_DMA_Abort+0x240>)
240044de:	4293      	cmp	r3, r2
240044e0:	d03b      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044e2:	687b      	ldr	r3, [r7, #4]
240044e4:	681b      	ldr	r3, [r3, #0]
240044e6:	4a2a      	ldr	r2, [pc, #168]	; (24004590 <HAL_DMA_Abort+0x244>)
240044e8:	4293      	cmp	r3, r2
240044ea:	d036      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044ec:	687b      	ldr	r3, [r7, #4]
240044ee:	681b      	ldr	r3, [r3, #0]
240044f0:	4a28      	ldr	r2, [pc, #160]	; (24004594 <HAL_DMA_Abort+0x248>)
240044f2:	4293      	cmp	r3, r2
240044f4:	d031      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
240044f6:	687b      	ldr	r3, [r7, #4]
240044f8:	681b      	ldr	r3, [r3, #0]
240044fa:	4a27      	ldr	r2, [pc, #156]	; (24004598 <HAL_DMA_Abort+0x24c>)
240044fc:	4293      	cmp	r3, r2
240044fe:	d02c      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004500:	687b      	ldr	r3, [r7, #4]
24004502:	681b      	ldr	r3, [r3, #0]
24004504:	4a25      	ldr	r2, [pc, #148]	; (2400459c <HAL_DMA_Abort+0x250>)
24004506:	4293      	cmp	r3, r2
24004508:	d027      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
2400450a:	687b      	ldr	r3, [r7, #4]
2400450c:	681b      	ldr	r3, [r3, #0]
2400450e:	4a24      	ldr	r2, [pc, #144]	; (240045a0 <HAL_DMA_Abort+0x254>)
24004510:	4293      	cmp	r3, r2
24004512:	d022      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004514:	687b      	ldr	r3, [r7, #4]
24004516:	681b      	ldr	r3, [r3, #0]
24004518:	4a22      	ldr	r2, [pc, #136]	; (240045a4 <HAL_DMA_Abort+0x258>)
2400451a:	4293      	cmp	r3, r2
2400451c:	d01d      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
2400451e:	687b      	ldr	r3, [r7, #4]
24004520:	681b      	ldr	r3, [r3, #0]
24004522:	4a21      	ldr	r2, [pc, #132]	; (240045a8 <HAL_DMA_Abort+0x25c>)
24004524:	4293      	cmp	r3, r2
24004526:	d018      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004528:	687b      	ldr	r3, [r7, #4]
2400452a:	681b      	ldr	r3, [r3, #0]
2400452c:	4a1f      	ldr	r2, [pc, #124]	; (240045ac <HAL_DMA_Abort+0x260>)
2400452e:	4293      	cmp	r3, r2
24004530:	d013      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004532:	687b      	ldr	r3, [r7, #4]
24004534:	681b      	ldr	r3, [r3, #0]
24004536:	4a1e      	ldr	r2, [pc, #120]	; (240045b0 <HAL_DMA_Abort+0x264>)
24004538:	4293      	cmp	r3, r2
2400453a:	d00e      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
2400453c:	687b      	ldr	r3, [r7, #4]
2400453e:	681b      	ldr	r3, [r3, #0]
24004540:	4a1c      	ldr	r2, [pc, #112]	; (240045b4 <HAL_DMA_Abort+0x268>)
24004542:	4293      	cmp	r3, r2
24004544:	d009      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004546:	687b      	ldr	r3, [r7, #4]
24004548:	681b      	ldr	r3, [r3, #0]
2400454a:	4a1b      	ldr	r2, [pc, #108]	; (240045b8 <HAL_DMA_Abort+0x26c>)
2400454c:	4293      	cmp	r3, r2
2400454e:	d004      	beq.n	2400455a <HAL_DMA_Abort+0x20e>
24004550:	687b      	ldr	r3, [r7, #4]
24004552:	681b      	ldr	r3, [r3, #0]
24004554:	4a19      	ldr	r2, [pc, #100]	; (240045bc <HAL_DMA_Abort+0x270>)
24004556:	4293      	cmp	r3, r2
24004558:	d132      	bne.n	240045c0 <HAL_DMA_Abort+0x274>
2400455a:	2301      	movs	r3, #1
2400455c:	e031      	b.n	240045c2 <HAL_DMA_Abort+0x276>
2400455e:	bf00      	nop
24004560:	40020010 	.word	0x40020010
24004564:	40020028 	.word	0x40020028
24004568:	40020040 	.word	0x40020040
2400456c:	40020058 	.word	0x40020058
24004570:	40020070 	.word	0x40020070
24004574:	40020088 	.word	0x40020088
24004578:	400200a0 	.word	0x400200a0
2400457c:	400200b8 	.word	0x400200b8
24004580:	40020410 	.word	0x40020410
24004584:	40020428 	.word	0x40020428
24004588:	40020440 	.word	0x40020440
2400458c:	40020458 	.word	0x40020458
24004590:	40020470 	.word	0x40020470
24004594:	40020488 	.word	0x40020488
24004598:	400204a0 	.word	0x400204a0
2400459c:	400204b8 	.word	0x400204b8
240045a0:	58025408 	.word	0x58025408
240045a4:	5802541c 	.word	0x5802541c
240045a8:	58025430 	.word	0x58025430
240045ac:	58025444 	.word	0x58025444
240045b0:	58025458 	.word	0x58025458
240045b4:	5802546c 	.word	0x5802546c
240045b8:	58025480 	.word	0x58025480
240045bc:	58025494 	.word	0x58025494
240045c0:	2300      	movs	r3, #0
240045c2:	2b00      	cmp	r3, #0
240045c4:	d007      	beq.n	240045d6 <HAL_DMA_Abort+0x28a>
    {
      /* disable the DMAMUX sync overrun IT */
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
240045c6:	687b      	ldr	r3, [r7, #4]
240045c8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240045ca:	681a      	ldr	r2, [r3, #0]
240045cc:	687b      	ldr	r3, [r7, #4]
240045ce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240045d0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
240045d4:	601a      	str	r2, [r3, #0]
    }

    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
240045d6:	687b      	ldr	r3, [r7, #4]
240045d8:	681b      	ldr	r3, [r3, #0]
240045da:	4a6d      	ldr	r2, [pc, #436]	; (24004790 <HAL_DMA_Abort+0x444>)
240045dc:	4293      	cmp	r3, r2
240045de:	d04a      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
240045e0:	687b      	ldr	r3, [r7, #4]
240045e2:	681b      	ldr	r3, [r3, #0]
240045e4:	4a6b      	ldr	r2, [pc, #428]	; (24004794 <HAL_DMA_Abort+0x448>)
240045e6:	4293      	cmp	r3, r2
240045e8:	d045      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
240045ea:	687b      	ldr	r3, [r7, #4]
240045ec:	681b      	ldr	r3, [r3, #0]
240045ee:	4a6a      	ldr	r2, [pc, #424]	; (24004798 <HAL_DMA_Abort+0x44c>)
240045f0:	4293      	cmp	r3, r2
240045f2:	d040      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
240045f4:	687b      	ldr	r3, [r7, #4]
240045f6:	681b      	ldr	r3, [r3, #0]
240045f8:	4a68      	ldr	r2, [pc, #416]	; (2400479c <HAL_DMA_Abort+0x450>)
240045fa:	4293      	cmp	r3, r2
240045fc:	d03b      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
240045fe:	687b      	ldr	r3, [r7, #4]
24004600:	681b      	ldr	r3, [r3, #0]
24004602:	4a67      	ldr	r2, [pc, #412]	; (240047a0 <HAL_DMA_Abort+0x454>)
24004604:	4293      	cmp	r3, r2
24004606:	d036      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
24004608:	687b      	ldr	r3, [r7, #4]
2400460a:	681b      	ldr	r3, [r3, #0]
2400460c:	4a65      	ldr	r2, [pc, #404]	; (240047a4 <HAL_DMA_Abort+0x458>)
2400460e:	4293      	cmp	r3, r2
24004610:	d031      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
24004612:	687b      	ldr	r3, [r7, #4]
24004614:	681b      	ldr	r3, [r3, #0]
24004616:	4a64      	ldr	r2, [pc, #400]	; (240047a8 <HAL_DMA_Abort+0x45c>)
24004618:	4293      	cmp	r3, r2
2400461a:	d02c      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
2400461c:	687b      	ldr	r3, [r7, #4]
2400461e:	681b      	ldr	r3, [r3, #0]
24004620:	4a62      	ldr	r2, [pc, #392]	; (240047ac <HAL_DMA_Abort+0x460>)
24004622:	4293      	cmp	r3, r2
24004624:	d027      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
24004626:	687b      	ldr	r3, [r7, #4]
24004628:	681b      	ldr	r3, [r3, #0]
2400462a:	4a61      	ldr	r2, [pc, #388]	; (240047b0 <HAL_DMA_Abort+0x464>)
2400462c:	4293      	cmp	r3, r2
2400462e:	d022      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
24004630:	687b      	ldr	r3, [r7, #4]
24004632:	681b      	ldr	r3, [r3, #0]
24004634:	4a5f      	ldr	r2, [pc, #380]	; (240047b4 <HAL_DMA_Abort+0x468>)
24004636:	4293      	cmp	r3, r2
24004638:	d01d      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
2400463a:	687b      	ldr	r3, [r7, #4]
2400463c:	681b      	ldr	r3, [r3, #0]
2400463e:	4a5e      	ldr	r2, [pc, #376]	; (240047b8 <HAL_DMA_Abort+0x46c>)
24004640:	4293      	cmp	r3, r2
24004642:	d018      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
24004644:	687b      	ldr	r3, [r7, #4]
24004646:	681b      	ldr	r3, [r3, #0]
24004648:	4a5c      	ldr	r2, [pc, #368]	; (240047bc <HAL_DMA_Abort+0x470>)
2400464a:	4293      	cmp	r3, r2
2400464c:	d013      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
2400464e:	687b      	ldr	r3, [r7, #4]
24004650:	681b      	ldr	r3, [r3, #0]
24004652:	4a5b      	ldr	r2, [pc, #364]	; (240047c0 <HAL_DMA_Abort+0x474>)
24004654:	4293      	cmp	r3, r2
24004656:	d00e      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
24004658:	687b      	ldr	r3, [r7, #4]
2400465a:	681b      	ldr	r3, [r3, #0]
2400465c:	4a59      	ldr	r2, [pc, #356]	; (240047c4 <HAL_DMA_Abort+0x478>)
2400465e:	4293      	cmp	r3, r2
24004660:	d009      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
24004662:	687b      	ldr	r3, [r7, #4]
24004664:	681b      	ldr	r3, [r3, #0]
24004666:	4a58      	ldr	r2, [pc, #352]	; (240047c8 <HAL_DMA_Abort+0x47c>)
24004668:	4293      	cmp	r3, r2
2400466a:	d004      	beq.n	24004676 <HAL_DMA_Abort+0x32a>
2400466c:	687b      	ldr	r3, [r7, #4]
2400466e:	681b      	ldr	r3, [r3, #0]
24004670:	4a56      	ldr	r2, [pc, #344]	; (240047cc <HAL_DMA_Abort+0x480>)
24004672:	4293      	cmp	r3, r2
24004674:	d108      	bne.n	24004688 <HAL_DMA_Abort+0x33c>
24004676:	687b      	ldr	r3, [r7, #4]
24004678:	681b      	ldr	r3, [r3, #0]
2400467a:	681a      	ldr	r2, [r3, #0]
2400467c:	687b      	ldr	r3, [r7, #4]
2400467e:	681b      	ldr	r3, [r3, #0]
24004680:	f022 0201 	bic.w	r2, r2, #1
24004684:	601a      	str	r2, [r3, #0]
24004686:	e007      	b.n	24004698 <HAL_DMA_Abort+0x34c>
24004688:	687b      	ldr	r3, [r7, #4]
2400468a:	681b      	ldr	r3, [r3, #0]
2400468c:	681a      	ldr	r2, [r3, #0]
2400468e:	687b      	ldr	r3, [r7, #4]
24004690:	681b      	ldr	r3, [r3, #0]
24004692:	f022 0201 	bic.w	r2, r2, #1
24004696:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
24004698:	e013      	b.n	240046c2 <HAL_DMA_Abort+0x376>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
2400469a:	f7fd fe53 	bl	24002344 <HAL_GetTick>
2400469e:	4602      	mov	r2, r0
240046a0:	693b      	ldr	r3, [r7, #16]
240046a2:	1ad3      	subs	r3, r2, r3
240046a4:	2b05      	cmp	r3, #5
240046a6:	d90c      	bls.n	240046c2 <HAL_DMA_Abort+0x376>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
240046a8:	687b      	ldr	r3, [r7, #4]
240046aa:	2220      	movs	r2, #32
240046ac:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
240046ae:	687b      	ldr	r3, [r7, #4]
240046b0:	2203      	movs	r2, #3
240046b2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
240046b6:	687b      	ldr	r3, [r7, #4]
240046b8:	2200      	movs	r2, #0
240046ba:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
240046be:	2301      	movs	r3, #1
240046c0:	e12d      	b.n	2400491e <HAL_DMA_Abort+0x5d2>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
240046c2:	697b      	ldr	r3, [r7, #20]
240046c4:	681b      	ldr	r3, [r3, #0]
240046c6:	f003 0301 	and.w	r3, r3, #1
240046ca:	2b00      	cmp	r3, #0
240046cc:	d1e5      	bne.n	2400469a <HAL_DMA_Abort+0x34e>
      }
    }

    /* Clear all interrupt flags at correct offset within the register */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240046ce:	687b      	ldr	r3, [r7, #4]
240046d0:	681b      	ldr	r3, [r3, #0]
240046d2:	4a2f      	ldr	r2, [pc, #188]	; (24004790 <HAL_DMA_Abort+0x444>)
240046d4:	4293      	cmp	r3, r2
240046d6:	d04a      	beq.n	2400476e <HAL_DMA_Abort+0x422>
240046d8:	687b      	ldr	r3, [r7, #4]
240046da:	681b      	ldr	r3, [r3, #0]
240046dc:	4a2d      	ldr	r2, [pc, #180]	; (24004794 <HAL_DMA_Abort+0x448>)
240046de:	4293      	cmp	r3, r2
240046e0:	d045      	beq.n	2400476e <HAL_DMA_Abort+0x422>
240046e2:	687b      	ldr	r3, [r7, #4]
240046e4:	681b      	ldr	r3, [r3, #0]
240046e6:	4a2c      	ldr	r2, [pc, #176]	; (24004798 <HAL_DMA_Abort+0x44c>)
240046e8:	4293      	cmp	r3, r2
240046ea:	d040      	beq.n	2400476e <HAL_DMA_Abort+0x422>
240046ec:	687b      	ldr	r3, [r7, #4]
240046ee:	681b      	ldr	r3, [r3, #0]
240046f0:	4a2a      	ldr	r2, [pc, #168]	; (2400479c <HAL_DMA_Abort+0x450>)
240046f2:	4293      	cmp	r3, r2
240046f4:	d03b      	beq.n	2400476e <HAL_DMA_Abort+0x422>
240046f6:	687b      	ldr	r3, [r7, #4]
240046f8:	681b      	ldr	r3, [r3, #0]
240046fa:	4a29      	ldr	r2, [pc, #164]	; (240047a0 <HAL_DMA_Abort+0x454>)
240046fc:	4293      	cmp	r3, r2
240046fe:	d036      	beq.n	2400476e <HAL_DMA_Abort+0x422>
24004700:	687b      	ldr	r3, [r7, #4]
24004702:	681b      	ldr	r3, [r3, #0]
24004704:	4a27      	ldr	r2, [pc, #156]	; (240047a4 <HAL_DMA_Abort+0x458>)
24004706:	4293      	cmp	r3, r2
24004708:	d031      	beq.n	2400476e <HAL_DMA_Abort+0x422>
2400470a:	687b      	ldr	r3, [r7, #4]
2400470c:	681b      	ldr	r3, [r3, #0]
2400470e:	4a26      	ldr	r2, [pc, #152]	; (240047a8 <HAL_DMA_Abort+0x45c>)
24004710:	4293      	cmp	r3, r2
24004712:	d02c      	beq.n	2400476e <HAL_DMA_Abort+0x422>
24004714:	687b      	ldr	r3, [r7, #4]
24004716:	681b      	ldr	r3, [r3, #0]
24004718:	4a24      	ldr	r2, [pc, #144]	; (240047ac <HAL_DMA_Abort+0x460>)
2400471a:	4293      	cmp	r3, r2
2400471c:	d027      	beq.n	2400476e <HAL_DMA_Abort+0x422>
2400471e:	687b      	ldr	r3, [r7, #4]
24004720:	681b      	ldr	r3, [r3, #0]
24004722:	4a23      	ldr	r2, [pc, #140]	; (240047b0 <HAL_DMA_Abort+0x464>)
24004724:	4293      	cmp	r3, r2
24004726:	d022      	beq.n	2400476e <HAL_DMA_Abort+0x422>
24004728:	687b      	ldr	r3, [r7, #4]
2400472a:	681b      	ldr	r3, [r3, #0]
2400472c:	4a21      	ldr	r2, [pc, #132]	; (240047b4 <HAL_DMA_Abort+0x468>)
2400472e:	4293      	cmp	r3, r2
24004730:	d01d      	beq.n	2400476e <HAL_DMA_Abort+0x422>
24004732:	687b      	ldr	r3, [r7, #4]
24004734:	681b      	ldr	r3, [r3, #0]
24004736:	4a20      	ldr	r2, [pc, #128]	; (240047b8 <HAL_DMA_Abort+0x46c>)
24004738:	4293      	cmp	r3, r2
2400473a:	d018      	beq.n	2400476e <HAL_DMA_Abort+0x422>
2400473c:	687b      	ldr	r3, [r7, #4]
2400473e:	681b      	ldr	r3, [r3, #0]
24004740:	4a1e      	ldr	r2, [pc, #120]	; (240047bc <HAL_DMA_Abort+0x470>)
24004742:	4293      	cmp	r3, r2
24004744:	d013      	beq.n	2400476e <HAL_DMA_Abort+0x422>
24004746:	687b      	ldr	r3, [r7, #4]
24004748:	681b      	ldr	r3, [r3, #0]
2400474a:	4a1d      	ldr	r2, [pc, #116]	; (240047c0 <HAL_DMA_Abort+0x474>)
2400474c:	4293      	cmp	r3, r2
2400474e:	d00e      	beq.n	2400476e <HAL_DMA_Abort+0x422>
24004750:	687b      	ldr	r3, [r7, #4]
24004752:	681b      	ldr	r3, [r3, #0]
24004754:	4a1b      	ldr	r2, [pc, #108]	; (240047c4 <HAL_DMA_Abort+0x478>)
24004756:	4293      	cmp	r3, r2
24004758:	d009      	beq.n	2400476e <HAL_DMA_Abort+0x422>
2400475a:	687b      	ldr	r3, [r7, #4]
2400475c:	681b      	ldr	r3, [r3, #0]
2400475e:	4a1a      	ldr	r2, [pc, #104]	; (240047c8 <HAL_DMA_Abort+0x47c>)
24004760:	4293      	cmp	r3, r2
24004762:	d004      	beq.n	2400476e <HAL_DMA_Abort+0x422>
24004764:	687b      	ldr	r3, [r7, #4]
24004766:	681b      	ldr	r3, [r3, #0]
24004768:	4a18      	ldr	r2, [pc, #96]	; (240047cc <HAL_DMA_Abort+0x480>)
2400476a:	4293      	cmp	r3, r2
2400476c:	d101      	bne.n	24004772 <HAL_DMA_Abort+0x426>
2400476e:	2301      	movs	r3, #1
24004770:	e000      	b.n	24004774 <HAL_DMA_Abort+0x428>
24004772:	2300      	movs	r3, #0
24004774:	2b00      	cmp	r3, #0
24004776:	d02b      	beq.n	240047d0 <HAL_DMA_Abort+0x484>
    {
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24004778:	687b      	ldr	r3, [r7, #4]
2400477a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400477c:	60bb      	str	r3, [r7, #8]
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400477e:	687b      	ldr	r3, [r7, #4]
24004780:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004782:	f003 031f 	and.w	r3, r3, #31
24004786:	223f      	movs	r2, #63	; 0x3f
24004788:	409a      	lsls	r2, r3
2400478a:	68bb      	ldr	r3, [r7, #8]
2400478c:	609a      	str	r2, [r3, #8]
2400478e:	e02a      	b.n	240047e6 <HAL_DMA_Abort+0x49a>
24004790:	40020010 	.word	0x40020010
24004794:	40020028 	.word	0x40020028
24004798:	40020040 	.word	0x40020040
2400479c:	40020058 	.word	0x40020058
240047a0:	40020070 	.word	0x40020070
240047a4:	40020088 	.word	0x40020088
240047a8:	400200a0 	.word	0x400200a0
240047ac:	400200b8 	.word	0x400200b8
240047b0:	40020410 	.word	0x40020410
240047b4:	40020428 	.word	0x40020428
240047b8:	40020440 	.word	0x40020440
240047bc:	40020458 	.word	0x40020458
240047c0:	40020470 	.word	0x40020470
240047c4:	40020488 	.word	0x40020488
240047c8:	400204a0 	.word	0x400204a0
240047cc:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
240047d0:	687b      	ldr	r3, [r7, #4]
240047d2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240047d4:	60fb      	str	r3, [r7, #12]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
240047d6:	687b      	ldr	r3, [r7, #4]
240047d8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240047da:	f003 031f 	and.w	r3, r3, #31
240047de:	2201      	movs	r2, #1
240047e0:	409a      	lsls	r2, r3
240047e2:	68fb      	ldr	r3, [r7, #12]
240047e4:	605a      	str	r2, [r3, #4]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240047e6:	687b      	ldr	r3, [r7, #4]
240047e8:	681b      	ldr	r3, [r3, #0]
240047ea:	4a4f      	ldr	r2, [pc, #316]	; (24004928 <HAL_DMA_Abort+0x5dc>)
240047ec:	4293      	cmp	r3, r2
240047ee:	d072      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
240047f0:	687b      	ldr	r3, [r7, #4]
240047f2:	681b      	ldr	r3, [r3, #0]
240047f4:	4a4d      	ldr	r2, [pc, #308]	; (2400492c <HAL_DMA_Abort+0x5e0>)
240047f6:	4293      	cmp	r3, r2
240047f8:	d06d      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
240047fa:	687b      	ldr	r3, [r7, #4]
240047fc:	681b      	ldr	r3, [r3, #0]
240047fe:	4a4c      	ldr	r2, [pc, #304]	; (24004930 <HAL_DMA_Abort+0x5e4>)
24004800:	4293      	cmp	r3, r2
24004802:	d068      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004804:	687b      	ldr	r3, [r7, #4]
24004806:	681b      	ldr	r3, [r3, #0]
24004808:	4a4a      	ldr	r2, [pc, #296]	; (24004934 <HAL_DMA_Abort+0x5e8>)
2400480a:	4293      	cmp	r3, r2
2400480c:	d063      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
2400480e:	687b      	ldr	r3, [r7, #4]
24004810:	681b      	ldr	r3, [r3, #0]
24004812:	4a49      	ldr	r2, [pc, #292]	; (24004938 <HAL_DMA_Abort+0x5ec>)
24004814:	4293      	cmp	r3, r2
24004816:	d05e      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004818:	687b      	ldr	r3, [r7, #4]
2400481a:	681b      	ldr	r3, [r3, #0]
2400481c:	4a47      	ldr	r2, [pc, #284]	; (2400493c <HAL_DMA_Abort+0x5f0>)
2400481e:	4293      	cmp	r3, r2
24004820:	d059      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004822:	687b      	ldr	r3, [r7, #4]
24004824:	681b      	ldr	r3, [r3, #0]
24004826:	4a46      	ldr	r2, [pc, #280]	; (24004940 <HAL_DMA_Abort+0x5f4>)
24004828:	4293      	cmp	r3, r2
2400482a:	d054      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
2400482c:	687b      	ldr	r3, [r7, #4]
2400482e:	681b      	ldr	r3, [r3, #0]
24004830:	4a44      	ldr	r2, [pc, #272]	; (24004944 <HAL_DMA_Abort+0x5f8>)
24004832:	4293      	cmp	r3, r2
24004834:	d04f      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004836:	687b      	ldr	r3, [r7, #4]
24004838:	681b      	ldr	r3, [r3, #0]
2400483a:	4a43      	ldr	r2, [pc, #268]	; (24004948 <HAL_DMA_Abort+0x5fc>)
2400483c:	4293      	cmp	r3, r2
2400483e:	d04a      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004840:	687b      	ldr	r3, [r7, #4]
24004842:	681b      	ldr	r3, [r3, #0]
24004844:	4a41      	ldr	r2, [pc, #260]	; (2400494c <HAL_DMA_Abort+0x600>)
24004846:	4293      	cmp	r3, r2
24004848:	d045      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
2400484a:	687b      	ldr	r3, [r7, #4]
2400484c:	681b      	ldr	r3, [r3, #0]
2400484e:	4a40      	ldr	r2, [pc, #256]	; (24004950 <HAL_DMA_Abort+0x604>)
24004850:	4293      	cmp	r3, r2
24004852:	d040      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004854:	687b      	ldr	r3, [r7, #4]
24004856:	681b      	ldr	r3, [r3, #0]
24004858:	4a3e      	ldr	r2, [pc, #248]	; (24004954 <HAL_DMA_Abort+0x608>)
2400485a:	4293      	cmp	r3, r2
2400485c:	d03b      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
2400485e:	687b      	ldr	r3, [r7, #4]
24004860:	681b      	ldr	r3, [r3, #0]
24004862:	4a3d      	ldr	r2, [pc, #244]	; (24004958 <HAL_DMA_Abort+0x60c>)
24004864:	4293      	cmp	r3, r2
24004866:	d036      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004868:	687b      	ldr	r3, [r7, #4]
2400486a:	681b      	ldr	r3, [r3, #0]
2400486c:	4a3b      	ldr	r2, [pc, #236]	; (2400495c <HAL_DMA_Abort+0x610>)
2400486e:	4293      	cmp	r3, r2
24004870:	d031      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004872:	687b      	ldr	r3, [r7, #4]
24004874:	681b      	ldr	r3, [r3, #0]
24004876:	4a3a      	ldr	r2, [pc, #232]	; (24004960 <HAL_DMA_Abort+0x614>)
24004878:	4293      	cmp	r3, r2
2400487a:	d02c      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
2400487c:	687b      	ldr	r3, [r7, #4]
2400487e:	681b      	ldr	r3, [r3, #0]
24004880:	4a38      	ldr	r2, [pc, #224]	; (24004964 <HAL_DMA_Abort+0x618>)
24004882:	4293      	cmp	r3, r2
24004884:	d027      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004886:	687b      	ldr	r3, [r7, #4]
24004888:	681b      	ldr	r3, [r3, #0]
2400488a:	4a37      	ldr	r2, [pc, #220]	; (24004968 <HAL_DMA_Abort+0x61c>)
2400488c:	4293      	cmp	r3, r2
2400488e:	d022      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
24004890:	687b      	ldr	r3, [r7, #4]
24004892:	681b      	ldr	r3, [r3, #0]
24004894:	4a35      	ldr	r2, [pc, #212]	; (2400496c <HAL_DMA_Abort+0x620>)
24004896:	4293      	cmp	r3, r2
24004898:	d01d      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
2400489a:	687b      	ldr	r3, [r7, #4]
2400489c:	681b      	ldr	r3, [r3, #0]
2400489e:	4a34      	ldr	r2, [pc, #208]	; (24004970 <HAL_DMA_Abort+0x624>)
240048a0:	4293      	cmp	r3, r2
240048a2:	d018      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
240048a4:	687b      	ldr	r3, [r7, #4]
240048a6:	681b      	ldr	r3, [r3, #0]
240048a8:	4a32      	ldr	r2, [pc, #200]	; (24004974 <HAL_DMA_Abort+0x628>)
240048aa:	4293      	cmp	r3, r2
240048ac:	d013      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
240048ae:	687b      	ldr	r3, [r7, #4]
240048b0:	681b      	ldr	r3, [r3, #0]
240048b2:	4a31      	ldr	r2, [pc, #196]	; (24004978 <HAL_DMA_Abort+0x62c>)
240048b4:	4293      	cmp	r3, r2
240048b6:	d00e      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
240048b8:	687b      	ldr	r3, [r7, #4]
240048ba:	681b      	ldr	r3, [r3, #0]
240048bc:	4a2f      	ldr	r2, [pc, #188]	; (2400497c <HAL_DMA_Abort+0x630>)
240048be:	4293      	cmp	r3, r2
240048c0:	d009      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
240048c2:	687b      	ldr	r3, [r7, #4]
240048c4:	681b      	ldr	r3, [r3, #0]
240048c6:	4a2e      	ldr	r2, [pc, #184]	; (24004980 <HAL_DMA_Abort+0x634>)
240048c8:	4293      	cmp	r3, r2
240048ca:	d004      	beq.n	240048d6 <HAL_DMA_Abort+0x58a>
240048cc:	687b      	ldr	r3, [r7, #4]
240048ce:	681b      	ldr	r3, [r3, #0]
240048d0:	4a2c      	ldr	r2, [pc, #176]	; (24004984 <HAL_DMA_Abort+0x638>)
240048d2:	4293      	cmp	r3, r2
240048d4:	d101      	bne.n	240048da <HAL_DMA_Abort+0x58e>
240048d6:	2301      	movs	r3, #1
240048d8:	e000      	b.n	240048dc <HAL_DMA_Abort+0x590>
240048da:	2300      	movs	r3, #0
240048dc:	2b00      	cmp	r3, #0
240048de:	d015      	beq.n	2400490c <HAL_DMA_Abort+0x5c0>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240048e0:	687b      	ldr	r3, [r7, #4]
240048e2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240048e4:	687a      	ldr	r2, [r7, #4]
240048e6:	6e92      	ldr	r2, [r2, #104]	; 0x68
240048e8:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
240048ea:	687b      	ldr	r3, [r7, #4]
240048ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240048ee:	2b00      	cmp	r3, #0
240048f0:	d00c      	beq.n	2400490c <HAL_DMA_Abort+0x5c0>
      {
        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */
        /* disable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
240048f2:	687b      	ldr	r3, [r7, #4]
240048f4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240048f6:	681a      	ldr	r2, [r3, #0]
240048f8:	687b      	ldr	r3, [r7, #4]
240048fa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240048fc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24004900:	601a      	str	r2, [r3, #0]

        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24004902:	687b      	ldr	r3, [r7, #4]
24004904:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24004906:	687a      	ldr	r2, [r7, #4]
24004908:	6f52      	ldr	r2, [r2, #116]	; 0x74
2400490a:	605a      	str	r2, [r3, #4]
      }
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
2400490c:	687b      	ldr	r3, [r7, #4]
2400490e:	2201      	movs	r2, #1
24004910:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24004914:	687b      	ldr	r3, [r7, #4]
24004916:	2200      	movs	r2, #0
24004918:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  }

  return HAL_OK;
2400491c:	2300      	movs	r3, #0
}
2400491e:	4618      	mov	r0, r3
24004920:	3718      	adds	r7, #24
24004922:	46bd      	mov	sp, r7
24004924:	bd80      	pop	{r7, pc}
24004926:	bf00      	nop
24004928:	40020010 	.word	0x40020010
2400492c:	40020028 	.word	0x40020028
24004930:	40020040 	.word	0x40020040
24004934:	40020058 	.word	0x40020058
24004938:	40020070 	.word	0x40020070
2400493c:	40020088 	.word	0x40020088
24004940:	400200a0 	.word	0x400200a0
24004944:	400200b8 	.word	0x400200b8
24004948:	40020410 	.word	0x40020410
2400494c:	40020428 	.word	0x40020428
24004950:	40020440 	.word	0x40020440
24004954:	40020458 	.word	0x40020458
24004958:	40020470 	.word	0x40020470
2400495c:	40020488 	.word	0x40020488
24004960:	400204a0 	.word	0x400204a0
24004964:	400204b8 	.word	0x400204b8
24004968:	58025408 	.word	0x58025408
2400496c:	5802541c 	.word	0x5802541c
24004970:	58025430 	.word	0x58025430
24004974:	58025444 	.word	0x58025444
24004978:	58025458 	.word	0x58025458
2400497c:	5802546c 	.word	0x5802546c
24004980:	58025480 	.word	0x58025480
24004984:	58025494 	.word	0x58025494

24004988 <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
24004988:	b580      	push	{r7, lr}
2400498a:	b084      	sub	sp, #16
2400498c:	af00      	add	r7, sp, #0
2400498e:	6078      	str	r0, [r7, #4]
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004990:	687b      	ldr	r3, [r7, #4]
24004992:	2b00      	cmp	r3, #0
24004994:	d101      	bne.n	2400499a <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
24004996:	2301      	movs	r3, #1
24004998:	e237      	b.n	24004e0a <HAL_DMA_Abort_IT+0x482>
  }

  if(hdma->State != HAL_DMA_STATE_BUSY)
2400499a:	687b      	ldr	r3, [r7, #4]
2400499c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240049a0:	b2db      	uxtb	r3, r3
240049a2:	2b02      	cmp	r3, #2
240049a4:	d004      	beq.n	240049b0 <HAL_DMA_Abort_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
240049a6:	687b      	ldr	r3, [r7, #4]
240049a8:	2280      	movs	r2, #128	; 0x80
240049aa:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
240049ac:	2301      	movs	r3, #1
240049ae:	e22c      	b.n	24004e0a <HAL_DMA_Abort_IT+0x482>
  }
  else
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240049b0:	687b      	ldr	r3, [r7, #4]
240049b2:	681b      	ldr	r3, [r3, #0]
240049b4:	4a5c      	ldr	r2, [pc, #368]	; (24004b28 <HAL_DMA_Abort_IT+0x1a0>)
240049b6:	4293      	cmp	r3, r2
240049b8:	d04a      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
240049ba:	687b      	ldr	r3, [r7, #4]
240049bc:	681b      	ldr	r3, [r3, #0]
240049be:	4a5b      	ldr	r2, [pc, #364]	; (24004b2c <HAL_DMA_Abort_IT+0x1a4>)
240049c0:	4293      	cmp	r3, r2
240049c2:	d045      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
240049c4:	687b      	ldr	r3, [r7, #4]
240049c6:	681b      	ldr	r3, [r3, #0]
240049c8:	4a59      	ldr	r2, [pc, #356]	; (24004b30 <HAL_DMA_Abort_IT+0x1a8>)
240049ca:	4293      	cmp	r3, r2
240049cc:	d040      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
240049ce:	687b      	ldr	r3, [r7, #4]
240049d0:	681b      	ldr	r3, [r3, #0]
240049d2:	4a58      	ldr	r2, [pc, #352]	; (24004b34 <HAL_DMA_Abort_IT+0x1ac>)
240049d4:	4293      	cmp	r3, r2
240049d6:	d03b      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
240049d8:	687b      	ldr	r3, [r7, #4]
240049da:	681b      	ldr	r3, [r3, #0]
240049dc:	4a56      	ldr	r2, [pc, #344]	; (24004b38 <HAL_DMA_Abort_IT+0x1b0>)
240049de:	4293      	cmp	r3, r2
240049e0:	d036      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
240049e2:	687b      	ldr	r3, [r7, #4]
240049e4:	681b      	ldr	r3, [r3, #0]
240049e6:	4a55      	ldr	r2, [pc, #340]	; (24004b3c <HAL_DMA_Abort_IT+0x1b4>)
240049e8:	4293      	cmp	r3, r2
240049ea:	d031      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
240049ec:	687b      	ldr	r3, [r7, #4]
240049ee:	681b      	ldr	r3, [r3, #0]
240049f0:	4a53      	ldr	r2, [pc, #332]	; (24004b40 <HAL_DMA_Abort_IT+0x1b8>)
240049f2:	4293      	cmp	r3, r2
240049f4:	d02c      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
240049f6:	687b      	ldr	r3, [r7, #4]
240049f8:	681b      	ldr	r3, [r3, #0]
240049fa:	4a52      	ldr	r2, [pc, #328]	; (24004b44 <HAL_DMA_Abort_IT+0x1bc>)
240049fc:	4293      	cmp	r3, r2
240049fe:	d027      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a00:	687b      	ldr	r3, [r7, #4]
24004a02:	681b      	ldr	r3, [r3, #0]
24004a04:	4a50      	ldr	r2, [pc, #320]	; (24004b48 <HAL_DMA_Abort_IT+0x1c0>)
24004a06:	4293      	cmp	r3, r2
24004a08:	d022      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a0a:	687b      	ldr	r3, [r7, #4]
24004a0c:	681b      	ldr	r3, [r3, #0]
24004a0e:	4a4f      	ldr	r2, [pc, #316]	; (24004b4c <HAL_DMA_Abort_IT+0x1c4>)
24004a10:	4293      	cmp	r3, r2
24004a12:	d01d      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a14:	687b      	ldr	r3, [r7, #4]
24004a16:	681b      	ldr	r3, [r3, #0]
24004a18:	4a4d      	ldr	r2, [pc, #308]	; (24004b50 <HAL_DMA_Abort_IT+0x1c8>)
24004a1a:	4293      	cmp	r3, r2
24004a1c:	d018      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a1e:	687b      	ldr	r3, [r7, #4]
24004a20:	681b      	ldr	r3, [r3, #0]
24004a22:	4a4c      	ldr	r2, [pc, #304]	; (24004b54 <HAL_DMA_Abort_IT+0x1cc>)
24004a24:	4293      	cmp	r3, r2
24004a26:	d013      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a28:	687b      	ldr	r3, [r7, #4]
24004a2a:	681b      	ldr	r3, [r3, #0]
24004a2c:	4a4a      	ldr	r2, [pc, #296]	; (24004b58 <HAL_DMA_Abort_IT+0x1d0>)
24004a2e:	4293      	cmp	r3, r2
24004a30:	d00e      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a32:	687b      	ldr	r3, [r7, #4]
24004a34:	681b      	ldr	r3, [r3, #0]
24004a36:	4a49      	ldr	r2, [pc, #292]	; (24004b5c <HAL_DMA_Abort_IT+0x1d4>)
24004a38:	4293      	cmp	r3, r2
24004a3a:	d009      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a3c:	687b      	ldr	r3, [r7, #4]
24004a3e:	681b      	ldr	r3, [r3, #0]
24004a40:	4a47      	ldr	r2, [pc, #284]	; (24004b60 <HAL_DMA_Abort_IT+0x1d8>)
24004a42:	4293      	cmp	r3, r2
24004a44:	d004      	beq.n	24004a50 <HAL_DMA_Abort_IT+0xc8>
24004a46:	687b      	ldr	r3, [r7, #4]
24004a48:	681b      	ldr	r3, [r3, #0]
24004a4a:	4a46      	ldr	r2, [pc, #280]	; (24004b64 <HAL_DMA_Abort_IT+0x1dc>)
24004a4c:	4293      	cmp	r3, r2
24004a4e:	d101      	bne.n	24004a54 <HAL_DMA_Abort_IT+0xcc>
24004a50:	2301      	movs	r3, #1
24004a52:	e000      	b.n	24004a56 <HAL_DMA_Abort_IT+0xce>
24004a54:	2300      	movs	r3, #0
24004a56:	2b00      	cmp	r3, #0
24004a58:	f000 8086 	beq.w	24004b68 <HAL_DMA_Abort_IT+0x1e0>
    {
      /* Set Abort State  */
      hdma->State = HAL_DMA_STATE_ABORT;
24004a5c:	687b      	ldr	r3, [r7, #4]
24004a5e:	2204      	movs	r2, #4
24004a60:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
24004a64:	687b      	ldr	r3, [r7, #4]
24004a66:	681b      	ldr	r3, [r3, #0]
24004a68:	4a2f      	ldr	r2, [pc, #188]	; (24004b28 <HAL_DMA_Abort_IT+0x1a0>)
24004a6a:	4293      	cmp	r3, r2
24004a6c:	d04a      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004a6e:	687b      	ldr	r3, [r7, #4]
24004a70:	681b      	ldr	r3, [r3, #0]
24004a72:	4a2e      	ldr	r2, [pc, #184]	; (24004b2c <HAL_DMA_Abort_IT+0x1a4>)
24004a74:	4293      	cmp	r3, r2
24004a76:	d045      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004a78:	687b      	ldr	r3, [r7, #4]
24004a7a:	681b      	ldr	r3, [r3, #0]
24004a7c:	4a2c      	ldr	r2, [pc, #176]	; (24004b30 <HAL_DMA_Abort_IT+0x1a8>)
24004a7e:	4293      	cmp	r3, r2
24004a80:	d040      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004a82:	687b      	ldr	r3, [r7, #4]
24004a84:	681b      	ldr	r3, [r3, #0]
24004a86:	4a2b      	ldr	r2, [pc, #172]	; (24004b34 <HAL_DMA_Abort_IT+0x1ac>)
24004a88:	4293      	cmp	r3, r2
24004a8a:	d03b      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004a8c:	687b      	ldr	r3, [r7, #4]
24004a8e:	681b      	ldr	r3, [r3, #0]
24004a90:	4a29      	ldr	r2, [pc, #164]	; (24004b38 <HAL_DMA_Abort_IT+0x1b0>)
24004a92:	4293      	cmp	r3, r2
24004a94:	d036      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004a96:	687b      	ldr	r3, [r7, #4]
24004a98:	681b      	ldr	r3, [r3, #0]
24004a9a:	4a28      	ldr	r2, [pc, #160]	; (24004b3c <HAL_DMA_Abort_IT+0x1b4>)
24004a9c:	4293      	cmp	r3, r2
24004a9e:	d031      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004aa0:	687b      	ldr	r3, [r7, #4]
24004aa2:	681b      	ldr	r3, [r3, #0]
24004aa4:	4a26      	ldr	r2, [pc, #152]	; (24004b40 <HAL_DMA_Abort_IT+0x1b8>)
24004aa6:	4293      	cmp	r3, r2
24004aa8:	d02c      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004aaa:	687b      	ldr	r3, [r7, #4]
24004aac:	681b      	ldr	r3, [r3, #0]
24004aae:	4a25      	ldr	r2, [pc, #148]	; (24004b44 <HAL_DMA_Abort_IT+0x1bc>)
24004ab0:	4293      	cmp	r3, r2
24004ab2:	d027      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004ab4:	687b      	ldr	r3, [r7, #4]
24004ab6:	681b      	ldr	r3, [r3, #0]
24004ab8:	4a23      	ldr	r2, [pc, #140]	; (24004b48 <HAL_DMA_Abort_IT+0x1c0>)
24004aba:	4293      	cmp	r3, r2
24004abc:	d022      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004abe:	687b      	ldr	r3, [r7, #4]
24004ac0:	681b      	ldr	r3, [r3, #0]
24004ac2:	4a22      	ldr	r2, [pc, #136]	; (24004b4c <HAL_DMA_Abort_IT+0x1c4>)
24004ac4:	4293      	cmp	r3, r2
24004ac6:	d01d      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004ac8:	687b      	ldr	r3, [r7, #4]
24004aca:	681b      	ldr	r3, [r3, #0]
24004acc:	4a20      	ldr	r2, [pc, #128]	; (24004b50 <HAL_DMA_Abort_IT+0x1c8>)
24004ace:	4293      	cmp	r3, r2
24004ad0:	d018      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004ad2:	687b      	ldr	r3, [r7, #4]
24004ad4:	681b      	ldr	r3, [r3, #0]
24004ad6:	4a1f      	ldr	r2, [pc, #124]	; (24004b54 <HAL_DMA_Abort_IT+0x1cc>)
24004ad8:	4293      	cmp	r3, r2
24004ada:	d013      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004adc:	687b      	ldr	r3, [r7, #4]
24004ade:	681b      	ldr	r3, [r3, #0]
24004ae0:	4a1d      	ldr	r2, [pc, #116]	; (24004b58 <HAL_DMA_Abort_IT+0x1d0>)
24004ae2:	4293      	cmp	r3, r2
24004ae4:	d00e      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004ae6:	687b      	ldr	r3, [r7, #4]
24004ae8:	681b      	ldr	r3, [r3, #0]
24004aea:	4a1c      	ldr	r2, [pc, #112]	; (24004b5c <HAL_DMA_Abort_IT+0x1d4>)
24004aec:	4293      	cmp	r3, r2
24004aee:	d009      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004af0:	687b      	ldr	r3, [r7, #4]
24004af2:	681b      	ldr	r3, [r3, #0]
24004af4:	4a1a      	ldr	r2, [pc, #104]	; (24004b60 <HAL_DMA_Abort_IT+0x1d8>)
24004af6:	4293      	cmp	r3, r2
24004af8:	d004      	beq.n	24004b04 <HAL_DMA_Abort_IT+0x17c>
24004afa:	687b      	ldr	r3, [r7, #4]
24004afc:	681b      	ldr	r3, [r3, #0]
24004afe:	4a19      	ldr	r2, [pc, #100]	; (24004b64 <HAL_DMA_Abort_IT+0x1dc>)
24004b00:	4293      	cmp	r3, r2
24004b02:	d108      	bne.n	24004b16 <HAL_DMA_Abort_IT+0x18e>
24004b04:	687b      	ldr	r3, [r7, #4]
24004b06:	681b      	ldr	r3, [r3, #0]
24004b08:	681a      	ldr	r2, [r3, #0]
24004b0a:	687b      	ldr	r3, [r7, #4]
24004b0c:	681b      	ldr	r3, [r3, #0]
24004b0e:	f022 0201 	bic.w	r2, r2, #1
24004b12:	601a      	str	r2, [r3, #0]
24004b14:	e178      	b.n	24004e08 <HAL_DMA_Abort_IT+0x480>
24004b16:	687b      	ldr	r3, [r7, #4]
24004b18:	681b      	ldr	r3, [r3, #0]
24004b1a:	681a      	ldr	r2, [r3, #0]
24004b1c:	687b      	ldr	r3, [r7, #4]
24004b1e:	681b      	ldr	r3, [r3, #0]
24004b20:	f022 0201 	bic.w	r2, r2, #1
24004b24:	601a      	str	r2, [r3, #0]
24004b26:	e16f      	b.n	24004e08 <HAL_DMA_Abort_IT+0x480>
24004b28:	40020010 	.word	0x40020010
24004b2c:	40020028 	.word	0x40020028
24004b30:	40020040 	.word	0x40020040
24004b34:	40020058 	.word	0x40020058
24004b38:	40020070 	.word	0x40020070
24004b3c:	40020088 	.word	0x40020088
24004b40:	400200a0 	.word	0x400200a0
24004b44:	400200b8 	.word	0x400200b8
24004b48:	40020410 	.word	0x40020410
24004b4c:	40020428 	.word	0x40020428
24004b50:	40020440 	.word	0x40020440
24004b54:	40020458 	.word	0x40020458
24004b58:	40020470 	.word	0x40020470
24004b5c:	40020488 	.word	0x40020488
24004b60:	400204a0 	.word	0x400204a0
24004b64:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts  */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
24004b68:	687b      	ldr	r3, [r7, #4]
24004b6a:	681b      	ldr	r3, [r3, #0]
24004b6c:	681a      	ldr	r2, [r3, #0]
24004b6e:	687b      	ldr	r3, [r7, #4]
24004b70:	681b      	ldr	r3, [r3, #0]
24004b72:	f022 020e 	bic.w	r2, r2, #14
24004b76:	601a      	str	r2, [r3, #0]

      /* Disable the channel */
      __HAL_DMA_DISABLE(hdma);
24004b78:	687b      	ldr	r3, [r7, #4]
24004b7a:	681b      	ldr	r3, [r3, #0]
24004b7c:	4a6c      	ldr	r2, [pc, #432]	; (24004d30 <HAL_DMA_Abort_IT+0x3a8>)
24004b7e:	4293      	cmp	r3, r2
24004b80:	d04a      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004b82:	687b      	ldr	r3, [r7, #4]
24004b84:	681b      	ldr	r3, [r3, #0]
24004b86:	4a6b      	ldr	r2, [pc, #428]	; (24004d34 <HAL_DMA_Abort_IT+0x3ac>)
24004b88:	4293      	cmp	r3, r2
24004b8a:	d045      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004b8c:	687b      	ldr	r3, [r7, #4]
24004b8e:	681b      	ldr	r3, [r3, #0]
24004b90:	4a69      	ldr	r2, [pc, #420]	; (24004d38 <HAL_DMA_Abort_IT+0x3b0>)
24004b92:	4293      	cmp	r3, r2
24004b94:	d040      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004b96:	687b      	ldr	r3, [r7, #4]
24004b98:	681b      	ldr	r3, [r3, #0]
24004b9a:	4a68      	ldr	r2, [pc, #416]	; (24004d3c <HAL_DMA_Abort_IT+0x3b4>)
24004b9c:	4293      	cmp	r3, r2
24004b9e:	d03b      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004ba0:	687b      	ldr	r3, [r7, #4]
24004ba2:	681b      	ldr	r3, [r3, #0]
24004ba4:	4a66      	ldr	r2, [pc, #408]	; (24004d40 <HAL_DMA_Abort_IT+0x3b8>)
24004ba6:	4293      	cmp	r3, r2
24004ba8:	d036      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004baa:	687b      	ldr	r3, [r7, #4]
24004bac:	681b      	ldr	r3, [r3, #0]
24004bae:	4a65      	ldr	r2, [pc, #404]	; (24004d44 <HAL_DMA_Abort_IT+0x3bc>)
24004bb0:	4293      	cmp	r3, r2
24004bb2:	d031      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004bb4:	687b      	ldr	r3, [r7, #4]
24004bb6:	681b      	ldr	r3, [r3, #0]
24004bb8:	4a63      	ldr	r2, [pc, #396]	; (24004d48 <HAL_DMA_Abort_IT+0x3c0>)
24004bba:	4293      	cmp	r3, r2
24004bbc:	d02c      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004bbe:	687b      	ldr	r3, [r7, #4]
24004bc0:	681b      	ldr	r3, [r3, #0]
24004bc2:	4a62      	ldr	r2, [pc, #392]	; (24004d4c <HAL_DMA_Abort_IT+0x3c4>)
24004bc4:	4293      	cmp	r3, r2
24004bc6:	d027      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004bc8:	687b      	ldr	r3, [r7, #4]
24004bca:	681b      	ldr	r3, [r3, #0]
24004bcc:	4a60      	ldr	r2, [pc, #384]	; (24004d50 <HAL_DMA_Abort_IT+0x3c8>)
24004bce:	4293      	cmp	r3, r2
24004bd0:	d022      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004bd2:	687b      	ldr	r3, [r7, #4]
24004bd4:	681b      	ldr	r3, [r3, #0]
24004bd6:	4a5f      	ldr	r2, [pc, #380]	; (24004d54 <HAL_DMA_Abort_IT+0x3cc>)
24004bd8:	4293      	cmp	r3, r2
24004bda:	d01d      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004bdc:	687b      	ldr	r3, [r7, #4]
24004bde:	681b      	ldr	r3, [r3, #0]
24004be0:	4a5d      	ldr	r2, [pc, #372]	; (24004d58 <HAL_DMA_Abort_IT+0x3d0>)
24004be2:	4293      	cmp	r3, r2
24004be4:	d018      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004be6:	687b      	ldr	r3, [r7, #4]
24004be8:	681b      	ldr	r3, [r3, #0]
24004bea:	4a5c      	ldr	r2, [pc, #368]	; (24004d5c <HAL_DMA_Abort_IT+0x3d4>)
24004bec:	4293      	cmp	r3, r2
24004bee:	d013      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004bf0:	687b      	ldr	r3, [r7, #4]
24004bf2:	681b      	ldr	r3, [r3, #0]
24004bf4:	4a5a      	ldr	r2, [pc, #360]	; (24004d60 <HAL_DMA_Abort_IT+0x3d8>)
24004bf6:	4293      	cmp	r3, r2
24004bf8:	d00e      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004bfa:	687b      	ldr	r3, [r7, #4]
24004bfc:	681b      	ldr	r3, [r3, #0]
24004bfe:	4a59      	ldr	r2, [pc, #356]	; (24004d64 <HAL_DMA_Abort_IT+0x3dc>)
24004c00:	4293      	cmp	r3, r2
24004c02:	d009      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004c04:	687b      	ldr	r3, [r7, #4]
24004c06:	681b      	ldr	r3, [r3, #0]
24004c08:	4a57      	ldr	r2, [pc, #348]	; (24004d68 <HAL_DMA_Abort_IT+0x3e0>)
24004c0a:	4293      	cmp	r3, r2
24004c0c:	d004      	beq.n	24004c18 <HAL_DMA_Abort_IT+0x290>
24004c0e:	687b      	ldr	r3, [r7, #4]
24004c10:	681b      	ldr	r3, [r3, #0]
24004c12:	4a56      	ldr	r2, [pc, #344]	; (24004d6c <HAL_DMA_Abort_IT+0x3e4>)
24004c14:	4293      	cmp	r3, r2
24004c16:	d108      	bne.n	24004c2a <HAL_DMA_Abort_IT+0x2a2>
24004c18:	687b      	ldr	r3, [r7, #4]
24004c1a:	681b      	ldr	r3, [r3, #0]
24004c1c:	681a      	ldr	r2, [r3, #0]
24004c1e:	687b      	ldr	r3, [r7, #4]
24004c20:	681b      	ldr	r3, [r3, #0]
24004c22:	f022 0201 	bic.w	r2, r2, #1
24004c26:	601a      	str	r2, [r3, #0]
24004c28:	e007      	b.n	24004c3a <HAL_DMA_Abort_IT+0x2b2>
24004c2a:	687b      	ldr	r3, [r7, #4]
24004c2c:	681b      	ldr	r3, [r3, #0]
24004c2e:	681a      	ldr	r2, [r3, #0]
24004c30:	687b      	ldr	r3, [r7, #4]
24004c32:	681b      	ldr	r3, [r3, #0]
24004c34:	f022 0201 	bic.w	r2, r2, #1
24004c38:	601a      	str	r2, [r3, #0]

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24004c3a:	687b      	ldr	r3, [r7, #4]
24004c3c:	681b      	ldr	r3, [r3, #0]
24004c3e:	4a3c      	ldr	r2, [pc, #240]	; (24004d30 <HAL_DMA_Abort_IT+0x3a8>)
24004c40:	4293      	cmp	r3, r2
24004c42:	d072      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c44:	687b      	ldr	r3, [r7, #4]
24004c46:	681b      	ldr	r3, [r3, #0]
24004c48:	4a3a      	ldr	r2, [pc, #232]	; (24004d34 <HAL_DMA_Abort_IT+0x3ac>)
24004c4a:	4293      	cmp	r3, r2
24004c4c:	d06d      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c4e:	687b      	ldr	r3, [r7, #4]
24004c50:	681b      	ldr	r3, [r3, #0]
24004c52:	4a39      	ldr	r2, [pc, #228]	; (24004d38 <HAL_DMA_Abort_IT+0x3b0>)
24004c54:	4293      	cmp	r3, r2
24004c56:	d068      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c58:	687b      	ldr	r3, [r7, #4]
24004c5a:	681b      	ldr	r3, [r3, #0]
24004c5c:	4a37      	ldr	r2, [pc, #220]	; (24004d3c <HAL_DMA_Abort_IT+0x3b4>)
24004c5e:	4293      	cmp	r3, r2
24004c60:	d063      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c62:	687b      	ldr	r3, [r7, #4]
24004c64:	681b      	ldr	r3, [r3, #0]
24004c66:	4a36      	ldr	r2, [pc, #216]	; (24004d40 <HAL_DMA_Abort_IT+0x3b8>)
24004c68:	4293      	cmp	r3, r2
24004c6a:	d05e      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c6c:	687b      	ldr	r3, [r7, #4]
24004c6e:	681b      	ldr	r3, [r3, #0]
24004c70:	4a34      	ldr	r2, [pc, #208]	; (24004d44 <HAL_DMA_Abort_IT+0x3bc>)
24004c72:	4293      	cmp	r3, r2
24004c74:	d059      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c76:	687b      	ldr	r3, [r7, #4]
24004c78:	681b      	ldr	r3, [r3, #0]
24004c7a:	4a33      	ldr	r2, [pc, #204]	; (24004d48 <HAL_DMA_Abort_IT+0x3c0>)
24004c7c:	4293      	cmp	r3, r2
24004c7e:	d054      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c80:	687b      	ldr	r3, [r7, #4]
24004c82:	681b      	ldr	r3, [r3, #0]
24004c84:	4a31      	ldr	r2, [pc, #196]	; (24004d4c <HAL_DMA_Abort_IT+0x3c4>)
24004c86:	4293      	cmp	r3, r2
24004c88:	d04f      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c8a:	687b      	ldr	r3, [r7, #4]
24004c8c:	681b      	ldr	r3, [r3, #0]
24004c8e:	4a30      	ldr	r2, [pc, #192]	; (24004d50 <HAL_DMA_Abort_IT+0x3c8>)
24004c90:	4293      	cmp	r3, r2
24004c92:	d04a      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c94:	687b      	ldr	r3, [r7, #4]
24004c96:	681b      	ldr	r3, [r3, #0]
24004c98:	4a2e      	ldr	r2, [pc, #184]	; (24004d54 <HAL_DMA_Abort_IT+0x3cc>)
24004c9a:	4293      	cmp	r3, r2
24004c9c:	d045      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004c9e:	687b      	ldr	r3, [r7, #4]
24004ca0:	681b      	ldr	r3, [r3, #0]
24004ca2:	4a2d      	ldr	r2, [pc, #180]	; (24004d58 <HAL_DMA_Abort_IT+0x3d0>)
24004ca4:	4293      	cmp	r3, r2
24004ca6:	d040      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004ca8:	687b      	ldr	r3, [r7, #4]
24004caa:	681b      	ldr	r3, [r3, #0]
24004cac:	4a2b      	ldr	r2, [pc, #172]	; (24004d5c <HAL_DMA_Abort_IT+0x3d4>)
24004cae:	4293      	cmp	r3, r2
24004cb0:	d03b      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004cb2:	687b      	ldr	r3, [r7, #4]
24004cb4:	681b      	ldr	r3, [r3, #0]
24004cb6:	4a2a      	ldr	r2, [pc, #168]	; (24004d60 <HAL_DMA_Abort_IT+0x3d8>)
24004cb8:	4293      	cmp	r3, r2
24004cba:	d036      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004cbc:	687b      	ldr	r3, [r7, #4]
24004cbe:	681b      	ldr	r3, [r3, #0]
24004cc0:	4a28      	ldr	r2, [pc, #160]	; (24004d64 <HAL_DMA_Abort_IT+0x3dc>)
24004cc2:	4293      	cmp	r3, r2
24004cc4:	d031      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004cc6:	687b      	ldr	r3, [r7, #4]
24004cc8:	681b      	ldr	r3, [r3, #0]
24004cca:	4a27      	ldr	r2, [pc, #156]	; (24004d68 <HAL_DMA_Abort_IT+0x3e0>)
24004ccc:	4293      	cmp	r3, r2
24004cce:	d02c      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004cd0:	687b      	ldr	r3, [r7, #4]
24004cd2:	681b      	ldr	r3, [r3, #0]
24004cd4:	4a25      	ldr	r2, [pc, #148]	; (24004d6c <HAL_DMA_Abort_IT+0x3e4>)
24004cd6:	4293      	cmp	r3, r2
24004cd8:	d027      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004cda:	687b      	ldr	r3, [r7, #4]
24004cdc:	681b      	ldr	r3, [r3, #0]
24004cde:	4a24      	ldr	r2, [pc, #144]	; (24004d70 <HAL_DMA_Abort_IT+0x3e8>)
24004ce0:	4293      	cmp	r3, r2
24004ce2:	d022      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004ce4:	687b      	ldr	r3, [r7, #4]
24004ce6:	681b      	ldr	r3, [r3, #0]
24004ce8:	4a22      	ldr	r2, [pc, #136]	; (24004d74 <HAL_DMA_Abort_IT+0x3ec>)
24004cea:	4293      	cmp	r3, r2
24004cec:	d01d      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004cee:	687b      	ldr	r3, [r7, #4]
24004cf0:	681b      	ldr	r3, [r3, #0]
24004cf2:	4a21      	ldr	r2, [pc, #132]	; (24004d78 <HAL_DMA_Abort_IT+0x3f0>)
24004cf4:	4293      	cmp	r3, r2
24004cf6:	d018      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004cf8:	687b      	ldr	r3, [r7, #4]
24004cfa:	681b      	ldr	r3, [r3, #0]
24004cfc:	4a1f      	ldr	r2, [pc, #124]	; (24004d7c <HAL_DMA_Abort_IT+0x3f4>)
24004cfe:	4293      	cmp	r3, r2
24004d00:	d013      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004d02:	687b      	ldr	r3, [r7, #4]
24004d04:	681b      	ldr	r3, [r3, #0]
24004d06:	4a1e      	ldr	r2, [pc, #120]	; (24004d80 <HAL_DMA_Abort_IT+0x3f8>)
24004d08:	4293      	cmp	r3, r2
24004d0a:	d00e      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004d0c:	687b      	ldr	r3, [r7, #4]
24004d0e:	681b      	ldr	r3, [r3, #0]
24004d10:	4a1c      	ldr	r2, [pc, #112]	; (24004d84 <HAL_DMA_Abort_IT+0x3fc>)
24004d12:	4293      	cmp	r3, r2
24004d14:	d009      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004d16:	687b      	ldr	r3, [r7, #4]
24004d18:	681b      	ldr	r3, [r3, #0]
24004d1a:	4a1b      	ldr	r2, [pc, #108]	; (24004d88 <HAL_DMA_Abort_IT+0x400>)
24004d1c:	4293      	cmp	r3, r2
24004d1e:	d004      	beq.n	24004d2a <HAL_DMA_Abort_IT+0x3a2>
24004d20:	687b      	ldr	r3, [r7, #4]
24004d22:	681b      	ldr	r3, [r3, #0]
24004d24:	4a19      	ldr	r2, [pc, #100]	; (24004d8c <HAL_DMA_Abort_IT+0x404>)
24004d26:	4293      	cmp	r3, r2
24004d28:	d132      	bne.n	24004d90 <HAL_DMA_Abort_IT+0x408>
24004d2a:	2301      	movs	r3, #1
24004d2c:	e031      	b.n	24004d92 <HAL_DMA_Abort_IT+0x40a>
24004d2e:	bf00      	nop
24004d30:	40020010 	.word	0x40020010
24004d34:	40020028 	.word	0x40020028
24004d38:	40020040 	.word	0x40020040
24004d3c:	40020058 	.word	0x40020058
24004d40:	40020070 	.word	0x40020070
24004d44:	40020088 	.word	0x40020088
24004d48:	400200a0 	.word	0x400200a0
24004d4c:	400200b8 	.word	0x400200b8
24004d50:	40020410 	.word	0x40020410
24004d54:	40020428 	.word	0x40020428
24004d58:	40020440 	.word	0x40020440
24004d5c:	40020458 	.word	0x40020458
24004d60:	40020470 	.word	0x40020470
24004d64:	40020488 	.word	0x40020488
24004d68:	400204a0 	.word	0x400204a0
24004d6c:	400204b8 	.word	0x400204b8
24004d70:	58025408 	.word	0x58025408
24004d74:	5802541c 	.word	0x5802541c
24004d78:	58025430 	.word	0x58025430
24004d7c:	58025444 	.word	0x58025444
24004d80:	58025458 	.word	0x58025458
24004d84:	5802546c 	.word	0x5802546c
24004d88:	58025480 	.word	0x58025480
24004d8c:	58025494 	.word	0x58025494
24004d90:	2300      	movs	r3, #0
24004d92:	2b00      	cmp	r3, #0
24004d94:	d028      	beq.n	24004de8 <HAL_DMA_Abort_IT+0x460>
      {
        /* disable the DMAMUX sync overrun IT */
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24004d96:	687b      	ldr	r3, [r7, #4]
24004d98:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24004d9a:	681a      	ldr	r2, [r3, #0]
24004d9c:	687b      	ldr	r3, [r7, #4]
24004d9e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24004da0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24004da4:	601a      	str	r2, [r3, #0]

        /* Clear all flags */
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24004da6:	687b      	ldr	r3, [r7, #4]
24004da8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004daa:	60fb      	str	r3, [r7, #12]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
24004dac:	687b      	ldr	r3, [r7, #4]
24004dae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004db0:	f003 031f 	and.w	r3, r3, #31
24004db4:	2201      	movs	r2, #1
24004db6:	409a      	lsls	r2, r3
24004db8:	68fb      	ldr	r3, [r7, #12]
24004dba:	605a      	str	r2, [r3, #4]

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24004dbc:	687b      	ldr	r3, [r7, #4]
24004dbe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24004dc0:	687a      	ldr	r2, [r7, #4]
24004dc2:	6e92      	ldr	r2, [r2, #104]	; 0x68
24004dc4:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
24004dc6:	687b      	ldr	r3, [r7, #4]
24004dc8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004dca:	2b00      	cmp	r3, #0
24004dcc:	d00c      	beq.n	24004de8 <HAL_DMA_Abort_IT+0x460>
        {
          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
          /* disable the request gen overrun IT */
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24004dce:	687b      	ldr	r3, [r7, #4]
24004dd0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004dd2:	681a      	ldr	r2, [r3, #0]
24004dd4:	687b      	ldr	r3, [r7, #4]
24004dd6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24004dd8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24004ddc:	601a      	str	r2, [r3, #0]

          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24004dde:	687b      	ldr	r3, [r7, #4]
24004de0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24004de2:	687a      	ldr	r2, [r7, #4]
24004de4:	6f52      	ldr	r2, [r2, #116]	; 0x74
24004de6:	605a      	str	r2, [r3, #4]
        }
      }

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
24004de8:	687b      	ldr	r3, [r7, #4]
24004dea:	2201      	movs	r2, #1
24004dec:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
24004df0:	687b      	ldr	r3, [r7, #4]
24004df2:	2200      	movs	r2, #0
24004df4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Call User Abort callback */
      if(hdma->XferAbortCallback != NULL)
24004df8:	687b      	ldr	r3, [r7, #4]
24004dfa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24004dfc:	2b00      	cmp	r3, #0
24004dfe:	d003      	beq.n	24004e08 <HAL_DMA_Abort_IT+0x480>
      {
        hdma->XferAbortCallback(hdma);
24004e00:	687b      	ldr	r3, [r7, #4]
24004e02:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24004e04:	6878      	ldr	r0, [r7, #4]
24004e06:	4798      	blx	r3
      }
    }
  }

  return HAL_OK;
24004e08:	2300      	movs	r3, #0
}
24004e0a:	4618      	mov	r0, r3
24004e0c:	3710      	adds	r7, #16
24004e0e:	46bd      	mov	sp, r7
24004e10:	bd80      	pop	{r7, pc}
24004e12:	bf00      	nop

24004e14 <HAL_DMA_PollForTransfer>:
  * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode).
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
24004e14:	b580      	push	{r7, lr}
24004e16:	b08a      	sub	sp, #40	; 0x28
24004e18:	af00      	add	r7, sp, #0
24004e1a:	60f8      	str	r0, [r7, #12]
24004e1c:	460b      	mov	r3, r1
24004e1e:	607a      	str	r2, [r7, #4]
24004e20:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
24004e22:	2300      	movs	r3, #0
24004e24:	76fb      	strb	r3, [r7, #27]
  uint32_t cpltlevel_mask;
  uint32_t tickstart = HAL_GetTick();
24004e26:	f7fd fa8d 	bl	24002344 <HAL_GetTick>
24004e2a:	6178      	str	r0, [r7, #20]
  __IO uint32_t *isr_reg;
  /* IT clear flag register */
  __IO uint32_t *ifcr_reg;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24004e2c:	68fb      	ldr	r3, [r7, #12]
24004e2e:	2b00      	cmp	r3, #0
24004e30:	d101      	bne.n	24004e36 <HAL_DMA_PollForTransfer+0x22>
  {
    return HAL_ERROR;
24004e32:	2301      	movs	r3, #1
24004e34:	e374      	b.n	24005520 <HAL_DMA_PollForTransfer+0x70c>
  }

  if(HAL_DMA_STATE_BUSY != hdma->State)
24004e36:	68fb      	ldr	r3, [r7, #12]
24004e38:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24004e3c:	b2db      	uxtb	r3, r3
24004e3e:	2b02      	cmp	r3, #2
24004e40:	d008      	beq.n	24004e54 <HAL_DMA_PollForTransfer+0x40>
  {
    /* No transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
24004e42:	68fb      	ldr	r3, [r7, #12]
24004e44:	2280      	movs	r2, #128	; 0x80
24004e46:	655a      	str	r2, [r3, #84]	; 0x54
    __HAL_UNLOCK(hdma);
24004e48:	68fb      	ldr	r3, [r7, #12]
24004e4a:	2200      	movs	r2, #0
24004e4c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
24004e50:	2301      	movs	r3, #1
24004e52:	e365      	b.n	24005520 <HAL_DMA_PollForTransfer+0x70c>
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004e54:	68fb      	ldr	r3, [r7, #12]
24004e56:	681b      	ldr	r3, [r3, #0]
24004e58:	4a7b      	ldr	r2, [pc, #492]	; (24005048 <HAL_DMA_PollForTransfer+0x234>)
24004e5a:	4293      	cmp	r3, r2
24004e5c:	d04a      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004e5e:	68fb      	ldr	r3, [r7, #12]
24004e60:	681b      	ldr	r3, [r3, #0]
24004e62:	4a7a      	ldr	r2, [pc, #488]	; (2400504c <HAL_DMA_PollForTransfer+0x238>)
24004e64:	4293      	cmp	r3, r2
24004e66:	d045      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004e68:	68fb      	ldr	r3, [r7, #12]
24004e6a:	681b      	ldr	r3, [r3, #0]
24004e6c:	4a78      	ldr	r2, [pc, #480]	; (24005050 <HAL_DMA_PollForTransfer+0x23c>)
24004e6e:	4293      	cmp	r3, r2
24004e70:	d040      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004e72:	68fb      	ldr	r3, [r7, #12]
24004e74:	681b      	ldr	r3, [r3, #0]
24004e76:	4a77      	ldr	r2, [pc, #476]	; (24005054 <HAL_DMA_PollForTransfer+0x240>)
24004e78:	4293      	cmp	r3, r2
24004e7a:	d03b      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004e7c:	68fb      	ldr	r3, [r7, #12]
24004e7e:	681b      	ldr	r3, [r3, #0]
24004e80:	4a75      	ldr	r2, [pc, #468]	; (24005058 <HAL_DMA_PollForTransfer+0x244>)
24004e82:	4293      	cmp	r3, r2
24004e84:	d036      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004e86:	68fb      	ldr	r3, [r7, #12]
24004e88:	681b      	ldr	r3, [r3, #0]
24004e8a:	4a74      	ldr	r2, [pc, #464]	; (2400505c <HAL_DMA_PollForTransfer+0x248>)
24004e8c:	4293      	cmp	r3, r2
24004e8e:	d031      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004e90:	68fb      	ldr	r3, [r7, #12]
24004e92:	681b      	ldr	r3, [r3, #0]
24004e94:	4a72      	ldr	r2, [pc, #456]	; (24005060 <HAL_DMA_PollForTransfer+0x24c>)
24004e96:	4293      	cmp	r3, r2
24004e98:	d02c      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004e9a:	68fb      	ldr	r3, [r7, #12]
24004e9c:	681b      	ldr	r3, [r3, #0]
24004e9e:	4a71      	ldr	r2, [pc, #452]	; (24005064 <HAL_DMA_PollForTransfer+0x250>)
24004ea0:	4293      	cmp	r3, r2
24004ea2:	d027      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004ea4:	68fb      	ldr	r3, [r7, #12]
24004ea6:	681b      	ldr	r3, [r3, #0]
24004ea8:	4a6f      	ldr	r2, [pc, #444]	; (24005068 <HAL_DMA_PollForTransfer+0x254>)
24004eaa:	4293      	cmp	r3, r2
24004eac:	d022      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004eae:	68fb      	ldr	r3, [r7, #12]
24004eb0:	681b      	ldr	r3, [r3, #0]
24004eb2:	4a6e      	ldr	r2, [pc, #440]	; (2400506c <HAL_DMA_PollForTransfer+0x258>)
24004eb4:	4293      	cmp	r3, r2
24004eb6:	d01d      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004eb8:	68fb      	ldr	r3, [r7, #12]
24004eba:	681b      	ldr	r3, [r3, #0]
24004ebc:	4a6c      	ldr	r2, [pc, #432]	; (24005070 <HAL_DMA_PollForTransfer+0x25c>)
24004ebe:	4293      	cmp	r3, r2
24004ec0:	d018      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004ec2:	68fb      	ldr	r3, [r7, #12]
24004ec4:	681b      	ldr	r3, [r3, #0]
24004ec6:	4a6b      	ldr	r2, [pc, #428]	; (24005074 <HAL_DMA_PollForTransfer+0x260>)
24004ec8:	4293      	cmp	r3, r2
24004eca:	d013      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004ecc:	68fb      	ldr	r3, [r7, #12]
24004ece:	681b      	ldr	r3, [r3, #0]
24004ed0:	4a69      	ldr	r2, [pc, #420]	; (24005078 <HAL_DMA_PollForTransfer+0x264>)
24004ed2:	4293      	cmp	r3, r2
24004ed4:	d00e      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004ed6:	68fb      	ldr	r3, [r7, #12]
24004ed8:	681b      	ldr	r3, [r3, #0]
24004eda:	4a68      	ldr	r2, [pc, #416]	; (2400507c <HAL_DMA_PollForTransfer+0x268>)
24004edc:	4293      	cmp	r3, r2
24004ede:	d009      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004ee0:	68fb      	ldr	r3, [r7, #12]
24004ee2:	681b      	ldr	r3, [r3, #0]
24004ee4:	4a66      	ldr	r2, [pc, #408]	; (24005080 <HAL_DMA_PollForTransfer+0x26c>)
24004ee6:	4293      	cmp	r3, r2
24004ee8:	d004      	beq.n	24004ef4 <HAL_DMA_PollForTransfer+0xe0>
24004eea:	68fb      	ldr	r3, [r7, #12]
24004eec:	681b      	ldr	r3, [r3, #0]
24004eee:	4a65      	ldr	r2, [pc, #404]	; (24005084 <HAL_DMA_PollForTransfer+0x270>)
24004ef0:	4293      	cmp	r3, r2
24004ef2:	d101      	bne.n	24004ef8 <HAL_DMA_PollForTransfer+0xe4>
24004ef4:	2301      	movs	r3, #1
24004ef6:	e000      	b.n	24004efa <HAL_DMA_PollForTransfer+0xe6>
24004ef8:	2300      	movs	r3, #0
24004efa:	2b00      	cmp	r3, #0
24004efc:	d028      	beq.n	24004f50 <HAL_DMA_PollForTransfer+0x13c>
  {
    /* Polling mode not supported in circular mode and double buffering mode */
    if ((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) != 0U)
24004efe:	68fb      	ldr	r3, [r7, #12]
24004f00:	681b      	ldr	r3, [r3, #0]
24004f02:	681b      	ldr	r3, [r3, #0]
24004f04:	f403 7380 	and.w	r3, r3, #256	; 0x100
24004f08:	2b00      	cmp	r3, #0
24004f0a:	d005      	beq.n	24004f18 <HAL_DMA_PollForTransfer+0x104>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24004f0c:	68fb      	ldr	r3, [r7, #12]
24004f0e:	f44f 7280 	mov.w	r2, #256	; 0x100
24004f12:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
24004f14:	2301      	movs	r3, #1
24004f16:	e303      	b.n	24005520 <HAL_DMA_PollForTransfer+0x70c>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
24004f18:	7afb      	ldrb	r3, [r7, #11]
24004f1a:	2b00      	cmp	r3, #0
24004f1c:	d108      	bne.n	24004f30 <HAL_DMA_PollForTransfer+0x11c>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
24004f1e:	68fb      	ldr	r3, [r7, #12]
24004f20:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004f22:	f003 031f 	and.w	r3, r3, #31
24004f26:	2220      	movs	r2, #32
24004f28:	fa02 f303 	lsl.w	r3, r2, r3
24004f2c:	627b      	str	r3, [r7, #36]	; 0x24
24004f2e:	e007      	b.n	24004f40 <HAL_DMA_PollForTransfer+0x12c>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24004f30:	68fb      	ldr	r3, [r7, #12]
24004f32:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004f34:	f003 031f 	and.w	r3, r3, #31
24004f38:	2210      	movs	r2, #16
24004f3a:	fa02 f303 	lsl.w	r3, r2, r3
24004f3e:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24004f40:	68fb      	ldr	r3, [r7, #12]
24004f42:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004f44:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((DMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24004f46:	68fb      	ldr	r3, [r7, #12]
24004f48:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004f4a:	3308      	adds	r3, #8
24004f4c:	61fb      	str	r3, [r7, #28]
24004f4e:	e1d5      	b.n	240052fc <HAL_DMA_PollForTransfer+0x4e8>
  }
  else /* BDMA channel */
  {
    /* Polling mode not supported in circular mode */
    if ((((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR & BDMA_CCR_CIRC) != 0U)
24004f50:	68fb      	ldr	r3, [r7, #12]
24004f52:	681b      	ldr	r3, [r3, #0]
24004f54:	681b      	ldr	r3, [r3, #0]
24004f56:	f003 0320 	and.w	r3, r3, #32
24004f5a:	2b00      	cmp	r3, #0
24004f5c:	d005      	beq.n	24004f6a <HAL_DMA_PollForTransfer+0x156>
    {
      hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24004f5e:	68fb      	ldr	r3, [r7, #12]
24004f60:	f44f 7280 	mov.w	r2, #256	; 0x100
24004f64:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_ERROR;
24004f66:	2301      	movs	r3, #1
24004f68:	e2da      	b.n	24005520 <HAL_DMA_PollForTransfer+0x70c>
    }

    /* Get the level transfer complete flag */
    if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
24004f6a:	7afb      	ldrb	r3, [r7, #11]
24004f6c:	2b00      	cmp	r3, #0
24004f6e:	d108      	bne.n	24004f82 <HAL_DMA_PollForTransfer+0x16e>
    {
      /* Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU);
24004f70:	68fb      	ldr	r3, [r7, #12]
24004f72:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004f74:	f003 031f 	and.w	r3, r3, #31
24004f78:	2202      	movs	r2, #2
24004f7a:	fa02 f303 	lsl.w	r3, r2, r3
24004f7e:	627b      	str	r3, [r7, #36]	; 0x24
24004f80:	e007      	b.n	24004f92 <HAL_DMA_PollForTransfer+0x17e>
    }
    else
    {
      /* Half Transfer Complete flag */
      cpltlevel_mask = BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU);
24004f82:	68fb      	ldr	r3, [r7, #12]
24004f84:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24004f86:	f003 031f 	and.w	r3, r3, #31
24004f8a:	2204      	movs	r2, #4
24004f8c:	fa02 f303 	lsl.w	r3, r2, r3
24004f90:	627b      	str	r3, [r7, #36]	; 0x24
    }

    isr_reg  = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->ISR);
24004f92:	68fb      	ldr	r3, [r7, #12]
24004f94:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004f96:	623b      	str	r3, [r7, #32]
    ifcr_reg = &(((BDMA_Base_Registers *)hdma->StreamBaseAddress)->IFCR);
24004f98:	68fb      	ldr	r3, [r7, #12]
24004f9a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24004f9c:	3304      	adds	r3, #4
24004f9e:	61fb      	str	r3, [r7, #28]
  }

  while(((*isr_reg) & cpltlevel_mask) == 0U)
24004fa0:	e1ac      	b.n	240052fc <HAL_DMA_PollForTransfer+0x4e8>
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24004fa2:	68fb      	ldr	r3, [r7, #12]
24004fa4:	681b      	ldr	r3, [r3, #0]
24004fa6:	4a28      	ldr	r2, [pc, #160]	; (24005048 <HAL_DMA_PollForTransfer+0x234>)
24004fa8:	4293      	cmp	r3, r2
24004faa:	d04a      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004fac:	68fb      	ldr	r3, [r7, #12]
24004fae:	681b      	ldr	r3, [r3, #0]
24004fb0:	4a26      	ldr	r2, [pc, #152]	; (2400504c <HAL_DMA_PollForTransfer+0x238>)
24004fb2:	4293      	cmp	r3, r2
24004fb4:	d045      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004fb6:	68fb      	ldr	r3, [r7, #12]
24004fb8:	681b      	ldr	r3, [r3, #0]
24004fba:	4a25      	ldr	r2, [pc, #148]	; (24005050 <HAL_DMA_PollForTransfer+0x23c>)
24004fbc:	4293      	cmp	r3, r2
24004fbe:	d040      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004fc0:	68fb      	ldr	r3, [r7, #12]
24004fc2:	681b      	ldr	r3, [r3, #0]
24004fc4:	4a23      	ldr	r2, [pc, #140]	; (24005054 <HAL_DMA_PollForTransfer+0x240>)
24004fc6:	4293      	cmp	r3, r2
24004fc8:	d03b      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004fca:	68fb      	ldr	r3, [r7, #12]
24004fcc:	681b      	ldr	r3, [r3, #0]
24004fce:	4a22      	ldr	r2, [pc, #136]	; (24005058 <HAL_DMA_PollForTransfer+0x244>)
24004fd0:	4293      	cmp	r3, r2
24004fd2:	d036      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004fd4:	68fb      	ldr	r3, [r7, #12]
24004fd6:	681b      	ldr	r3, [r3, #0]
24004fd8:	4a20      	ldr	r2, [pc, #128]	; (2400505c <HAL_DMA_PollForTransfer+0x248>)
24004fda:	4293      	cmp	r3, r2
24004fdc:	d031      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004fde:	68fb      	ldr	r3, [r7, #12]
24004fe0:	681b      	ldr	r3, [r3, #0]
24004fe2:	4a1f      	ldr	r2, [pc, #124]	; (24005060 <HAL_DMA_PollForTransfer+0x24c>)
24004fe4:	4293      	cmp	r3, r2
24004fe6:	d02c      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004fe8:	68fb      	ldr	r3, [r7, #12]
24004fea:	681b      	ldr	r3, [r3, #0]
24004fec:	4a1d      	ldr	r2, [pc, #116]	; (24005064 <HAL_DMA_PollForTransfer+0x250>)
24004fee:	4293      	cmp	r3, r2
24004ff0:	d027      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004ff2:	68fb      	ldr	r3, [r7, #12]
24004ff4:	681b      	ldr	r3, [r3, #0]
24004ff6:	4a1c      	ldr	r2, [pc, #112]	; (24005068 <HAL_DMA_PollForTransfer+0x254>)
24004ff8:	4293      	cmp	r3, r2
24004ffa:	d022      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24004ffc:	68fb      	ldr	r3, [r7, #12]
24004ffe:	681b      	ldr	r3, [r3, #0]
24005000:	4a1a      	ldr	r2, [pc, #104]	; (2400506c <HAL_DMA_PollForTransfer+0x258>)
24005002:	4293      	cmp	r3, r2
24005004:	d01d      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24005006:	68fb      	ldr	r3, [r7, #12]
24005008:	681b      	ldr	r3, [r3, #0]
2400500a:	4a19      	ldr	r2, [pc, #100]	; (24005070 <HAL_DMA_PollForTransfer+0x25c>)
2400500c:	4293      	cmp	r3, r2
2400500e:	d018      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24005010:	68fb      	ldr	r3, [r7, #12]
24005012:	681b      	ldr	r3, [r3, #0]
24005014:	4a17      	ldr	r2, [pc, #92]	; (24005074 <HAL_DMA_PollForTransfer+0x260>)
24005016:	4293      	cmp	r3, r2
24005018:	d013      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
2400501a:	68fb      	ldr	r3, [r7, #12]
2400501c:	681b      	ldr	r3, [r3, #0]
2400501e:	4a16      	ldr	r2, [pc, #88]	; (24005078 <HAL_DMA_PollForTransfer+0x264>)
24005020:	4293      	cmp	r3, r2
24005022:	d00e      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24005024:	68fb      	ldr	r3, [r7, #12]
24005026:	681b      	ldr	r3, [r3, #0]
24005028:	4a14      	ldr	r2, [pc, #80]	; (2400507c <HAL_DMA_PollForTransfer+0x268>)
2400502a:	4293      	cmp	r3, r2
2400502c:	d009      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
2400502e:	68fb      	ldr	r3, [r7, #12]
24005030:	681b      	ldr	r3, [r3, #0]
24005032:	4a13      	ldr	r2, [pc, #76]	; (24005080 <HAL_DMA_PollForTransfer+0x26c>)
24005034:	4293      	cmp	r3, r2
24005036:	d004      	beq.n	24005042 <HAL_DMA_PollForTransfer+0x22e>
24005038:	68fb      	ldr	r3, [r7, #12]
2400503a:	681b      	ldr	r3, [r3, #0]
2400503c:	4a11      	ldr	r2, [pc, #68]	; (24005084 <HAL_DMA_PollForTransfer+0x270>)
2400503e:	4293      	cmp	r3, r2
24005040:	d122      	bne.n	24005088 <HAL_DMA_PollForTransfer+0x274>
24005042:	2301      	movs	r3, #1
24005044:	e021      	b.n	2400508a <HAL_DMA_PollForTransfer+0x276>
24005046:	bf00      	nop
24005048:	40020010 	.word	0x40020010
2400504c:	40020028 	.word	0x40020028
24005050:	40020040 	.word	0x40020040
24005054:	40020058 	.word	0x40020058
24005058:	40020070 	.word	0x40020070
2400505c:	40020088 	.word	0x40020088
24005060:	400200a0 	.word	0x400200a0
24005064:	400200b8 	.word	0x400200b8
24005068:	40020410 	.word	0x40020410
2400506c:	40020428 	.word	0x40020428
24005070:	40020440 	.word	0x40020440
24005074:	40020458 	.word	0x40020458
24005078:	40020470 	.word	0x40020470
2400507c:	40020488 	.word	0x40020488
24005080:	400204a0 	.word	0x400204a0
24005084:	400204b8 	.word	0x400204b8
24005088:	2300      	movs	r3, #0
2400508a:	2b00      	cmp	r3, #0
2400508c:	d057      	beq.n	2400513e <HAL_DMA_PollForTransfer+0x32a>
    {
      if(((*isr_reg) & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400508e:	6a3b      	ldr	r3, [r7, #32]
24005090:	681a      	ldr	r2, [r3, #0]
24005092:	68fb      	ldr	r3, [r7, #12]
24005094:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005096:	f003 031f 	and.w	r3, r3, #31
2400509a:	fa22 f303 	lsr.w	r3, r2, r3
2400509e:	f003 0301 	and.w	r3, r3, #1
240050a2:	2b00      	cmp	r3, #0
240050a4:	d00d      	beq.n	240050c2 <HAL_DMA_PollForTransfer+0x2ae>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
240050a6:	68fb      	ldr	r3, [r7, #12]
240050a8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240050aa:	f043 0202 	orr.w	r2, r3, #2
240050ae:	68fb      	ldr	r3, [r7, #12]
240050b0:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the FIFO error flag */
        (*ifcr_reg) = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
240050b2:	68fb      	ldr	r3, [r7, #12]
240050b4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240050b6:	f003 031f 	and.w	r3, r3, #31
240050ba:	2201      	movs	r2, #1
240050bc:	409a      	lsls	r2, r3
240050be:	69fb      	ldr	r3, [r7, #28]
240050c0:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240050c2:	6a3b      	ldr	r3, [r7, #32]
240050c4:	681a      	ldr	r2, [r3, #0]
240050c6:	68fb      	ldr	r3, [r7, #12]
240050c8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240050ca:	f003 031f 	and.w	r3, r3, #31
240050ce:	2104      	movs	r1, #4
240050d0:	fa01 f303 	lsl.w	r3, r1, r3
240050d4:	4013      	ands	r3, r2
240050d6:	2b00      	cmp	r3, #0
240050d8:	d00d      	beq.n	240050f6 <HAL_DMA_PollForTransfer+0x2e2>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
240050da:	68fb      	ldr	r3, [r7, #12]
240050dc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240050de:	f043 0204 	orr.w	r2, r3, #4
240050e2:	68fb      	ldr	r3, [r7, #12]
240050e4:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the Direct Mode error flag */
        (*ifcr_reg) = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
240050e6:	68fb      	ldr	r3, [r7, #12]
240050e8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240050ea:	f003 031f 	and.w	r3, r3, #31
240050ee:	2204      	movs	r2, #4
240050f0:	409a      	lsls	r2, r3
240050f2:	69fb      	ldr	r3, [r7, #28]
240050f4:	601a      	str	r2, [r3, #0]
      }

      if(((*isr_reg) & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240050f6:	6a3b      	ldr	r3, [r7, #32]
240050f8:	681a      	ldr	r2, [r3, #0]
240050fa:	68fb      	ldr	r3, [r7, #12]
240050fc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240050fe:	f003 031f 	and.w	r3, r3, #31
24005102:	2108      	movs	r1, #8
24005104:	fa01 f303 	lsl.w	r3, r1, r3
24005108:	4013      	ands	r3, r2
2400510a:	2b00      	cmp	r3, #0
2400510c:	d038      	beq.n	24005180 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
2400510e:	68fb      	ldr	r3, [r7, #12]
24005110:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005112:	f043 0201 	orr.w	r2, r3, #1
24005116:	68fb      	ldr	r3, [r7, #12]
24005118:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the transfer error flag */
        (*ifcr_reg) = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
2400511a:	68fb      	ldr	r3, [r7, #12]
2400511c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400511e:	f003 031f 	and.w	r3, r3, #31
24005122:	2208      	movs	r2, #8
24005124:	409a      	lsls	r2, r3
24005126:	69fb      	ldr	r3, [r7, #28]
24005128:	601a      	str	r2, [r3, #0]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
2400512a:	68fb      	ldr	r3, [r7, #12]
2400512c:	2201      	movs	r2, #1
2400512e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24005132:	68fb      	ldr	r3, [r7, #12]
24005134:	2200      	movs	r2, #0
24005136:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
2400513a:	2301      	movs	r3, #1
2400513c:	e1f0      	b.n	24005520 <HAL_DMA_PollForTransfer+0x70c>
      }
    }
    else /* BDMA channel */
    {
      if(((*isr_reg) & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U)
2400513e:	6a3b      	ldr	r3, [r7, #32]
24005140:	681a      	ldr	r2, [r3, #0]
24005142:	68fb      	ldr	r3, [r7, #12]
24005144:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005146:	f003 031f 	and.w	r3, r3, #31
2400514a:	2108      	movs	r1, #8
2400514c:	fa01 f303 	lsl.w	r3, r1, r3
24005150:	4013      	ands	r3, r2
24005152:	2b00      	cmp	r3, #0
24005154:	d014      	beq.n	24005180 <HAL_DMA_PollForTransfer+0x36c>
      {
        /* When a DMA transfer error occurs */
        /* A hardware clear of its EN bits is performed */
        /* Clear all flags */
        (*isr_reg) = ((BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU));
24005156:	68fb      	ldr	r3, [r7, #12]
24005158:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400515a:	f003 031f 	and.w	r3, r3, #31
2400515e:	2201      	movs	r2, #1
24005160:	409a      	lsls	r2, r3
24005162:	6a3b      	ldr	r3, [r7, #32]
24005164:	601a      	str	r2, [r3, #0]

        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TE;
24005166:	68fb      	ldr	r3, [r7, #12]
24005168:	2201      	movs	r2, #1
2400516a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
2400516c:	68fb      	ldr	r3, [r7, #12]
2400516e:	2201      	movs	r2, #1
24005170:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24005174:	68fb      	ldr	r3, [r7, #12]
24005176:	2200      	movs	r2, #0
24005178:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
2400517c:	2301      	movs	r3, #1
2400517e:	e1cf      	b.n	24005520 <HAL_DMA_PollForTransfer+0x70c>
      }
    }

    /* Check for the Timeout (Not applicable in circular mode)*/
    if(Timeout != HAL_MAX_DELAY)
24005180:	687b      	ldr	r3, [r7, #4]
24005182:	f1b3 3fff 	cmp.w	r3, #4294967295
24005186:	d012      	beq.n	240051ae <HAL_DMA_PollForTransfer+0x39a>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
24005188:	f7fd f8dc 	bl	24002344 <HAL_GetTick>
2400518c:	4602      	mov	r2, r0
2400518e:	697b      	ldr	r3, [r7, #20]
24005190:	1ad3      	subs	r3, r2, r3
24005192:	687a      	ldr	r2, [r7, #4]
24005194:	429a      	cmp	r2, r3
24005196:	d302      	bcc.n	2400519e <HAL_DMA_PollForTransfer+0x38a>
24005198:	687b      	ldr	r3, [r7, #4]
2400519a:	2b00      	cmp	r3, #0
2400519c:	d107      	bne.n	240051ae <HAL_DMA_PollForTransfer+0x39a>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
2400519e:	68fb      	ldr	r3, [r7, #12]
240051a0:	2220      	movs	r2, #32
240051a2:	655a      	str	r2, [r3, #84]	; 0x54

        /* if timeout then abort the current transfer */
        /* No need to check return value: as in this case we will return HAL_ERROR with HAL_DMA_ERROR_TIMEOUT error code  */
        (void) HAL_DMA_Abort(hdma);
240051a4:	68f8      	ldr	r0, [r7, #12]
240051a6:	f7ff f8d1 	bl	2400434c <HAL_DMA_Abort>
              - Clear the transfer error flags
              - Unlock
              - Set the State
          */

        return HAL_ERROR;
240051aa:	2301      	movs	r3, #1
240051ac:	e1b8      	b.n	24005520 <HAL_DMA_PollForTransfer+0x70c>
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240051ae:	68fb      	ldr	r3, [r7, #12]
240051b0:	681b      	ldr	r3, [r3, #0]
240051b2:	4a81      	ldr	r2, [pc, #516]	; (240053b8 <HAL_DMA_PollForTransfer+0x5a4>)
240051b4:	4293      	cmp	r3, r2
240051b6:	d072      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051b8:	68fb      	ldr	r3, [r7, #12]
240051ba:	681b      	ldr	r3, [r3, #0]
240051bc:	4a7f      	ldr	r2, [pc, #508]	; (240053bc <HAL_DMA_PollForTransfer+0x5a8>)
240051be:	4293      	cmp	r3, r2
240051c0:	d06d      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051c2:	68fb      	ldr	r3, [r7, #12]
240051c4:	681b      	ldr	r3, [r3, #0]
240051c6:	4a7e      	ldr	r2, [pc, #504]	; (240053c0 <HAL_DMA_PollForTransfer+0x5ac>)
240051c8:	4293      	cmp	r3, r2
240051ca:	d068      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051cc:	68fb      	ldr	r3, [r7, #12]
240051ce:	681b      	ldr	r3, [r3, #0]
240051d0:	4a7c      	ldr	r2, [pc, #496]	; (240053c4 <HAL_DMA_PollForTransfer+0x5b0>)
240051d2:	4293      	cmp	r3, r2
240051d4:	d063      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051d6:	68fb      	ldr	r3, [r7, #12]
240051d8:	681b      	ldr	r3, [r3, #0]
240051da:	4a7b      	ldr	r2, [pc, #492]	; (240053c8 <HAL_DMA_PollForTransfer+0x5b4>)
240051dc:	4293      	cmp	r3, r2
240051de:	d05e      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051e0:	68fb      	ldr	r3, [r7, #12]
240051e2:	681b      	ldr	r3, [r3, #0]
240051e4:	4a79      	ldr	r2, [pc, #484]	; (240053cc <HAL_DMA_PollForTransfer+0x5b8>)
240051e6:	4293      	cmp	r3, r2
240051e8:	d059      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051ea:	68fb      	ldr	r3, [r7, #12]
240051ec:	681b      	ldr	r3, [r3, #0]
240051ee:	4a78      	ldr	r2, [pc, #480]	; (240053d0 <HAL_DMA_PollForTransfer+0x5bc>)
240051f0:	4293      	cmp	r3, r2
240051f2:	d054      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051f4:	68fb      	ldr	r3, [r7, #12]
240051f6:	681b      	ldr	r3, [r3, #0]
240051f8:	4a76      	ldr	r2, [pc, #472]	; (240053d4 <HAL_DMA_PollForTransfer+0x5c0>)
240051fa:	4293      	cmp	r3, r2
240051fc:	d04f      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
240051fe:	68fb      	ldr	r3, [r7, #12]
24005200:	681b      	ldr	r3, [r3, #0]
24005202:	4a75      	ldr	r2, [pc, #468]	; (240053d8 <HAL_DMA_PollForTransfer+0x5c4>)
24005204:	4293      	cmp	r3, r2
24005206:	d04a      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005208:	68fb      	ldr	r3, [r7, #12]
2400520a:	681b      	ldr	r3, [r3, #0]
2400520c:	4a73      	ldr	r2, [pc, #460]	; (240053dc <HAL_DMA_PollForTransfer+0x5c8>)
2400520e:	4293      	cmp	r3, r2
24005210:	d045      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005212:	68fb      	ldr	r3, [r7, #12]
24005214:	681b      	ldr	r3, [r3, #0]
24005216:	4a72      	ldr	r2, [pc, #456]	; (240053e0 <HAL_DMA_PollForTransfer+0x5cc>)
24005218:	4293      	cmp	r3, r2
2400521a:	d040      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
2400521c:	68fb      	ldr	r3, [r7, #12]
2400521e:	681b      	ldr	r3, [r3, #0]
24005220:	4a70      	ldr	r2, [pc, #448]	; (240053e4 <HAL_DMA_PollForTransfer+0x5d0>)
24005222:	4293      	cmp	r3, r2
24005224:	d03b      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005226:	68fb      	ldr	r3, [r7, #12]
24005228:	681b      	ldr	r3, [r3, #0]
2400522a:	4a6f      	ldr	r2, [pc, #444]	; (240053e8 <HAL_DMA_PollForTransfer+0x5d4>)
2400522c:	4293      	cmp	r3, r2
2400522e:	d036      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005230:	68fb      	ldr	r3, [r7, #12]
24005232:	681b      	ldr	r3, [r3, #0]
24005234:	4a6d      	ldr	r2, [pc, #436]	; (240053ec <HAL_DMA_PollForTransfer+0x5d8>)
24005236:	4293      	cmp	r3, r2
24005238:	d031      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
2400523a:	68fb      	ldr	r3, [r7, #12]
2400523c:	681b      	ldr	r3, [r3, #0]
2400523e:	4a6c      	ldr	r2, [pc, #432]	; (240053f0 <HAL_DMA_PollForTransfer+0x5dc>)
24005240:	4293      	cmp	r3, r2
24005242:	d02c      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005244:	68fb      	ldr	r3, [r7, #12]
24005246:	681b      	ldr	r3, [r3, #0]
24005248:	4a6a      	ldr	r2, [pc, #424]	; (240053f4 <HAL_DMA_PollForTransfer+0x5e0>)
2400524a:	4293      	cmp	r3, r2
2400524c:	d027      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
2400524e:	68fb      	ldr	r3, [r7, #12]
24005250:	681b      	ldr	r3, [r3, #0]
24005252:	4a69      	ldr	r2, [pc, #420]	; (240053f8 <HAL_DMA_PollForTransfer+0x5e4>)
24005254:	4293      	cmp	r3, r2
24005256:	d022      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005258:	68fb      	ldr	r3, [r7, #12]
2400525a:	681b      	ldr	r3, [r3, #0]
2400525c:	4a67      	ldr	r2, [pc, #412]	; (240053fc <HAL_DMA_PollForTransfer+0x5e8>)
2400525e:	4293      	cmp	r3, r2
24005260:	d01d      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005262:	68fb      	ldr	r3, [r7, #12]
24005264:	681b      	ldr	r3, [r3, #0]
24005266:	4a66      	ldr	r2, [pc, #408]	; (24005400 <HAL_DMA_PollForTransfer+0x5ec>)
24005268:	4293      	cmp	r3, r2
2400526a:	d018      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
2400526c:	68fb      	ldr	r3, [r7, #12]
2400526e:	681b      	ldr	r3, [r3, #0]
24005270:	4a64      	ldr	r2, [pc, #400]	; (24005404 <HAL_DMA_PollForTransfer+0x5f0>)
24005272:	4293      	cmp	r3, r2
24005274:	d013      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005276:	68fb      	ldr	r3, [r7, #12]
24005278:	681b      	ldr	r3, [r3, #0]
2400527a:	4a63      	ldr	r2, [pc, #396]	; (24005408 <HAL_DMA_PollForTransfer+0x5f4>)
2400527c:	4293      	cmp	r3, r2
2400527e:	d00e      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005280:	68fb      	ldr	r3, [r7, #12]
24005282:	681b      	ldr	r3, [r3, #0]
24005284:	4a61      	ldr	r2, [pc, #388]	; (2400540c <HAL_DMA_PollForTransfer+0x5f8>)
24005286:	4293      	cmp	r3, r2
24005288:	d009      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
2400528a:	68fb      	ldr	r3, [r7, #12]
2400528c:	681b      	ldr	r3, [r3, #0]
2400528e:	4a60      	ldr	r2, [pc, #384]	; (24005410 <HAL_DMA_PollForTransfer+0x5fc>)
24005290:	4293      	cmp	r3, r2
24005292:	d004      	beq.n	2400529e <HAL_DMA_PollForTransfer+0x48a>
24005294:	68fb      	ldr	r3, [r7, #12]
24005296:	681b      	ldr	r3, [r3, #0]
24005298:	4a5e      	ldr	r2, [pc, #376]	; (24005414 <HAL_DMA_PollForTransfer+0x600>)
2400529a:	4293      	cmp	r3, r2
2400529c:	d101      	bne.n	240052a2 <HAL_DMA_PollForTransfer+0x48e>
2400529e:	2301      	movs	r3, #1
240052a0:	e000      	b.n	240052a4 <HAL_DMA_PollForTransfer+0x490>
240052a2:	2300      	movs	r3, #0
240052a4:	2b00      	cmp	r3, #0
240052a6:	d029      	beq.n	240052fc <HAL_DMA_PollForTransfer+0x4e8>
    {
      /* Check for DMAMUX Request generator (if used) overrun status */
      if(hdma->DMAmuxRequestGen != 0U)
240052a8:	68fb      	ldr	r3, [r7, #12]
240052aa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240052ac:	2b00      	cmp	r3, #0
240052ae:	d012      	beq.n	240052d6 <HAL_DMA_PollForTransfer+0x4c2>
      {
        /* if using DMAMUX request generator Check for DMAMUX request generator overrun */
        if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
240052b0:	68fb      	ldr	r3, [r7, #12]
240052b2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240052b4:	681a      	ldr	r2, [r3, #0]
240052b6:	68fb      	ldr	r3, [r7, #12]
240052b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
240052ba:	4013      	ands	r3, r2
240052bc:	2b00      	cmp	r3, #0
240052be:	d00a      	beq.n	240052d6 <HAL_DMA_PollForTransfer+0x4c2>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
240052c0:	68fb      	ldr	r3, [r7, #12]
240052c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240052c4:	68fa      	ldr	r2, [r7, #12]
240052c6:	6f52      	ldr	r2, [r2, #116]	; 0x74
240052c8:	605a      	str	r2, [r3, #4]

          /* Update error code */
          hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
240052ca:	68fb      	ldr	r3, [r7, #12]
240052cc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240052ce:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
240052d2:	68fb      	ldr	r3, [r7, #12]
240052d4:	655a      	str	r2, [r3, #84]	; 0x54
        }
      }

      /* Check for DMAMUX Synchronization overrun */
      if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
240052d6:	68fb      	ldr	r3, [r7, #12]
240052d8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240052da:	681a      	ldr	r2, [r3, #0]
240052dc:	68fb      	ldr	r3, [r7, #12]
240052de:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240052e0:	4013      	ands	r3, r2
240052e2:	2b00      	cmp	r3, #0
240052e4:	d00a      	beq.n	240052fc <HAL_DMA_PollForTransfer+0x4e8>
      {
        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
240052e6:	68fb      	ldr	r3, [r7, #12]
240052e8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240052ea:	68fa      	ldr	r2, [r7, #12]
240052ec:	6e92      	ldr	r2, [r2, #104]	; 0x68
240052ee:	605a      	str	r2, [r3, #4]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
240052f0:	68fb      	ldr	r3, [r7, #12]
240052f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240052f4:	f443 7200 	orr.w	r2, r3, #512	; 0x200
240052f8:	68fb      	ldr	r3, [r7, #12]
240052fa:	655a      	str	r2, [r3, #84]	; 0x54
  while(((*isr_reg) & cpltlevel_mask) == 0U)
240052fc:	6a3b      	ldr	r3, [r7, #32]
240052fe:	681a      	ldr	r2, [r3, #0]
24005300:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24005302:	4013      	ands	r3, r2
24005304:	2b00      	cmp	r3, #0
24005306:	f43f ae4c 	beq.w	24004fa2 <HAL_DMA_PollForTransfer+0x18e>
    }
  }


  /* Get the level transfer complete flag */
  if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
2400530a:	7afb      	ldrb	r3, [r7, #11]
2400530c:	2b00      	cmp	r3, #0
2400530e:	f040 80a0 	bne.w	24005452 <HAL_DMA_PollForTransfer+0x63e>
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24005312:	68fb      	ldr	r3, [r7, #12]
24005314:	681b      	ldr	r3, [r3, #0]
24005316:	4a28      	ldr	r2, [pc, #160]	; (240053b8 <HAL_DMA_PollForTransfer+0x5a4>)
24005318:	4293      	cmp	r3, r2
2400531a:	d04a      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
2400531c:	68fb      	ldr	r3, [r7, #12]
2400531e:	681b      	ldr	r3, [r3, #0]
24005320:	4a26      	ldr	r2, [pc, #152]	; (240053bc <HAL_DMA_PollForTransfer+0x5a8>)
24005322:	4293      	cmp	r3, r2
24005324:	d045      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005326:	68fb      	ldr	r3, [r7, #12]
24005328:	681b      	ldr	r3, [r3, #0]
2400532a:	4a25      	ldr	r2, [pc, #148]	; (240053c0 <HAL_DMA_PollForTransfer+0x5ac>)
2400532c:	4293      	cmp	r3, r2
2400532e:	d040      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005330:	68fb      	ldr	r3, [r7, #12]
24005332:	681b      	ldr	r3, [r3, #0]
24005334:	4a23      	ldr	r2, [pc, #140]	; (240053c4 <HAL_DMA_PollForTransfer+0x5b0>)
24005336:	4293      	cmp	r3, r2
24005338:	d03b      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
2400533a:	68fb      	ldr	r3, [r7, #12]
2400533c:	681b      	ldr	r3, [r3, #0]
2400533e:	4a22      	ldr	r2, [pc, #136]	; (240053c8 <HAL_DMA_PollForTransfer+0x5b4>)
24005340:	4293      	cmp	r3, r2
24005342:	d036      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005344:	68fb      	ldr	r3, [r7, #12]
24005346:	681b      	ldr	r3, [r3, #0]
24005348:	4a20      	ldr	r2, [pc, #128]	; (240053cc <HAL_DMA_PollForTransfer+0x5b8>)
2400534a:	4293      	cmp	r3, r2
2400534c:	d031      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
2400534e:	68fb      	ldr	r3, [r7, #12]
24005350:	681b      	ldr	r3, [r3, #0]
24005352:	4a1f      	ldr	r2, [pc, #124]	; (240053d0 <HAL_DMA_PollForTransfer+0x5bc>)
24005354:	4293      	cmp	r3, r2
24005356:	d02c      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005358:	68fb      	ldr	r3, [r7, #12]
2400535a:	681b      	ldr	r3, [r3, #0]
2400535c:	4a1d      	ldr	r2, [pc, #116]	; (240053d4 <HAL_DMA_PollForTransfer+0x5c0>)
2400535e:	4293      	cmp	r3, r2
24005360:	d027      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005362:	68fb      	ldr	r3, [r7, #12]
24005364:	681b      	ldr	r3, [r3, #0]
24005366:	4a1c      	ldr	r2, [pc, #112]	; (240053d8 <HAL_DMA_PollForTransfer+0x5c4>)
24005368:	4293      	cmp	r3, r2
2400536a:	d022      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
2400536c:	68fb      	ldr	r3, [r7, #12]
2400536e:	681b      	ldr	r3, [r3, #0]
24005370:	4a1a      	ldr	r2, [pc, #104]	; (240053dc <HAL_DMA_PollForTransfer+0x5c8>)
24005372:	4293      	cmp	r3, r2
24005374:	d01d      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005376:	68fb      	ldr	r3, [r7, #12]
24005378:	681b      	ldr	r3, [r3, #0]
2400537a:	4a19      	ldr	r2, [pc, #100]	; (240053e0 <HAL_DMA_PollForTransfer+0x5cc>)
2400537c:	4293      	cmp	r3, r2
2400537e:	d018      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005380:	68fb      	ldr	r3, [r7, #12]
24005382:	681b      	ldr	r3, [r3, #0]
24005384:	4a17      	ldr	r2, [pc, #92]	; (240053e4 <HAL_DMA_PollForTransfer+0x5d0>)
24005386:	4293      	cmp	r3, r2
24005388:	d013      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
2400538a:	68fb      	ldr	r3, [r7, #12]
2400538c:	681b      	ldr	r3, [r3, #0]
2400538e:	4a16      	ldr	r2, [pc, #88]	; (240053e8 <HAL_DMA_PollForTransfer+0x5d4>)
24005390:	4293      	cmp	r3, r2
24005392:	d00e      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
24005394:	68fb      	ldr	r3, [r7, #12]
24005396:	681b      	ldr	r3, [r3, #0]
24005398:	4a14      	ldr	r2, [pc, #80]	; (240053ec <HAL_DMA_PollForTransfer+0x5d8>)
2400539a:	4293      	cmp	r3, r2
2400539c:	d009      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
2400539e:	68fb      	ldr	r3, [r7, #12]
240053a0:	681b      	ldr	r3, [r3, #0]
240053a2:	4a13      	ldr	r2, [pc, #76]	; (240053f0 <HAL_DMA_PollForTransfer+0x5dc>)
240053a4:	4293      	cmp	r3, r2
240053a6:	d004      	beq.n	240053b2 <HAL_DMA_PollForTransfer+0x59e>
240053a8:	68fb      	ldr	r3, [r7, #12]
240053aa:	681b      	ldr	r3, [r3, #0]
240053ac:	4a11      	ldr	r2, [pc, #68]	; (240053f4 <HAL_DMA_PollForTransfer+0x5e0>)
240053ae:	4293      	cmp	r3, r2
240053b0:	d132      	bne.n	24005418 <HAL_DMA_PollForTransfer+0x604>
240053b2:	2301      	movs	r3, #1
240053b4:	e031      	b.n	2400541a <HAL_DMA_PollForTransfer+0x606>
240053b6:	bf00      	nop
240053b8:	40020010 	.word	0x40020010
240053bc:	40020028 	.word	0x40020028
240053c0:	40020040 	.word	0x40020040
240053c4:	40020058 	.word	0x40020058
240053c8:	40020070 	.word	0x40020070
240053cc:	40020088 	.word	0x40020088
240053d0:	400200a0 	.word	0x400200a0
240053d4:	400200b8 	.word	0x400200b8
240053d8:	40020410 	.word	0x40020410
240053dc:	40020428 	.word	0x40020428
240053e0:	40020440 	.word	0x40020440
240053e4:	40020458 	.word	0x40020458
240053e8:	40020470 	.word	0x40020470
240053ec:	40020488 	.word	0x40020488
240053f0:	400204a0 	.word	0x400204a0
240053f4:	400204b8 	.word	0x400204b8
240053f8:	58025408 	.word	0x58025408
240053fc:	5802541c 	.word	0x5802541c
24005400:	58025430 	.word	0x58025430
24005404:	58025444 	.word	0x58025444
24005408:	58025458 	.word	0x58025458
2400540c:	5802546c 	.word	0x5802546c
24005410:	58025480 	.word	0x58025480
24005414:	58025494 	.word	0x58025494
24005418:	2300      	movs	r3, #0
2400541a:	2b00      	cmp	r3, #0
2400541c:	d008      	beq.n	24005430 <HAL_DMA_PollForTransfer+0x61c>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << (hdma->StreamIndex & 0x1FU);
2400541e:	68fb      	ldr	r3, [r7, #12]
24005420:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005422:	f003 031f 	and.w	r3, r3, #31
24005426:	2230      	movs	r2, #48	; 0x30
24005428:	409a      	lsls	r2, r3
2400542a:	69fb      	ldr	r3, [r7, #28]
2400542c:	601a      	str	r2, [r3, #0]
2400542e:	e007      	b.n	24005440 <HAL_DMA_PollForTransfer+0x62c>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU));
24005430:	68fb      	ldr	r3, [r7, #12]
24005432:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005434:	f003 031f 	and.w	r3, r3, #31
24005438:	2202      	movs	r2, #2
2400543a:	409a      	lsls	r2, r3
2400543c:	69fb      	ldr	r3, [r7, #28]
2400543e:	601a      	str	r2, [r3, #0]
    }

    hdma->State = HAL_DMA_STATE_READY;
24005440:	68fb      	ldr	r3, [r7, #12]
24005442:	2201      	movs	r2, #1
24005444:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
24005448:	68fb      	ldr	r3, [r7, #12]
2400544a:	2200      	movs	r2, #0
2400544c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
24005450:	e065      	b.n	2400551e <HAL_DMA_PollForTransfer+0x70a>
  }
  else /*CompleteLevel = HAL_DMA_HALF_TRANSFER*/
  {
    /* Clear the half transfer and transfer complete flags */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24005452:	68fb      	ldr	r3, [r7, #12]
24005454:	681b      	ldr	r3, [r3, #0]
24005456:	4a34      	ldr	r2, [pc, #208]	; (24005528 <HAL_DMA_PollForTransfer+0x714>)
24005458:	4293      	cmp	r3, r2
2400545a:	d04a      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
2400545c:	68fb      	ldr	r3, [r7, #12]
2400545e:	681b      	ldr	r3, [r3, #0]
24005460:	4a32      	ldr	r2, [pc, #200]	; (2400552c <HAL_DMA_PollForTransfer+0x718>)
24005462:	4293      	cmp	r3, r2
24005464:	d045      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
24005466:	68fb      	ldr	r3, [r7, #12]
24005468:	681b      	ldr	r3, [r3, #0]
2400546a:	4a31      	ldr	r2, [pc, #196]	; (24005530 <HAL_DMA_PollForTransfer+0x71c>)
2400546c:	4293      	cmp	r3, r2
2400546e:	d040      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
24005470:	68fb      	ldr	r3, [r7, #12]
24005472:	681b      	ldr	r3, [r3, #0]
24005474:	4a2f      	ldr	r2, [pc, #188]	; (24005534 <HAL_DMA_PollForTransfer+0x720>)
24005476:	4293      	cmp	r3, r2
24005478:	d03b      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
2400547a:	68fb      	ldr	r3, [r7, #12]
2400547c:	681b      	ldr	r3, [r3, #0]
2400547e:	4a2e      	ldr	r2, [pc, #184]	; (24005538 <HAL_DMA_PollForTransfer+0x724>)
24005480:	4293      	cmp	r3, r2
24005482:	d036      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
24005484:	68fb      	ldr	r3, [r7, #12]
24005486:	681b      	ldr	r3, [r3, #0]
24005488:	4a2c      	ldr	r2, [pc, #176]	; (2400553c <HAL_DMA_PollForTransfer+0x728>)
2400548a:	4293      	cmp	r3, r2
2400548c:	d031      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
2400548e:	68fb      	ldr	r3, [r7, #12]
24005490:	681b      	ldr	r3, [r3, #0]
24005492:	4a2b      	ldr	r2, [pc, #172]	; (24005540 <HAL_DMA_PollForTransfer+0x72c>)
24005494:	4293      	cmp	r3, r2
24005496:	d02c      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
24005498:	68fb      	ldr	r3, [r7, #12]
2400549a:	681b      	ldr	r3, [r3, #0]
2400549c:	4a29      	ldr	r2, [pc, #164]	; (24005544 <HAL_DMA_PollForTransfer+0x730>)
2400549e:	4293      	cmp	r3, r2
240054a0:	d027      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054a2:	68fb      	ldr	r3, [r7, #12]
240054a4:	681b      	ldr	r3, [r3, #0]
240054a6:	4a28      	ldr	r2, [pc, #160]	; (24005548 <HAL_DMA_PollForTransfer+0x734>)
240054a8:	4293      	cmp	r3, r2
240054aa:	d022      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054ac:	68fb      	ldr	r3, [r7, #12]
240054ae:	681b      	ldr	r3, [r3, #0]
240054b0:	4a26      	ldr	r2, [pc, #152]	; (2400554c <HAL_DMA_PollForTransfer+0x738>)
240054b2:	4293      	cmp	r3, r2
240054b4:	d01d      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054b6:	68fb      	ldr	r3, [r7, #12]
240054b8:	681b      	ldr	r3, [r3, #0]
240054ba:	4a25      	ldr	r2, [pc, #148]	; (24005550 <HAL_DMA_PollForTransfer+0x73c>)
240054bc:	4293      	cmp	r3, r2
240054be:	d018      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054c0:	68fb      	ldr	r3, [r7, #12]
240054c2:	681b      	ldr	r3, [r3, #0]
240054c4:	4a23      	ldr	r2, [pc, #140]	; (24005554 <HAL_DMA_PollForTransfer+0x740>)
240054c6:	4293      	cmp	r3, r2
240054c8:	d013      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054ca:	68fb      	ldr	r3, [r7, #12]
240054cc:	681b      	ldr	r3, [r3, #0]
240054ce:	4a22      	ldr	r2, [pc, #136]	; (24005558 <HAL_DMA_PollForTransfer+0x744>)
240054d0:	4293      	cmp	r3, r2
240054d2:	d00e      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054d4:	68fb      	ldr	r3, [r7, #12]
240054d6:	681b      	ldr	r3, [r3, #0]
240054d8:	4a20      	ldr	r2, [pc, #128]	; (2400555c <HAL_DMA_PollForTransfer+0x748>)
240054da:	4293      	cmp	r3, r2
240054dc:	d009      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054de:	68fb      	ldr	r3, [r7, #12]
240054e0:	681b      	ldr	r3, [r3, #0]
240054e2:	4a1f      	ldr	r2, [pc, #124]	; (24005560 <HAL_DMA_PollForTransfer+0x74c>)
240054e4:	4293      	cmp	r3, r2
240054e6:	d004      	beq.n	240054f2 <HAL_DMA_PollForTransfer+0x6de>
240054e8:	68fb      	ldr	r3, [r7, #12]
240054ea:	681b      	ldr	r3, [r3, #0]
240054ec:	4a1d      	ldr	r2, [pc, #116]	; (24005564 <HAL_DMA_PollForTransfer+0x750>)
240054ee:	4293      	cmp	r3, r2
240054f0:	d101      	bne.n	240054f6 <HAL_DMA_PollForTransfer+0x6e2>
240054f2:	2301      	movs	r3, #1
240054f4:	e000      	b.n	240054f8 <HAL_DMA_PollForTransfer+0x6e4>
240054f6:	2300      	movs	r3, #0
240054f8:	2b00      	cmp	r3, #0
240054fa:	d008      	beq.n	2400550e <HAL_DMA_PollForTransfer+0x6fa>
    {
      (*ifcr_reg) = (DMA_FLAG_HTIF0_4) << (hdma->StreamIndex & 0x1FU);
240054fc:	68fb      	ldr	r3, [r7, #12]
240054fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005500:	f003 031f 	and.w	r3, r3, #31
24005504:	2210      	movs	r2, #16
24005506:	409a      	lsls	r2, r3
24005508:	69fb      	ldr	r3, [r7, #28]
2400550a:	601a      	str	r2, [r3, #0]
2400550c:	e007      	b.n	2400551e <HAL_DMA_PollForTransfer+0x70a>
    }
    else /* BDMA channel */
    {
      (*ifcr_reg) = (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU));
2400550e:	68fb      	ldr	r3, [r7, #12]
24005510:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005512:	f003 031f 	and.w	r3, r3, #31
24005516:	2204      	movs	r2, #4
24005518:	409a      	lsls	r2, r3
2400551a:	69fb      	ldr	r3, [r7, #28]
2400551c:	601a      	str	r2, [r3, #0]
    }
  }

  return status;
2400551e:	7efb      	ldrb	r3, [r7, #27]
}
24005520:	4618      	mov	r0, r3
24005522:	3728      	adds	r7, #40	; 0x28
24005524:	46bd      	mov	sp, r7
24005526:	bd80      	pop	{r7, pc}
24005528:	40020010 	.word	0x40020010
2400552c:	40020028 	.word	0x40020028
24005530:	40020040 	.word	0x40020040
24005534:	40020058 	.word	0x40020058
24005538:	40020070 	.word	0x40020070
2400553c:	40020088 	.word	0x40020088
24005540:	400200a0 	.word	0x400200a0
24005544:	400200b8 	.word	0x400200b8
24005548:	40020410 	.word	0x40020410
2400554c:	40020428 	.word	0x40020428
24005550:	40020440 	.word	0x40020440
24005554:	40020458 	.word	0x40020458
24005558:	40020470 	.word	0x40020470
2400555c:	40020488 	.word	0x40020488
24005560:	400204a0 	.word	0x400204a0
24005564:	400204b8 	.word	0x400204b8

24005568 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
24005568:	b580      	push	{r7, lr}
2400556a:	b08a      	sub	sp, #40	; 0x28
2400556c:	af00      	add	r7, sp, #0
2400556e:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
24005570:	2300      	movs	r3, #0
24005572:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
24005574:	4b67      	ldr	r3, [pc, #412]	; (24005714 <HAL_DMA_IRQHandler+0x1ac>)
24005576:	681b      	ldr	r3, [r3, #0]
24005578:	4a67      	ldr	r2, [pc, #412]	; (24005718 <HAL_DMA_IRQHandler+0x1b0>)
2400557a:	fba2 2303 	umull	r2, r3, r2, r3
2400557e:	0a9b      	lsrs	r3, r3, #10
24005580:	627b      	str	r3, [r7, #36]	; 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
24005582:	687b      	ldr	r3, [r7, #4]
24005584:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24005586:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24005588:	687b      	ldr	r3, [r7, #4]
2400558a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2400558c:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
2400558e:	6a3b      	ldr	r3, [r7, #32]
24005590:	681b      	ldr	r3, [r3, #0]
24005592:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
24005594:	69fb      	ldr	r3, [r7, #28]
24005596:	681b      	ldr	r3, [r3, #0]
24005598:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
2400559a:	687b      	ldr	r3, [r7, #4]
2400559c:	681b      	ldr	r3, [r3, #0]
2400559e:	4a5f      	ldr	r2, [pc, #380]	; (2400571c <HAL_DMA_IRQHandler+0x1b4>)
240055a0:	4293      	cmp	r3, r2
240055a2:	d04a      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055a4:	687b      	ldr	r3, [r7, #4]
240055a6:	681b      	ldr	r3, [r3, #0]
240055a8:	4a5d      	ldr	r2, [pc, #372]	; (24005720 <HAL_DMA_IRQHandler+0x1b8>)
240055aa:	4293      	cmp	r3, r2
240055ac:	d045      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055ae:	687b      	ldr	r3, [r7, #4]
240055b0:	681b      	ldr	r3, [r3, #0]
240055b2:	4a5c      	ldr	r2, [pc, #368]	; (24005724 <HAL_DMA_IRQHandler+0x1bc>)
240055b4:	4293      	cmp	r3, r2
240055b6:	d040      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055b8:	687b      	ldr	r3, [r7, #4]
240055ba:	681b      	ldr	r3, [r3, #0]
240055bc:	4a5a      	ldr	r2, [pc, #360]	; (24005728 <HAL_DMA_IRQHandler+0x1c0>)
240055be:	4293      	cmp	r3, r2
240055c0:	d03b      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055c2:	687b      	ldr	r3, [r7, #4]
240055c4:	681b      	ldr	r3, [r3, #0]
240055c6:	4a59      	ldr	r2, [pc, #356]	; (2400572c <HAL_DMA_IRQHandler+0x1c4>)
240055c8:	4293      	cmp	r3, r2
240055ca:	d036      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055cc:	687b      	ldr	r3, [r7, #4]
240055ce:	681b      	ldr	r3, [r3, #0]
240055d0:	4a57      	ldr	r2, [pc, #348]	; (24005730 <HAL_DMA_IRQHandler+0x1c8>)
240055d2:	4293      	cmp	r3, r2
240055d4:	d031      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055d6:	687b      	ldr	r3, [r7, #4]
240055d8:	681b      	ldr	r3, [r3, #0]
240055da:	4a56      	ldr	r2, [pc, #344]	; (24005734 <HAL_DMA_IRQHandler+0x1cc>)
240055dc:	4293      	cmp	r3, r2
240055de:	d02c      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055e0:	687b      	ldr	r3, [r7, #4]
240055e2:	681b      	ldr	r3, [r3, #0]
240055e4:	4a54      	ldr	r2, [pc, #336]	; (24005738 <HAL_DMA_IRQHandler+0x1d0>)
240055e6:	4293      	cmp	r3, r2
240055e8:	d027      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055ea:	687b      	ldr	r3, [r7, #4]
240055ec:	681b      	ldr	r3, [r3, #0]
240055ee:	4a53      	ldr	r2, [pc, #332]	; (2400573c <HAL_DMA_IRQHandler+0x1d4>)
240055f0:	4293      	cmp	r3, r2
240055f2:	d022      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055f4:	687b      	ldr	r3, [r7, #4]
240055f6:	681b      	ldr	r3, [r3, #0]
240055f8:	4a51      	ldr	r2, [pc, #324]	; (24005740 <HAL_DMA_IRQHandler+0x1d8>)
240055fa:	4293      	cmp	r3, r2
240055fc:	d01d      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
240055fe:	687b      	ldr	r3, [r7, #4]
24005600:	681b      	ldr	r3, [r3, #0]
24005602:	4a50      	ldr	r2, [pc, #320]	; (24005744 <HAL_DMA_IRQHandler+0x1dc>)
24005604:	4293      	cmp	r3, r2
24005606:	d018      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
24005608:	687b      	ldr	r3, [r7, #4]
2400560a:	681b      	ldr	r3, [r3, #0]
2400560c:	4a4e      	ldr	r2, [pc, #312]	; (24005748 <HAL_DMA_IRQHandler+0x1e0>)
2400560e:	4293      	cmp	r3, r2
24005610:	d013      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
24005612:	687b      	ldr	r3, [r7, #4]
24005614:	681b      	ldr	r3, [r3, #0]
24005616:	4a4d      	ldr	r2, [pc, #308]	; (2400574c <HAL_DMA_IRQHandler+0x1e4>)
24005618:	4293      	cmp	r3, r2
2400561a:	d00e      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
2400561c:	687b      	ldr	r3, [r7, #4]
2400561e:	681b      	ldr	r3, [r3, #0]
24005620:	4a4b      	ldr	r2, [pc, #300]	; (24005750 <HAL_DMA_IRQHandler+0x1e8>)
24005622:	4293      	cmp	r3, r2
24005624:	d009      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
24005626:	687b      	ldr	r3, [r7, #4]
24005628:	681b      	ldr	r3, [r3, #0]
2400562a:	4a4a      	ldr	r2, [pc, #296]	; (24005754 <HAL_DMA_IRQHandler+0x1ec>)
2400562c:	4293      	cmp	r3, r2
2400562e:	d004      	beq.n	2400563a <HAL_DMA_IRQHandler+0xd2>
24005630:	687b      	ldr	r3, [r7, #4]
24005632:	681b      	ldr	r3, [r3, #0]
24005634:	4a48      	ldr	r2, [pc, #288]	; (24005758 <HAL_DMA_IRQHandler+0x1f0>)
24005636:	4293      	cmp	r3, r2
24005638:	d101      	bne.n	2400563e <HAL_DMA_IRQHandler+0xd6>
2400563a:	2301      	movs	r3, #1
2400563c:	e000      	b.n	24005640 <HAL_DMA_IRQHandler+0xd8>
2400563e:	2300      	movs	r3, #0
24005640:	2b00      	cmp	r3, #0
24005642:	f000 842b 	beq.w	24005e9c <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24005646:	687b      	ldr	r3, [r7, #4]
24005648:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400564a:	f003 031f 	and.w	r3, r3, #31
2400564e:	2208      	movs	r2, #8
24005650:	409a      	lsls	r2, r3
24005652:	69bb      	ldr	r3, [r7, #24]
24005654:	4013      	ands	r3, r2
24005656:	2b00      	cmp	r3, #0
24005658:	f000 80a2 	beq.w	240057a0 <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
2400565c:	687b      	ldr	r3, [r7, #4]
2400565e:	681b      	ldr	r3, [r3, #0]
24005660:	4a2e      	ldr	r2, [pc, #184]	; (2400571c <HAL_DMA_IRQHandler+0x1b4>)
24005662:	4293      	cmp	r3, r2
24005664:	d04a      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
24005666:	687b      	ldr	r3, [r7, #4]
24005668:	681b      	ldr	r3, [r3, #0]
2400566a:	4a2d      	ldr	r2, [pc, #180]	; (24005720 <HAL_DMA_IRQHandler+0x1b8>)
2400566c:	4293      	cmp	r3, r2
2400566e:	d045      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
24005670:	687b      	ldr	r3, [r7, #4]
24005672:	681b      	ldr	r3, [r3, #0]
24005674:	4a2b      	ldr	r2, [pc, #172]	; (24005724 <HAL_DMA_IRQHandler+0x1bc>)
24005676:	4293      	cmp	r3, r2
24005678:	d040      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
2400567a:	687b      	ldr	r3, [r7, #4]
2400567c:	681b      	ldr	r3, [r3, #0]
2400567e:	4a2a      	ldr	r2, [pc, #168]	; (24005728 <HAL_DMA_IRQHandler+0x1c0>)
24005680:	4293      	cmp	r3, r2
24005682:	d03b      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
24005684:	687b      	ldr	r3, [r7, #4]
24005686:	681b      	ldr	r3, [r3, #0]
24005688:	4a28      	ldr	r2, [pc, #160]	; (2400572c <HAL_DMA_IRQHandler+0x1c4>)
2400568a:	4293      	cmp	r3, r2
2400568c:	d036      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
2400568e:	687b      	ldr	r3, [r7, #4]
24005690:	681b      	ldr	r3, [r3, #0]
24005692:	4a27      	ldr	r2, [pc, #156]	; (24005730 <HAL_DMA_IRQHandler+0x1c8>)
24005694:	4293      	cmp	r3, r2
24005696:	d031      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
24005698:	687b      	ldr	r3, [r7, #4]
2400569a:	681b      	ldr	r3, [r3, #0]
2400569c:	4a25      	ldr	r2, [pc, #148]	; (24005734 <HAL_DMA_IRQHandler+0x1cc>)
2400569e:	4293      	cmp	r3, r2
240056a0:	d02c      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056a2:	687b      	ldr	r3, [r7, #4]
240056a4:	681b      	ldr	r3, [r3, #0]
240056a6:	4a24      	ldr	r2, [pc, #144]	; (24005738 <HAL_DMA_IRQHandler+0x1d0>)
240056a8:	4293      	cmp	r3, r2
240056aa:	d027      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056ac:	687b      	ldr	r3, [r7, #4]
240056ae:	681b      	ldr	r3, [r3, #0]
240056b0:	4a22      	ldr	r2, [pc, #136]	; (2400573c <HAL_DMA_IRQHandler+0x1d4>)
240056b2:	4293      	cmp	r3, r2
240056b4:	d022      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056b6:	687b      	ldr	r3, [r7, #4]
240056b8:	681b      	ldr	r3, [r3, #0]
240056ba:	4a21      	ldr	r2, [pc, #132]	; (24005740 <HAL_DMA_IRQHandler+0x1d8>)
240056bc:	4293      	cmp	r3, r2
240056be:	d01d      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056c0:	687b      	ldr	r3, [r7, #4]
240056c2:	681b      	ldr	r3, [r3, #0]
240056c4:	4a1f      	ldr	r2, [pc, #124]	; (24005744 <HAL_DMA_IRQHandler+0x1dc>)
240056c6:	4293      	cmp	r3, r2
240056c8:	d018      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056ca:	687b      	ldr	r3, [r7, #4]
240056cc:	681b      	ldr	r3, [r3, #0]
240056ce:	4a1e      	ldr	r2, [pc, #120]	; (24005748 <HAL_DMA_IRQHandler+0x1e0>)
240056d0:	4293      	cmp	r3, r2
240056d2:	d013      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056d4:	687b      	ldr	r3, [r7, #4]
240056d6:	681b      	ldr	r3, [r3, #0]
240056d8:	4a1c      	ldr	r2, [pc, #112]	; (2400574c <HAL_DMA_IRQHandler+0x1e4>)
240056da:	4293      	cmp	r3, r2
240056dc:	d00e      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056de:	687b      	ldr	r3, [r7, #4]
240056e0:	681b      	ldr	r3, [r3, #0]
240056e2:	4a1b      	ldr	r2, [pc, #108]	; (24005750 <HAL_DMA_IRQHandler+0x1e8>)
240056e4:	4293      	cmp	r3, r2
240056e6:	d009      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056e8:	687b      	ldr	r3, [r7, #4]
240056ea:	681b      	ldr	r3, [r3, #0]
240056ec:	4a19      	ldr	r2, [pc, #100]	; (24005754 <HAL_DMA_IRQHandler+0x1ec>)
240056ee:	4293      	cmp	r3, r2
240056f0:	d004      	beq.n	240056fc <HAL_DMA_IRQHandler+0x194>
240056f2:	687b      	ldr	r3, [r7, #4]
240056f4:	681b      	ldr	r3, [r3, #0]
240056f6:	4a18      	ldr	r2, [pc, #96]	; (24005758 <HAL_DMA_IRQHandler+0x1f0>)
240056f8:	4293      	cmp	r3, r2
240056fa:	d12f      	bne.n	2400575c <HAL_DMA_IRQHandler+0x1f4>
240056fc:	687b      	ldr	r3, [r7, #4]
240056fe:	681b      	ldr	r3, [r3, #0]
24005700:	681b      	ldr	r3, [r3, #0]
24005702:	f003 0304 	and.w	r3, r3, #4
24005706:	2b00      	cmp	r3, #0
24005708:	bf14      	ite	ne
2400570a:	2301      	movne	r3, #1
2400570c:	2300      	moveq	r3, #0
2400570e:	b2db      	uxtb	r3, r3
24005710:	e02e      	b.n	24005770 <HAL_DMA_IRQHandler+0x208>
24005712:	bf00      	nop
24005714:	240004b0 	.word	0x240004b0
24005718:	1b4e81b5 	.word	0x1b4e81b5
2400571c:	40020010 	.word	0x40020010
24005720:	40020028 	.word	0x40020028
24005724:	40020040 	.word	0x40020040
24005728:	40020058 	.word	0x40020058
2400572c:	40020070 	.word	0x40020070
24005730:	40020088 	.word	0x40020088
24005734:	400200a0 	.word	0x400200a0
24005738:	400200b8 	.word	0x400200b8
2400573c:	40020410 	.word	0x40020410
24005740:	40020428 	.word	0x40020428
24005744:	40020440 	.word	0x40020440
24005748:	40020458 	.word	0x40020458
2400574c:	40020470 	.word	0x40020470
24005750:	40020488 	.word	0x40020488
24005754:	400204a0 	.word	0x400204a0
24005758:	400204b8 	.word	0x400204b8
2400575c:	687b      	ldr	r3, [r7, #4]
2400575e:	681b      	ldr	r3, [r3, #0]
24005760:	681b      	ldr	r3, [r3, #0]
24005762:	f003 0308 	and.w	r3, r3, #8
24005766:	2b00      	cmp	r3, #0
24005768:	bf14      	ite	ne
2400576a:	2301      	movne	r3, #1
2400576c:	2300      	moveq	r3, #0
2400576e:	b2db      	uxtb	r3, r3
24005770:	2b00      	cmp	r3, #0
24005772:	d015      	beq.n	240057a0 <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
24005774:	687b      	ldr	r3, [r7, #4]
24005776:	681b      	ldr	r3, [r3, #0]
24005778:	681a      	ldr	r2, [r3, #0]
2400577a:	687b      	ldr	r3, [r7, #4]
2400577c:	681b      	ldr	r3, [r3, #0]
2400577e:	f022 0204 	bic.w	r2, r2, #4
24005782:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
24005784:	687b      	ldr	r3, [r7, #4]
24005786:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005788:	f003 031f 	and.w	r3, r3, #31
2400578c:	2208      	movs	r2, #8
2400578e:	409a      	lsls	r2, r3
24005790:	6a3b      	ldr	r3, [r7, #32]
24005792:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
24005794:	687b      	ldr	r3, [r7, #4]
24005796:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005798:	f043 0201 	orr.w	r2, r3, #1
2400579c:	687b      	ldr	r3, [r7, #4]
2400579e:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240057a0:	687b      	ldr	r3, [r7, #4]
240057a2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240057a4:	f003 031f 	and.w	r3, r3, #31
240057a8:	69ba      	ldr	r2, [r7, #24]
240057aa:	fa22 f303 	lsr.w	r3, r2, r3
240057ae:	f003 0301 	and.w	r3, r3, #1
240057b2:	2b00      	cmp	r3, #0
240057b4:	d06e      	beq.n	24005894 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
240057b6:	687b      	ldr	r3, [r7, #4]
240057b8:	681b      	ldr	r3, [r3, #0]
240057ba:	4a69      	ldr	r2, [pc, #420]	; (24005960 <HAL_DMA_IRQHandler+0x3f8>)
240057bc:	4293      	cmp	r3, r2
240057be:	d04a      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
240057c0:	687b      	ldr	r3, [r7, #4]
240057c2:	681b      	ldr	r3, [r3, #0]
240057c4:	4a67      	ldr	r2, [pc, #412]	; (24005964 <HAL_DMA_IRQHandler+0x3fc>)
240057c6:	4293      	cmp	r3, r2
240057c8:	d045      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
240057ca:	687b      	ldr	r3, [r7, #4]
240057cc:	681b      	ldr	r3, [r3, #0]
240057ce:	4a66      	ldr	r2, [pc, #408]	; (24005968 <HAL_DMA_IRQHandler+0x400>)
240057d0:	4293      	cmp	r3, r2
240057d2:	d040      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
240057d4:	687b      	ldr	r3, [r7, #4]
240057d6:	681b      	ldr	r3, [r3, #0]
240057d8:	4a64      	ldr	r2, [pc, #400]	; (2400596c <HAL_DMA_IRQHandler+0x404>)
240057da:	4293      	cmp	r3, r2
240057dc:	d03b      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
240057de:	687b      	ldr	r3, [r7, #4]
240057e0:	681b      	ldr	r3, [r3, #0]
240057e2:	4a63      	ldr	r2, [pc, #396]	; (24005970 <HAL_DMA_IRQHandler+0x408>)
240057e4:	4293      	cmp	r3, r2
240057e6:	d036      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
240057e8:	687b      	ldr	r3, [r7, #4]
240057ea:	681b      	ldr	r3, [r3, #0]
240057ec:	4a61      	ldr	r2, [pc, #388]	; (24005974 <HAL_DMA_IRQHandler+0x40c>)
240057ee:	4293      	cmp	r3, r2
240057f0:	d031      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
240057f2:	687b      	ldr	r3, [r7, #4]
240057f4:	681b      	ldr	r3, [r3, #0]
240057f6:	4a60      	ldr	r2, [pc, #384]	; (24005978 <HAL_DMA_IRQHandler+0x410>)
240057f8:	4293      	cmp	r3, r2
240057fa:	d02c      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
240057fc:	687b      	ldr	r3, [r7, #4]
240057fe:	681b      	ldr	r3, [r3, #0]
24005800:	4a5e      	ldr	r2, [pc, #376]	; (2400597c <HAL_DMA_IRQHandler+0x414>)
24005802:	4293      	cmp	r3, r2
24005804:	d027      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
24005806:	687b      	ldr	r3, [r7, #4]
24005808:	681b      	ldr	r3, [r3, #0]
2400580a:	4a5d      	ldr	r2, [pc, #372]	; (24005980 <HAL_DMA_IRQHandler+0x418>)
2400580c:	4293      	cmp	r3, r2
2400580e:	d022      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
24005810:	687b      	ldr	r3, [r7, #4]
24005812:	681b      	ldr	r3, [r3, #0]
24005814:	4a5b      	ldr	r2, [pc, #364]	; (24005984 <HAL_DMA_IRQHandler+0x41c>)
24005816:	4293      	cmp	r3, r2
24005818:	d01d      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
2400581a:	687b      	ldr	r3, [r7, #4]
2400581c:	681b      	ldr	r3, [r3, #0]
2400581e:	4a5a      	ldr	r2, [pc, #360]	; (24005988 <HAL_DMA_IRQHandler+0x420>)
24005820:	4293      	cmp	r3, r2
24005822:	d018      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
24005824:	687b      	ldr	r3, [r7, #4]
24005826:	681b      	ldr	r3, [r3, #0]
24005828:	4a58      	ldr	r2, [pc, #352]	; (2400598c <HAL_DMA_IRQHandler+0x424>)
2400582a:	4293      	cmp	r3, r2
2400582c:	d013      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
2400582e:	687b      	ldr	r3, [r7, #4]
24005830:	681b      	ldr	r3, [r3, #0]
24005832:	4a57      	ldr	r2, [pc, #348]	; (24005990 <HAL_DMA_IRQHandler+0x428>)
24005834:	4293      	cmp	r3, r2
24005836:	d00e      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
24005838:	687b      	ldr	r3, [r7, #4]
2400583a:	681b      	ldr	r3, [r3, #0]
2400583c:	4a55      	ldr	r2, [pc, #340]	; (24005994 <HAL_DMA_IRQHandler+0x42c>)
2400583e:	4293      	cmp	r3, r2
24005840:	d009      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
24005842:	687b      	ldr	r3, [r7, #4]
24005844:	681b      	ldr	r3, [r3, #0]
24005846:	4a54      	ldr	r2, [pc, #336]	; (24005998 <HAL_DMA_IRQHandler+0x430>)
24005848:	4293      	cmp	r3, r2
2400584a:	d004      	beq.n	24005856 <HAL_DMA_IRQHandler+0x2ee>
2400584c:	687b      	ldr	r3, [r7, #4]
2400584e:	681b      	ldr	r3, [r3, #0]
24005850:	4a52      	ldr	r2, [pc, #328]	; (2400599c <HAL_DMA_IRQHandler+0x434>)
24005852:	4293      	cmp	r3, r2
24005854:	d10a      	bne.n	2400586c <HAL_DMA_IRQHandler+0x304>
24005856:	687b      	ldr	r3, [r7, #4]
24005858:	681b      	ldr	r3, [r3, #0]
2400585a:	695b      	ldr	r3, [r3, #20]
2400585c:	f003 0380 	and.w	r3, r3, #128	; 0x80
24005860:	2b00      	cmp	r3, #0
24005862:	bf14      	ite	ne
24005864:	2301      	movne	r3, #1
24005866:	2300      	moveq	r3, #0
24005868:	b2db      	uxtb	r3, r3
2400586a:	e003      	b.n	24005874 <HAL_DMA_IRQHandler+0x30c>
2400586c:	687b      	ldr	r3, [r7, #4]
2400586e:	681b      	ldr	r3, [r3, #0]
24005870:	681b      	ldr	r3, [r3, #0]
24005872:	2300      	movs	r3, #0
24005874:	2b00      	cmp	r3, #0
24005876:	d00d      	beq.n	24005894 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
24005878:	687b      	ldr	r3, [r7, #4]
2400587a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400587c:	f003 031f 	and.w	r3, r3, #31
24005880:	2201      	movs	r2, #1
24005882:	409a      	lsls	r2, r3
24005884:	6a3b      	ldr	r3, [r7, #32]
24005886:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
24005888:	687b      	ldr	r3, [r7, #4]
2400588a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2400588c:	f043 0202 	orr.w	r2, r3, #2
24005890:	687b      	ldr	r3, [r7, #4]
24005892:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24005894:	687b      	ldr	r3, [r7, #4]
24005896:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005898:	f003 031f 	and.w	r3, r3, #31
2400589c:	2204      	movs	r2, #4
2400589e:	409a      	lsls	r2, r3
240058a0:	69bb      	ldr	r3, [r7, #24]
240058a2:	4013      	ands	r3, r2
240058a4:	2b00      	cmp	r3, #0
240058a6:	f000 808f 	beq.w	240059c8 <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
240058aa:	687b      	ldr	r3, [r7, #4]
240058ac:	681b      	ldr	r3, [r3, #0]
240058ae:	4a2c      	ldr	r2, [pc, #176]	; (24005960 <HAL_DMA_IRQHandler+0x3f8>)
240058b0:	4293      	cmp	r3, r2
240058b2:	d04a      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058b4:	687b      	ldr	r3, [r7, #4]
240058b6:	681b      	ldr	r3, [r3, #0]
240058b8:	4a2a      	ldr	r2, [pc, #168]	; (24005964 <HAL_DMA_IRQHandler+0x3fc>)
240058ba:	4293      	cmp	r3, r2
240058bc:	d045      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058be:	687b      	ldr	r3, [r7, #4]
240058c0:	681b      	ldr	r3, [r3, #0]
240058c2:	4a29      	ldr	r2, [pc, #164]	; (24005968 <HAL_DMA_IRQHandler+0x400>)
240058c4:	4293      	cmp	r3, r2
240058c6:	d040      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058c8:	687b      	ldr	r3, [r7, #4]
240058ca:	681b      	ldr	r3, [r3, #0]
240058cc:	4a27      	ldr	r2, [pc, #156]	; (2400596c <HAL_DMA_IRQHandler+0x404>)
240058ce:	4293      	cmp	r3, r2
240058d0:	d03b      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058d2:	687b      	ldr	r3, [r7, #4]
240058d4:	681b      	ldr	r3, [r3, #0]
240058d6:	4a26      	ldr	r2, [pc, #152]	; (24005970 <HAL_DMA_IRQHandler+0x408>)
240058d8:	4293      	cmp	r3, r2
240058da:	d036      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058dc:	687b      	ldr	r3, [r7, #4]
240058de:	681b      	ldr	r3, [r3, #0]
240058e0:	4a24      	ldr	r2, [pc, #144]	; (24005974 <HAL_DMA_IRQHandler+0x40c>)
240058e2:	4293      	cmp	r3, r2
240058e4:	d031      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058e6:	687b      	ldr	r3, [r7, #4]
240058e8:	681b      	ldr	r3, [r3, #0]
240058ea:	4a23      	ldr	r2, [pc, #140]	; (24005978 <HAL_DMA_IRQHandler+0x410>)
240058ec:	4293      	cmp	r3, r2
240058ee:	d02c      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058f0:	687b      	ldr	r3, [r7, #4]
240058f2:	681b      	ldr	r3, [r3, #0]
240058f4:	4a21      	ldr	r2, [pc, #132]	; (2400597c <HAL_DMA_IRQHandler+0x414>)
240058f6:	4293      	cmp	r3, r2
240058f8:	d027      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
240058fa:	687b      	ldr	r3, [r7, #4]
240058fc:	681b      	ldr	r3, [r3, #0]
240058fe:	4a20      	ldr	r2, [pc, #128]	; (24005980 <HAL_DMA_IRQHandler+0x418>)
24005900:	4293      	cmp	r3, r2
24005902:	d022      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
24005904:	687b      	ldr	r3, [r7, #4]
24005906:	681b      	ldr	r3, [r3, #0]
24005908:	4a1e      	ldr	r2, [pc, #120]	; (24005984 <HAL_DMA_IRQHandler+0x41c>)
2400590a:	4293      	cmp	r3, r2
2400590c:	d01d      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
2400590e:	687b      	ldr	r3, [r7, #4]
24005910:	681b      	ldr	r3, [r3, #0]
24005912:	4a1d      	ldr	r2, [pc, #116]	; (24005988 <HAL_DMA_IRQHandler+0x420>)
24005914:	4293      	cmp	r3, r2
24005916:	d018      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
24005918:	687b      	ldr	r3, [r7, #4]
2400591a:	681b      	ldr	r3, [r3, #0]
2400591c:	4a1b      	ldr	r2, [pc, #108]	; (2400598c <HAL_DMA_IRQHandler+0x424>)
2400591e:	4293      	cmp	r3, r2
24005920:	d013      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
24005922:	687b      	ldr	r3, [r7, #4]
24005924:	681b      	ldr	r3, [r3, #0]
24005926:	4a1a      	ldr	r2, [pc, #104]	; (24005990 <HAL_DMA_IRQHandler+0x428>)
24005928:	4293      	cmp	r3, r2
2400592a:	d00e      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
2400592c:	687b      	ldr	r3, [r7, #4]
2400592e:	681b      	ldr	r3, [r3, #0]
24005930:	4a18      	ldr	r2, [pc, #96]	; (24005994 <HAL_DMA_IRQHandler+0x42c>)
24005932:	4293      	cmp	r3, r2
24005934:	d009      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
24005936:	687b      	ldr	r3, [r7, #4]
24005938:	681b      	ldr	r3, [r3, #0]
2400593a:	4a17      	ldr	r2, [pc, #92]	; (24005998 <HAL_DMA_IRQHandler+0x430>)
2400593c:	4293      	cmp	r3, r2
2400593e:	d004      	beq.n	2400594a <HAL_DMA_IRQHandler+0x3e2>
24005940:	687b      	ldr	r3, [r7, #4]
24005942:	681b      	ldr	r3, [r3, #0]
24005944:	4a15      	ldr	r2, [pc, #84]	; (2400599c <HAL_DMA_IRQHandler+0x434>)
24005946:	4293      	cmp	r3, r2
24005948:	d12a      	bne.n	240059a0 <HAL_DMA_IRQHandler+0x438>
2400594a:	687b      	ldr	r3, [r7, #4]
2400594c:	681b      	ldr	r3, [r3, #0]
2400594e:	681b      	ldr	r3, [r3, #0]
24005950:	f003 0302 	and.w	r3, r3, #2
24005954:	2b00      	cmp	r3, #0
24005956:	bf14      	ite	ne
24005958:	2301      	movne	r3, #1
2400595a:	2300      	moveq	r3, #0
2400595c:	b2db      	uxtb	r3, r3
2400595e:	e023      	b.n	240059a8 <HAL_DMA_IRQHandler+0x440>
24005960:	40020010 	.word	0x40020010
24005964:	40020028 	.word	0x40020028
24005968:	40020040 	.word	0x40020040
2400596c:	40020058 	.word	0x40020058
24005970:	40020070 	.word	0x40020070
24005974:	40020088 	.word	0x40020088
24005978:	400200a0 	.word	0x400200a0
2400597c:	400200b8 	.word	0x400200b8
24005980:	40020410 	.word	0x40020410
24005984:	40020428 	.word	0x40020428
24005988:	40020440 	.word	0x40020440
2400598c:	40020458 	.word	0x40020458
24005990:	40020470 	.word	0x40020470
24005994:	40020488 	.word	0x40020488
24005998:	400204a0 	.word	0x400204a0
2400599c:	400204b8 	.word	0x400204b8
240059a0:	687b      	ldr	r3, [r7, #4]
240059a2:	681b      	ldr	r3, [r3, #0]
240059a4:	681b      	ldr	r3, [r3, #0]
240059a6:	2300      	movs	r3, #0
240059a8:	2b00      	cmp	r3, #0
240059aa:	d00d      	beq.n	240059c8 <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
240059ac:	687b      	ldr	r3, [r7, #4]
240059ae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240059b0:	f003 031f 	and.w	r3, r3, #31
240059b4:	2204      	movs	r2, #4
240059b6:	409a      	lsls	r2, r3
240059b8:	6a3b      	ldr	r3, [r7, #32]
240059ba:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
240059bc:	687b      	ldr	r3, [r7, #4]
240059be:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240059c0:	f043 0204 	orr.w	r2, r3, #4
240059c4:	687b      	ldr	r3, [r7, #4]
240059c6:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
240059c8:	687b      	ldr	r3, [r7, #4]
240059ca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240059cc:	f003 031f 	and.w	r3, r3, #31
240059d0:	2210      	movs	r2, #16
240059d2:	409a      	lsls	r2, r3
240059d4:	69bb      	ldr	r3, [r7, #24]
240059d6:	4013      	ands	r3, r2
240059d8:	2b00      	cmp	r3, #0
240059da:	f000 80a6 	beq.w	24005b2a <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
240059de:	687b      	ldr	r3, [r7, #4]
240059e0:	681b      	ldr	r3, [r3, #0]
240059e2:	4a85      	ldr	r2, [pc, #532]	; (24005bf8 <HAL_DMA_IRQHandler+0x690>)
240059e4:	4293      	cmp	r3, r2
240059e6:	d04a      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
240059e8:	687b      	ldr	r3, [r7, #4]
240059ea:	681b      	ldr	r3, [r3, #0]
240059ec:	4a83      	ldr	r2, [pc, #524]	; (24005bfc <HAL_DMA_IRQHandler+0x694>)
240059ee:	4293      	cmp	r3, r2
240059f0:	d045      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
240059f2:	687b      	ldr	r3, [r7, #4]
240059f4:	681b      	ldr	r3, [r3, #0]
240059f6:	4a82      	ldr	r2, [pc, #520]	; (24005c00 <HAL_DMA_IRQHandler+0x698>)
240059f8:	4293      	cmp	r3, r2
240059fa:	d040      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
240059fc:	687b      	ldr	r3, [r7, #4]
240059fe:	681b      	ldr	r3, [r3, #0]
24005a00:	4a80      	ldr	r2, [pc, #512]	; (24005c04 <HAL_DMA_IRQHandler+0x69c>)
24005a02:	4293      	cmp	r3, r2
24005a04:	d03b      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a06:	687b      	ldr	r3, [r7, #4]
24005a08:	681b      	ldr	r3, [r3, #0]
24005a0a:	4a7f      	ldr	r2, [pc, #508]	; (24005c08 <HAL_DMA_IRQHandler+0x6a0>)
24005a0c:	4293      	cmp	r3, r2
24005a0e:	d036      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a10:	687b      	ldr	r3, [r7, #4]
24005a12:	681b      	ldr	r3, [r3, #0]
24005a14:	4a7d      	ldr	r2, [pc, #500]	; (24005c0c <HAL_DMA_IRQHandler+0x6a4>)
24005a16:	4293      	cmp	r3, r2
24005a18:	d031      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a1a:	687b      	ldr	r3, [r7, #4]
24005a1c:	681b      	ldr	r3, [r3, #0]
24005a1e:	4a7c      	ldr	r2, [pc, #496]	; (24005c10 <HAL_DMA_IRQHandler+0x6a8>)
24005a20:	4293      	cmp	r3, r2
24005a22:	d02c      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a24:	687b      	ldr	r3, [r7, #4]
24005a26:	681b      	ldr	r3, [r3, #0]
24005a28:	4a7a      	ldr	r2, [pc, #488]	; (24005c14 <HAL_DMA_IRQHandler+0x6ac>)
24005a2a:	4293      	cmp	r3, r2
24005a2c:	d027      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a2e:	687b      	ldr	r3, [r7, #4]
24005a30:	681b      	ldr	r3, [r3, #0]
24005a32:	4a79      	ldr	r2, [pc, #484]	; (24005c18 <HAL_DMA_IRQHandler+0x6b0>)
24005a34:	4293      	cmp	r3, r2
24005a36:	d022      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a38:	687b      	ldr	r3, [r7, #4]
24005a3a:	681b      	ldr	r3, [r3, #0]
24005a3c:	4a77      	ldr	r2, [pc, #476]	; (24005c1c <HAL_DMA_IRQHandler+0x6b4>)
24005a3e:	4293      	cmp	r3, r2
24005a40:	d01d      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a42:	687b      	ldr	r3, [r7, #4]
24005a44:	681b      	ldr	r3, [r3, #0]
24005a46:	4a76      	ldr	r2, [pc, #472]	; (24005c20 <HAL_DMA_IRQHandler+0x6b8>)
24005a48:	4293      	cmp	r3, r2
24005a4a:	d018      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a4c:	687b      	ldr	r3, [r7, #4]
24005a4e:	681b      	ldr	r3, [r3, #0]
24005a50:	4a74      	ldr	r2, [pc, #464]	; (24005c24 <HAL_DMA_IRQHandler+0x6bc>)
24005a52:	4293      	cmp	r3, r2
24005a54:	d013      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a56:	687b      	ldr	r3, [r7, #4]
24005a58:	681b      	ldr	r3, [r3, #0]
24005a5a:	4a73      	ldr	r2, [pc, #460]	; (24005c28 <HAL_DMA_IRQHandler+0x6c0>)
24005a5c:	4293      	cmp	r3, r2
24005a5e:	d00e      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a60:	687b      	ldr	r3, [r7, #4]
24005a62:	681b      	ldr	r3, [r3, #0]
24005a64:	4a71      	ldr	r2, [pc, #452]	; (24005c2c <HAL_DMA_IRQHandler+0x6c4>)
24005a66:	4293      	cmp	r3, r2
24005a68:	d009      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a6a:	687b      	ldr	r3, [r7, #4]
24005a6c:	681b      	ldr	r3, [r3, #0]
24005a6e:	4a70      	ldr	r2, [pc, #448]	; (24005c30 <HAL_DMA_IRQHandler+0x6c8>)
24005a70:	4293      	cmp	r3, r2
24005a72:	d004      	beq.n	24005a7e <HAL_DMA_IRQHandler+0x516>
24005a74:	687b      	ldr	r3, [r7, #4]
24005a76:	681b      	ldr	r3, [r3, #0]
24005a78:	4a6e      	ldr	r2, [pc, #440]	; (24005c34 <HAL_DMA_IRQHandler+0x6cc>)
24005a7a:	4293      	cmp	r3, r2
24005a7c:	d10a      	bne.n	24005a94 <HAL_DMA_IRQHandler+0x52c>
24005a7e:	687b      	ldr	r3, [r7, #4]
24005a80:	681b      	ldr	r3, [r3, #0]
24005a82:	681b      	ldr	r3, [r3, #0]
24005a84:	f003 0308 	and.w	r3, r3, #8
24005a88:	2b00      	cmp	r3, #0
24005a8a:	bf14      	ite	ne
24005a8c:	2301      	movne	r3, #1
24005a8e:	2300      	moveq	r3, #0
24005a90:	b2db      	uxtb	r3, r3
24005a92:	e009      	b.n	24005aa8 <HAL_DMA_IRQHandler+0x540>
24005a94:	687b      	ldr	r3, [r7, #4]
24005a96:	681b      	ldr	r3, [r3, #0]
24005a98:	681b      	ldr	r3, [r3, #0]
24005a9a:	f003 0304 	and.w	r3, r3, #4
24005a9e:	2b00      	cmp	r3, #0
24005aa0:	bf14      	ite	ne
24005aa2:	2301      	movne	r3, #1
24005aa4:	2300      	moveq	r3, #0
24005aa6:	b2db      	uxtb	r3, r3
24005aa8:	2b00      	cmp	r3, #0
24005aaa:	d03e      	beq.n	24005b2a <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
24005aac:	687b      	ldr	r3, [r7, #4]
24005aae:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005ab0:	f003 031f 	and.w	r3, r3, #31
24005ab4:	2210      	movs	r2, #16
24005ab6:	409a      	lsls	r2, r3
24005ab8:	6a3b      	ldr	r3, [r7, #32]
24005aba:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
24005abc:	687b      	ldr	r3, [r7, #4]
24005abe:	681b      	ldr	r3, [r3, #0]
24005ac0:	681b      	ldr	r3, [r3, #0]
24005ac2:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24005ac6:	2b00      	cmp	r3, #0
24005ac8:	d018      	beq.n	24005afc <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
24005aca:	687b      	ldr	r3, [r7, #4]
24005acc:	681b      	ldr	r3, [r3, #0]
24005ace:	681b      	ldr	r3, [r3, #0]
24005ad0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24005ad4:	2b00      	cmp	r3, #0
24005ad6:	d108      	bne.n	24005aea <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
24005ad8:	687b      	ldr	r3, [r7, #4]
24005ada:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005adc:	2b00      	cmp	r3, #0
24005ade:	d024      	beq.n	24005b2a <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
24005ae0:	687b      	ldr	r3, [r7, #4]
24005ae2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005ae4:	6878      	ldr	r0, [r7, #4]
24005ae6:	4798      	blx	r3
24005ae8:	e01f      	b.n	24005b2a <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
24005aea:	687b      	ldr	r3, [r7, #4]
24005aec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005aee:	2b00      	cmp	r3, #0
24005af0:	d01b      	beq.n	24005b2a <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
24005af2:	687b      	ldr	r3, [r7, #4]
24005af4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005af6:	6878      	ldr	r0, [r7, #4]
24005af8:	4798      	blx	r3
24005afa:	e016      	b.n	24005b2a <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
24005afc:	687b      	ldr	r3, [r7, #4]
24005afe:	681b      	ldr	r3, [r3, #0]
24005b00:	681b      	ldr	r3, [r3, #0]
24005b02:	f403 7380 	and.w	r3, r3, #256	; 0x100
24005b06:	2b00      	cmp	r3, #0
24005b08:	d107      	bne.n	24005b1a <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
24005b0a:	687b      	ldr	r3, [r7, #4]
24005b0c:	681b      	ldr	r3, [r3, #0]
24005b0e:	681a      	ldr	r2, [r3, #0]
24005b10:	687b      	ldr	r3, [r7, #4]
24005b12:	681b      	ldr	r3, [r3, #0]
24005b14:	f022 0208 	bic.w	r2, r2, #8
24005b18:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
24005b1a:	687b      	ldr	r3, [r7, #4]
24005b1c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005b1e:	2b00      	cmp	r3, #0
24005b20:	d003      	beq.n	24005b2a <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
24005b22:	687b      	ldr	r3, [r7, #4]
24005b24:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005b26:	6878      	ldr	r0, [r7, #4]
24005b28:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
24005b2a:	687b      	ldr	r3, [r7, #4]
24005b2c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005b2e:	f003 031f 	and.w	r3, r3, #31
24005b32:	2220      	movs	r2, #32
24005b34:	409a      	lsls	r2, r3
24005b36:	69bb      	ldr	r3, [r7, #24]
24005b38:	4013      	ands	r3, r2
24005b3a:	2b00      	cmp	r3, #0
24005b3c:	f000 8110 	beq.w	24005d60 <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
24005b40:	687b      	ldr	r3, [r7, #4]
24005b42:	681b      	ldr	r3, [r3, #0]
24005b44:	4a2c      	ldr	r2, [pc, #176]	; (24005bf8 <HAL_DMA_IRQHandler+0x690>)
24005b46:	4293      	cmp	r3, r2
24005b48:	d04a      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b4a:	687b      	ldr	r3, [r7, #4]
24005b4c:	681b      	ldr	r3, [r3, #0]
24005b4e:	4a2b      	ldr	r2, [pc, #172]	; (24005bfc <HAL_DMA_IRQHandler+0x694>)
24005b50:	4293      	cmp	r3, r2
24005b52:	d045      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b54:	687b      	ldr	r3, [r7, #4]
24005b56:	681b      	ldr	r3, [r3, #0]
24005b58:	4a29      	ldr	r2, [pc, #164]	; (24005c00 <HAL_DMA_IRQHandler+0x698>)
24005b5a:	4293      	cmp	r3, r2
24005b5c:	d040      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b5e:	687b      	ldr	r3, [r7, #4]
24005b60:	681b      	ldr	r3, [r3, #0]
24005b62:	4a28      	ldr	r2, [pc, #160]	; (24005c04 <HAL_DMA_IRQHandler+0x69c>)
24005b64:	4293      	cmp	r3, r2
24005b66:	d03b      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b68:	687b      	ldr	r3, [r7, #4]
24005b6a:	681b      	ldr	r3, [r3, #0]
24005b6c:	4a26      	ldr	r2, [pc, #152]	; (24005c08 <HAL_DMA_IRQHandler+0x6a0>)
24005b6e:	4293      	cmp	r3, r2
24005b70:	d036      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b72:	687b      	ldr	r3, [r7, #4]
24005b74:	681b      	ldr	r3, [r3, #0]
24005b76:	4a25      	ldr	r2, [pc, #148]	; (24005c0c <HAL_DMA_IRQHandler+0x6a4>)
24005b78:	4293      	cmp	r3, r2
24005b7a:	d031      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b7c:	687b      	ldr	r3, [r7, #4]
24005b7e:	681b      	ldr	r3, [r3, #0]
24005b80:	4a23      	ldr	r2, [pc, #140]	; (24005c10 <HAL_DMA_IRQHandler+0x6a8>)
24005b82:	4293      	cmp	r3, r2
24005b84:	d02c      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b86:	687b      	ldr	r3, [r7, #4]
24005b88:	681b      	ldr	r3, [r3, #0]
24005b8a:	4a22      	ldr	r2, [pc, #136]	; (24005c14 <HAL_DMA_IRQHandler+0x6ac>)
24005b8c:	4293      	cmp	r3, r2
24005b8e:	d027      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b90:	687b      	ldr	r3, [r7, #4]
24005b92:	681b      	ldr	r3, [r3, #0]
24005b94:	4a20      	ldr	r2, [pc, #128]	; (24005c18 <HAL_DMA_IRQHandler+0x6b0>)
24005b96:	4293      	cmp	r3, r2
24005b98:	d022      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005b9a:	687b      	ldr	r3, [r7, #4]
24005b9c:	681b      	ldr	r3, [r3, #0]
24005b9e:	4a1f      	ldr	r2, [pc, #124]	; (24005c1c <HAL_DMA_IRQHandler+0x6b4>)
24005ba0:	4293      	cmp	r3, r2
24005ba2:	d01d      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005ba4:	687b      	ldr	r3, [r7, #4]
24005ba6:	681b      	ldr	r3, [r3, #0]
24005ba8:	4a1d      	ldr	r2, [pc, #116]	; (24005c20 <HAL_DMA_IRQHandler+0x6b8>)
24005baa:	4293      	cmp	r3, r2
24005bac:	d018      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005bae:	687b      	ldr	r3, [r7, #4]
24005bb0:	681b      	ldr	r3, [r3, #0]
24005bb2:	4a1c      	ldr	r2, [pc, #112]	; (24005c24 <HAL_DMA_IRQHandler+0x6bc>)
24005bb4:	4293      	cmp	r3, r2
24005bb6:	d013      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005bb8:	687b      	ldr	r3, [r7, #4]
24005bba:	681b      	ldr	r3, [r3, #0]
24005bbc:	4a1a      	ldr	r2, [pc, #104]	; (24005c28 <HAL_DMA_IRQHandler+0x6c0>)
24005bbe:	4293      	cmp	r3, r2
24005bc0:	d00e      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005bc2:	687b      	ldr	r3, [r7, #4]
24005bc4:	681b      	ldr	r3, [r3, #0]
24005bc6:	4a19      	ldr	r2, [pc, #100]	; (24005c2c <HAL_DMA_IRQHandler+0x6c4>)
24005bc8:	4293      	cmp	r3, r2
24005bca:	d009      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005bcc:	687b      	ldr	r3, [r7, #4]
24005bce:	681b      	ldr	r3, [r3, #0]
24005bd0:	4a17      	ldr	r2, [pc, #92]	; (24005c30 <HAL_DMA_IRQHandler+0x6c8>)
24005bd2:	4293      	cmp	r3, r2
24005bd4:	d004      	beq.n	24005be0 <HAL_DMA_IRQHandler+0x678>
24005bd6:	687b      	ldr	r3, [r7, #4]
24005bd8:	681b      	ldr	r3, [r3, #0]
24005bda:	4a16      	ldr	r2, [pc, #88]	; (24005c34 <HAL_DMA_IRQHandler+0x6cc>)
24005bdc:	4293      	cmp	r3, r2
24005bde:	d12b      	bne.n	24005c38 <HAL_DMA_IRQHandler+0x6d0>
24005be0:	687b      	ldr	r3, [r7, #4]
24005be2:	681b      	ldr	r3, [r3, #0]
24005be4:	681b      	ldr	r3, [r3, #0]
24005be6:	f003 0310 	and.w	r3, r3, #16
24005bea:	2b00      	cmp	r3, #0
24005bec:	bf14      	ite	ne
24005bee:	2301      	movne	r3, #1
24005bf0:	2300      	moveq	r3, #0
24005bf2:	b2db      	uxtb	r3, r3
24005bf4:	e02a      	b.n	24005c4c <HAL_DMA_IRQHandler+0x6e4>
24005bf6:	bf00      	nop
24005bf8:	40020010 	.word	0x40020010
24005bfc:	40020028 	.word	0x40020028
24005c00:	40020040 	.word	0x40020040
24005c04:	40020058 	.word	0x40020058
24005c08:	40020070 	.word	0x40020070
24005c0c:	40020088 	.word	0x40020088
24005c10:	400200a0 	.word	0x400200a0
24005c14:	400200b8 	.word	0x400200b8
24005c18:	40020410 	.word	0x40020410
24005c1c:	40020428 	.word	0x40020428
24005c20:	40020440 	.word	0x40020440
24005c24:	40020458 	.word	0x40020458
24005c28:	40020470 	.word	0x40020470
24005c2c:	40020488 	.word	0x40020488
24005c30:	400204a0 	.word	0x400204a0
24005c34:	400204b8 	.word	0x400204b8
24005c38:	687b      	ldr	r3, [r7, #4]
24005c3a:	681b      	ldr	r3, [r3, #0]
24005c3c:	681b      	ldr	r3, [r3, #0]
24005c3e:	f003 0302 	and.w	r3, r3, #2
24005c42:	2b00      	cmp	r3, #0
24005c44:	bf14      	ite	ne
24005c46:	2301      	movne	r3, #1
24005c48:	2300      	moveq	r3, #0
24005c4a:	b2db      	uxtb	r3, r3
24005c4c:	2b00      	cmp	r3, #0
24005c4e:	f000 8087 	beq.w	24005d60 <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
24005c52:	687b      	ldr	r3, [r7, #4]
24005c54:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005c56:	f003 031f 	and.w	r3, r3, #31
24005c5a:	2220      	movs	r2, #32
24005c5c:	409a      	lsls	r2, r3
24005c5e:	6a3b      	ldr	r3, [r7, #32]
24005c60:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
24005c62:	687b      	ldr	r3, [r7, #4]
24005c64:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24005c68:	b2db      	uxtb	r3, r3
24005c6a:	2b04      	cmp	r3, #4
24005c6c:	d139      	bne.n	24005ce2 <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
24005c6e:	687b      	ldr	r3, [r7, #4]
24005c70:	681b      	ldr	r3, [r3, #0]
24005c72:	681a      	ldr	r2, [r3, #0]
24005c74:	687b      	ldr	r3, [r7, #4]
24005c76:	681b      	ldr	r3, [r3, #0]
24005c78:	f022 0216 	bic.w	r2, r2, #22
24005c7c:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
24005c7e:	687b      	ldr	r3, [r7, #4]
24005c80:	681b      	ldr	r3, [r3, #0]
24005c82:	695a      	ldr	r2, [r3, #20]
24005c84:	687b      	ldr	r3, [r7, #4]
24005c86:	681b      	ldr	r3, [r3, #0]
24005c88:	f022 0280 	bic.w	r2, r2, #128	; 0x80
24005c8c:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24005c8e:	687b      	ldr	r3, [r7, #4]
24005c90:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005c92:	2b00      	cmp	r3, #0
24005c94:	d103      	bne.n	24005c9e <HAL_DMA_IRQHandler+0x736>
24005c96:	687b      	ldr	r3, [r7, #4]
24005c98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005c9a:	2b00      	cmp	r3, #0
24005c9c:	d007      	beq.n	24005cae <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
24005c9e:	687b      	ldr	r3, [r7, #4]
24005ca0:	681b      	ldr	r3, [r3, #0]
24005ca2:	681a      	ldr	r2, [r3, #0]
24005ca4:	687b      	ldr	r3, [r7, #4]
24005ca6:	681b      	ldr	r3, [r3, #0]
24005ca8:	f022 0208 	bic.w	r2, r2, #8
24005cac:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24005cae:	687b      	ldr	r3, [r7, #4]
24005cb0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005cb2:	f003 031f 	and.w	r3, r3, #31
24005cb6:	223f      	movs	r2, #63	; 0x3f
24005cb8:	409a      	lsls	r2, r3
24005cba:	6a3b      	ldr	r3, [r7, #32]
24005cbc:	609a      	str	r2, [r3, #8]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
24005cbe:	687b      	ldr	r3, [r7, #4]
24005cc0:	2201      	movs	r2, #1
24005cc2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
24005cc6:	687b      	ldr	r3, [r7, #4]
24005cc8:	2200      	movs	r2, #0
24005cca:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          if(hdma->XferAbortCallback != NULL)
24005cce:	687b      	ldr	r3, [r7, #4]
24005cd0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24005cd2:	2b00      	cmp	r3, #0
24005cd4:	f000 834a 	beq.w	2400636c <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
24005cd8:	687b      	ldr	r3, [r7, #4]
24005cda:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24005cdc:	6878      	ldr	r0, [r7, #4]
24005cde:	4798      	blx	r3
          }
          return;
24005ce0:	e344      	b.n	2400636c <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
24005ce2:	687b      	ldr	r3, [r7, #4]
24005ce4:	681b      	ldr	r3, [r3, #0]
24005ce6:	681b      	ldr	r3, [r3, #0]
24005ce8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24005cec:	2b00      	cmp	r3, #0
24005cee:	d018      	beq.n	24005d22 <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
24005cf0:	687b      	ldr	r3, [r7, #4]
24005cf2:	681b      	ldr	r3, [r3, #0]
24005cf4:	681b      	ldr	r3, [r3, #0]
24005cf6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24005cfa:	2b00      	cmp	r3, #0
24005cfc:	d108      	bne.n	24005d10 <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
24005cfe:	687b      	ldr	r3, [r7, #4]
24005d00:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24005d02:	2b00      	cmp	r3, #0
24005d04:	d02c      	beq.n	24005d60 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
24005d06:	687b      	ldr	r3, [r7, #4]
24005d08:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24005d0a:	6878      	ldr	r0, [r7, #4]
24005d0c:	4798      	blx	r3
24005d0e:	e027      	b.n	24005d60 <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
24005d10:	687b      	ldr	r3, [r7, #4]
24005d12:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005d14:	2b00      	cmp	r3, #0
24005d16:	d023      	beq.n	24005d60 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
24005d18:	687b      	ldr	r3, [r7, #4]
24005d1a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005d1c:	6878      	ldr	r0, [r7, #4]
24005d1e:	4798      	blx	r3
24005d20:	e01e      	b.n	24005d60 <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
24005d22:	687b      	ldr	r3, [r7, #4]
24005d24:	681b      	ldr	r3, [r3, #0]
24005d26:	681b      	ldr	r3, [r3, #0]
24005d28:	f403 7380 	and.w	r3, r3, #256	; 0x100
24005d2c:	2b00      	cmp	r3, #0
24005d2e:	d10f      	bne.n	24005d50 <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
24005d30:	687b      	ldr	r3, [r7, #4]
24005d32:	681b      	ldr	r3, [r3, #0]
24005d34:	681a      	ldr	r2, [r3, #0]
24005d36:	687b      	ldr	r3, [r7, #4]
24005d38:	681b      	ldr	r3, [r3, #0]
24005d3a:	f022 0210 	bic.w	r2, r2, #16
24005d3e:	601a      	str	r2, [r3, #0]

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
24005d40:	687b      	ldr	r3, [r7, #4]
24005d42:	2201      	movs	r2, #1
24005d44:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
24005d48:	687b      	ldr	r3, [r7, #4]
24005d4a:	2200      	movs	r2, #0
24005d4c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
          }

          if(hdma->XferCpltCallback != NULL)
24005d50:	687b      	ldr	r3, [r7, #4]
24005d52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005d54:	2b00      	cmp	r3, #0
24005d56:	d003      	beq.n	24005d60 <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
24005d58:	687b      	ldr	r3, [r7, #4]
24005d5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24005d5c:	6878      	ldr	r0, [r7, #4]
24005d5e:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
24005d60:	687b      	ldr	r3, [r7, #4]
24005d62:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005d64:	2b00      	cmp	r3, #0
24005d66:	f000 8306 	beq.w	24006376 <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
24005d6a:	687b      	ldr	r3, [r7, #4]
24005d6c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24005d6e:	f003 0301 	and.w	r3, r3, #1
24005d72:	2b00      	cmp	r3, #0
24005d74:	f000 8088 	beq.w	24005e88 <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
24005d78:	687b      	ldr	r3, [r7, #4]
24005d7a:	2204      	movs	r2, #4
24005d7c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
24005d80:	687b      	ldr	r3, [r7, #4]
24005d82:	681b      	ldr	r3, [r3, #0]
24005d84:	4a7a      	ldr	r2, [pc, #488]	; (24005f70 <HAL_DMA_IRQHandler+0xa08>)
24005d86:	4293      	cmp	r3, r2
24005d88:	d04a      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005d8a:	687b      	ldr	r3, [r7, #4]
24005d8c:	681b      	ldr	r3, [r3, #0]
24005d8e:	4a79      	ldr	r2, [pc, #484]	; (24005f74 <HAL_DMA_IRQHandler+0xa0c>)
24005d90:	4293      	cmp	r3, r2
24005d92:	d045      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005d94:	687b      	ldr	r3, [r7, #4]
24005d96:	681b      	ldr	r3, [r3, #0]
24005d98:	4a77      	ldr	r2, [pc, #476]	; (24005f78 <HAL_DMA_IRQHandler+0xa10>)
24005d9a:	4293      	cmp	r3, r2
24005d9c:	d040      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005d9e:	687b      	ldr	r3, [r7, #4]
24005da0:	681b      	ldr	r3, [r3, #0]
24005da2:	4a76      	ldr	r2, [pc, #472]	; (24005f7c <HAL_DMA_IRQHandler+0xa14>)
24005da4:	4293      	cmp	r3, r2
24005da6:	d03b      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005da8:	687b      	ldr	r3, [r7, #4]
24005daa:	681b      	ldr	r3, [r3, #0]
24005dac:	4a74      	ldr	r2, [pc, #464]	; (24005f80 <HAL_DMA_IRQHandler+0xa18>)
24005dae:	4293      	cmp	r3, r2
24005db0:	d036      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005db2:	687b      	ldr	r3, [r7, #4]
24005db4:	681b      	ldr	r3, [r3, #0]
24005db6:	4a73      	ldr	r2, [pc, #460]	; (24005f84 <HAL_DMA_IRQHandler+0xa1c>)
24005db8:	4293      	cmp	r3, r2
24005dba:	d031      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005dbc:	687b      	ldr	r3, [r7, #4]
24005dbe:	681b      	ldr	r3, [r3, #0]
24005dc0:	4a71      	ldr	r2, [pc, #452]	; (24005f88 <HAL_DMA_IRQHandler+0xa20>)
24005dc2:	4293      	cmp	r3, r2
24005dc4:	d02c      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005dc6:	687b      	ldr	r3, [r7, #4]
24005dc8:	681b      	ldr	r3, [r3, #0]
24005dca:	4a70      	ldr	r2, [pc, #448]	; (24005f8c <HAL_DMA_IRQHandler+0xa24>)
24005dcc:	4293      	cmp	r3, r2
24005dce:	d027      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005dd0:	687b      	ldr	r3, [r7, #4]
24005dd2:	681b      	ldr	r3, [r3, #0]
24005dd4:	4a6e      	ldr	r2, [pc, #440]	; (24005f90 <HAL_DMA_IRQHandler+0xa28>)
24005dd6:	4293      	cmp	r3, r2
24005dd8:	d022      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005dda:	687b      	ldr	r3, [r7, #4]
24005ddc:	681b      	ldr	r3, [r3, #0]
24005dde:	4a6d      	ldr	r2, [pc, #436]	; (24005f94 <HAL_DMA_IRQHandler+0xa2c>)
24005de0:	4293      	cmp	r3, r2
24005de2:	d01d      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005de4:	687b      	ldr	r3, [r7, #4]
24005de6:	681b      	ldr	r3, [r3, #0]
24005de8:	4a6b      	ldr	r2, [pc, #428]	; (24005f98 <HAL_DMA_IRQHandler+0xa30>)
24005dea:	4293      	cmp	r3, r2
24005dec:	d018      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005dee:	687b      	ldr	r3, [r7, #4]
24005df0:	681b      	ldr	r3, [r3, #0]
24005df2:	4a6a      	ldr	r2, [pc, #424]	; (24005f9c <HAL_DMA_IRQHandler+0xa34>)
24005df4:	4293      	cmp	r3, r2
24005df6:	d013      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005df8:	687b      	ldr	r3, [r7, #4]
24005dfa:	681b      	ldr	r3, [r3, #0]
24005dfc:	4a68      	ldr	r2, [pc, #416]	; (24005fa0 <HAL_DMA_IRQHandler+0xa38>)
24005dfe:	4293      	cmp	r3, r2
24005e00:	d00e      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005e02:	687b      	ldr	r3, [r7, #4]
24005e04:	681b      	ldr	r3, [r3, #0]
24005e06:	4a67      	ldr	r2, [pc, #412]	; (24005fa4 <HAL_DMA_IRQHandler+0xa3c>)
24005e08:	4293      	cmp	r3, r2
24005e0a:	d009      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005e0c:	687b      	ldr	r3, [r7, #4]
24005e0e:	681b      	ldr	r3, [r3, #0]
24005e10:	4a65      	ldr	r2, [pc, #404]	; (24005fa8 <HAL_DMA_IRQHandler+0xa40>)
24005e12:	4293      	cmp	r3, r2
24005e14:	d004      	beq.n	24005e20 <HAL_DMA_IRQHandler+0x8b8>
24005e16:	687b      	ldr	r3, [r7, #4]
24005e18:	681b      	ldr	r3, [r3, #0]
24005e1a:	4a64      	ldr	r2, [pc, #400]	; (24005fac <HAL_DMA_IRQHandler+0xa44>)
24005e1c:	4293      	cmp	r3, r2
24005e1e:	d108      	bne.n	24005e32 <HAL_DMA_IRQHandler+0x8ca>
24005e20:	687b      	ldr	r3, [r7, #4]
24005e22:	681b      	ldr	r3, [r3, #0]
24005e24:	681a      	ldr	r2, [r3, #0]
24005e26:	687b      	ldr	r3, [r7, #4]
24005e28:	681b      	ldr	r3, [r3, #0]
24005e2a:	f022 0201 	bic.w	r2, r2, #1
24005e2e:	601a      	str	r2, [r3, #0]
24005e30:	e007      	b.n	24005e42 <HAL_DMA_IRQHandler+0x8da>
24005e32:	687b      	ldr	r3, [r7, #4]
24005e34:	681b      	ldr	r3, [r3, #0]
24005e36:	681a      	ldr	r2, [r3, #0]
24005e38:	687b      	ldr	r3, [r7, #4]
24005e3a:	681b      	ldr	r3, [r3, #0]
24005e3c:	f022 0201 	bic.w	r2, r2, #1
24005e40:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
24005e42:	68fb      	ldr	r3, [r7, #12]
24005e44:	3301      	adds	r3, #1
24005e46:	60fb      	str	r3, [r7, #12]
24005e48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
24005e4a:	429a      	cmp	r2, r3
24005e4c:	d307      	bcc.n	24005e5e <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
24005e4e:	687b      	ldr	r3, [r7, #4]
24005e50:	681b      	ldr	r3, [r3, #0]
24005e52:	681b      	ldr	r3, [r3, #0]
24005e54:	f003 0301 	and.w	r3, r3, #1
24005e58:	2b00      	cmp	r3, #0
24005e5a:	d1f2      	bne.n	24005e42 <HAL_DMA_IRQHandler+0x8da>
24005e5c:	e000      	b.n	24005e60 <HAL_DMA_IRQHandler+0x8f8>
            break;
24005e5e:	bf00      	nop

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
24005e60:	687b      	ldr	r3, [r7, #4]
24005e62:	681b      	ldr	r3, [r3, #0]
24005e64:	681b      	ldr	r3, [r3, #0]
24005e66:	f003 0301 	and.w	r3, r3, #1
24005e6a:	2b00      	cmp	r3, #0
24005e6c:	d004      	beq.n	24005e78 <HAL_DMA_IRQHandler+0x910>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
24005e6e:	687b      	ldr	r3, [r7, #4]
24005e70:	2203      	movs	r2, #3
24005e72:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
24005e76:	e003      	b.n	24005e80 <HAL_DMA_IRQHandler+0x918>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
24005e78:	687b      	ldr	r3, [r7, #4]
24005e7a:	2201      	movs	r2, #1
24005e7c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
24005e80:	687b      	ldr	r3, [r7, #4]
24005e82:	2200      	movs	r2, #0
24005e84:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      }

      if(hdma->XferErrorCallback != NULL)
24005e88:	687b      	ldr	r3, [r7, #4]
24005e8a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24005e8c:	2b00      	cmp	r3, #0
24005e8e:	f000 8272 	beq.w	24006376 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24005e92:	687b      	ldr	r3, [r7, #4]
24005e94:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24005e96:	6878      	ldr	r0, [r7, #4]
24005e98:	4798      	blx	r3
24005e9a:	e26c      	b.n	24006376 <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
24005e9c:	687b      	ldr	r3, [r7, #4]
24005e9e:	681b      	ldr	r3, [r3, #0]
24005ea0:	4a43      	ldr	r2, [pc, #268]	; (24005fb0 <HAL_DMA_IRQHandler+0xa48>)
24005ea2:	4293      	cmp	r3, r2
24005ea4:	d022      	beq.n	24005eec <HAL_DMA_IRQHandler+0x984>
24005ea6:	687b      	ldr	r3, [r7, #4]
24005ea8:	681b      	ldr	r3, [r3, #0]
24005eaa:	4a42      	ldr	r2, [pc, #264]	; (24005fb4 <HAL_DMA_IRQHandler+0xa4c>)
24005eac:	4293      	cmp	r3, r2
24005eae:	d01d      	beq.n	24005eec <HAL_DMA_IRQHandler+0x984>
24005eb0:	687b      	ldr	r3, [r7, #4]
24005eb2:	681b      	ldr	r3, [r3, #0]
24005eb4:	4a40      	ldr	r2, [pc, #256]	; (24005fb8 <HAL_DMA_IRQHandler+0xa50>)
24005eb6:	4293      	cmp	r3, r2
24005eb8:	d018      	beq.n	24005eec <HAL_DMA_IRQHandler+0x984>
24005eba:	687b      	ldr	r3, [r7, #4]
24005ebc:	681b      	ldr	r3, [r3, #0]
24005ebe:	4a3f      	ldr	r2, [pc, #252]	; (24005fbc <HAL_DMA_IRQHandler+0xa54>)
24005ec0:	4293      	cmp	r3, r2
24005ec2:	d013      	beq.n	24005eec <HAL_DMA_IRQHandler+0x984>
24005ec4:	687b      	ldr	r3, [r7, #4]
24005ec6:	681b      	ldr	r3, [r3, #0]
24005ec8:	4a3d      	ldr	r2, [pc, #244]	; (24005fc0 <HAL_DMA_IRQHandler+0xa58>)
24005eca:	4293      	cmp	r3, r2
24005ecc:	d00e      	beq.n	24005eec <HAL_DMA_IRQHandler+0x984>
24005ece:	687b      	ldr	r3, [r7, #4]
24005ed0:	681b      	ldr	r3, [r3, #0]
24005ed2:	4a3c      	ldr	r2, [pc, #240]	; (24005fc4 <HAL_DMA_IRQHandler+0xa5c>)
24005ed4:	4293      	cmp	r3, r2
24005ed6:	d009      	beq.n	24005eec <HAL_DMA_IRQHandler+0x984>
24005ed8:	687b      	ldr	r3, [r7, #4]
24005eda:	681b      	ldr	r3, [r3, #0]
24005edc:	4a3a      	ldr	r2, [pc, #232]	; (24005fc8 <HAL_DMA_IRQHandler+0xa60>)
24005ede:	4293      	cmp	r3, r2
24005ee0:	d004      	beq.n	24005eec <HAL_DMA_IRQHandler+0x984>
24005ee2:	687b      	ldr	r3, [r7, #4]
24005ee4:	681b      	ldr	r3, [r3, #0]
24005ee6:	4a39      	ldr	r2, [pc, #228]	; (24005fcc <HAL_DMA_IRQHandler+0xa64>)
24005ee8:	4293      	cmp	r3, r2
24005eea:	d101      	bne.n	24005ef0 <HAL_DMA_IRQHandler+0x988>
24005eec:	2301      	movs	r3, #1
24005eee:	e000      	b.n	24005ef2 <HAL_DMA_IRQHandler+0x98a>
24005ef0:	2300      	movs	r3, #0
24005ef2:	2b00      	cmp	r3, #0
24005ef4:	f000 823f 	beq.w	24006376 <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
24005ef8:	687b      	ldr	r3, [r7, #4]
24005efa:	681b      	ldr	r3, [r3, #0]
24005efc:	681b      	ldr	r3, [r3, #0]
24005efe:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
24005f00:	687b      	ldr	r3, [r7, #4]
24005f02:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005f04:	f003 031f 	and.w	r3, r3, #31
24005f08:	2204      	movs	r2, #4
24005f0a:	409a      	lsls	r2, r3
24005f0c:	697b      	ldr	r3, [r7, #20]
24005f0e:	4013      	ands	r3, r2
24005f10:	2b00      	cmp	r3, #0
24005f12:	f000 80cd 	beq.w	240060b0 <HAL_DMA_IRQHandler+0xb48>
24005f16:	693b      	ldr	r3, [r7, #16]
24005f18:	f003 0304 	and.w	r3, r3, #4
24005f1c:	2b00      	cmp	r3, #0
24005f1e:	f000 80c7 	beq.w	240060b0 <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
24005f22:	687b      	ldr	r3, [r7, #4]
24005f24:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24005f26:	f003 031f 	and.w	r3, r3, #31
24005f2a:	2204      	movs	r2, #4
24005f2c:	409a      	lsls	r2, r3
24005f2e:	69fb      	ldr	r3, [r7, #28]
24005f30:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005f32:	693b      	ldr	r3, [r7, #16]
24005f34:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24005f38:	2b00      	cmp	r3, #0
24005f3a:	d049      	beq.n	24005fd0 <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
24005f3c:	693b      	ldr	r3, [r7, #16]
24005f3e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24005f42:	2b00      	cmp	r3, #0
24005f44:	d109      	bne.n	24005f5a <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
24005f46:	687b      	ldr	r3, [r7, #4]
24005f48:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005f4a:	2b00      	cmp	r3, #0
24005f4c:	f000 8210 	beq.w	24006370 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
24005f50:	687b      	ldr	r3, [r7, #4]
24005f52:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24005f54:	6878      	ldr	r0, [r7, #4]
24005f56:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005f58:	e20a      	b.n	24006370 <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
24005f5a:	687b      	ldr	r3, [r7, #4]
24005f5c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005f5e:	2b00      	cmp	r3, #0
24005f60:	f000 8206 	beq.w	24006370 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
24005f64:	687b      	ldr	r3, [r7, #4]
24005f66:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24005f68:	6878      	ldr	r0, [r7, #4]
24005f6a:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24005f6c:	e200      	b.n	24006370 <HAL_DMA_IRQHandler+0xe08>
24005f6e:	bf00      	nop
24005f70:	40020010 	.word	0x40020010
24005f74:	40020028 	.word	0x40020028
24005f78:	40020040 	.word	0x40020040
24005f7c:	40020058 	.word	0x40020058
24005f80:	40020070 	.word	0x40020070
24005f84:	40020088 	.word	0x40020088
24005f88:	400200a0 	.word	0x400200a0
24005f8c:	400200b8 	.word	0x400200b8
24005f90:	40020410 	.word	0x40020410
24005f94:	40020428 	.word	0x40020428
24005f98:	40020440 	.word	0x40020440
24005f9c:	40020458 	.word	0x40020458
24005fa0:	40020470 	.word	0x40020470
24005fa4:	40020488 	.word	0x40020488
24005fa8:	400204a0 	.word	0x400204a0
24005fac:	400204b8 	.word	0x400204b8
24005fb0:	58025408 	.word	0x58025408
24005fb4:	5802541c 	.word	0x5802541c
24005fb8:	58025430 	.word	0x58025430
24005fbc:	58025444 	.word	0x58025444
24005fc0:	58025458 	.word	0x58025458
24005fc4:	5802546c 	.word	0x5802546c
24005fc8:	58025480 	.word	0x58025480
24005fcc:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
24005fd0:	693b      	ldr	r3, [r7, #16]
24005fd2:	f003 0320 	and.w	r3, r3, #32
24005fd6:	2b00      	cmp	r3, #0
24005fd8:	d160      	bne.n	2400609c <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
24005fda:	687b      	ldr	r3, [r7, #4]
24005fdc:	681b      	ldr	r3, [r3, #0]
24005fde:	4a7f      	ldr	r2, [pc, #508]	; (240061dc <HAL_DMA_IRQHandler+0xc74>)
24005fe0:	4293      	cmp	r3, r2
24005fe2:	d04a      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24005fe4:	687b      	ldr	r3, [r7, #4]
24005fe6:	681b      	ldr	r3, [r3, #0]
24005fe8:	4a7d      	ldr	r2, [pc, #500]	; (240061e0 <HAL_DMA_IRQHandler+0xc78>)
24005fea:	4293      	cmp	r3, r2
24005fec:	d045      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24005fee:	687b      	ldr	r3, [r7, #4]
24005ff0:	681b      	ldr	r3, [r3, #0]
24005ff2:	4a7c      	ldr	r2, [pc, #496]	; (240061e4 <HAL_DMA_IRQHandler+0xc7c>)
24005ff4:	4293      	cmp	r3, r2
24005ff6:	d040      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24005ff8:	687b      	ldr	r3, [r7, #4]
24005ffa:	681b      	ldr	r3, [r3, #0]
24005ffc:	4a7a      	ldr	r2, [pc, #488]	; (240061e8 <HAL_DMA_IRQHandler+0xc80>)
24005ffe:	4293      	cmp	r3, r2
24006000:	d03b      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006002:	687b      	ldr	r3, [r7, #4]
24006004:	681b      	ldr	r3, [r3, #0]
24006006:	4a79      	ldr	r2, [pc, #484]	; (240061ec <HAL_DMA_IRQHandler+0xc84>)
24006008:	4293      	cmp	r3, r2
2400600a:	d036      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
2400600c:	687b      	ldr	r3, [r7, #4]
2400600e:	681b      	ldr	r3, [r3, #0]
24006010:	4a77      	ldr	r2, [pc, #476]	; (240061f0 <HAL_DMA_IRQHandler+0xc88>)
24006012:	4293      	cmp	r3, r2
24006014:	d031      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006016:	687b      	ldr	r3, [r7, #4]
24006018:	681b      	ldr	r3, [r3, #0]
2400601a:	4a76      	ldr	r2, [pc, #472]	; (240061f4 <HAL_DMA_IRQHandler+0xc8c>)
2400601c:	4293      	cmp	r3, r2
2400601e:	d02c      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006020:	687b      	ldr	r3, [r7, #4]
24006022:	681b      	ldr	r3, [r3, #0]
24006024:	4a74      	ldr	r2, [pc, #464]	; (240061f8 <HAL_DMA_IRQHandler+0xc90>)
24006026:	4293      	cmp	r3, r2
24006028:	d027      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
2400602a:	687b      	ldr	r3, [r7, #4]
2400602c:	681b      	ldr	r3, [r3, #0]
2400602e:	4a73      	ldr	r2, [pc, #460]	; (240061fc <HAL_DMA_IRQHandler+0xc94>)
24006030:	4293      	cmp	r3, r2
24006032:	d022      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006034:	687b      	ldr	r3, [r7, #4]
24006036:	681b      	ldr	r3, [r3, #0]
24006038:	4a71      	ldr	r2, [pc, #452]	; (24006200 <HAL_DMA_IRQHandler+0xc98>)
2400603a:	4293      	cmp	r3, r2
2400603c:	d01d      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
2400603e:	687b      	ldr	r3, [r7, #4]
24006040:	681b      	ldr	r3, [r3, #0]
24006042:	4a70      	ldr	r2, [pc, #448]	; (24006204 <HAL_DMA_IRQHandler+0xc9c>)
24006044:	4293      	cmp	r3, r2
24006046:	d018      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006048:	687b      	ldr	r3, [r7, #4]
2400604a:	681b      	ldr	r3, [r3, #0]
2400604c:	4a6e      	ldr	r2, [pc, #440]	; (24006208 <HAL_DMA_IRQHandler+0xca0>)
2400604e:	4293      	cmp	r3, r2
24006050:	d013      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006052:	687b      	ldr	r3, [r7, #4]
24006054:	681b      	ldr	r3, [r3, #0]
24006056:	4a6d      	ldr	r2, [pc, #436]	; (2400620c <HAL_DMA_IRQHandler+0xca4>)
24006058:	4293      	cmp	r3, r2
2400605a:	d00e      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
2400605c:	687b      	ldr	r3, [r7, #4]
2400605e:	681b      	ldr	r3, [r3, #0]
24006060:	4a6b      	ldr	r2, [pc, #428]	; (24006210 <HAL_DMA_IRQHandler+0xca8>)
24006062:	4293      	cmp	r3, r2
24006064:	d009      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006066:	687b      	ldr	r3, [r7, #4]
24006068:	681b      	ldr	r3, [r3, #0]
2400606a:	4a6a      	ldr	r2, [pc, #424]	; (24006214 <HAL_DMA_IRQHandler+0xcac>)
2400606c:	4293      	cmp	r3, r2
2400606e:	d004      	beq.n	2400607a <HAL_DMA_IRQHandler+0xb12>
24006070:	687b      	ldr	r3, [r7, #4]
24006072:	681b      	ldr	r3, [r3, #0]
24006074:	4a68      	ldr	r2, [pc, #416]	; (24006218 <HAL_DMA_IRQHandler+0xcb0>)
24006076:	4293      	cmp	r3, r2
24006078:	d108      	bne.n	2400608c <HAL_DMA_IRQHandler+0xb24>
2400607a:	687b      	ldr	r3, [r7, #4]
2400607c:	681b      	ldr	r3, [r3, #0]
2400607e:	681a      	ldr	r2, [r3, #0]
24006080:	687b      	ldr	r3, [r7, #4]
24006082:	681b      	ldr	r3, [r3, #0]
24006084:	f022 0208 	bic.w	r2, r2, #8
24006088:	601a      	str	r2, [r3, #0]
2400608a:	e007      	b.n	2400609c <HAL_DMA_IRQHandler+0xb34>
2400608c:	687b      	ldr	r3, [r7, #4]
2400608e:	681b      	ldr	r3, [r3, #0]
24006090:	681a      	ldr	r2, [r3, #0]
24006092:	687b      	ldr	r3, [r7, #4]
24006094:	681b      	ldr	r3, [r3, #0]
24006096:	f022 0204 	bic.w	r2, r2, #4
2400609a:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
2400609c:	687b      	ldr	r3, [r7, #4]
2400609e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240060a0:	2b00      	cmp	r3, #0
240060a2:	f000 8165 	beq.w	24006370 <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
240060a6:	687b      	ldr	r3, [r7, #4]
240060a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240060aa:	6878      	ldr	r0, [r7, #4]
240060ac:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240060ae:	e15f      	b.n	24006370 <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
240060b0:	687b      	ldr	r3, [r7, #4]
240060b2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240060b4:	f003 031f 	and.w	r3, r3, #31
240060b8:	2202      	movs	r2, #2
240060ba:	409a      	lsls	r2, r3
240060bc:	697b      	ldr	r3, [r7, #20]
240060be:	4013      	ands	r3, r2
240060c0:	2b00      	cmp	r3, #0
240060c2:	f000 80c5 	beq.w	24006250 <HAL_DMA_IRQHandler+0xce8>
240060c6:	693b      	ldr	r3, [r7, #16]
240060c8:	f003 0302 	and.w	r3, r3, #2
240060cc:	2b00      	cmp	r3, #0
240060ce:	f000 80bf 	beq.w	24006250 <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
240060d2:	687b      	ldr	r3, [r7, #4]
240060d4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240060d6:	f003 031f 	and.w	r3, r3, #31
240060da:	2202      	movs	r2, #2
240060dc:	409a      	lsls	r2, r3
240060de:	69fb      	ldr	r3, [r7, #28]
240060e0:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
240060e2:	693b      	ldr	r3, [r7, #16]
240060e4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
240060e8:	2b00      	cmp	r3, #0
240060ea:	d018      	beq.n	2400611e <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
240060ec:	693b      	ldr	r3, [r7, #16]
240060ee:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240060f2:	2b00      	cmp	r3, #0
240060f4:	d109      	bne.n	2400610a <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
240060f6:	687b      	ldr	r3, [r7, #4]
240060f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240060fa:	2b00      	cmp	r3, #0
240060fc:	f000 813a 	beq.w	24006374 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
24006100:	687b      	ldr	r3, [r7, #4]
24006102:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24006104:	6878      	ldr	r0, [r7, #4]
24006106:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24006108:	e134      	b.n	24006374 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
2400610a:	687b      	ldr	r3, [r7, #4]
2400610c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400610e:	2b00      	cmp	r3, #0
24006110:	f000 8130 	beq.w	24006374 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
24006114:	687b      	ldr	r3, [r7, #4]
24006116:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24006118:	6878      	ldr	r0, [r7, #4]
2400611a:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
2400611c:	e12a      	b.n	24006374 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
2400611e:	693b      	ldr	r3, [r7, #16]
24006120:	f003 0320 	and.w	r3, r3, #32
24006124:	2b00      	cmp	r3, #0
24006126:	f040 8089 	bne.w	2400623c <HAL_DMA_IRQHandler+0xcd4>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
2400612a:	687b      	ldr	r3, [r7, #4]
2400612c:	681b      	ldr	r3, [r3, #0]
2400612e:	4a2b      	ldr	r2, [pc, #172]	; (240061dc <HAL_DMA_IRQHandler+0xc74>)
24006130:	4293      	cmp	r3, r2
24006132:	d04a      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
24006134:	687b      	ldr	r3, [r7, #4]
24006136:	681b      	ldr	r3, [r3, #0]
24006138:	4a29      	ldr	r2, [pc, #164]	; (240061e0 <HAL_DMA_IRQHandler+0xc78>)
2400613a:	4293      	cmp	r3, r2
2400613c:	d045      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
2400613e:	687b      	ldr	r3, [r7, #4]
24006140:	681b      	ldr	r3, [r3, #0]
24006142:	4a28      	ldr	r2, [pc, #160]	; (240061e4 <HAL_DMA_IRQHandler+0xc7c>)
24006144:	4293      	cmp	r3, r2
24006146:	d040      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
24006148:	687b      	ldr	r3, [r7, #4]
2400614a:	681b      	ldr	r3, [r3, #0]
2400614c:	4a26      	ldr	r2, [pc, #152]	; (240061e8 <HAL_DMA_IRQHandler+0xc80>)
2400614e:	4293      	cmp	r3, r2
24006150:	d03b      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
24006152:	687b      	ldr	r3, [r7, #4]
24006154:	681b      	ldr	r3, [r3, #0]
24006156:	4a25      	ldr	r2, [pc, #148]	; (240061ec <HAL_DMA_IRQHandler+0xc84>)
24006158:	4293      	cmp	r3, r2
2400615a:	d036      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
2400615c:	687b      	ldr	r3, [r7, #4]
2400615e:	681b      	ldr	r3, [r3, #0]
24006160:	4a23      	ldr	r2, [pc, #140]	; (240061f0 <HAL_DMA_IRQHandler+0xc88>)
24006162:	4293      	cmp	r3, r2
24006164:	d031      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
24006166:	687b      	ldr	r3, [r7, #4]
24006168:	681b      	ldr	r3, [r3, #0]
2400616a:	4a22      	ldr	r2, [pc, #136]	; (240061f4 <HAL_DMA_IRQHandler+0xc8c>)
2400616c:	4293      	cmp	r3, r2
2400616e:	d02c      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
24006170:	687b      	ldr	r3, [r7, #4]
24006172:	681b      	ldr	r3, [r3, #0]
24006174:	4a20      	ldr	r2, [pc, #128]	; (240061f8 <HAL_DMA_IRQHandler+0xc90>)
24006176:	4293      	cmp	r3, r2
24006178:	d027      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
2400617a:	687b      	ldr	r3, [r7, #4]
2400617c:	681b      	ldr	r3, [r3, #0]
2400617e:	4a1f      	ldr	r2, [pc, #124]	; (240061fc <HAL_DMA_IRQHandler+0xc94>)
24006180:	4293      	cmp	r3, r2
24006182:	d022      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
24006184:	687b      	ldr	r3, [r7, #4]
24006186:	681b      	ldr	r3, [r3, #0]
24006188:	4a1d      	ldr	r2, [pc, #116]	; (24006200 <HAL_DMA_IRQHandler+0xc98>)
2400618a:	4293      	cmp	r3, r2
2400618c:	d01d      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
2400618e:	687b      	ldr	r3, [r7, #4]
24006190:	681b      	ldr	r3, [r3, #0]
24006192:	4a1c      	ldr	r2, [pc, #112]	; (24006204 <HAL_DMA_IRQHandler+0xc9c>)
24006194:	4293      	cmp	r3, r2
24006196:	d018      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
24006198:	687b      	ldr	r3, [r7, #4]
2400619a:	681b      	ldr	r3, [r3, #0]
2400619c:	4a1a      	ldr	r2, [pc, #104]	; (24006208 <HAL_DMA_IRQHandler+0xca0>)
2400619e:	4293      	cmp	r3, r2
240061a0:	d013      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
240061a2:	687b      	ldr	r3, [r7, #4]
240061a4:	681b      	ldr	r3, [r3, #0]
240061a6:	4a19      	ldr	r2, [pc, #100]	; (2400620c <HAL_DMA_IRQHandler+0xca4>)
240061a8:	4293      	cmp	r3, r2
240061aa:	d00e      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
240061ac:	687b      	ldr	r3, [r7, #4]
240061ae:	681b      	ldr	r3, [r3, #0]
240061b0:	4a17      	ldr	r2, [pc, #92]	; (24006210 <HAL_DMA_IRQHandler+0xca8>)
240061b2:	4293      	cmp	r3, r2
240061b4:	d009      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
240061b6:	687b      	ldr	r3, [r7, #4]
240061b8:	681b      	ldr	r3, [r3, #0]
240061ba:	4a16      	ldr	r2, [pc, #88]	; (24006214 <HAL_DMA_IRQHandler+0xcac>)
240061bc:	4293      	cmp	r3, r2
240061be:	d004      	beq.n	240061ca <HAL_DMA_IRQHandler+0xc62>
240061c0:	687b      	ldr	r3, [r7, #4]
240061c2:	681b      	ldr	r3, [r3, #0]
240061c4:	4a14      	ldr	r2, [pc, #80]	; (24006218 <HAL_DMA_IRQHandler+0xcb0>)
240061c6:	4293      	cmp	r3, r2
240061c8:	d128      	bne.n	2400621c <HAL_DMA_IRQHandler+0xcb4>
240061ca:	687b      	ldr	r3, [r7, #4]
240061cc:	681b      	ldr	r3, [r3, #0]
240061ce:	681a      	ldr	r2, [r3, #0]
240061d0:	687b      	ldr	r3, [r7, #4]
240061d2:	681b      	ldr	r3, [r3, #0]
240061d4:	f022 0214 	bic.w	r2, r2, #20
240061d8:	601a      	str	r2, [r3, #0]
240061da:	e027      	b.n	2400622c <HAL_DMA_IRQHandler+0xcc4>
240061dc:	40020010 	.word	0x40020010
240061e0:	40020028 	.word	0x40020028
240061e4:	40020040 	.word	0x40020040
240061e8:	40020058 	.word	0x40020058
240061ec:	40020070 	.word	0x40020070
240061f0:	40020088 	.word	0x40020088
240061f4:	400200a0 	.word	0x400200a0
240061f8:	400200b8 	.word	0x400200b8
240061fc:	40020410 	.word	0x40020410
24006200:	40020428 	.word	0x40020428
24006204:	40020440 	.word	0x40020440
24006208:	40020458 	.word	0x40020458
2400620c:	40020470 	.word	0x40020470
24006210:	40020488 	.word	0x40020488
24006214:	400204a0 	.word	0x400204a0
24006218:	400204b8 	.word	0x400204b8
2400621c:	687b      	ldr	r3, [r7, #4]
2400621e:	681b      	ldr	r3, [r3, #0]
24006220:	681a      	ldr	r2, [r3, #0]
24006222:	687b      	ldr	r3, [r7, #4]
24006224:	681b      	ldr	r3, [r3, #0]
24006226:	f022 020a 	bic.w	r2, r2, #10
2400622a:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
2400622c:	687b      	ldr	r3, [r7, #4]
2400622e:	2201      	movs	r2, #1
24006230:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
24006234:	687b      	ldr	r3, [r7, #4]
24006236:	2200      	movs	r2, #0
24006238:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        }

        if(hdma->XferCpltCallback != NULL)
2400623c:	687b      	ldr	r3, [r7, #4]
2400623e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24006240:	2b00      	cmp	r3, #0
24006242:	f000 8097 	beq.w	24006374 <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
24006246:	687b      	ldr	r3, [r7, #4]
24006248:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400624a:	6878      	ldr	r0, [r7, #4]
2400624c:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
2400624e:	e091      	b.n	24006374 <HAL_DMA_IRQHandler+0xe0c>
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
24006250:	687b      	ldr	r3, [r7, #4]
24006252:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006254:	f003 031f 	and.w	r3, r3, #31
24006258:	2208      	movs	r2, #8
2400625a:	409a      	lsls	r2, r3
2400625c:	697b      	ldr	r3, [r7, #20]
2400625e:	4013      	ands	r3, r2
24006260:	2b00      	cmp	r3, #0
24006262:	f000 8088 	beq.w	24006376 <HAL_DMA_IRQHandler+0xe0e>
24006266:	693b      	ldr	r3, [r7, #16]
24006268:	f003 0308 	and.w	r3, r3, #8
2400626c:	2b00      	cmp	r3, #0
2400626e:	f000 8082 	beq.w	24006376 <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
24006272:	687b      	ldr	r3, [r7, #4]
24006274:	681b      	ldr	r3, [r3, #0]
24006276:	4a41      	ldr	r2, [pc, #260]	; (2400637c <HAL_DMA_IRQHandler+0xe14>)
24006278:	4293      	cmp	r3, r2
2400627a:	d04a      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
2400627c:	687b      	ldr	r3, [r7, #4]
2400627e:	681b      	ldr	r3, [r3, #0]
24006280:	4a3f      	ldr	r2, [pc, #252]	; (24006380 <HAL_DMA_IRQHandler+0xe18>)
24006282:	4293      	cmp	r3, r2
24006284:	d045      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
24006286:	687b      	ldr	r3, [r7, #4]
24006288:	681b      	ldr	r3, [r3, #0]
2400628a:	4a3e      	ldr	r2, [pc, #248]	; (24006384 <HAL_DMA_IRQHandler+0xe1c>)
2400628c:	4293      	cmp	r3, r2
2400628e:	d040      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
24006290:	687b      	ldr	r3, [r7, #4]
24006292:	681b      	ldr	r3, [r3, #0]
24006294:	4a3c      	ldr	r2, [pc, #240]	; (24006388 <HAL_DMA_IRQHandler+0xe20>)
24006296:	4293      	cmp	r3, r2
24006298:	d03b      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
2400629a:	687b      	ldr	r3, [r7, #4]
2400629c:	681b      	ldr	r3, [r3, #0]
2400629e:	4a3b      	ldr	r2, [pc, #236]	; (2400638c <HAL_DMA_IRQHandler+0xe24>)
240062a0:	4293      	cmp	r3, r2
240062a2:	d036      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062a4:	687b      	ldr	r3, [r7, #4]
240062a6:	681b      	ldr	r3, [r3, #0]
240062a8:	4a39      	ldr	r2, [pc, #228]	; (24006390 <HAL_DMA_IRQHandler+0xe28>)
240062aa:	4293      	cmp	r3, r2
240062ac:	d031      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062ae:	687b      	ldr	r3, [r7, #4]
240062b0:	681b      	ldr	r3, [r3, #0]
240062b2:	4a38      	ldr	r2, [pc, #224]	; (24006394 <HAL_DMA_IRQHandler+0xe2c>)
240062b4:	4293      	cmp	r3, r2
240062b6:	d02c      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062b8:	687b      	ldr	r3, [r7, #4]
240062ba:	681b      	ldr	r3, [r3, #0]
240062bc:	4a36      	ldr	r2, [pc, #216]	; (24006398 <HAL_DMA_IRQHandler+0xe30>)
240062be:	4293      	cmp	r3, r2
240062c0:	d027      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062c2:	687b      	ldr	r3, [r7, #4]
240062c4:	681b      	ldr	r3, [r3, #0]
240062c6:	4a35      	ldr	r2, [pc, #212]	; (2400639c <HAL_DMA_IRQHandler+0xe34>)
240062c8:	4293      	cmp	r3, r2
240062ca:	d022      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062cc:	687b      	ldr	r3, [r7, #4]
240062ce:	681b      	ldr	r3, [r3, #0]
240062d0:	4a33      	ldr	r2, [pc, #204]	; (240063a0 <HAL_DMA_IRQHandler+0xe38>)
240062d2:	4293      	cmp	r3, r2
240062d4:	d01d      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062d6:	687b      	ldr	r3, [r7, #4]
240062d8:	681b      	ldr	r3, [r3, #0]
240062da:	4a32      	ldr	r2, [pc, #200]	; (240063a4 <HAL_DMA_IRQHandler+0xe3c>)
240062dc:	4293      	cmp	r3, r2
240062de:	d018      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062e0:	687b      	ldr	r3, [r7, #4]
240062e2:	681b      	ldr	r3, [r3, #0]
240062e4:	4a30      	ldr	r2, [pc, #192]	; (240063a8 <HAL_DMA_IRQHandler+0xe40>)
240062e6:	4293      	cmp	r3, r2
240062e8:	d013      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062ea:	687b      	ldr	r3, [r7, #4]
240062ec:	681b      	ldr	r3, [r3, #0]
240062ee:	4a2f      	ldr	r2, [pc, #188]	; (240063ac <HAL_DMA_IRQHandler+0xe44>)
240062f0:	4293      	cmp	r3, r2
240062f2:	d00e      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062f4:	687b      	ldr	r3, [r7, #4]
240062f6:	681b      	ldr	r3, [r3, #0]
240062f8:	4a2d      	ldr	r2, [pc, #180]	; (240063b0 <HAL_DMA_IRQHandler+0xe48>)
240062fa:	4293      	cmp	r3, r2
240062fc:	d009      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
240062fe:	687b      	ldr	r3, [r7, #4]
24006300:	681b      	ldr	r3, [r3, #0]
24006302:	4a2c      	ldr	r2, [pc, #176]	; (240063b4 <HAL_DMA_IRQHandler+0xe4c>)
24006304:	4293      	cmp	r3, r2
24006306:	d004      	beq.n	24006312 <HAL_DMA_IRQHandler+0xdaa>
24006308:	687b      	ldr	r3, [r7, #4]
2400630a:	681b      	ldr	r3, [r3, #0]
2400630c:	4a2a      	ldr	r2, [pc, #168]	; (240063b8 <HAL_DMA_IRQHandler+0xe50>)
2400630e:	4293      	cmp	r3, r2
24006310:	d108      	bne.n	24006324 <HAL_DMA_IRQHandler+0xdbc>
24006312:	687b      	ldr	r3, [r7, #4]
24006314:	681b      	ldr	r3, [r3, #0]
24006316:	681a      	ldr	r2, [r3, #0]
24006318:	687b      	ldr	r3, [r7, #4]
2400631a:	681b      	ldr	r3, [r3, #0]
2400631c:	f022 021c 	bic.w	r2, r2, #28
24006320:	601a      	str	r2, [r3, #0]
24006322:	e007      	b.n	24006334 <HAL_DMA_IRQHandler+0xdcc>
24006324:	687b      	ldr	r3, [r7, #4]
24006326:	681b      	ldr	r3, [r3, #0]
24006328:	681a      	ldr	r2, [r3, #0]
2400632a:	687b      	ldr	r3, [r7, #4]
2400632c:	681b      	ldr	r3, [r3, #0]
2400632e:	f022 020e 	bic.w	r2, r2, #14
24006332:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24006334:	687b      	ldr	r3, [r7, #4]
24006336:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006338:	f003 031f 	and.w	r3, r3, #31
2400633c:	2201      	movs	r2, #1
2400633e:	409a      	lsls	r2, r3
24006340:	69fb      	ldr	r3, [r7, #28]
24006342:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
24006344:	687b      	ldr	r3, [r7, #4]
24006346:	2201      	movs	r2, #1
24006348:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
2400634a:	687b      	ldr	r3, [r7, #4]
2400634c:	2201      	movs	r2, #1
2400634e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
24006352:	687b      	ldr	r3, [r7, #4]
24006354:	2200      	movs	r2, #0
24006356:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if (hdma->XferErrorCallback != NULL)
2400635a:	687b      	ldr	r3, [r7, #4]
2400635c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400635e:	2b00      	cmp	r3, #0
24006360:	d009      	beq.n	24006376 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24006362:	687b      	ldr	r3, [r7, #4]
24006364:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24006366:	6878      	ldr	r0, [r7, #4]
24006368:	4798      	blx	r3
2400636a:	e004      	b.n	24006376 <HAL_DMA_IRQHandler+0xe0e>
          return;
2400636c:	bf00      	nop
2400636e:	e002      	b.n	24006376 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24006370:	bf00      	nop
24006372:	e000      	b.n	24006376 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
24006374:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
24006376:	3728      	adds	r7, #40	; 0x28
24006378:	46bd      	mov	sp, r7
2400637a:	bd80      	pop	{r7, pc}
2400637c:	40020010 	.word	0x40020010
24006380:	40020028 	.word	0x40020028
24006384:	40020040 	.word	0x40020040
24006388:	40020058 	.word	0x40020058
2400638c:	40020070 	.word	0x40020070
24006390:	40020088 	.word	0x40020088
24006394:	400200a0 	.word	0x400200a0
24006398:	400200b8 	.word	0x400200b8
2400639c:	40020410 	.word	0x40020410
240063a0:	40020428 	.word	0x40020428
240063a4:	40020440 	.word	0x40020440
240063a8:	40020458 	.word	0x40020458
240063ac:	40020470 	.word	0x40020470
240063b0:	40020488 	.word	0x40020488
240063b4:	400204a0 	.word	0x400204a0
240063b8:	400204b8 	.word	0x400204b8

240063bc <HAL_DMA_RegisterCallback>:
  * @param  pCallback:            pointer to private callback function which has pointer to
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
240063bc:	b480      	push	{r7}
240063be:	b087      	sub	sp, #28
240063c0:	af00      	add	r7, sp, #0
240063c2:	60f8      	str	r0, [r7, #12]
240063c4:	460b      	mov	r3, r1
240063c6:	607a      	str	r2, [r7, #4]
240063c8:	72fb      	strb	r3, [r7, #11]

  HAL_StatusTypeDef status = HAL_OK;
240063ca:	2300      	movs	r3, #0
240063cc:	75fb      	strb	r3, [r7, #23]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
240063ce:	68fb      	ldr	r3, [r7, #12]
240063d0:	2b00      	cmp	r3, #0
240063d2:	d101      	bne.n	240063d8 <HAL_DMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
240063d4:	2301      	movs	r3, #1
240063d6:	e045      	b.n	24006464 <HAL_DMA_RegisterCallback+0xa8>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
240063d8:	68fb      	ldr	r3, [r7, #12]
240063da:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
240063de:	2b01      	cmp	r3, #1
240063e0:	d101      	bne.n	240063e6 <HAL_DMA_RegisterCallback+0x2a>
240063e2:	2302      	movs	r3, #2
240063e4:	e03e      	b.n	24006464 <HAL_DMA_RegisterCallback+0xa8>
240063e6:	68fb      	ldr	r3, [r7, #12]
240063e8:	2201      	movs	r2, #1
240063ea:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
240063ee:	68fb      	ldr	r3, [r7, #12]
240063f0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240063f4:	b2db      	uxtb	r3, r3
240063f6:	2b01      	cmp	r3, #1
240063f8:	d12d      	bne.n	24006456 <HAL_DMA_RegisterCallback+0x9a>
  {
    switch (CallbackID)
240063fa:	7afb      	ldrb	r3, [r7, #11]
240063fc:	2b05      	cmp	r3, #5
240063fe:	d827      	bhi.n	24006450 <HAL_DMA_RegisterCallback+0x94>
24006400:	a201      	add	r2, pc, #4	; (adr r2, 24006408 <HAL_DMA_RegisterCallback+0x4c>)
24006402:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24006406:	bf00      	nop
24006408:	24006421 	.word	0x24006421
2400640c:	24006429 	.word	0x24006429
24006410:	24006431 	.word	0x24006431
24006414:	24006439 	.word	0x24006439
24006418:	24006441 	.word	0x24006441
2400641c:	24006449 	.word	0x24006449
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = pCallback;
24006420:	68fb      	ldr	r3, [r7, #12]
24006422:	687a      	ldr	r2, [r7, #4]
24006424:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
24006426:	e018      	b.n	2400645a <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = pCallback;
24006428:	68fb      	ldr	r3, [r7, #12]
2400642a:	687a      	ldr	r2, [r7, #4]
2400642c:	641a      	str	r2, [r3, #64]	; 0x40
      break;
2400642e:	e014      	b.n	2400645a <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = pCallback;
24006430:	68fb      	ldr	r3, [r7, #12]
24006432:	687a      	ldr	r2, [r7, #4]
24006434:	645a      	str	r2, [r3, #68]	; 0x44
      break;
24006436:	e010      	b.n	2400645a <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = pCallback;
24006438:	68fb      	ldr	r3, [r7, #12]
2400643a:	687a      	ldr	r2, [r7, #4]
2400643c:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400643e:	e00c      	b.n	2400645a <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = pCallback;
24006440:	68fb      	ldr	r3, [r7, #12]
24006442:	687a      	ldr	r2, [r7, #4]
24006444:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
24006446:	e008      	b.n	2400645a <HAL_DMA_RegisterCallback+0x9e>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = pCallback;
24006448:	68fb      	ldr	r3, [r7, #12]
2400644a:	687a      	ldr	r2, [r7, #4]
2400644c:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400644e:	e004      	b.n	2400645a <HAL_DMA_RegisterCallback+0x9e>

    default:
      status =  HAL_ERROR;
24006450:	2301      	movs	r3, #1
24006452:	75fb      	strb	r3, [r7, #23]
      break;
24006454:	e001      	b.n	2400645a <HAL_DMA_RegisterCallback+0x9e>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
24006456:	2301      	movs	r3, #1
24006458:	75fb      	strb	r3, [r7, #23]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
2400645a:	68fb      	ldr	r3, [r7, #12]
2400645c:	2200      	movs	r2, #0
2400645e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
24006462:	7dfb      	ldrb	r3, [r7, #23]
}
24006464:	4618      	mov	r0, r3
24006466:	371c      	adds	r7, #28
24006468:	46bd      	mov	sp, r7
2400646a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400646e:	4770      	bx	lr

24006470 <HAL_DMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
{
24006470:	b480      	push	{r7}
24006472:	b085      	sub	sp, #20
24006474:	af00      	add	r7, sp, #0
24006476:	6078      	str	r0, [r7, #4]
24006478:	460b      	mov	r3, r1
2400647a:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
2400647c:	2300      	movs	r3, #0
2400647e:	73fb      	strb	r3, [r7, #15]

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
24006480:	687b      	ldr	r3, [r7, #4]
24006482:	2b00      	cmp	r3, #0
24006484:	d101      	bne.n	2400648a <HAL_DMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
24006486:	2301      	movs	r3, #1
24006488:	e059      	b.n	2400653e <HAL_DMA_UnRegisterCallback+0xce>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
2400648a:	687b      	ldr	r3, [r7, #4]
2400648c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24006490:	2b01      	cmp	r3, #1
24006492:	d101      	bne.n	24006498 <HAL_DMA_UnRegisterCallback+0x28>
24006494:	2302      	movs	r3, #2
24006496:	e052      	b.n	2400653e <HAL_DMA_UnRegisterCallback+0xce>
24006498:	687b      	ldr	r3, [r7, #4]
2400649a:	2201      	movs	r2, #1
2400649c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
240064a0:	687b      	ldr	r3, [r7, #4]
240064a2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
240064a6:	b2db      	uxtb	r3, r3
240064a8:	2b01      	cmp	r3, #1
240064aa:	d141      	bne.n	24006530 <HAL_DMA_UnRegisterCallback+0xc0>
  {
    switch (CallbackID)
240064ac:	78fb      	ldrb	r3, [r7, #3]
240064ae:	2b06      	cmp	r3, #6
240064b0:	d83b      	bhi.n	2400652a <HAL_DMA_UnRegisterCallback+0xba>
240064b2:	a201      	add	r2, pc, #4	; (adr r2, 240064b8 <HAL_DMA_UnRegisterCallback+0x48>)
240064b4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240064b8:	240064d5 	.word	0x240064d5
240064bc:	240064dd 	.word	0x240064dd
240064c0:	240064e5 	.word	0x240064e5
240064c4:	240064ed 	.word	0x240064ed
240064c8:	240064f5 	.word	0x240064f5
240064cc:	240064fd 	.word	0x240064fd
240064d0:	24006505 	.word	0x24006505
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = NULL;
240064d4:	687b      	ldr	r3, [r7, #4]
240064d6:	2200      	movs	r2, #0
240064d8:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
240064da:	e02b      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = NULL;
240064dc:	687b      	ldr	r3, [r7, #4]
240064de:	2200      	movs	r2, #0
240064e0:	641a      	str	r2, [r3, #64]	; 0x40
      break;
240064e2:	e027      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = NULL;
240064e4:	687b      	ldr	r3, [r7, #4]
240064e6:	2200      	movs	r2, #0
240064e8:	645a      	str	r2, [r3, #68]	; 0x44
      break;
240064ea:	e023      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = NULL;
240064ec:	687b      	ldr	r3, [r7, #4]
240064ee:	2200      	movs	r2, #0
240064f0:	649a      	str	r2, [r3, #72]	; 0x48
      break;
240064f2:	e01f      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = NULL;
240064f4:	687b      	ldr	r3, [r7, #4]
240064f6:	2200      	movs	r2, #0
240064f8:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
240064fa:	e01b      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = NULL;
240064fc:	687b      	ldr	r3, [r7, #4]
240064fe:	2200      	movs	r2, #0
24006500:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24006502:	e017      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>

    case   HAL_DMA_XFER_ALL_CB_ID:
      hdma->XferCpltCallback = NULL;
24006504:	687b      	ldr	r3, [r7, #4]
24006506:	2200      	movs	r2, #0
24006508:	63da      	str	r2, [r3, #60]	; 0x3c
      hdma->XferHalfCpltCallback = NULL;
2400650a:	687b      	ldr	r3, [r7, #4]
2400650c:	2200      	movs	r2, #0
2400650e:	641a      	str	r2, [r3, #64]	; 0x40
      hdma->XferM1CpltCallback = NULL;
24006510:	687b      	ldr	r3, [r7, #4]
24006512:	2200      	movs	r2, #0
24006514:	645a      	str	r2, [r3, #68]	; 0x44
      hdma->XferM1HalfCpltCallback = NULL;
24006516:	687b      	ldr	r3, [r7, #4]
24006518:	2200      	movs	r2, #0
2400651a:	649a      	str	r2, [r3, #72]	; 0x48
      hdma->XferErrorCallback = NULL;
2400651c:	687b      	ldr	r3, [r7, #4]
2400651e:	2200      	movs	r2, #0
24006520:	64da      	str	r2, [r3, #76]	; 0x4c
      hdma->XferAbortCallback = NULL;
24006522:	687b      	ldr	r3, [r7, #4]
24006524:	2200      	movs	r2, #0
24006526:	651a      	str	r2, [r3, #80]	; 0x50
      break;
24006528:	e004      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>

    default:
      status = HAL_ERROR;
2400652a:	2301      	movs	r3, #1
2400652c:	73fb      	strb	r3, [r7, #15]
      break;
2400652e:	e001      	b.n	24006534 <HAL_DMA_UnRegisterCallback+0xc4>
    }
  }
  else
  {
    status = HAL_ERROR;
24006530:	2301      	movs	r3, #1
24006532:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
24006534:	687b      	ldr	r3, [r7, #4]
24006536:	2200      	movs	r2, #0
24006538:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
2400653c:	7bfb      	ldrb	r3, [r7, #15]
}
2400653e:	4618      	mov	r0, r3
24006540:	3714      	adds	r7, #20
24006542:	46bd      	mov	sp, r7
24006544:	f85d 7b04 	ldr.w	r7, [sp], #4
24006548:	4770      	bx	lr
2400654a:	bf00      	nop

2400654c <HAL_DMA_GetState>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
2400654c:	b480      	push	{r7}
2400654e:	b083      	sub	sp, #12
24006550:	af00      	add	r7, sp, #0
24006552:	6078      	str	r0, [r7, #4]
  return hdma->State;
24006554:	687b      	ldr	r3, [r7, #4]
24006556:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
2400655a:	b2db      	uxtb	r3, r3
}
2400655c:	4618      	mov	r0, r3
2400655e:	370c      	adds	r7, #12
24006560:	46bd      	mov	sp, r7
24006562:	f85d 7b04 	ldr.w	r7, [sp], #4
24006566:	4770      	bx	lr

24006568 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
24006568:	b480      	push	{r7}
2400656a:	b083      	sub	sp, #12
2400656c:	af00      	add	r7, sp, #0
2400656e:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
24006570:	687b      	ldr	r3, [r7, #4]
24006572:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
24006574:	4618      	mov	r0, r3
24006576:	370c      	adds	r7, #12
24006578:	46bd      	mov	sp, r7
2400657a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400657e:	4770      	bx	lr

24006580 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24006580:	b480      	push	{r7}
24006582:	b087      	sub	sp, #28
24006584:	af00      	add	r7, sp, #0
24006586:	60f8      	str	r0, [r7, #12]
24006588:	60b9      	str	r1, [r7, #8]
2400658a:	607a      	str	r2, [r7, #4]
2400658c:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
2400658e:	68fb      	ldr	r3, [r7, #12]
24006590:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006592:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
24006594:	68fb      	ldr	r3, [r7, #12]
24006596:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006598:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
2400659a:	68fb      	ldr	r3, [r7, #12]
2400659c:	681b      	ldr	r3, [r3, #0]
2400659e:	4a7f      	ldr	r2, [pc, #508]	; (2400679c <DMA_SetConfig+0x21c>)
240065a0:	4293      	cmp	r3, r2
240065a2:	d072      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065a4:	68fb      	ldr	r3, [r7, #12]
240065a6:	681b      	ldr	r3, [r3, #0]
240065a8:	4a7d      	ldr	r2, [pc, #500]	; (240067a0 <DMA_SetConfig+0x220>)
240065aa:	4293      	cmp	r3, r2
240065ac:	d06d      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065ae:	68fb      	ldr	r3, [r7, #12]
240065b0:	681b      	ldr	r3, [r3, #0]
240065b2:	4a7c      	ldr	r2, [pc, #496]	; (240067a4 <DMA_SetConfig+0x224>)
240065b4:	4293      	cmp	r3, r2
240065b6:	d068      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065b8:	68fb      	ldr	r3, [r7, #12]
240065ba:	681b      	ldr	r3, [r3, #0]
240065bc:	4a7a      	ldr	r2, [pc, #488]	; (240067a8 <DMA_SetConfig+0x228>)
240065be:	4293      	cmp	r3, r2
240065c0:	d063      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065c2:	68fb      	ldr	r3, [r7, #12]
240065c4:	681b      	ldr	r3, [r3, #0]
240065c6:	4a79      	ldr	r2, [pc, #484]	; (240067ac <DMA_SetConfig+0x22c>)
240065c8:	4293      	cmp	r3, r2
240065ca:	d05e      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065cc:	68fb      	ldr	r3, [r7, #12]
240065ce:	681b      	ldr	r3, [r3, #0]
240065d0:	4a77      	ldr	r2, [pc, #476]	; (240067b0 <DMA_SetConfig+0x230>)
240065d2:	4293      	cmp	r3, r2
240065d4:	d059      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065d6:	68fb      	ldr	r3, [r7, #12]
240065d8:	681b      	ldr	r3, [r3, #0]
240065da:	4a76      	ldr	r2, [pc, #472]	; (240067b4 <DMA_SetConfig+0x234>)
240065dc:	4293      	cmp	r3, r2
240065de:	d054      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065e0:	68fb      	ldr	r3, [r7, #12]
240065e2:	681b      	ldr	r3, [r3, #0]
240065e4:	4a74      	ldr	r2, [pc, #464]	; (240067b8 <DMA_SetConfig+0x238>)
240065e6:	4293      	cmp	r3, r2
240065e8:	d04f      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065ea:	68fb      	ldr	r3, [r7, #12]
240065ec:	681b      	ldr	r3, [r3, #0]
240065ee:	4a73      	ldr	r2, [pc, #460]	; (240067bc <DMA_SetConfig+0x23c>)
240065f0:	4293      	cmp	r3, r2
240065f2:	d04a      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065f4:	68fb      	ldr	r3, [r7, #12]
240065f6:	681b      	ldr	r3, [r3, #0]
240065f8:	4a71      	ldr	r2, [pc, #452]	; (240067c0 <DMA_SetConfig+0x240>)
240065fa:	4293      	cmp	r3, r2
240065fc:	d045      	beq.n	2400668a <DMA_SetConfig+0x10a>
240065fe:	68fb      	ldr	r3, [r7, #12]
24006600:	681b      	ldr	r3, [r3, #0]
24006602:	4a70      	ldr	r2, [pc, #448]	; (240067c4 <DMA_SetConfig+0x244>)
24006604:	4293      	cmp	r3, r2
24006606:	d040      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006608:	68fb      	ldr	r3, [r7, #12]
2400660a:	681b      	ldr	r3, [r3, #0]
2400660c:	4a6e      	ldr	r2, [pc, #440]	; (240067c8 <DMA_SetConfig+0x248>)
2400660e:	4293      	cmp	r3, r2
24006610:	d03b      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006612:	68fb      	ldr	r3, [r7, #12]
24006614:	681b      	ldr	r3, [r3, #0]
24006616:	4a6d      	ldr	r2, [pc, #436]	; (240067cc <DMA_SetConfig+0x24c>)
24006618:	4293      	cmp	r3, r2
2400661a:	d036      	beq.n	2400668a <DMA_SetConfig+0x10a>
2400661c:	68fb      	ldr	r3, [r7, #12]
2400661e:	681b      	ldr	r3, [r3, #0]
24006620:	4a6b      	ldr	r2, [pc, #428]	; (240067d0 <DMA_SetConfig+0x250>)
24006622:	4293      	cmp	r3, r2
24006624:	d031      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006626:	68fb      	ldr	r3, [r7, #12]
24006628:	681b      	ldr	r3, [r3, #0]
2400662a:	4a6a      	ldr	r2, [pc, #424]	; (240067d4 <DMA_SetConfig+0x254>)
2400662c:	4293      	cmp	r3, r2
2400662e:	d02c      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006630:	68fb      	ldr	r3, [r7, #12]
24006632:	681b      	ldr	r3, [r3, #0]
24006634:	4a68      	ldr	r2, [pc, #416]	; (240067d8 <DMA_SetConfig+0x258>)
24006636:	4293      	cmp	r3, r2
24006638:	d027      	beq.n	2400668a <DMA_SetConfig+0x10a>
2400663a:	68fb      	ldr	r3, [r7, #12]
2400663c:	681b      	ldr	r3, [r3, #0]
2400663e:	4a67      	ldr	r2, [pc, #412]	; (240067dc <DMA_SetConfig+0x25c>)
24006640:	4293      	cmp	r3, r2
24006642:	d022      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006644:	68fb      	ldr	r3, [r7, #12]
24006646:	681b      	ldr	r3, [r3, #0]
24006648:	4a65      	ldr	r2, [pc, #404]	; (240067e0 <DMA_SetConfig+0x260>)
2400664a:	4293      	cmp	r3, r2
2400664c:	d01d      	beq.n	2400668a <DMA_SetConfig+0x10a>
2400664e:	68fb      	ldr	r3, [r7, #12]
24006650:	681b      	ldr	r3, [r3, #0]
24006652:	4a64      	ldr	r2, [pc, #400]	; (240067e4 <DMA_SetConfig+0x264>)
24006654:	4293      	cmp	r3, r2
24006656:	d018      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006658:	68fb      	ldr	r3, [r7, #12]
2400665a:	681b      	ldr	r3, [r3, #0]
2400665c:	4a62      	ldr	r2, [pc, #392]	; (240067e8 <DMA_SetConfig+0x268>)
2400665e:	4293      	cmp	r3, r2
24006660:	d013      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006662:	68fb      	ldr	r3, [r7, #12]
24006664:	681b      	ldr	r3, [r3, #0]
24006666:	4a61      	ldr	r2, [pc, #388]	; (240067ec <DMA_SetConfig+0x26c>)
24006668:	4293      	cmp	r3, r2
2400666a:	d00e      	beq.n	2400668a <DMA_SetConfig+0x10a>
2400666c:	68fb      	ldr	r3, [r7, #12]
2400666e:	681b      	ldr	r3, [r3, #0]
24006670:	4a5f      	ldr	r2, [pc, #380]	; (240067f0 <DMA_SetConfig+0x270>)
24006672:	4293      	cmp	r3, r2
24006674:	d009      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006676:	68fb      	ldr	r3, [r7, #12]
24006678:	681b      	ldr	r3, [r3, #0]
2400667a:	4a5e      	ldr	r2, [pc, #376]	; (240067f4 <DMA_SetConfig+0x274>)
2400667c:	4293      	cmp	r3, r2
2400667e:	d004      	beq.n	2400668a <DMA_SetConfig+0x10a>
24006680:	68fb      	ldr	r3, [r7, #12]
24006682:	681b      	ldr	r3, [r3, #0]
24006684:	4a5c      	ldr	r2, [pc, #368]	; (240067f8 <DMA_SetConfig+0x278>)
24006686:	4293      	cmp	r3, r2
24006688:	d101      	bne.n	2400668e <DMA_SetConfig+0x10e>
2400668a:	2301      	movs	r3, #1
2400668c:	e000      	b.n	24006690 <DMA_SetConfig+0x110>
2400668e:	2300      	movs	r3, #0
24006690:	2b00      	cmp	r3, #0
24006692:	d00d      	beq.n	240066b0 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24006694:	68fb      	ldr	r3, [r7, #12]
24006696:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24006698:	68fa      	ldr	r2, [r7, #12]
2400669a:	6e92      	ldr	r2, [r2, #104]	; 0x68
2400669c:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
2400669e:	68fb      	ldr	r3, [r7, #12]
240066a0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240066a2:	2b00      	cmp	r3, #0
240066a4:	d004      	beq.n	240066b0 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
240066a6:	68fb      	ldr	r3, [r7, #12]
240066a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240066aa:	68fa      	ldr	r2, [r7, #12]
240066ac:	6f52      	ldr	r2, [r2, #116]	; 0x74
240066ae:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240066b0:	68fb      	ldr	r3, [r7, #12]
240066b2:	681b      	ldr	r3, [r3, #0]
240066b4:	4a39      	ldr	r2, [pc, #228]	; (2400679c <DMA_SetConfig+0x21c>)
240066b6:	4293      	cmp	r3, r2
240066b8:	d04a      	beq.n	24006750 <DMA_SetConfig+0x1d0>
240066ba:	68fb      	ldr	r3, [r7, #12]
240066bc:	681b      	ldr	r3, [r3, #0]
240066be:	4a38      	ldr	r2, [pc, #224]	; (240067a0 <DMA_SetConfig+0x220>)
240066c0:	4293      	cmp	r3, r2
240066c2:	d045      	beq.n	24006750 <DMA_SetConfig+0x1d0>
240066c4:	68fb      	ldr	r3, [r7, #12]
240066c6:	681b      	ldr	r3, [r3, #0]
240066c8:	4a36      	ldr	r2, [pc, #216]	; (240067a4 <DMA_SetConfig+0x224>)
240066ca:	4293      	cmp	r3, r2
240066cc:	d040      	beq.n	24006750 <DMA_SetConfig+0x1d0>
240066ce:	68fb      	ldr	r3, [r7, #12]
240066d0:	681b      	ldr	r3, [r3, #0]
240066d2:	4a35      	ldr	r2, [pc, #212]	; (240067a8 <DMA_SetConfig+0x228>)
240066d4:	4293      	cmp	r3, r2
240066d6:	d03b      	beq.n	24006750 <DMA_SetConfig+0x1d0>
240066d8:	68fb      	ldr	r3, [r7, #12]
240066da:	681b      	ldr	r3, [r3, #0]
240066dc:	4a33      	ldr	r2, [pc, #204]	; (240067ac <DMA_SetConfig+0x22c>)
240066de:	4293      	cmp	r3, r2
240066e0:	d036      	beq.n	24006750 <DMA_SetConfig+0x1d0>
240066e2:	68fb      	ldr	r3, [r7, #12]
240066e4:	681b      	ldr	r3, [r3, #0]
240066e6:	4a32      	ldr	r2, [pc, #200]	; (240067b0 <DMA_SetConfig+0x230>)
240066e8:	4293      	cmp	r3, r2
240066ea:	d031      	beq.n	24006750 <DMA_SetConfig+0x1d0>
240066ec:	68fb      	ldr	r3, [r7, #12]
240066ee:	681b      	ldr	r3, [r3, #0]
240066f0:	4a30      	ldr	r2, [pc, #192]	; (240067b4 <DMA_SetConfig+0x234>)
240066f2:	4293      	cmp	r3, r2
240066f4:	d02c      	beq.n	24006750 <DMA_SetConfig+0x1d0>
240066f6:	68fb      	ldr	r3, [r7, #12]
240066f8:	681b      	ldr	r3, [r3, #0]
240066fa:	4a2f      	ldr	r2, [pc, #188]	; (240067b8 <DMA_SetConfig+0x238>)
240066fc:	4293      	cmp	r3, r2
240066fe:	d027      	beq.n	24006750 <DMA_SetConfig+0x1d0>
24006700:	68fb      	ldr	r3, [r7, #12]
24006702:	681b      	ldr	r3, [r3, #0]
24006704:	4a2d      	ldr	r2, [pc, #180]	; (240067bc <DMA_SetConfig+0x23c>)
24006706:	4293      	cmp	r3, r2
24006708:	d022      	beq.n	24006750 <DMA_SetConfig+0x1d0>
2400670a:	68fb      	ldr	r3, [r7, #12]
2400670c:	681b      	ldr	r3, [r3, #0]
2400670e:	4a2c      	ldr	r2, [pc, #176]	; (240067c0 <DMA_SetConfig+0x240>)
24006710:	4293      	cmp	r3, r2
24006712:	d01d      	beq.n	24006750 <DMA_SetConfig+0x1d0>
24006714:	68fb      	ldr	r3, [r7, #12]
24006716:	681b      	ldr	r3, [r3, #0]
24006718:	4a2a      	ldr	r2, [pc, #168]	; (240067c4 <DMA_SetConfig+0x244>)
2400671a:	4293      	cmp	r3, r2
2400671c:	d018      	beq.n	24006750 <DMA_SetConfig+0x1d0>
2400671e:	68fb      	ldr	r3, [r7, #12]
24006720:	681b      	ldr	r3, [r3, #0]
24006722:	4a29      	ldr	r2, [pc, #164]	; (240067c8 <DMA_SetConfig+0x248>)
24006724:	4293      	cmp	r3, r2
24006726:	d013      	beq.n	24006750 <DMA_SetConfig+0x1d0>
24006728:	68fb      	ldr	r3, [r7, #12]
2400672a:	681b      	ldr	r3, [r3, #0]
2400672c:	4a27      	ldr	r2, [pc, #156]	; (240067cc <DMA_SetConfig+0x24c>)
2400672e:	4293      	cmp	r3, r2
24006730:	d00e      	beq.n	24006750 <DMA_SetConfig+0x1d0>
24006732:	68fb      	ldr	r3, [r7, #12]
24006734:	681b      	ldr	r3, [r3, #0]
24006736:	4a26      	ldr	r2, [pc, #152]	; (240067d0 <DMA_SetConfig+0x250>)
24006738:	4293      	cmp	r3, r2
2400673a:	d009      	beq.n	24006750 <DMA_SetConfig+0x1d0>
2400673c:	68fb      	ldr	r3, [r7, #12]
2400673e:	681b      	ldr	r3, [r3, #0]
24006740:	4a24      	ldr	r2, [pc, #144]	; (240067d4 <DMA_SetConfig+0x254>)
24006742:	4293      	cmp	r3, r2
24006744:	d004      	beq.n	24006750 <DMA_SetConfig+0x1d0>
24006746:	68fb      	ldr	r3, [r7, #12]
24006748:	681b      	ldr	r3, [r3, #0]
2400674a:	4a23      	ldr	r2, [pc, #140]	; (240067d8 <DMA_SetConfig+0x258>)
2400674c:	4293      	cmp	r3, r2
2400674e:	d101      	bne.n	24006754 <DMA_SetConfig+0x1d4>
24006750:	2301      	movs	r3, #1
24006752:	e000      	b.n	24006756 <DMA_SetConfig+0x1d6>
24006754:	2300      	movs	r3, #0
24006756:	2b00      	cmp	r3, #0
24006758:	d059      	beq.n	2400680e <DMA_SetConfig+0x28e>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
2400675a:	68fb      	ldr	r3, [r7, #12]
2400675c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400675e:	f003 031f 	and.w	r3, r3, #31
24006762:	223f      	movs	r2, #63	; 0x3f
24006764:	409a      	lsls	r2, r3
24006766:	697b      	ldr	r3, [r7, #20]
24006768:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
2400676a:	68fb      	ldr	r3, [r7, #12]
2400676c:	681b      	ldr	r3, [r3, #0]
2400676e:	681a      	ldr	r2, [r3, #0]
24006770:	68fb      	ldr	r3, [r7, #12]
24006772:	681b      	ldr	r3, [r3, #0]
24006774:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24006778:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
2400677a:	68fb      	ldr	r3, [r7, #12]
2400677c:	681b      	ldr	r3, [r3, #0]
2400677e:	683a      	ldr	r2, [r7, #0]
24006780:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24006782:	68fb      	ldr	r3, [r7, #12]
24006784:	689b      	ldr	r3, [r3, #8]
24006786:	2b40      	cmp	r3, #64	; 0x40
24006788:	d138      	bne.n	240067fc <DMA_SetConfig+0x27c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
2400678a:	68fb      	ldr	r3, [r7, #12]
2400678c:	681b      	ldr	r3, [r3, #0]
2400678e:	687a      	ldr	r2, [r7, #4]
24006790:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
24006792:	68fb      	ldr	r3, [r7, #12]
24006794:	681b      	ldr	r3, [r3, #0]
24006796:	68ba      	ldr	r2, [r7, #8]
24006798:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
2400679a:	e086      	b.n	240068aa <DMA_SetConfig+0x32a>
2400679c:	40020010 	.word	0x40020010
240067a0:	40020028 	.word	0x40020028
240067a4:	40020040 	.word	0x40020040
240067a8:	40020058 	.word	0x40020058
240067ac:	40020070 	.word	0x40020070
240067b0:	40020088 	.word	0x40020088
240067b4:	400200a0 	.word	0x400200a0
240067b8:	400200b8 	.word	0x400200b8
240067bc:	40020410 	.word	0x40020410
240067c0:	40020428 	.word	0x40020428
240067c4:	40020440 	.word	0x40020440
240067c8:	40020458 	.word	0x40020458
240067cc:	40020470 	.word	0x40020470
240067d0:	40020488 	.word	0x40020488
240067d4:	400204a0 	.word	0x400204a0
240067d8:	400204b8 	.word	0x400204b8
240067dc:	58025408 	.word	0x58025408
240067e0:	5802541c 	.word	0x5802541c
240067e4:	58025430 	.word	0x58025430
240067e8:	58025444 	.word	0x58025444
240067ec:	58025458 	.word	0x58025458
240067f0:	5802546c 	.word	0x5802546c
240067f4:	58025480 	.word	0x58025480
240067f8:	58025494 	.word	0x58025494
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
240067fc:	68fb      	ldr	r3, [r7, #12]
240067fe:	681b      	ldr	r3, [r3, #0]
24006800:	68ba      	ldr	r2, [r7, #8]
24006802:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
24006804:	68fb      	ldr	r3, [r7, #12]
24006806:	681b      	ldr	r3, [r3, #0]
24006808:	687a      	ldr	r2, [r7, #4]
2400680a:	60da      	str	r2, [r3, #12]
}
2400680c:	e04d      	b.n	240068aa <DMA_SetConfig+0x32a>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
2400680e:	68fb      	ldr	r3, [r7, #12]
24006810:	681b      	ldr	r3, [r3, #0]
24006812:	4a29      	ldr	r2, [pc, #164]	; (240068b8 <DMA_SetConfig+0x338>)
24006814:	4293      	cmp	r3, r2
24006816:	d022      	beq.n	2400685e <DMA_SetConfig+0x2de>
24006818:	68fb      	ldr	r3, [r7, #12]
2400681a:	681b      	ldr	r3, [r3, #0]
2400681c:	4a27      	ldr	r2, [pc, #156]	; (240068bc <DMA_SetConfig+0x33c>)
2400681e:	4293      	cmp	r3, r2
24006820:	d01d      	beq.n	2400685e <DMA_SetConfig+0x2de>
24006822:	68fb      	ldr	r3, [r7, #12]
24006824:	681b      	ldr	r3, [r3, #0]
24006826:	4a26      	ldr	r2, [pc, #152]	; (240068c0 <DMA_SetConfig+0x340>)
24006828:	4293      	cmp	r3, r2
2400682a:	d018      	beq.n	2400685e <DMA_SetConfig+0x2de>
2400682c:	68fb      	ldr	r3, [r7, #12]
2400682e:	681b      	ldr	r3, [r3, #0]
24006830:	4a24      	ldr	r2, [pc, #144]	; (240068c4 <DMA_SetConfig+0x344>)
24006832:	4293      	cmp	r3, r2
24006834:	d013      	beq.n	2400685e <DMA_SetConfig+0x2de>
24006836:	68fb      	ldr	r3, [r7, #12]
24006838:	681b      	ldr	r3, [r3, #0]
2400683a:	4a23      	ldr	r2, [pc, #140]	; (240068c8 <DMA_SetConfig+0x348>)
2400683c:	4293      	cmp	r3, r2
2400683e:	d00e      	beq.n	2400685e <DMA_SetConfig+0x2de>
24006840:	68fb      	ldr	r3, [r7, #12]
24006842:	681b      	ldr	r3, [r3, #0]
24006844:	4a21      	ldr	r2, [pc, #132]	; (240068cc <DMA_SetConfig+0x34c>)
24006846:	4293      	cmp	r3, r2
24006848:	d009      	beq.n	2400685e <DMA_SetConfig+0x2de>
2400684a:	68fb      	ldr	r3, [r7, #12]
2400684c:	681b      	ldr	r3, [r3, #0]
2400684e:	4a20      	ldr	r2, [pc, #128]	; (240068d0 <DMA_SetConfig+0x350>)
24006850:	4293      	cmp	r3, r2
24006852:	d004      	beq.n	2400685e <DMA_SetConfig+0x2de>
24006854:	68fb      	ldr	r3, [r7, #12]
24006856:	681b      	ldr	r3, [r3, #0]
24006858:	4a1e      	ldr	r2, [pc, #120]	; (240068d4 <DMA_SetConfig+0x354>)
2400685a:	4293      	cmp	r3, r2
2400685c:	d101      	bne.n	24006862 <DMA_SetConfig+0x2e2>
2400685e:	2301      	movs	r3, #1
24006860:	e000      	b.n	24006864 <DMA_SetConfig+0x2e4>
24006862:	2300      	movs	r3, #0
24006864:	2b00      	cmp	r3, #0
24006866:	d020      	beq.n	240068aa <DMA_SetConfig+0x32a>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24006868:	68fb      	ldr	r3, [r7, #12]
2400686a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400686c:	f003 031f 	and.w	r3, r3, #31
24006870:	2201      	movs	r2, #1
24006872:	409a      	lsls	r2, r3
24006874:	693b      	ldr	r3, [r7, #16]
24006876:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
24006878:	68fb      	ldr	r3, [r7, #12]
2400687a:	681b      	ldr	r3, [r3, #0]
2400687c:	683a      	ldr	r2, [r7, #0]
2400687e:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24006880:	68fb      	ldr	r3, [r7, #12]
24006882:	689b      	ldr	r3, [r3, #8]
24006884:	2b40      	cmp	r3, #64	; 0x40
24006886:	d108      	bne.n	2400689a <DMA_SetConfig+0x31a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
24006888:	68fb      	ldr	r3, [r7, #12]
2400688a:	681b      	ldr	r3, [r3, #0]
2400688c:	687a      	ldr	r2, [r7, #4]
2400688e:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
24006890:	68fb      	ldr	r3, [r7, #12]
24006892:	681b      	ldr	r3, [r3, #0]
24006894:	68ba      	ldr	r2, [r7, #8]
24006896:	60da      	str	r2, [r3, #12]
}
24006898:	e007      	b.n	240068aa <DMA_SetConfig+0x32a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
2400689a:	68fb      	ldr	r3, [r7, #12]
2400689c:	681b      	ldr	r3, [r3, #0]
2400689e:	68ba      	ldr	r2, [r7, #8]
240068a0:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
240068a2:	68fb      	ldr	r3, [r7, #12]
240068a4:	681b      	ldr	r3, [r3, #0]
240068a6:	687a      	ldr	r2, [r7, #4]
240068a8:	60da      	str	r2, [r3, #12]
}
240068aa:	bf00      	nop
240068ac:	371c      	adds	r7, #28
240068ae:	46bd      	mov	sp, r7
240068b0:	f85d 7b04 	ldr.w	r7, [sp], #4
240068b4:	4770      	bx	lr
240068b6:	bf00      	nop
240068b8:	58025408 	.word	0x58025408
240068bc:	5802541c 	.word	0x5802541c
240068c0:	58025430 	.word	0x58025430
240068c4:	58025444 	.word	0x58025444
240068c8:	58025458 	.word	0x58025458
240068cc:	5802546c 	.word	0x5802546c
240068d0:	58025480 	.word	0x58025480
240068d4:	58025494 	.word	0x58025494

240068d8 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
240068d8:	b480      	push	{r7}
240068da:	b085      	sub	sp, #20
240068dc:	af00      	add	r7, sp, #0
240068de:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240068e0:	687b      	ldr	r3, [r7, #4]
240068e2:	681b      	ldr	r3, [r3, #0]
240068e4:	4a42      	ldr	r2, [pc, #264]	; (240069f0 <DMA_CalcBaseAndBitshift+0x118>)
240068e6:	4293      	cmp	r3, r2
240068e8:	d04a      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
240068ea:	687b      	ldr	r3, [r7, #4]
240068ec:	681b      	ldr	r3, [r3, #0]
240068ee:	4a41      	ldr	r2, [pc, #260]	; (240069f4 <DMA_CalcBaseAndBitshift+0x11c>)
240068f0:	4293      	cmp	r3, r2
240068f2:	d045      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
240068f4:	687b      	ldr	r3, [r7, #4]
240068f6:	681b      	ldr	r3, [r3, #0]
240068f8:	4a3f      	ldr	r2, [pc, #252]	; (240069f8 <DMA_CalcBaseAndBitshift+0x120>)
240068fa:	4293      	cmp	r3, r2
240068fc:	d040      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
240068fe:	687b      	ldr	r3, [r7, #4]
24006900:	681b      	ldr	r3, [r3, #0]
24006902:	4a3e      	ldr	r2, [pc, #248]	; (240069fc <DMA_CalcBaseAndBitshift+0x124>)
24006904:	4293      	cmp	r3, r2
24006906:	d03b      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006908:	687b      	ldr	r3, [r7, #4]
2400690a:	681b      	ldr	r3, [r3, #0]
2400690c:	4a3c      	ldr	r2, [pc, #240]	; (24006a00 <DMA_CalcBaseAndBitshift+0x128>)
2400690e:	4293      	cmp	r3, r2
24006910:	d036      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006912:	687b      	ldr	r3, [r7, #4]
24006914:	681b      	ldr	r3, [r3, #0]
24006916:	4a3b      	ldr	r2, [pc, #236]	; (24006a04 <DMA_CalcBaseAndBitshift+0x12c>)
24006918:	4293      	cmp	r3, r2
2400691a:	d031      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
2400691c:	687b      	ldr	r3, [r7, #4]
2400691e:	681b      	ldr	r3, [r3, #0]
24006920:	4a39      	ldr	r2, [pc, #228]	; (24006a08 <DMA_CalcBaseAndBitshift+0x130>)
24006922:	4293      	cmp	r3, r2
24006924:	d02c      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006926:	687b      	ldr	r3, [r7, #4]
24006928:	681b      	ldr	r3, [r3, #0]
2400692a:	4a38      	ldr	r2, [pc, #224]	; (24006a0c <DMA_CalcBaseAndBitshift+0x134>)
2400692c:	4293      	cmp	r3, r2
2400692e:	d027      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006930:	687b      	ldr	r3, [r7, #4]
24006932:	681b      	ldr	r3, [r3, #0]
24006934:	4a36      	ldr	r2, [pc, #216]	; (24006a10 <DMA_CalcBaseAndBitshift+0x138>)
24006936:	4293      	cmp	r3, r2
24006938:	d022      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
2400693a:	687b      	ldr	r3, [r7, #4]
2400693c:	681b      	ldr	r3, [r3, #0]
2400693e:	4a35      	ldr	r2, [pc, #212]	; (24006a14 <DMA_CalcBaseAndBitshift+0x13c>)
24006940:	4293      	cmp	r3, r2
24006942:	d01d      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006944:	687b      	ldr	r3, [r7, #4]
24006946:	681b      	ldr	r3, [r3, #0]
24006948:	4a33      	ldr	r2, [pc, #204]	; (24006a18 <DMA_CalcBaseAndBitshift+0x140>)
2400694a:	4293      	cmp	r3, r2
2400694c:	d018      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
2400694e:	687b      	ldr	r3, [r7, #4]
24006950:	681b      	ldr	r3, [r3, #0]
24006952:	4a32      	ldr	r2, [pc, #200]	; (24006a1c <DMA_CalcBaseAndBitshift+0x144>)
24006954:	4293      	cmp	r3, r2
24006956:	d013      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006958:	687b      	ldr	r3, [r7, #4]
2400695a:	681b      	ldr	r3, [r3, #0]
2400695c:	4a30      	ldr	r2, [pc, #192]	; (24006a20 <DMA_CalcBaseAndBitshift+0x148>)
2400695e:	4293      	cmp	r3, r2
24006960:	d00e      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006962:	687b      	ldr	r3, [r7, #4]
24006964:	681b      	ldr	r3, [r3, #0]
24006966:	4a2f      	ldr	r2, [pc, #188]	; (24006a24 <DMA_CalcBaseAndBitshift+0x14c>)
24006968:	4293      	cmp	r3, r2
2400696a:	d009      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
2400696c:	687b      	ldr	r3, [r7, #4]
2400696e:	681b      	ldr	r3, [r3, #0]
24006970:	4a2d      	ldr	r2, [pc, #180]	; (24006a28 <DMA_CalcBaseAndBitshift+0x150>)
24006972:	4293      	cmp	r3, r2
24006974:	d004      	beq.n	24006980 <DMA_CalcBaseAndBitshift+0xa8>
24006976:	687b      	ldr	r3, [r7, #4]
24006978:	681b      	ldr	r3, [r3, #0]
2400697a:	4a2c      	ldr	r2, [pc, #176]	; (24006a2c <DMA_CalcBaseAndBitshift+0x154>)
2400697c:	4293      	cmp	r3, r2
2400697e:	d101      	bne.n	24006984 <DMA_CalcBaseAndBitshift+0xac>
24006980:	2301      	movs	r3, #1
24006982:	e000      	b.n	24006986 <DMA_CalcBaseAndBitshift+0xae>
24006984:	2300      	movs	r3, #0
24006986:	2b00      	cmp	r3, #0
24006988:	d024      	beq.n	240069d4 <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
2400698a:	687b      	ldr	r3, [r7, #4]
2400698c:	681b      	ldr	r3, [r3, #0]
2400698e:	b2db      	uxtb	r3, r3
24006990:	3b10      	subs	r3, #16
24006992:	4a27      	ldr	r2, [pc, #156]	; (24006a30 <DMA_CalcBaseAndBitshift+0x158>)
24006994:	fba2 2303 	umull	r2, r3, r2, r3
24006998:	091b      	lsrs	r3, r3, #4
2400699a:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
2400699c:	68fb      	ldr	r3, [r7, #12]
2400699e:	f003 0307 	and.w	r3, r3, #7
240069a2:	4a24      	ldr	r2, [pc, #144]	; (24006a34 <DMA_CalcBaseAndBitshift+0x15c>)
240069a4:	5cd3      	ldrb	r3, [r2, r3]
240069a6:	461a      	mov	r2, r3
240069a8:	687b      	ldr	r3, [r7, #4]
240069aa:	65da      	str	r2, [r3, #92]	; 0x5c

    if (stream_number > 3U)
240069ac:	68fb      	ldr	r3, [r7, #12]
240069ae:	2b03      	cmp	r3, #3
240069b0:	d908      	bls.n	240069c4 <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
240069b2:	687b      	ldr	r3, [r7, #4]
240069b4:	681b      	ldr	r3, [r3, #0]
240069b6:	461a      	mov	r2, r3
240069b8:	4b1f      	ldr	r3, [pc, #124]	; (24006a38 <DMA_CalcBaseAndBitshift+0x160>)
240069ba:	4013      	ands	r3, r2
240069bc:	1d1a      	adds	r2, r3, #4
240069be:	687b      	ldr	r3, [r7, #4]
240069c0:	659a      	str	r2, [r3, #88]	; 0x58
240069c2:	e00d      	b.n	240069e0 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
240069c4:	687b      	ldr	r3, [r7, #4]
240069c6:	681b      	ldr	r3, [r3, #0]
240069c8:	461a      	mov	r2, r3
240069ca:	4b1b      	ldr	r3, [pc, #108]	; (24006a38 <DMA_CalcBaseAndBitshift+0x160>)
240069cc:	4013      	ands	r3, r2
240069ce:	687a      	ldr	r2, [r7, #4]
240069d0:	6593      	str	r3, [r2, #88]	; 0x58
240069d2:	e005      	b.n	240069e0 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
240069d4:	687b      	ldr	r3, [r7, #4]
240069d6:	681b      	ldr	r3, [r3, #0]
240069d8:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
240069dc:	687b      	ldr	r3, [r7, #4]
240069de:	659a      	str	r2, [r3, #88]	; 0x58
  }

  return hdma->StreamBaseAddress;
240069e0:	687b      	ldr	r3, [r7, #4]
240069e2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
240069e4:	4618      	mov	r0, r3
240069e6:	3714      	adds	r7, #20
240069e8:	46bd      	mov	sp, r7
240069ea:	f85d 7b04 	ldr.w	r7, [sp], #4
240069ee:	4770      	bx	lr
240069f0:	40020010 	.word	0x40020010
240069f4:	40020028 	.word	0x40020028
240069f8:	40020040 	.word	0x40020040
240069fc:	40020058 	.word	0x40020058
24006a00:	40020070 	.word	0x40020070
24006a04:	40020088 	.word	0x40020088
24006a08:	400200a0 	.word	0x400200a0
24006a0c:	400200b8 	.word	0x400200b8
24006a10:	40020410 	.word	0x40020410
24006a14:	40020428 	.word	0x40020428
24006a18:	40020440 	.word	0x40020440
24006a1c:	40020458 	.word	0x40020458
24006a20:	40020470 	.word	0x40020470
24006a24:	40020488 	.word	0x40020488
24006a28:	400204a0 	.word	0x400204a0
24006a2c:	400204b8 	.word	0x400204b8
24006a30:	aaaaaaab 	.word	0xaaaaaaab
24006a34:	240178b4 	.word	0x240178b4
24006a38:	fffffc00 	.word	0xfffffc00

24006a3c <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
24006a3c:	b480      	push	{r7}
24006a3e:	b085      	sub	sp, #20
24006a40:	af00      	add	r7, sp, #0
24006a42:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24006a44:	2300      	movs	r3, #0
24006a46:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
24006a48:	687b      	ldr	r3, [r7, #4]
24006a4a:	699b      	ldr	r3, [r3, #24]
24006a4c:	2b00      	cmp	r3, #0
24006a4e:	d120      	bne.n	24006a92 <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
24006a50:	687b      	ldr	r3, [r7, #4]
24006a52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24006a54:	2b03      	cmp	r3, #3
24006a56:	d858      	bhi.n	24006b0a <DMA_CheckFifoParam+0xce>
24006a58:	a201      	add	r2, pc, #4	; (adr r2, 24006a60 <DMA_CheckFifoParam+0x24>)
24006a5a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24006a5e:	bf00      	nop
24006a60:	24006a71 	.word	0x24006a71
24006a64:	24006a83 	.word	0x24006a83
24006a68:	24006a71 	.word	0x24006a71
24006a6c:	24006b0b 	.word	0x24006b0b
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24006a70:	687b      	ldr	r3, [r7, #4]
24006a72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24006a74:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24006a78:	2b00      	cmp	r3, #0
24006a7a:	d048      	beq.n	24006b0e <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
24006a7c:	2301      	movs	r3, #1
24006a7e:	73fb      	strb	r3, [r7, #15]
        }
        break;
24006a80:	e045      	b.n	24006b0e <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
24006a82:	687b      	ldr	r3, [r7, #4]
24006a84:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24006a86:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
24006a8a:	d142      	bne.n	24006b12 <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
24006a8c:	2301      	movs	r3, #1
24006a8e:	73fb      	strb	r3, [r7, #15]
        }
        break;
24006a90:	e03f      	b.n	24006b12 <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
24006a92:	687b      	ldr	r3, [r7, #4]
24006a94:	699b      	ldr	r3, [r3, #24]
24006a96:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24006a9a:	d123      	bne.n	24006ae4 <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
24006a9c:	687b      	ldr	r3, [r7, #4]
24006a9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24006aa0:	2b03      	cmp	r3, #3
24006aa2:	d838      	bhi.n	24006b16 <DMA_CheckFifoParam+0xda>
24006aa4:	a201      	add	r2, pc, #4	; (adr r2, 24006aac <DMA_CheckFifoParam+0x70>)
24006aa6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24006aaa:	bf00      	nop
24006aac:	24006abd 	.word	0x24006abd
24006ab0:	24006ac3 	.word	0x24006ac3
24006ab4:	24006abd 	.word	0x24006abd
24006ab8:	24006ad5 	.word	0x24006ad5
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
24006abc:	2301      	movs	r3, #1
24006abe:	73fb      	strb	r3, [r7, #15]
        break;
24006ac0:	e030      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24006ac2:	687b      	ldr	r3, [r7, #4]
24006ac4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24006ac6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24006aca:	2b00      	cmp	r3, #0
24006acc:	d025      	beq.n	24006b1a <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
24006ace:	2301      	movs	r3, #1
24006ad0:	73fb      	strb	r3, [r7, #15]
        }
        break;
24006ad2:	e022      	b.n	24006b1a <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
24006ad4:	687b      	ldr	r3, [r7, #4]
24006ad6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24006ad8:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
24006adc:	d11f      	bne.n	24006b1e <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
24006ade:	2301      	movs	r3, #1
24006ae0:	73fb      	strb	r3, [r7, #15]
        }
        break;
24006ae2:	e01c      	b.n	24006b1e <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
24006ae4:	687b      	ldr	r3, [r7, #4]
24006ae6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24006ae8:	2b02      	cmp	r3, #2
24006aea:	d902      	bls.n	24006af2 <DMA_CheckFifoParam+0xb6>
24006aec:	2b03      	cmp	r3, #3
24006aee:	d003      	beq.n	24006af8 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
24006af0:	e018      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
24006af2:	2301      	movs	r3, #1
24006af4:	73fb      	strb	r3, [r7, #15]
        break;
24006af6:	e015      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
24006af8:	687b      	ldr	r3, [r7, #4]
24006afa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24006afc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
24006b00:	2b00      	cmp	r3, #0
24006b02:	d00e      	beq.n	24006b22 <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
24006b04:	2301      	movs	r3, #1
24006b06:	73fb      	strb	r3, [r7, #15]
    break;
24006b08:	e00b      	b.n	24006b22 <DMA_CheckFifoParam+0xe6>
        break;
24006b0a:	bf00      	nop
24006b0c:	e00a      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
        break;
24006b0e:	bf00      	nop
24006b10:	e008      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
        break;
24006b12:	bf00      	nop
24006b14:	e006      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
        break;
24006b16:	bf00      	nop
24006b18:	e004      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
        break;
24006b1a:	bf00      	nop
24006b1c:	e002      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
        break;
24006b1e:	bf00      	nop
24006b20:	e000      	b.n	24006b24 <DMA_CheckFifoParam+0xe8>
    break;
24006b22:	bf00      	nop
    }
  }

  return status;
24006b24:	7bfb      	ldrb	r3, [r7, #15]
}
24006b26:	4618      	mov	r0, r3
24006b28:	3714      	adds	r7, #20
24006b2a:	46bd      	mov	sp, r7
24006b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
24006b30:	4770      	bx	lr
24006b32:	bf00      	nop

24006b34 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
24006b34:	b480      	push	{r7}
24006b36:	b085      	sub	sp, #20
24006b38:	af00      	add	r7, sp, #0
24006b3a:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
24006b3c:	687b      	ldr	r3, [r7, #4]
24006b3e:	681b      	ldr	r3, [r3, #0]
24006b40:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24006b42:	687b      	ldr	r3, [r7, #4]
24006b44:	681b      	ldr	r3, [r3, #0]
24006b46:	4a38      	ldr	r2, [pc, #224]	; (24006c28 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
24006b48:	4293      	cmp	r3, r2
24006b4a:	d022      	beq.n	24006b92 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006b4c:	687b      	ldr	r3, [r7, #4]
24006b4e:	681b      	ldr	r3, [r3, #0]
24006b50:	4a36      	ldr	r2, [pc, #216]	; (24006c2c <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
24006b52:	4293      	cmp	r3, r2
24006b54:	d01d      	beq.n	24006b92 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006b56:	687b      	ldr	r3, [r7, #4]
24006b58:	681b      	ldr	r3, [r3, #0]
24006b5a:	4a35      	ldr	r2, [pc, #212]	; (24006c30 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
24006b5c:	4293      	cmp	r3, r2
24006b5e:	d018      	beq.n	24006b92 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006b60:	687b      	ldr	r3, [r7, #4]
24006b62:	681b      	ldr	r3, [r3, #0]
24006b64:	4a33      	ldr	r2, [pc, #204]	; (24006c34 <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
24006b66:	4293      	cmp	r3, r2
24006b68:	d013      	beq.n	24006b92 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006b6a:	687b      	ldr	r3, [r7, #4]
24006b6c:	681b      	ldr	r3, [r3, #0]
24006b6e:	4a32      	ldr	r2, [pc, #200]	; (24006c38 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
24006b70:	4293      	cmp	r3, r2
24006b72:	d00e      	beq.n	24006b92 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006b74:	687b      	ldr	r3, [r7, #4]
24006b76:	681b      	ldr	r3, [r3, #0]
24006b78:	4a30      	ldr	r2, [pc, #192]	; (24006c3c <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
24006b7a:	4293      	cmp	r3, r2
24006b7c:	d009      	beq.n	24006b92 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006b7e:	687b      	ldr	r3, [r7, #4]
24006b80:	681b      	ldr	r3, [r3, #0]
24006b82:	4a2f      	ldr	r2, [pc, #188]	; (24006c40 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
24006b84:	4293      	cmp	r3, r2
24006b86:	d004      	beq.n	24006b92 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
24006b88:	687b      	ldr	r3, [r7, #4]
24006b8a:	681b      	ldr	r3, [r3, #0]
24006b8c:	4a2d      	ldr	r2, [pc, #180]	; (24006c44 <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
24006b8e:	4293      	cmp	r3, r2
24006b90:	d101      	bne.n	24006b96 <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
24006b92:	2301      	movs	r3, #1
24006b94:	e000      	b.n	24006b98 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
24006b96:	2300      	movs	r3, #0
24006b98:	2b00      	cmp	r3, #0
24006b9a:	d01a      	beq.n	24006bd2 <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
24006b9c:	687b      	ldr	r3, [r7, #4]
24006b9e:	681b      	ldr	r3, [r3, #0]
24006ba0:	b2db      	uxtb	r3, r3
24006ba2:	3b08      	subs	r3, #8
24006ba4:	4a28      	ldr	r2, [pc, #160]	; (24006c48 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
24006ba6:	fba2 2303 	umull	r2, r3, r2, r3
24006baa:	091b      	lsrs	r3, r3, #4
24006bac:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
24006bae:	68fa      	ldr	r2, [r7, #12]
24006bb0:	4b26      	ldr	r3, [pc, #152]	; (24006c4c <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
24006bb2:	4413      	add	r3, r2
24006bb4:	009b      	lsls	r3, r3, #2
24006bb6:	461a      	mov	r2, r3
24006bb8:	687b      	ldr	r3, [r7, #4]
24006bba:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
24006bbc:	687b      	ldr	r3, [r7, #4]
24006bbe:	4a24      	ldr	r2, [pc, #144]	; (24006c50 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
24006bc0:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24006bc2:	68fb      	ldr	r3, [r7, #12]
24006bc4:	f003 031f 	and.w	r3, r3, #31
24006bc8:	2201      	movs	r2, #1
24006bca:	409a      	lsls	r2, r3
24006bcc:	687b      	ldr	r3, [r7, #4]
24006bce:	669a      	str	r2, [r3, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
24006bd0:	e024      	b.n	24006c1c <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
24006bd2:	687b      	ldr	r3, [r7, #4]
24006bd4:	681b      	ldr	r3, [r3, #0]
24006bd6:	b2db      	uxtb	r3, r3
24006bd8:	3b10      	subs	r3, #16
24006bda:	4a1e      	ldr	r2, [pc, #120]	; (24006c54 <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
24006bdc:	fba2 2303 	umull	r2, r3, r2, r3
24006be0:	091b      	lsrs	r3, r3, #4
24006be2:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
24006be4:	68bb      	ldr	r3, [r7, #8]
24006be6:	4a1c      	ldr	r2, [pc, #112]	; (24006c58 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
24006be8:	4293      	cmp	r3, r2
24006bea:	d806      	bhi.n	24006bfa <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
24006bec:	68bb      	ldr	r3, [r7, #8]
24006bee:	4a1b      	ldr	r2, [pc, #108]	; (24006c5c <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
24006bf0:	4293      	cmp	r3, r2
24006bf2:	d902      	bls.n	24006bfa <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
24006bf4:	68fb      	ldr	r3, [r7, #12]
24006bf6:	3308      	adds	r3, #8
24006bf8:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
24006bfa:	68fa      	ldr	r2, [r7, #12]
24006bfc:	4b18      	ldr	r3, [pc, #96]	; (24006c60 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
24006bfe:	4413      	add	r3, r2
24006c00:	009b      	lsls	r3, r3, #2
24006c02:	461a      	mov	r2, r3
24006c04:	687b      	ldr	r3, [r7, #4]
24006c06:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
24006c08:	687b      	ldr	r3, [r7, #4]
24006c0a:	4a16      	ldr	r2, [pc, #88]	; (24006c64 <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
24006c0c:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
24006c0e:	68fb      	ldr	r3, [r7, #12]
24006c10:	f003 031f 	and.w	r3, r3, #31
24006c14:	2201      	movs	r2, #1
24006c16:	409a      	lsls	r2, r3
24006c18:	687b      	ldr	r3, [r7, #4]
24006c1a:	669a      	str	r2, [r3, #104]	; 0x68
}
24006c1c:	bf00      	nop
24006c1e:	3714      	adds	r7, #20
24006c20:	46bd      	mov	sp, r7
24006c22:	f85d 7b04 	ldr.w	r7, [sp], #4
24006c26:	4770      	bx	lr
24006c28:	58025408 	.word	0x58025408
24006c2c:	5802541c 	.word	0x5802541c
24006c30:	58025430 	.word	0x58025430
24006c34:	58025444 	.word	0x58025444
24006c38:	58025458 	.word	0x58025458
24006c3c:	5802546c 	.word	0x5802546c
24006c40:	58025480 	.word	0x58025480
24006c44:	58025494 	.word	0x58025494
24006c48:	cccccccd 	.word	0xcccccccd
24006c4c:	16009600 	.word	0x16009600
24006c50:	58025880 	.word	0x58025880
24006c54:	aaaaaaab 	.word	0xaaaaaaab
24006c58:	400204b8 	.word	0x400204b8
24006c5c:	4002040f 	.word	0x4002040f
24006c60:	10008200 	.word	0x10008200
24006c64:	40020880 	.word	0x40020880

24006c68 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
24006c68:	b480      	push	{r7}
24006c6a:	b085      	sub	sp, #20
24006c6c:	af00      	add	r7, sp, #0
24006c6e:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
24006c70:	687b      	ldr	r3, [r7, #4]
24006c72:	685b      	ldr	r3, [r3, #4]
24006c74:	b2db      	uxtb	r3, r3
24006c76:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
24006c78:	68fb      	ldr	r3, [r7, #12]
24006c7a:	2b00      	cmp	r3, #0
24006c7c:	d04a      	beq.n	24006d14 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
24006c7e:	68fb      	ldr	r3, [r7, #12]
24006c80:	2b08      	cmp	r3, #8
24006c82:	d847      	bhi.n	24006d14 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
24006c84:	687b      	ldr	r3, [r7, #4]
24006c86:	681b      	ldr	r3, [r3, #0]
24006c88:	4a25      	ldr	r2, [pc, #148]	; (24006d20 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
24006c8a:	4293      	cmp	r3, r2
24006c8c:	d022      	beq.n	24006cd4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006c8e:	687b      	ldr	r3, [r7, #4]
24006c90:	681b      	ldr	r3, [r3, #0]
24006c92:	4a24      	ldr	r2, [pc, #144]	; (24006d24 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
24006c94:	4293      	cmp	r3, r2
24006c96:	d01d      	beq.n	24006cd4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006c98:	687b      	ldr	r3, [r7, #4]
24006c9a:	681b      	ldr	r3, [r3, #0]
24006c9c:	4a22      	ldr	r2, [pc, #136]	; (24006d28 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
24006c9e:	4293      	cmp	r3, r2
24006ca0:	d018      	beq.n	24006cd4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006ca2:	687b      	ldr	r3, [r7, #4]
24006ca4:	681b      	ldr	r3, [r3, #0]
24006ca6:	4a21      	ldr	r2, [pc, #132]	; (24006d2c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
24006ca8:	4293      	cmp	r3, r2
24006caa:	d013      	beq.n	24006cd4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006cac:	687b      	ldr	r3, [r7, #4]
24006cae:	681b      	ldr	r3, [r3, #0]
24006cb0:	4a1f      	ldr	r2, [pc, #124]	; (24006d30 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
24006cb2:	4293      	cmp	r3, r2
24006cb4:	d00e      	beq.n	24006cd4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006cb6:	687b      	ldr	r3, [r7, #4]
24006cb8:	681b      	ldr	r3, [r3, #0]
24006cba:	4a1e      	ldr	r2, [pc, #120]	; (24006d34 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
24006cbc:	4293      	cmp	r3, r2
24006cbe:	d009      	beq.n	24006cd4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006cc0:	687b      	ldr	r3, [r7, #4]
24006cc2:	681b      	ldr	r3, [r3, #0]
24006cc4:	4a1c      	ldr	r2, [pc, #112]	; (24006d38 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
24006cc6:	4293      	cmp	r3, r2
24006cc8:	d004      	beq.n	24006cd4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
24006cca:	687b      	ldr	r3, [r7, #4]
24006ccc:	681b      	ldr	r3, [r3, #0]
24006cce:	4a1b      	ldr	r2, [pc, #108]	; (24006d3c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
24006cd0:	4293      	cmp	r3, r2
24006cd2:	d101      	bne.n	24006cd8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
24006cd4:	2301      	movs	r3, #1
24006cd6:	e000      	b.n	24006cda <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
24006cd8:	2300      	movs	r3, #0
24006cda:	2b00      	cmp	r3, #0
24006cdc:	d00a      	beq.n	24006cf4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
24006cde:	68fa      	ldr	r2, [r7, #12]
24006ce0:	4b17      	ldr	r3, [pc, #92]	; (24006d40 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
24006ce2:	4413      	add	r3, r2
24006ce4:	009b      	lsls	r3, r3, #2
24006ce6:	461a      	mov	r2, r3
24006ce8:	687b      	ldr	r3, [r7, #4]
24006cea:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
24006cec:	687b      	ldr	r3, [r7, #4]
24006cee:	4a15      	ldr	r2, [pc, #84]	; (24006d44 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
24006cf0:	671a      	str	r2, [r3, #112]	; 0x70
24006cf2:	e009      	b.n	24006d08 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
24006cf4:	68fa      	ldr	r2, [r7, #12]
24006cf6:	4b14      	ldr	r3, [pc, #80]	; (24006d48 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
24006cf8:	4413      	add	r3, r2
24006cfa:	009b      	lsls	r3, r3, #2
24006cfc:	461a      	mov	r2, r3
24006cfe:	687b      	ldr	r3, [r7, #4]
24006d00:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
24006d02:	687b      	ldr	r3, [r7, #4]
24006d04:	4a11      	ldr	r2, [pc, #68]	; (24006d4c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
24006d06:	671a      	str	r2, [r3, #112]	; 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
24006d08:	68fb      	ldr	r3, [r7, #12]
24006d0a:	3b01      	subs	r3, #1
24006d0c:	2201      	movs	r2, #1
24006d0e:	409a      	lsls	r2, r3
24006d10:	687b      	ldr	r3, [r7, #4]
24006d12:	675a      	str	r2, [r3, #116]	; 0x74
  }
}
24006d14:	bf00      	nop
24006d16:	3714      	adds	r7, #20
24006d18:	46bd      	mov	sp, r7
24006d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
24006d1e:	4770      	bx	lr
24006d20:	58025408 	.word	0x58025408
24006d24:	5802541c 	.word	0x5802541c
24006d28:	58025430 	.word	0x58025430
24006d2c:	58025444 	.word	0x58025444
24006d30:	58025458 	.word	0x58025458
24006d34:	5802546c 	.word	0x5802546c
24006d38:	58025480 	.word	0x58025480
24006d3c:	58025494 	.word	0x58025494
24006d40:	1600963f 	.word	0x1600963f
24006d44:	58025940 	.word	0x58025940
24006d48:	1000823f 	.word	0x1000823f
24006d4c:	40020940 	.word	0x40020940

24006d50 <HAL_DMAEx_MultiBufferStart>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24006d50:	b580      	push	{r7, lr}
24006d52:	b086      	sub	sp, #24
24006d54:	af00      	add	r7, sp, #0
24006d56:	60f8      	str	r0, [r7, #12]
24006d58:	60b9      	str	r1, [r7, #8]
24006d5a:	607a      	str	r2, [r7, #4]
24006d5c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24006d5e:	2300      	movs	r3, #0
24006d60:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24006d62:	68fb      	ldr	r3, [r7, #12]
24006d64:	689b      	ldr	r3, [r3, #8]
24006d66:	2b80      	cmp	r3, #128	; 0x80
24006d68:	d106      	bne.n	24006d78 <HAL_DMAEx_MultiBufferStart+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
24006d6a:	68fb      	ldr	r3, [r7, #12]
24006d6c:	f44f 7280 	mov.w	r2, #256	; 0x100
24006d70:	655a      	str	r2, [r3, #84]	; 0x54
    status = HAL_ERROR;
24006d72:	2301      	movs	r3, #1
24006d74:	75fb      	strb	r3, [r7, #23]
24006d76:	e1c8      	b.n	2400710a <HAL_DMAEx_MultiBufferStart+0x3ba>
  }
  else
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
24006d78:	68fb      	ldr	r3, [r7, #12]
24006d7a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24006d7e:	2b01      	cmp	r3, #1
24006d80:	d101      	bne.n	24006d86 <HAL_DMAEx_MultiBufferStart+0x36>
24006d82:	2302      	movs	r3, #2
24006d84:	e1c2      	b.n	2400710c <HAL_DMAEx_MultiBufferStart+0x3bc>
24006d86:	68fb      	ldr	r3, [r7, #12]
24006d88:	2201      	movs	r2, #1
24006d8a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    if(HAL_DMA_STATE_READY == hdma->State)
24006d8e:	68fb      	ldr	r3, [r7, #12]
24006d90:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24006d94:	b2db      	uxtb	r3, r3
24006d96:	2b01      	cmp	r3, #1
24006d98:	f040 81b1 	bne.w	240070fe <HAL_DMAEx_MultiBufferStart+0x3ae>
    {
      /* Change DMA peripheral state */
      hdma->State = HAL_DMA_STATE_BUSY;
24006d9c:	68fb      	ldr	r3, [r7, #12]
24006d9e:	2202      	movs	r2, #2
24006da0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Initialize the error code */
      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
24006da4:	68fb      	ldr	r3, [r7, #12]
24006da6:	2200      	movs	r2, #0
24006da8:	655a      	str	r2, [r3, #84]	; 0x54

      if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24006daa:	68fb      	ldr	r3, [r7, #12]
24006dac:	681b      	ldr	r3, [r3, #0]
24006dae:	4a7f      	ldr	r2, [pc, #508]	; (24006fac <HAL_DMAEx_MultiBufferStart+0x25c>)
24006db0:	4293      	cmp	r3, r2
24006db2:	d04a      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006db4:	68fb      	ldr	r3, [r7, #12]
24006db6:	681b      	ldr	r3, [r3, #0]
24006db8:	4a7d      	ldr	r2, [pc, #500]	; (24006fb0 <HAL_DMAEx_MultiBufferStart+0x260>)
24006dba:	4293      	cmp	r3, r2
24006dbc:	d045      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006dbe:	68fb      	ldr	r3, [r7, #12]
24006dc0:	681b      	ldr	r3, [r3, #0]
24006dc2:	4a7c      	ldr	r2, [pc, #496]	; (24006fb4 <HAL_DMAEx_MultiBufferStart+0x264>)
24006dc4:	4293      	cmp	r3, r2
24006dc6:	d040      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006dc8:	68fb      	ldr	r3, [r7, #12]
24006dca:	681b      	ldr	r3, [r3, #0]
24006dcc:	4a7a      	ldr	r2, [pc, #488]	; (24006fb8 <HAL_DMAEx_MultiBufferStart+0x268>)
24006dce:	4293      	cmp	r3, r2
24006dd0:	d03b      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006dd2:	68fb      	ldr	r3, [r7, #12]
24006dd4:	681b      	ldr	r3, [r3, #0]
24006dd6:	4a79      	ldr	r2, [pc, #484]	; (24006fbc <HAL_DMAEx_MultiBufferStart+0x26c>)
24006dd8:	4293      	cmp	r3, r2
24006dda:	d036      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006ddc:	68fb      	ldr	r3, [r7, #12]
24006dde:	681b      	ldr	r3, [r3, #0]
24006de0:	4a77      	ldr	r2, [pc, #476]	; (24006fc0 <HAL_DMAEx_MultiBufferStart+0x270>)
24006de2:	4293      	cmp	r3, r2
24006de4:	d031      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006de6:	68fb      	ldr	r3, [r7, #12]
24006de8:	681b      	ldr	r3, [r3, #0]
24006dea:	4a76      	ldr	r2, [pc, #472]	; (24006fc4 <HAL_DMAEx_MultiBufferStart+0x274>)
24006dec:	4293      	cmp	r3, r2
24006dee:	d02c      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006df0:	68fb      	ldr	r3, [r7, #12]
24006df2:	681b      	ldr	r3, [r3, #0]
24006df4:	4a74      	ldr	r2, [pc, #464]	; (24006fc8 <HAL_DMAEx_MultiBufferStart+0x278>)
24006df6:	4293      	cmp	r3, r2
24006df8:	d027      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006dfa:	68fb      	ldr	r3, [r7, #12]
24006dfc:	681b      	ldr	r3, [r3, #0]
24006dfe:	4a73      	ldr	r2, [pc, #460]	; (24006fcc <HAL_DMAEx_MultiBufferStart+0x27c>)
24006e00:	4293      	cmp	r3, r2
24006e02:	d022      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006e04:	68fb      	ldr	r3, [r7, #12]
24006e06:	681b      	ldr	r3, [r3, #0]
24006e08:	4a71      	ldr	r2, [pc, #452]	; (24006fd0 <HAL_DMAEx_MultiBufferStart+0x280>)
24006e0a:	4293      	cmp	r3, r2
24006e0c:	d01d      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006e0e:	68fb      	ldr	r3, [r7, #12]
24006e10:	681b      	ldr	r3, [r3, #0]
24006e12:	4a70      	ldr	r2, [pc, #448]	; (24006fd4 <HAL_DMAEx_MultiBufferStart+0x284>)
24006e14:	4293      	cmp	r3, r2
24006e16:	d018      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006e18:	68fb      	ldr	r3, [r7, #12]
24006e1a:	681b      	ldr	r3, [r3, #0]
24006e1c:	4a6e      	ldr	r2, [pc, #440]	; (24006fd8 <HAL_DMAEx_MultiBufferStart+0x288>)
24006e1e:	4293      	cmp	r3, r2
24006e20:	d013      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006e22:	68fb      	ldr	r3, [r7, #12]
24006e24:	681b      	ldr	r3, [r3, #0]
24006e26:	4a6d      	ldr	r2, [pc, #436]	; (24006fdc <HAL_DMAEx_MultiBufferStart+0x28c>)
24006e28:	4293      	cmp	r3, r2
24006e2a:	d00e      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006e2c:	68fb      	ldr	r3, [r7, #12]
24006e2e:	681b      	ldr	r3, [r3, #0]
24006e30:	4a6b      	ldr	r2, [pc, #428]	; (24006fe0 <HAL_DMAEx_MultiBufferStart+0x290>)
24006e32:	4293      	cmp	r3, r2
24006e34:	d009      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006e36:	68fb      	ldr	r3, [r7, #12]
24006e38:	681b      	ldr	r3, [r3, #0]
24006e3a:	4a6a      	ldr	r2, [pc, #424]	; (24006fe4 <HAL_DMAEx_MultiBufferStart+0x294>)
24006e3c:	4293      	cmp	r3, r2
24006e3e:	d004      	beq.n	24006e4a <HAL_DMAEx_MultiBufferStart+0xfa>
24006e40:	68fb      	ldr	r3, [r7, #12]
24006e42:	681b      	ldr	r3, [r3, #0]
24006e44:	4a68      	ldr	r2, [pc, #416]	; (24006fe8 <HAL_DMAEx_MultiBufferStart+0x298>)
24006e46:	4293      	cmp	r3, r2
24006e48:	d101      	bne.n	24006e4e <HAL_DMAEx_MultiBufferStart+0xfe>
24006e4a:	2301      	movs	r3, #1
24006e4c:	e000      	b.n	24006e50 <HAL_DMAEx_MultiBufferStart+0x100>
24006e4e:	2300      	movs	r3, #0
24006e50:	2b00      	cmp	r3, #0
24006e52:	d018      	beq.n	24006e86 <HAL_DMAEx_MultiBufferStart+0x136>
      {
        /* Enable the Double buffer mode */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24006e54:	68fb      	ldr	r3, [r7, #12]
24006e56:	681b      	ldr	r3, [r3, #0]
24006e58:	681a      	ldr	r2, [r3, #0]
24006e5a:	68fb      	ldr	r3, [r7, #12]
24006e5c:	681b      	ldr	r3, [r3, #0]
24006e5e:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24006e62:	601a      	str	r2, [r3, #0]

        /* Configure DMA Stream destination address */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24006e64:	68fb      	ldr	r3, [r7, #12]
24006e66:	681b      	ldr	r3, [r3, #0]
24006e68:	683a      	ldr	r2, [r7, #0]
24006e6a:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
24006e6c:	68fb      	ldr	r3, [r7, #12]
24006e6e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006e70:	3308      	adds	r3, #8
24006e72:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24006e74:	68fb      	ldr	r3, [r7, #12]
24006e76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006e78:	f003 031f 	and.w	r3, r3, #31
24006e7c:	223f      	movs	r2, #63	; 0x3f
24006e7e:	409a      	lsls	r2, r3
24006e80:	693b      	ldr	r3, [r7, #16]
24006e82:	601a      	str	r2, [r3, #0]
24006e84:	e018      	b.n	24006eb8 <HAL_DMAEx_MultiBufferStart+0x168>
      }
      else /* BDMA instance(s) */
      {
        /* Enable the Double buffer mode */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24006e86:	68fb      	ldr	r3, [r7, #12]
24006e88:	681b      	ldr	r3, [r3, #0]
24006e8a:	6819      	ldr	r1, [r3, #0]
24006e8c:	68fb      	ldr	r3, [r7, #12]
24006e8e:	681a      	ldr	r2, [r3, #0]
24006e90:	f248 0320 	movw	r3, #32800	; 0x8020
24006e94:	430b      	orrs	r3, r1
24006e96:	6013      	str	r3, [r2, #0]

        /* Configure DMA Stream destination address */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
24006e98:	68fb      	ldr	r3, [r7, #12]
24006e9a:	681b      	ldr	r3, [r3, #0]
24006e9c:	683a      	ldr	r2, [r7, #0]
24006e9e:	611a      	str	r2, [r3, #16]

        /* Calculate the interrupt clear flag register (IFCR) base address  */
        ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
24006ea0:	68fb      	ldr	r3, [r7, #12]
24006ea2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24006ea4:	3304      	adds	r3, #4
24006ea6:	613b      	str	r3, [r7, #16]

        /* Clear all flags */
        *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
24006ea8:	68fb      	ldr	r3, [r7, #12]
24006eaa:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24006eac:	f003 031f 	and.w	r3, r3, #31
24006eb0:	2201      	movs	r2, #1
24006eb2:	409a      	lsls	r2, r3
24006eb4:	693b      	ldr	r3, [r7, #16]
24006eb6:	601a      	str	r2, [r3, #0]
      }

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
24006eb8:	68fb      	ldr	r3, [r7, #12]
24006eba:	681b      	ldr	r3, [r3, #0]
24006ebc:	4a3b      	ldr	r2, [pc, #236]	; (24006fac <HAL_DMAEx_MultiBufferStart+0x25c>)
24006ebe:	4293      	cmp	r3, r2
24006ec0:	d072      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006ec2:	68fb      	ldr	r3, [r7, #12]
24006ec4:	681b      	ldr	r3, [r3, #0]
24006ec6:	4a3a      	ldr	r2, [pc, #232]	; (24006fb0 <HAL_DMAEx_MultiBufferStart+0x260>)
24006ec8:	4293      	cmp	r3, r2
24006eca:	d06d      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006ecc:	68fb      	ldr	r3, [r7, #12]
24006ece:	681b      	ldr	r3, [r3, #0]
24006ed0:	4a38      	ldr	r2, [pc, #224]	; (24006fb4 <HAL_DMAEx_MultiBufferStart+0x264>)
24006ed2:	4293      	cmp	r3, r2
24006ed4:	d068      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006ed6:	68fb      	ldr	r3, [r7, #12]
24006ed8:	681b      	ldr	r3, [r3, #0]
24006eda:	4a37      	ldr	r2, [pc, #220]	; (24006fb8 <HAL_DMAEx_MultiBufferStart+0x268>)
24006edc:	4293      	cmp	r3, r2
24006ede:	d063      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006ee0:	68fb      	ldr	r3, [r7, #12]
24006ee2:	681b      	ldr	r3, [r3, #0]
24006ee4:	4a35      	ldr	r2, [pc, #212]	; (24006fbc <HAL_DMAEx_MultiBufferStart+0x26c>)
24006ee6:	4293      	cmp	r3, r2
24006ee8:	d05e      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006eea:	68fb      	ldr	r3, [r7, #12]
24006eec:	681b      	ldr	r3, [r3, #0]
24006eee:	4a34      	ldr	r2, [pc, #208]	; (24006fc0 <HAL_DMAEx_MultiBufferStart+0x270>)
24006ef0:	4293      	cmp	r3, r2
24006ef2:	d059      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006ef4:	68fb      	ldr	r3, [r7, #12]
24006ef6:	681b      	ldr	r3, [r3, #0]
24006ef8:	4a32      	ldr	r2, [pc, #200]	; (24006fc4 <HAL_DMAEx_MultiBufferStart+0x274>)
24006efa:	4293      	cmp	r3, r2
24006efc:	d054      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006efe:	68fb      	ldr	r3, [r7, #12]
24006f00:	681b      	ldr	r3, [r3, #0]
24006f02:	4a31      	ldr	r2, [pc, #196]	; (24006fc8 <HAL_DMAEx_MultiBufferStart+0x278>)
24006f04:	4293      	cmp	r3, r2
24006f06:	d04f      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f08:	68fb      	ldr	r3, [r7, #12]
24006f0a:	681b      	ldr	r3, [r3, #0]
24006f0c:	4a2f      	ldr	r2, [pc, #188]	; (24006fcc <HAL_DMAEx_MultiBufferStart+0x27c>)
24006f0e:	4293      	cmp	r3, r2
24006f10:	d04a      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f12:	68fb      	ldr	r3, [r7, #12]
24006f14:	681b      	ldr	r3, [r3, #0]
24006f16:	4a2e      	ldr	r2, [pc, #184]	; (24006fd0 <HAL_DMAEx_MultiBufferStart+0x280>)
24006f18:	4293      	cmp	r3, r2
24006f1a:	d045      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f1c:	68fb      	ldr	r3, [r7, #12]
24006f1e:	681b      	ldr	r3, [r3, #0]
24006f20:	4a2c      	ldr	r2, [pc, #176]	; (24006fd4 <HAL_DMAEx_MultiBufferStart+0x284>)
24006f22:	4293      	cmp	r3, r2
24006f24:	d040      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f26:	68fb      	ldr	r3, [r7, #12]
24006f28:	681b      	ldr	r3, [r3, #0]
24006f2a:	4a2b      	ldr	r2, [pc, #172]	; (24006fd8 <HAL_DMAEx_MultiBufferStart+0x288>)
24006f2c:	4293      	cmp	r3, r2
24006f2e:	d03b      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f30:	68fb      	ldr	r3, [r7, #12]
24006f32:	681b      	ldr	r3, [r3, #0]
24006f34:	4a29      	ldr	r2, [pc, #164]	; (24006fdc <HAL_DMAEx_MultiBufferStart+0x28c>)
24006f36:	4293      	cmp	r3, r2
24006f38:	d036      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f3a:	68fb      	ldr	r3, [r7, #12]
24006f3c:	681b      	ldr	r3, [r3, #0]
24006f3e:	4a28      	ldr	r2, [pc, #160]	; (24006fe0 <HAL_DMAEx_MultiBufferStart+0x290>)
24006f40:	4293      	cmp	r3, r2
24006f42:	d031      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f44:	68fb      	ldr	r3, [r7, #12]
24006f46:	681b      	ldr	r3, [r3, #0]
24006f48:	4a26      	ldr	r2, [pc, #152]	; (24006fe4 <HAL_DMAEx_MultiBufferStart+0x294>)
24006f4a:	4293      	cmp	r3, r2
24006f4c:	d02c      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f4e:	68fb      	ldr	r3, [r7, #12]
24006f50:	681b      	ldr	r3, [r3, #0]
24006f52:	4a25      	ldr	r2, [pc, #148]	; (24006fe8 <HAL_DMAEx_MultiBufferStart+0x298>)
24006f54:	4293      	cmp	r3, r2
24006f56:	d027      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f58:	68fb      	ldr	r3, [r7, #12]
24006f5a:	681b      	ldr	r3, [r3, #0]
24006f5c:	4a23      	ldr	r2, [pc, #140]	; (24006fec <HAL_DMAEx_MultiBufferStart+0x29c>)
24006f5e:	4293      	cmp	r3, r2
24006f60:	d022      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f62:	68fb      	ldr	r3, [r7, #12]
24006f64:	681b      	ldr	r3, [r3, #0]
24006f66:	4a22      	ldr	r2, [pc, #136]	; (24006ff0 <HAL_DMAEx_MultiBufferStart+0x2a0>)
24006f68:	4293      	cmp	r3, r2
24006f6a:	d01d      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f6c:	68fb      	ldr	r3, [r7, #12]
24006f6e:	681b      	ldr	r3, [r3, #0]
24006f70:	4a20      	ldr	r2, [pc, #128]	; (24006ff4 <HAL_DMAEx_MultiBufferStart+0x2a4>)
24006f72:	4293      	cmp	r3, r2
24006f74:	d018      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f76:	68fb      	ldr	r3, [r7, #12]
24006f78:	681b      	ldr	r3, [r3, #0]
24006f7a:	4a1f      	ldr	r2, [pc, #124]	; (24006ff8 <HAL_DMAEx_MultiBufferStart+0x2a8>)
24006f7c:	4293      	cmp	r3, r2
24006f7e:	d013      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f80:	68fb      	ldr	r3, [r7, #12]
24006f82:	681b      	ldr	r3, [r3, #0]
24006f84:	4a1d      	ldr	r2, [pc, #116]	; (24006ffc <HAL_DMAEx_MultiBufferStart+0x2ac>)
24006f86:	4293      	cmp	r3, r2
24006f88:	d00e      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f8a:	68fb      	ldr	r3, [r7, #12]
24006f8c:	681b      	ldr	r3, [r3, #0]
24006f8e:	4a1c      	ldr	r2, [pc, #112]	; (24007000 <HAL_DMAEx_MultiBufferStart+0x2b0>)
24006f90:	4293      	cmp	r3, r2
24006f92:	d009      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f94:	68fb      	ldr	r3, [r7, #12]
24006f96:	681b      	ldr	r3, [r3, #0]
24006f98:	4a1a      	ldr	r2, [pc, #104]	; (24007004 <HAL_DMAEx_MultiBufferStart+0x2b4>)
24006f9a:	4293      	cmp	r3, r2
24006f9c:	d004      	beq.n	24006fa8 <HAL_DMAEx_MultiBufferStart+0x258>
24006f9e:	68fb      	ldr	r3, [r7, #12]
24006fa0:	681b      	ldr	r3, [r3, #0]
24006fa2:	4a19      	ldr	r2, [pc, #100]	; (24007008 <HAL_DMAEx_MultiBufferStart+0x2b8>)
24006fa4:	4293      	cmp	r3, r2
24006fa6:	d131      	bne.n	2400700c <HAL_DMAEx_MultiBufferStart+0x2bc>
24006fa8:	2301      	movs	r3, #1
24006faa:	e030      	b.n	2400700e <HAL_DMAEx_MultiBufferStart+0x2be>
24006fac:	40020010 	.word	0x40020010
24006fb0:	40020028 	.word	0x40020028
24006fb4:	40020040 	.word	0x40020040
24006fb8:	40020058 	.word	0x40020058
24006fbc:	40020070 	.word	0x40020070
24006fc0:	40020088 	.word	0x40020088
24006fc4:	400200a0 	.word	0x400200a0
24006fc8:	400200b8 	.word	0x400200b8
24006fcc:	40020410 	.word	0x40020410
24006fd0:	40020428 	.word	0x40020428
24006fd4:	40020440 	.word	0x40020440
24006fd8:	40020458 	.word	0x40020458
24006fdc:	40020470 	.word	0x40020470
24006fe0:	40020488 	.word	0x40020488
24006fe4:	400204a0 	.word	0x400204a0
24006fe8:	400204b8 	.word	0x400204b8
24006fec:	58025408 	.word	0x58025408
24006ff0:	5802541c 	.word	0x5802541c
24006ff4:	58025430 	.word	0x58025430
24006ff8:	58025444 	.word	0x58025444
24006ffc:	58025458 	.word	0x58025458
24007000:	5802546c 	.word	0x5802546c
24007004:	58025480 	.word	0x58025480
24007008:	58025494 	.word	0x58025494
2400700c:	2300      	movs	r3, #0
2400700e:	2b00      	cmp	r3, #0
24007010:	d013      	beq.n	2400703a <HAL_DMAEx_MultiBufferStart+0x2ea>
      {
        /* Configure the source, destination address and the data length */
        DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
24007012:	6a3b      	ldr	r3, [r7, #32]
24007014:	687a      	ldr	r2, [r7, #4]
24007016:	68b9      	ldr	r1, [r7, #8]
24007018:	68f8      	ldr	r0, [r7, #12]
2400701a:	f000 fea3 	bl	24007d64 <DMA_MultiBufferSetConfig>

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
2400701e:	68fb      	ldr	r3, [r7, #12]
24007020:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24007022:	68fa      	ldr	r2, [r7, #12]
24007024:	6e92      	ldr	r2, [r2, #104]	; 0x68
24007026:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
24007028:	68fb      	ldr	r3, [r7, #12]
2400702a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
2400702c:	2b00      	cmp	r3, #0
2400702e:	d004      	beq.n	2400703a <HAL_DMAEx_MultiBufferStart+0x2ea>
        {
          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24007030:	68fb      	ldr	r3, [r7, #12]
24007032:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24007034:	68fa      	ldr	r2, [r7, #12]
24007036:	6f52      	ldr	r2, [r2, #116]	; 0x74
24007038:	605a      	str	r2, [r3, #4]
        }
      }

      /* Enable the peripheral */
      __HAL_DMA_ENABLE(hdma);
2400703a:	68fb      	ldr	r3, [r7, #12]
2400703c:	681b      	ldr	r3, [r3, #0]
2400703e:	4a35      	ldr	r2, [pc, #212]	; (24007114 <HAL_DMAEx_MultiBufferStart+0x3c4>)
24007040:	4293      	cmp	r3, r2
24007042:	d04a      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
24007044:	68fb      	ldr	r3, [r7, #12]
24007046:	681b      	ldr	r3, [r3, #0]
24007048:	4a33      	ldr	r2, [pc, #204]	; (24007118 <HAL_DMAEx_MultiBufferStart+0x3c8>)
2400704a:	4293      	cmp	r3, r2
2400704c:	d045      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
2400704e:	68fb      	ldr	r3, [r7, #12]
24007050:	681b      	ldr	r3, [r3, #0]
24007052:	4a32      	ldr	r2, [pc, #200]	; (2400711c <HAL_DMAEx_MultiBufferStart+0x3cc>)
24007054:	4293      	cmp	r3, r2
24007056:	d040      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
24007058:	68fb      	ldr	r3, [r7, #12]
2400705a:	681b      	ldr	r3, [r3, #0]
2400705c:	4a30      	ldr	r2, [pc, #192]	; (24007120 <HAL_DMAEx_MultiBufferStart+0x3d0>)
2400705e:	4293      	cmp	r3, r2
24007060:	d03b      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
24007062:	68fb      	ldr	r3, [r7, #12]
24007064:	681b      	ldr	r3, [r3, #0]
24007066:	4a2f      	ldr	r2, [pc, #188]	; (24007124 <HAL_DMAEx_MultiBufferStart+0x3d4>)
24007068:	4293      	cmp	r3, r2
2400706a:	d036      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
2400706c:	68fb      	ldr	r3, [r7, #12]
2400706e:	681b      	ldr	r3, [r3, #0]
24007070:	4a2d      	ldr	r2, [pc, #180]	; (24007128 <HAL_DMAEx_MultiBufferStart+0x3d8>)
24007072:	4293      	cmp	r3, r2
24007074:	d031      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
24007076:	68fb      	ldr	r3, [r7, #12]
24007078:	681b      	ldr	r3, [r3, #0]
2400707a:	4a2c      	ldr	r2, [pc, #176]	; (2400712c <HAL_DMAEx_MultiBufferStart+0x3dc>)
2400707c:	4293      	cmp	r3, r2
2400707e:	d02c      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
24007080:	68fb      	ldr	r3, [r7, #12]
24007082:	681b      	ldr	r3, [r3, #0]
24007084:	4a2a      	ldr	r2, [pc, #168]	; (24007130 <HAL_DMAEx_MultiBufferStart+0x3e0>)
24007086:	4293      	cmp	r3, r2
24007088:	d027      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
2400708a:	68fb      	ldr	r3, [r7, #12]
2400708c:	681b      	ldr	r3, [r3, #0]
2400708e:	4a29      	ldr	r2, [pc, #164]	; (24007134 <HAL_DMAEx_MultiBufferStart+0x3e4>)
24007090:	4293      	cmp	r3, r2
24007092:	d022      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
24007094:	68fb      	ldr	r3, [r7, #12]
24007096:	681b      	ldr	r3, [r3, #0]
24007098:	4a27      	ldr	r2, [pc, #156]	; (24007138 <HAL_DMAEx_MultiBufferStart+0x3e8>)
2400709a:	4293      	cmp	r3, r2
2400709c:	d01d      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
2400709e:	68fb      	ldr	r3, [r7, #12]
240070a0:	681b      	ldr	r3, [r3, #0]
240070a2:	4a26      	ldr	r2, [pc, #152]	; (2400713c <HAL_DMAEx_MultiBufferStart+0x3ec>)
240070a4:	4293      	cmp	r3, r2
240070a6:	d018      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
240070a8:	68fb      	ldr	r3, [r7, #12]
240070aa:	681b      	ldr	r3, [r3, #0]
240070ac:	4a24      	ldr	r2, [pc, #144]	; (24007140 <HAL_DMAEx_MultiBufferStart+0x3f0>)
240070ae:	4293      	cmp	r3, r2
240070b0:	d013      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
240070b2:	68fb      	ldr	r3, [r7, #12]
240070b4:	681b      	ldr	r3, [r3, #0]
240070b6:	4a23      	ldr	r2, [pc, #140]	; (24007144 <HAL_DMAEx_MultiBufferStart+0x3f4>)
240070b8:	4293      	cmp	r3, r2
240070ba:	d00e      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
240070bc:	68fb      	ldr	r3, [r7, #12]
240070be:	681b      	ldr	r3, [r3, #0]
240070c0:	4a21      	ldr	r2, [pc, #132]	; (24007148 <HAL_DMAEx_MultiBufferStart+0x3f8>)
240070c2:	4293      	cmp	r3, r2
240070c4:	d009      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
240070c6:	68fb      	ldr	r3, [r7, #12]
240070c8:	681b      	ldr	r3, [r3, #0]
240070ca:	4a20      	ldr	r2, [pc, #128]	; (2400714c <HAL_DMAEx_MultiBufferStart+0x3fc>)
240070cc:	4293      	cmp	r3, r2
240070ce:	d004      	beq.n	240070da <HAL_DMAEx_MultiBufferStart+0x38a>
240070d0:	68fb      	ldr	r3, [r7, #12]
240070d2:	681b      	ldr	r3, [r3, #0]
240070d4:	4a1e      	ldr	r2, [pc, #120]	; (24007150 <HAL_DMAEx_MultiBufferStart+0x400>)
240070d6:	4293      	cmp	r3, r2
240070d8:	d108      	bne.n	240070ec <HAL_DMAEx_MultiBufferStart+0x39c>
240070da:	68fb      	ldr	r3, [r7, #12]
240070dc:	681b      	ldr	r3, [r3, #0]
240070de:	681a      	ldr	r2, [r3, #0]
240070e0:	68fb      	ldr	r3, [r7, #12]
240070e2:	681b      	ldr	r3, [r3, #0]
240070e4:	f042 0201 	orr.w	r2, r2, #1
240070e8:	601a      	str	r2, [r3, #0]
240070ea:	e00e      	b.n	2400710a <HAL_DMAEx_MultiBufferStart+0x3ba>
240070ec:	68fb      	ldr	r3, [r7, #12]
240070ee:	681b      	ldr	r3, [r3, #0]
240070f0:	681a      	ldr	r2, [r3, #0]
240070f2:	68fb      	ldr	r3, [r7, #12]
240070f4:	681b      	ldr	r3, [r3, #0]
240070f6:	f042 0201 	orr.w	r2, r2, #1
240070fa:	601a      	str	r2, [r3, #0]
240070fc:	e005      	b.n	2400710a <HAL_DMAEx_MultiBufferStart+0x3ba>
    }
    else
    {
      /* Set the error code to busy */
      hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
240070fe:	68fb      	ldr	r3, [r7, #12]
24007100:	f44f 6200 	mov.w	r2, #2048	; 0x800
24007104:	655a      	str	r2, [r3, #84]	; 0x54

      /* Return error status */
      status = HAL_ERROR;
24007106:	2301      	movs	r3, #1
24007108:	75fb      	strb	r3, [r7, #23]
    }
  }
  return status;
2400710a:	7dfb      	ldrb	r3, [r7, #23]
}
2400710c:	4618      	mov	r0, r3
2400710e:	3718      	adds	r7, #24
24007110:	46bd      	mov	sp, r7
24007112:	bd80      	pop	{r7, pc}
24007114:	40020010 	.word	0x40020010
24007118:	40020028 	.word	0x40020028
2400711c:	40020040 	.word	0x40020040
24007120:	40020058 	.word	0x40020058
24007124:	40020070 	.word	0x40020070
24007128:	40020088 	.word	0x40020088
2400712c:	400200a0 	.word	0x400200a0
24007130:	400200b8 	.word	0x400200b8
24007134:	40020410 	.word	0x40020410
24007138:	40020428 	.word	0x40020428
2400713c:	40020440 	.word	0x40020440
24007140:	40020458 	.word	0x40020458
24007144:	40020470 	.word	0x40020470
24007148:	40020488 	.word	0x40020488
2400714c:	400204a0 	.word	0x400204a0
24007150:	400204b8 	.word	0x400204b8

24007154 <HAL_DMAEx_MultiBufferStart_IT>:
  * @param  SecondMemAddress: The second memory Buffer address in case of multi buffer Transfer
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength)
{
24007154:	b580      	push	{r7, lr}
24007156:	b086      	sub	sp, #24
24007158:	af00      	add	r7, sp, #0
2400715a:	60f8      	str	r0, [r7, #12]
2400715c:	60b9      	str	r1, [r7, #8]
2400715e:	607a      	str	r2, [r7, #4]
24007160:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24007162:	2300      	movs	r3, #0
24007164:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));

  /* Memory-to-memory transfer not supported in double buffering mode */
  if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
24007166:	68fb      	ldr	r3, [r7, #12]
24007168:	689b      	ldr	r3, [r3, #8]
2400716a:	2b80      	cmp	r3, #128	; 0x80
2400716c:	d105      	bne.n	2400717a <HAL_DMAEx_MultiBufferStart_IT+0x26>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
2400716e:	68fb      	ldr	r3, [r7, #12]
24007170:	f44f 7280 	mov.w	r2, #256	; 0x100
24007174:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
24007176:	2301      	movs	r3, #1
24007178:	e315      	b.n	240077a6 <HAL_DMAEx_MultiBufferStart_IT+0x652>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
2400717a:	68fb      	ldr	r3, [r7, #12]
2400717c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24007180:	2b01      	cmp	r3, #1
24007182:	d101      	bne.n	24007188 <HAL_DMAEx_MultiBufferStart_IT+0x34>
24007184:	2302      	movs	r3, #2
24007186:	e30e      	b.n	240077a6 <HAL_DMAEx_MultiBufferStart_IT+0x652>
24007188:	68fb      	ldr	r3, [r7, #12]
2400718a:	2201      	movs	r2, #1
2400718c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
24007190:	68fb      	ldr	r3, [r7, #12]
24007192:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24007196:	b2db      	uxtb	r3, r3
24007198:	2b01      	cmp	r3, #1
2400719a:	f040 82fd 	bne.w	24007798 <HAL_DMAEx_MultiBufferStart_IT+0x644>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
2400719e:	68fb      	ldr	r3, [r7, #12]
240071a0:	2202      	movs	r2, #2
240071a2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
240071a6:	68fb      	ldr	r3, [r7, #12]
240071a8:	2200      	movs	r2, #0
240071aa:	655a      	str	r2, [r3, #84]	; 0x54

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
240071ac:	68fb      	ldr	r3, [r7, #12]
240071ae:	681b      	ldr	r3, [r3, #0]
240071b0:	4a82      	ldr	r2, [pc, #520]	; (240073bc <HAL_DMAEx_MultiBufferStart_IT+0x268>)
240071b2:	4293      	cmp	r3, r2
240071b4:	d04a      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071b6:	68fb      	ldr	r3, [r7, #12]
240071b8:	681b      	ldr	r3, [r3, #0]
240071ba:	4a81      	ldr	r2, [pc, #516]	; (240073c0 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
240071bc:	4293      	cmp	r3, r2
240071be:	d045      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071c0:	68fb      	ldr	r3, [r7, #12]
240071c2:	681b      	ldr	r3, [r3, #0]
240071c4:	4a7f      	ldr	r2, [pc, #508]	; (240073c4 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
240071c6:	4293      	cmp	r3, r2
240071c8:	d040      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071ca:	68fb      	ldr	r3, [r7, #12]
240071cc:	681b      	ldr	r3, [r3, #0]
240071ce:	4a7e      	ldr	r2, [pc, #504]	; (240073c8 <HAL_DMAEx_MultiBufferStart_IT+0x274>)
240071d0:	4293      	cmp	r3, r2
240071d2:	d03b      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071d4:	68fb      	ldr	r3, [r7, #12]
240071d6:	681b      	ldr	r3, [r3, #0]
240071d8:	4a7c      	ldr	r2, [pc, #496]	; (240073cc <HAL_DMAEx_MultiBufferStart_IT+0x278>)
240071da:	4293      	cmp	r3, r2
240071dc:	d036      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071de:	68fb      	ldr	r3, [r7, #12]
240071e0:	681b      	ldr	r3, [r3, #0]
240071e2:	4a7b      	ldr	r2, [pc, #492]	; (240073d0 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
240071e4:	4293      	cmp	r3, r2
240071e6:	d031      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071e8:	68fb      	ldr	r3, [r7, #12]
240071ea:	681b      	ldr	r3, [r3, #0]
240071ec:	4a79      	ldr	r2, [pc, #484]	; (240073d4 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
240071ee:	4293      	cmp	r3, r2
240071f0:	d02c      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071f2:	68fb      	ldr	r3, [r7, #12]
240071f4:	681b      	ldr	r3, [r3, #0]
240071f6:	4a78      	ldr	r2, [pc, #480]	; (240073d8 <HAL_DMAEx_MultiBufferStart_IT+0x284>)
240071f8:	4293      	cmp	r3, r2
240071fa:	d027      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
240071fc:	68fb      	ldr	r3, [r7, #12]
240071fe:	681b      	ldr	r3, [r3, #0]
24007200:	4a76      	ldr	r2, [pc, #472]	; (240073dc <HAL_DMAEx_MultiBufferStart_IT+0x288>)
24007202:	4293      	cmp	r3, r2
24007204:	d022      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24007206:	68fb      	ldr	r3, [r7, #12]
24007208:	681b      	ldr	r3, [r3, #0]
2400720a:	4a75      	ldr	r2, [pc, #468]	; (240073e0 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
2400720c:	4293      	cmp	r3, r2
2400720e:	d01d      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24007210:	68fb      	ldr	r3, [r7, #12]
24007212:	681b      	ldr	r3, [r3, #0]
24007214:	4a73      	ldr	r2, [pc, #460]	; (240073e4 <HAL_DMAEx_MultiBufferStart_IT+0x290>)
24007216:	4293      	cmp	r3, r2
24007218:	d018      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
2400721a:	68fb      	ldr	r3, [r7, #12]
2400721c:	681b      	ldr	r3, [r3, #0]
2400721e:	4a72      	ldr	r2, [pc, #456]	; (240073e8 <HAL_DMAEx_MultiBufferStart_IT+0x294>)
24007220:	4293      	cmp	r3, r2
24007222:	d013      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24007224:	68fb      	ldr	r3, [r7, #12]
24007226:	681b      	ldr	r3, [r3, #0]
24007228:	4a70      	ldr	r2, [pc, #448]	; (240073ec <HAL_DMAEx_MultiBufferStart_IT+0x298>)
2400722a:	4293      	cmp	r3, r2
2400722c:	d00e      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
2400722e:	68fb      	ldr	r3, [r7, #12]
24007230:	681b      	ldr	r3, [r3, #0]
24007232:	4a6f      	ldr	r2, [pc, #444]	; (240073f0 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
24007234:	4293      	cmp	r3, r2
24007236:	d009      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24007238:	68fb      	ldr	r3, [r7, #12]
2400723a:	681b      	ldr	r3, [r3, #0]
2400723c:	4a6d      	ldr	r2, [pc, #436]	; (240073f4 <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
2400723e:	4293      	cmp	r3, r2
24007240:	d004      	beq.n	2400724c <HAL_DMAEx_MultiBufferStart_IT+0xf8>
24007242:	68fb      	ldr	r3, [r7, #12]
24007244:	681b      	ldr	r3, [r3, #0]
24007246:	4a6c      	ldr	r2, [pc, #432]	; (240073f8 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
24007248:	4293      	cmp	r3, r2
2400724a:	d101      	bne.n	24007250 <HAL_DMAEx_MultiBufferStart_IT+0xfc>
2400724c:	2301      	movs	r3, #1
2400724e:	e000      	b.n	24007252 <HAL_DMAEx_MultiBufferStart_IT+0xfe>
24007250:	2300      	movs	r3, #0
24007252:	2b00      	cmp	r3, #0
24007254:	d018      	beq.n	24007288 <HAL_DMAEx_MultiBufferStart_IT+0x134>
    {
      /* Enable the Double buffer mode */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR |= DMA_SxCR_DBM;
24007256:	68fb      	ldr	r3, [r7, #12]
24007258:	681b      	ldr	r3, [r3, #0]
2400725a:	681a      	ldr	r2, [r3, #0]
2400725c:	68fb      	ldr	r3, [r7, #12]
2400725e:	681b      	ldr	r3, [r3, #0]
24007260:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
24007264:	601a      	str	r2, [r3, #0]

      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = SecondMemAddress;
24007266:	68fb      	ldr	r3, [r7, #12]
24007268:	681b      	ldr	r3, [r3, #0]
2400726a:	683a      	ldr	r2, [r7, #0]
2400726c:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 8U));
2400726e:	68fb      	ldr	r3, [r7, #12]
24007270:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24007272:	3308      	adds	r3, #8
24007274:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = 0x3FUL << (hdma->StreamIndex & 0x1FU);
24007276:	68fb      	ldr	r3, [r7, #12]
24007278:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400727a:	f003 031f 	and.w	r3, r3, #31
2400727e:	223f      	movs	r2, #63	; 0x3f
24007280:	409a      	lsls	r2, r3
24007282:	693b      	ldr	r3, [r7, #16]
24007284:	601a      	str	r2, [r3, #0]
24007286:	e018      	b.n	240072ba <HAL_DMAEx_MultiBufferStart_IT+0x166>
    }
    else /* BDMA instance(s) */
    {
      /* Enable the Double buffer mode */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR |= (BDMA_CCR_DBM | BDMA_CCR_CIRC);
24007288:	68fb      	ldr	r3, [r7, #12]
2400728a:	681b      	ldr	r3, [r3, #0]
2400728c:	6819      	ldr	r1, [r3, #0]
2400728e:	68fb      	ldr	r3, [r7, #12]
24007290:	681a      	ldr	r2, [r3, #0]
24007292:	f248 0320 	movw	r3, #32800	; 0x8020
24007296:	430b      	orrs	r3, r1
24007298:	6013      	str	r3, [r2, #0]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = SecondMemAddress;
2400729a:	68fb      	ldr	r3, [r7, #12]
2400729c:	681b      	ldr	r3, [r3, #0]
2400729e:	683a      	ldr	r2, [r7, #0]
240072a0:	611a      	str	r2, [r3, #16]

      /* Calculate the interrupt clear flag register (IFCR) base address  */
      ifcRegister_Base = (uint32_t *)((uint32_t)(hdma->StreamBaseAddress + 4U));
240072a2:	68fb      	ldr	r3, [r7, #12]
240072a4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240072a6:	3304      	adds	r3, #4
240072a8:	613b      	str	r3, [r7, #16]

      /* Clear all flags */
      *ifcRegister_Base = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
240072aa:	68fb      	ldr	r3, [r7, #12]
240072ac:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
240072ae:	f003 031f 	and.w	r3, r3, #31
240072b2:	2201      	movs	r2, #1
240072b4:	409a      	lsls	r2, r3
240072b6:	693b      	ldr	r3, [r7, #16]
240072b8:	601a      	str	r2, [r3, #0]
    }

    /* Configure the source, destination address and the data length */
    DMA_MultiBufferSetConfig(hdma, SrcAddress, DstAddress, DataLength);
240072ba:	6a3b      	ldr	r3, [r7, #32]
240072bc:	687a      	ldr	r2, [r7, #4]
240072be:	68b9      	ldr	r1, [r7, #8]
240072c0:	68f8      	ldr	r0, [r7, #12]
240072c2:	f000 fd4f 	bl	24007d64 <DMA_MultiBufferSetConfig>

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240072c6:	68fb      	ldr	r3, [r7, #12]
240072c8:	681b      	ldr	r3, [r3, #0]
240072ca:	4a3c      	ldr	r2, [pc, #240]	; (240073bc <HAL_DMAEx_MultiBufferStart_IT+0x268>)
240072cc:	4293      	cmp	r3, r2
240072ce:	d072      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240072d0:	68fb      	ldr	r3, [r7, #12]
240072d2:	681b      	ldr	r3, [r3, #0]
240072d4:	4a3a      	ldr	r2, [pc, #232]	; (240073c0 <HAL_DMAEx_MultiBufferStart_IT+0x26c>)
240072d6:	4293      	cmp	r3, r2
240072d8:	d06d      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240072da:	68fb      	ldr	r3, [r7, #12]
240072dc:	681b      	ldr	r3, [r3, #0]
240072de:	4a39      	ldr	r2, [pc, #228]	; (240073c4 <HAL_DMAEx_MultiBufferStart_IT+0x270>)
240072e0:	4293      	cmp	r3, r2
240072e2:	d068      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240072e4:	68fb      	ldr	r3, [r7, #12]
240072e6:	681b      	ldr	r3, [r3, #0]
240072e8:	4a37      	ldr	r2, [pc, #220]	; (240073c8 <HAL_DMAEx_MultiBufferStart_IT+0x274>)
240072ea:	4293      	cmp	r3, r2
240072ec:	d063      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240072ee:	68fb      	ldr	r3, [r7, #12]
240072f0:	681b      	ldr	r3, [r3, #0]
240072f2:	4a36      	ldr	r2, [pc, #216]	; (240073cc <HAL_DMAEx_MultiBufferStart_IT+0x278>)
240072f4:	4293      	cmp	r3, r2
240072f6:	d05e      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240072f8:	68fb      	ldr	r3, [r7, #12]
240072fa:	681b      	ldr	r3, [r3, #0]
240072fc:	4a34      	ldr	r2, [pc, #208]	; (240073d0 <HAL_DMAEx_MultiBufferStart_IT+0x27c>)
240072fe:	4293      	cmp	r3, r2
24007300:	d059      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007302:	68fb      	ldr	r3, [r7, #12]
24007304:	681b      	ldr	r3, [r3, #0]
24007306:	4a33      	ldr	r2, [pc, #204]	; (240073d4 <HAL_DMAEx_MultiBufferStart_IT+0x280>)
24007308:	4293      	cmp	r3, r2
2400730a:	d054      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400730c:	68fb      	ldr	r3, [r7, #12]
2400730e:	681b      	ldr	r3, [r3, #0]
24007310:	4a31      	ldr	r2, [pc, #196]	; (240073d8 <HAL_DMAEx_MultiBufferStart_IT+0x284>)
24007312:	4293      	cmp	r3, r2
24007314:	d04f      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007316:	68fb      	ldr	r3, [r7, #12]
24007318:	681b      	ldr	r3, [r3, #0]
2400731a:	4a30      	ldr	r2, [pc, #192]	; (240073dc <HAL_DMAEx_MultiBufferStart_IT+0x288>)
2400731c:	4293      	cmp	r3, r2
2400731e:	d04a      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007320:	68fb      	ldr	r3, [r7, #12]
24007322:	681b      	ldr	r3, [r3, #0]
24007324:	4a2e      	ldr	r2, [pc, #184]	; (240073e0 <HAL_DMAEx_MultiBufferStart_IT+0x28c>)
24007326:	4293      	cmp	r3, r2
24007328:	d045      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400732a:	68fb      	ldr	r3, [r7, #12]
2400732c:	681b      	ldr	r3, [r3, #0]
2400732e:	4a2d      	ldr	r2, [pc, #180]	; (240073e4 <HAL_DMAEx_MultiBufferStart_IT+0x290>)
24007330:	4293      	cmp	r3, r2
24007332:	d040      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007334:	68fb      	ldr	r3, [r7, #12]
24007336:	681b      	ldr	r3, [r3, #0]
24007338:	4a2b      	ldr	r2, [pc, #172]	; (240073e8 <HAL_DMAEx_MultiBufferStart_IT+0x294>)
2400733a:	4293      	cmp	r3, r2
2400733c:	d03b      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400733e:	68fb      	ldr	r3, [r7, #12]
24007340:	681b      	ldr	r3, [r3, #0]
24007342:	4a2a      	ldr	r2, [pc, #168]	; (240073ec <HAL_DMAEx_MultiBufferStart_IT+0x298>)
24007344:	4293      	cmp	r3, r2
24007346:	d036      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007348:	68fb      	ldr	r3, [r7, #12]
2400734a:	681b      	ldr	r3, [r3, #0]
2400734c:	4a28      	ldr	r2, [pc, #160]	; (240073f0 <HAL_DMAEx_MultiBufferStart_IT+0x29c>)
2400734e:	4293      	cmp	r3, r2
24007350:	d031      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007352:	68fb      	ldr	r3, [r7, #12]
24007354:	681b      	ldr	r3, [r3, #0]
24007356:	4a27      	ldr	r2, [pc, #156]	; (240073f4 <HAL_DMAEx_MultiBufferStart_IT+0x2a0>)
24007358:	4293      	cmp	r3, r2
2400735a:	d02c      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400735c:	68fb      	ldr	r3, [r7, #12]
2400735e:	681b      	ldr	r3, [r3, #0]
24007360:	4a25      	ldr	r2, [pc, #148]	; (240073f8 <HAL_DMAEx_MultiBufferStart_IT+0x2a4>)
24007362:	4293      	cmp	r3, r2
24007364:	d027      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007366:	68fb      	ldr	r3, [r7, #12]
24007368:	681b      	ldr	r3, [r3, #0]
2400736a:	4a24      	ldr	r2, [pc, #144]	; (240073fc <HAL_DMAEx_MultiBufferStart_IT+0x2a8>)
2400736c:	4293      	cmp	r3, r2
2400736e:	d022      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007370:	68fb      	ldr	r3, [r7, #12]
24007372:	681b      	ldr	r3, [r3, #0]
24007374:	4a22      	ldr	r2, [pc, #136]	; (24007400 <HAL_DMAEx_MultiBufferStart_IT+0x2ac>)
24007376:	4293      	cmp	r3, r2
24007378:	d01d      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400737a:	68fb      	ldr	r3, [r7, #12]
2400737c:	681b      	ldr	r3, [r3, #0]
2400737e:	4a21      	ldr	r2, [pc, #132]	; (24007404 <HAL_DMAEx_MultiBufferStart_IT+0x2b0>)
24007380:	4293      	cmp	r3, r2
24007382:	d018      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007384:	68fb      	ldr	r3, [r7, #12]
24007386:	681b      	ldr	r3, [r3, #0]
24007388:	4a1f      	ldr	r2, [pc, #124]	; (24007408 <HAL_DMAEx_MultiBufferStart_IT+0x2b4>)
2400738a:	4293      	cmp	r3, r2
2400738c:	d013      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
2400738e:	68fb      	ldr	r3, [r7, #12]
24007390:	681b      	ldr	r3, [r3, #0]
24007392:	4a1e      	ldr	r2, [pc, #120]	; (2400740c <HAL_DMAEx_MultiBufferStart_IT+0x2b8>)
24007394:	4293      	cmp	r3, r2
24007396:	d00e      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
24007398:	68fb      	ldr	r3, [r7, #12]
2400739a:	681b      	ldr	r3, [r3, #0]
2400739c:	4a1c      	ldr	r2, [pc, #112]	; (24007410 <HAL_DMAEx_MultiBufferStart_IT+0x2bc>)
2400739e:	4293      	cmp	r3, r2
240073a0:	d009      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240073a2:	68fb      	ldr	r3, [r7, #12]
240073a4:	681b      	ldr	r3, [r3, #0]
240073a6:	4a1b      	ldr	r2, [pc, #108]	; (24007414 <HAL_DMAEx_MultiBufferStart_IT+0x2c0>)
240073a8:	4293      	cmp	r3, r2
240073aa:	d004      	beq.n	240073b6 <HAL_DMAEx_MultiBufferStart_IT+0x262>
240073ac:	68fb      	ldr	r3, [r7, #12]
240073ae:	681b      	ldr	r3, [r3, #0]
240073b0:	4a19      	ldr	r2, [pc, #100]	; (24007418 <HAL_DMAEx_MultiBufferStart_IT+0x2c4>)
240073b2:	4293      	cmp	r3, r2
240073b4:	d132      	bne.n	2400741c <HAL_DMAEx_MultiBufferStart_IT+0x2c8>
240073b6:	2301      	movs	r3, #1
240073b8:	e031      	b.n	2400741e <HAL_DMAEx_MultiBufferStart_IT+0x2ca>
240073ba:	bf00      	nop
240073bc:	40020010 	.word	0x40020010
240073c0:	40020028 	.word	0x40020028
240073c4:	40020040 	.word	0x40020040
240073c8:	40020058 	.word	0x40020058
240073cc:	40020070 	.word	0x40020070
240073d0:	40020088 	.word	0x40020088
240073d4:	400200a0 	.word	0x400200a0
240073d8:	400200b8 	.word	0x400200b8
240073dc:	40020410 	.word	0x40020410
240073e0:	40020428 	.word	0x40020428
240073e4:	40020440 	.word	0x40020440
240073e8:	40020458 	.word	0x40020458
240073ec:	40020470 	.word	0x40020470
240073f0:	40020488 	.word	0x40020488
240073f4:	400204a0 	.word	0x400204a0
240073f8:	400204b8 	.word	0x400204b8
240073fc:	58025408 	.word	0x58025408
24007400:	5802541c 	.word	0x5802541c
24007404:	58025430 	.word	0x58025430
24007408:	58025444 	.word	0x58025444
2400740c:	58025458 	.word	0x58025458
24007410:	5802546c 	.word	0x5802546c
24007414:	58025480 	.word	0x58025480
24007418:	58025494 	.word	0x58025494
2400741c:	2300      	movs	r3, #0
2400741e:	2b00      	cmp	r3, #0
24007420:	d00d      	beq.n	2400743e <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24007422:	68fb      	ldr	r3, [r7, #12]
24007424:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24007426:	68fa      	ldr	r2, [r7, #12]
24007428:	6e92      	ldr	r2, [r2, #104]	; 0x68
2400742a:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
2400742c:	68fb      	ldr	r3, [r7, #12]
2400742e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007430:	2b00      	cmp	r3, #0
24007432:	d004      	beq.n	2400743e <HAL_DMAEx_MultiBufferStart_IT+0x2ea>
      {
        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24007434:	68fb      	ldr	r3, [r7, #12]
24007436:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24007438:	68fa      	ldr	r2, [r7, #12]
2400743a:	6f52      	ldr	r2, [r2, #116]	; 0x74
2400743c:	605a      	str	r2, [r3, #4]
      }
    }

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400743e:	68fb      	ldr	r3, [r7, #12]
24007440:	681b      	ldr	r3, [r3, #0]
24007442:	4a3b      	ldr	r2, [pc, #236]	; (24007530 <HAL_DMAEx_MultiBufferStart_IT+0x3dc>)
24007444:	4293      	cmp	r3, r2
24007446:	d04a      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007448:	68fb      	ldr	r3, [r7, #12]
2400744a:	681b      	ldr	r3, [r3, #0]
2400744c:	4a39      	ldr	r2, [pc, #228]	; (24007534 <HAL_DMAEx_MultiBufferStart_IT+0x3e0>)
2400744e:	4293      	cmp	r3, r2
24007450:	d045      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007452:	68fb      	ldr	r3, [r7, #12]
24007454:	681b      	ldr	r3, [r3, #0]
24007456:	4a38      	ldr	r2, [pc, #224]	; (24007538 <HAL_DMAEx_MultiBufferStart_IT+0x3e4>)
24007458:	4293      	cmp	r3, r2
2400745a:	d040      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400745c:	68fb      	ldr	r3, [r7, #12]
2400745e:	681b      	ldr	r3, [r3, #0]
24007460:	4a36      	ldr	r2, [pc, #216]	; (2400753c <HAL_DMAEx_MultiBufferStart_IT+0x3e8>)
24007462:	4293      	cmp	r3, r2
24007464:	d03b      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007466:	68fb      	ldr	r3, [r7, #12]
24007468:	681b      	ldr	r3, [r3, #0]
2400746a:	4a35      	ldr	r2, [pc, #212]	; (24007540 <HAL_DMAEx_MultiBufferStart_IT+0x3ec>)
2400746c:	4293      	cmp	r3, r2
2400746e:	d036      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007470:	68fb      	ldr	r3, [r7, #12]
24007472:	681b      	ldr	r3, [r3, #0]
24007474:	4a33      	ldr	r2, [pc, #204]	; (24007544 <HAL_DMAEx_MultiBufferStart_IT+0x3f0>)
24007476:	4293      	cmp	r3, r2
24007478:	d031      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400747a:	68fb      	ldr	r3, [r7, #12]
2400747c:	681b      	ldr	r3, [r3, #0]
2400747e:	4a32      	ldr	r2, [pc, #200]	; (24007548 <HAL_DMAEx_MultiBufferStart_IT+0x3f4>)
24007480:	4293      	cmp	r3, r2
24007482:	d02c      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007484:	68fb      	ldr	r3, [r7, #12]
24007486:	681b      	ldr	r3, [r3, #0]
24007488:	4a30      	ldr	r2, [pc, #192]	; (2400754c <HAL_DMAEx_MultiBufferStart_IT+0x3f8>)
2400748a:	4293      	cmp	r3, r2
2400748c:	d027      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
2400748e:	68fb      	ldr	r3, [r7, #12]
24007490:	681b      	ldr	r3, [r3, #0]
24007492:	4a2f      	ldr	r2, [pc, #188]	; (24007550 <HAL_DMAEx_MultiBufferStart_IT+0x3fc>)
24007494:	4293      	cmp	r3, r2
24007496:	d022      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
24007498:	68fb      	ldr	r3, [r7, #12]
2400749a:	681b      	ldr	r3, [r3, #0]
2400749c:	4a2d      	ldr	r2, [pc, #180]	; (24007554 <HAL_DMAEx_MultiBufferStart_IT+0x400>)
2400749e:	4293      	cmp	r3, r2
240074a0:	d01d      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240074a2:	68fb      	ldr	r3, [r7, #12]
240074a4:	681b      	ldr	r3, [r3, #0]
240074a6:	4a2c      	ldr	r2, [pc, #176]	; (24007558 <HAL_DMAEx_MultiBufferStart_IT+0x404>)
240074a8:	4293      	cmp	r3, r2
240074aa:	d018      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240074ac:	68fb      	ldr	r3, [r7, #12]
240074ae:	681b      	ldr	r3, [r3, #0]
240074b0:	4a2a      	ldr	r2, [pc, #168]	; (2400755c <HAL_DMAEx_MultiBufferStart_IT+0x408>)
240074b2:	4293      	cmp	r3, r2
240074b4:	d013      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240074b6:	68fb      	ldr	r3, [r7, #12]
240074b8:	681b      	ldr	r3, [r3, #0]
240074ba:	4a29      	ldr	r2, [pc, #164]	; (24007560 <HAL_DMAEx_MultiBufferStart_IT+0x40c>)
240074bc:	4293      	cmp	r3, r2
240074be:	d00e      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240074c0:	68fb      	ldr	r3, [r7, #12]
240074c2:	681b      	ldr	r3, [r3, #0]
240074c4:	4a27      	ldr	r2, [pc, #156]	; (24007564 <HAL_DMAEx_MultiBufferStart_IT+0x410>)
240074c6:	4293      	cmp	r3, r2
240074c8:	d009      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240074ca:	68fb      	ldr	r3, [r7, #12]
240074cc:	681b      	ldr	r3, [r3, #0]
240074ce:	4a26      	ldr	r2, [pc, #152]	; (24007568 <HAL_DMAEx_MultiBufferStart_IT+0x414>)
240074d0:	4293      	cmp	r3, r2
240074d2:	d004      	beq.n	240074de <HAL_DMAEx_MultiBufferStart_IT+0x38a>
240074d4:	68fb      	ldr	r3, [r7, #12]
240074d6:	681b      	ldr	r3, [r3, #0]
240074d8:	4a24      	ldr	r2, [pc, #144]	; (2400756c <HAL_DMAEx_MultiBufferStart_IT+0x418>)
240074da:	4293      	cmp	r3, r2
240074dc:	d101      	bne.n	240074e2 <HAL_DMAEx_MultiBufferStart_IT+0x38e>
240074de:	2301      	movs	r3, #1
240074e0:	e000      	b.n	240074e4 <HAL_DMAEx_MultiBufferStart_IT+0x390>
240074e2:	2300      	movs	r3, #0
240074e4:	2b00      	cmp	r3, #0
240074e6:	d043      	beq.n	24007570 <HAL_DMAEx_MultiBufferStart_IT+0x41c>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
240074e8:	68fb      	ldr	r3, [r7, #12]
240074ea:	681b      	ldr	r3, [r3, #0]
240074ec:	681b      	ldr	r3, [r3, #0]
240074ee:	f023 021e 	bic.w	r2, r3, #30
240074f2:	68fb      	ldr	r3, [r7, #12]
240074f4:	681b      	ldr	r3, [r3, #0]
240074f6:	f042 0216 	orr.w	r2, r2, #22
240074fa:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR |= DMA_IT_FE;
240074fc:	68fb      	ldr	r3, [r7, #12]
240074fe:	681b      	ldr	r3, [r3, #0]
24007500:	695a      	ldr	r2, [r3, #20]
24007502:	68fb      	ldr	r3, [r7, #12]
24007504:	681b      	ldr	r3, [r3, #0]
24007506:	f042 0280 	orr.w	r2, r2, #128	; 0x80
2400750a:	615a      	str	r2, [r3, #20]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
2400750c:	68fb      	ldr	r3, [r7, #12]
2400750e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24007510:	2b00      	cmp	r3, #0
24007512:	d103      	bne.n	2400751c <HAL_DMAEx_MultiBufferStart_IT+0x3c8>
24007514:	68fb      	ldr	r3, [r7, #12]
24007516:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24007518:	2b00      	cmp	r3, #0
2400751a:	d043      	beq.n	240075a4 <HAL_DMAEx_MultiBufferStart_IT+0x450>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
2400751c:	68fb      	ldr	r3, [r7, #12]
2400751e:	681b      	ldr	r3, [r3, #0]
24007520:	681a      	ldr	r2, [r3, #0]
24007522:	68fb      	ldr	r3, [r7, #12]
24007524:	681b      	ldr	r3, [r3, #0]
24007526:	f042 0208 	orr.w	r2, r2, #8
2400752a:	601a      	str	r2, [r3, #0]
2400752c:	e03a      	b.n	240075a4 <HAL_DMAEx_MultiBufferStart_IT+0x450>
2400752e:	bf00      	nop
24007530:	40020010 	.word	0x40020010
24007534:	40020028 	.word	0x40020028
24007538:	40020040 	.word	0x40020040
2400753c:	40020058 	.word	0x40020058
24007540:	40020070 	.word	0x40020070
24007544:	40020088 	.word	0x40020088
24007548:	400200a0 	.word	0x400200a0
2400754c:	400200b8 	.word	0x400200b8
24007550:	40020410 	.word	0x40020410
24007554:	40020428 	.word	0x40020428
24007558:	40020440 	.word	0x40020440
2400755c:	40020458 	.word	0x40020458
24007560:	40020470 	.word	0x40020470
24007564:	40020488 	.word	0x40020488
24007568:	400204a0 	.word	0x400204a0
2400756c:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA instance(s) */
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
24007570:	68fb      	ldr	r3, [r7, #12]
24007572:	681b      	ldr	r3, [r3, #0]
24007574:	681b      	ldr	r3, [r3, #0]
24007576:	f023 020e 	bic.w	r2, r3, #14
2400757a:	68fb      	ldr	r3, [r7, #12]
2400757c:	681b      	ldr	r3, [r3, #0]
2400757e:	f042 020a 	orr.w	r2, r2, #10
24007582:	601a      	str	r2, [r3, #0]

      if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
24007584:	68fb      	ldr	r3, [r7, #12]
24007586:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24007588:	2b00      	cmp	r3, #0
2400758a:	d103      	bne.n	24007594 <HAL_DMAEx_MultiBufferStart_IT+0x440>
2400758c:	68fb      	ldr	r3, [r7, #12]
2400758e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24007590:	2b00      	cmp	r3, #0
24007592:	d007      	beq.n	240075a4 <HAL_DMAEx_MultiBufferStart_IT+0x450>
      {
        /*Enable Half Transfer IT if corresponding Callback is set*/
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
24007594:	68fb      	ldr	r3, [r7, #12]
24007596:	681b      	ldr	r3, [r3, #0]
24007598:	681a      	ldr	r2, [r3, #0]
2400759a:	68fb      	ldr	r3, [r7, #12]
2400759c:	681b      	ldr	r3, [r3, #0]
2400759e:	f042 0204 	orr.w	r2, r2, #4
240075a2:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
240075a4:	68fb      	ldr	r3, [r7, #12]
240075a6:	681b      	ldr	r3, [r3, #0]
240075a8:	4a81      	ldr	r2, [pc, #516]	; (240077b0 <HAL_DMAEx_MultiBufferStart_IT+0x65c>)
240075aa:	4293      	cmp	r3, r2
240075ac:	d072      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075ae:	68fb      	ldr	r3, [r7, #12]
240075b0:	681b      	ldr	r3, [r3, #0]
240075b2:	4a80      	ldr	r2, [pc, #512]	; (240077b4 <HAL_DMAEx_MultiBufferStart_IT+0x660>)
240075b4:	4293      	cmp	r3, r2
240075b6:	d06d      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075b8:	68fb      	ldr	r3, [r7, #12]
240075ba:	681b      	ldr	r3, [r3, #0]
240075bc:	4a7e      	ldr	r2, [pc, #504]	; (240077b8 <HAL_DMAEx_MultiBufferStart_IT+0x664>)
240075be:	4293      	cmp	r3, r2
240075c0:	d068      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075c2:	68fb      	ldr	r3, [r7, #12]
240075c4:	681b      	ldr	r3, [r3, #0]
240075c6:	4a7d      	ldr	r2, [pc, #500]	; (240077bc <HAL_DMAEx_MultiBufferStart_IT+0x668>)
240075c8:	4293      	cmp	r3, r2
240075ca:	d063      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075cc:	68fb      	ldr	r3, [r7, #12]
240075ce:	681b      	ldr	r3, [r3, #0]
240075d0:	4a7b      	ldr	r2, [pc, #492]	; (240077c0 <HAL_DMAEx_MultiBufferStart_IT+0x66c>)
240075d2:	4293      	cmp	r3, r2
240075d4:	d05e      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075d6:	68fb      	ldr	r3, [r7, #12]
240075d8:	681b      	ldr	r3, [r3, #0]
240075da:	4a7a      	ldr	r2, [pc, #488]	; (240077c4 <HAL_DMAEx_MultiBufferStart_IT+0x670>)
240075dc:	4293      	cmp	r3, r2
240075de:	d059      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075e0:	68fb      	ldr	r3, [r7, #12]
240075e2:	681b      	ldr	r3, [r3, #0]
240075e4:	4a78      	ldr	r2, [pc, #480]	; (240077c8 <HAL_DMAEx_MultiBufferStart_IT+0x674>)
240075e6:	4293      	cmp	r3, r2
240075e8:	d054      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075ea:	68fb      	ldr	r3, [r7, #12]
240075ec:	681b      	ldr	r3, [r3, #0]
240075ee:	4a77      	ldr	r2, [pc, #476]	; (240077cc <HAL_DMAEx_MultiBufferStart_IT+0x678>)
240075f0:	4293      	cmp	r3, r2
240075f2:	d04f      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075f4:	68fb      	ldr	r3, [r7, #12]
240075f6:	681b      	ldr	r3, [r3, #0]
240075f8:	4a75      	ldr	r2, [pc, #468]	; (240077d0 <HAL_DMAEx_MultiBufferStart_IT+0x67c>)
240075fa:	4293      	cmp	r3, r2
240075fc:	d04a      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
240075fe:	68fb      	ldr	r3, [r7, #12]
24007600:	681b      	ldr	r3, [r3, #0]
24007602:	4a74      	ldr	r2, [pc, #464]	; (240077d4 <HAL_DMAEx_MultiBufferStart_IT+0x680>)
24007604:	4293      	cmp	r3, r2
24007606:	d045      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007608:	68fb      	ldr	r3, [r7, #12]
2400760a:	681b      	ldr	r3, [r3, #0]
2400760c:	4a72      	ldr	r2, [pc, #456]	; (240077d8 <HAL_DMAEx_MultiBufferStart_IT+0x684>)
2400760e:	4293      	cmp	r3, r2
24007610:	d040      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007612:	68fb      	ldr	r3, [r7, #12]
24007614:	681b      	ldr	r3, [r3, #0]
24007616:	4a71      	ldr	r2, [pc, #452]	; (240077dc <HAL_DMAEx_MultiBufferStart_IT+0x688>)
24007618:	4293      	cmp	r3, r2
2400761a:	d03b      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400761c:	68fb      	ldr	r3, [r7, #12]
2400761e:	681b      	ldr	r3, [r3, #0]
24007620:	4a6f      	ldr	r2, [pc, #444]	; (240077e0 <HAL_DMAEx_MultiBufferStart_IT+0x68c>)
24007622:	4293      	cmp	r3, r2
24007624:	d036      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007626:	68fb      	ldr	r3, [r7, #12]
24007628:	681b      	ldr	r3, [r3, #0]
2400762a:	4a6e      	ldr	r2, [pc, #440]	; (240077e4 <HAL_DMAEx_MultiBufferStart_IT+0x690>)
2400762c:	4293      	cmp	r3, r2
2400762e:	d031      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007630:	68fb      	ldr	r3, [r7, #12]
24007632:	681b      	ldr	r3, [r3, #0]
24007634:	4a6c      	ldr	r2, [pc, #432]	; (240077e8 <HAL_DMAEx_MultiBufferStart_IT+0x694>)
24007636:	4293      	cmp	r3, r2
24007638:	d02c      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400763a:	68fb      	ldr	r3, [r7, #12]
2400763c:	681b      	ldr	r3, [r3, #0]
2400763e:	4a6b      	ldr	r2, [pc, #428]	; (240077ec <HAL_DMAEx_MultiBufferStart_IT+0x698>)
24007640:	4293      	cmp	r3, r2
24007642:	d027      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007644:	68fb      	ldr	r3, [r7, #12]
24007646:	681b      	ldr	r3, [r3, #0]
24007648:	4a69      	ldr	r2, [pc, #420]	; (240077f0 <HAL_DMAEx_MultiBufferStart_IT+0x69c>)
2400764a:	4293      	cmp	r3, r2
2400764c:	d022      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400764e:	68fb      	ldr	r3, [r7, #12]
24007650:	681b      	ldr	r3, [r3, #0]
24007652:	4a68      	ldr	r2, [pc, #416]	; (240077f4 <HAL_DMAEx_MultiBufferStart_IT+0x6a0>)
24007654:	4293      	cmp	r3, r2
24007656:	d01d      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007658:	68fb      	ldr	r3, [r7, #12]
2400765a:	681b      	ldr	r3, [r3, #0]
2400765c:	4a66      	ldr	r2, [pc, #408]	; (240077f8 <HAL_DMAEx_MultiBufferStart_IT+0x6a4>)
2400765e:	4293      	cmp	r3, r2
24007660:	d018      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007662:	68fb      	ldr	r3, [r7, #12]
24007664:	681b      	ldr	r3, [r3, #0]
24007666:	4a65      	ldr	r2, [pc, #404]	; (240077fc <HAL_DMAEx_MultiBufferStart_IT+0x6a8>)
24007668:	4293      	cmp	r3, r2
2400766a:	d013      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400766c:	68fb      	ldr	r3, [r7, #12]
2400766e:	681b      	ldr	r3, [r3, #0]
24007670:	4a63      	ldr	r2, [pc, #396]	; (24007800 <HAL_DMAEx_MultiBufferStart_IT+0x6ac>)
24007672:	4293      	cmp	r3, r2
24007674:	d00e      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007676:	68fb      	ldr	r3, [r7, #12]
24007678:	681b      	ldr	r3, [r3, #0]
2400767a:	4a62      	ldr	r2, [pc, #392]	; (24007804 <HAL_DMAEx_MultiBufferStart_IT+0x6b0>)
2400767c:	4293      	cmp	r3, r2
2400767e:	d009      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
24007680:	68fb      	ldr	r3, [r7, #12]
24007682:	681b      	ldr	r3, [r3, #0]
24007684:	4a60      	ldr	r2, [pc, #384]	; (24007808 <HAL_DMAEx_MultiBufferStart_IT+0x6b4>)
24007686:	4293      	cmp	r3, r2
24007688:	d004      	beq.n	24007694 <HAL_DMAEx_MultiBufferStart_IT+0x540>
2400768a:	68fb      	ldr	r3, [r7, #12]
2400768c:	681b      	ldr	r3, [r3, #0]
2400768e:	4a5f      	ldr	r2, [pc, #380]	; (2400780c <HAL_DMAEx_MultiBufferStart_IT+0x6b8>)
24007690:	4293      	cmp	r3, r2
24007692:	d101      	bne.n	24007698 <HAL_DMAEx_MultiBufferStart_IT+0x544>
24007694:	2301      	movs	r3, #1
24007696:	e000      	b.n	2400769a <HAL_DMAEx_MultiBufferStart_IT+0x546>
24007698:	2300      	movs	r3, #0
2400769a:	2b00      	cmp	r3, #0
2400769c:	d01a      	beq.n	240076d4 <HAL_DMAEx_MultiBufferStart_IT+0x580>
    {
      /* Check if DMAMUX Synchronization is enabled*/
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
2400769e:	68fb      	ldr	r3, [r7, #12]
240076a0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240076a2:	681b      	ldr	r3, [r3, #0]
240076a4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240076a8:	2b00      	cmp	r3, #0
240076aa:	d007      	beq.n	240076bc <HAL_DMAEx_MultiBufferStart_IT+0x568>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
240076ac:	68fb      	ldr	r3, [r7, #12]
240076ae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240076b0:	681a      	ldr	r2, [r3, #0]
240076b2:	68fb      	ldr	r3, [r7, #12]
240076b4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240076b6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240076ba:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
240076bc:	68fb      	ldr	r3, [r7, #12]
240076be:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240076c0:	2b00      	cmp	r3, #0
240076c2:	d007      	beq.n	240076d4 <HAL_DMAEx_MultiBufferStart_IT+0x580>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT*/
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
240076c4:	68fb      	ldr	r3, [r7, #12]
240076c6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240076c8:	681a      	ldr	r2, [r3, #0]
240076ca:	68fb      	ldr	r3, [r7, #12]
240076cc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240076ce:	f442 7280 	orr.w	r2, r2, #256	; 0x100
240076d2:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the peripheral */
    __HAL_DMA_ENABLE(hdma);
240076d4:	68fb      	ldr	r3, [r7, #12]
240076d6:	681b      	ldr	r3, [r3, #0]
240076d8:	4a35      	ldr	r2, [pc, #212]	; (240077b0 <HAL_DMAEx_MultiBufferStart_IT+0x65c>)
240076da:	4293      	cmp	r3, r2
240076dc:	d04a      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
240076de:	68fb      	ldr	r3, [r7, #12]
240076e0:	681b      	ldr	r3, [r3, #0]
240076e2:	4a34      	ldr	r2, [pc, #208]	; (240077b4 <HAL_DMAEx_MultiBufferStart_IT+0x660>)
240076e4:	4293      	cmp	r3, r2
240076e6:	d045      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
240076e8:	68fb      	ldr	r3, [r7, #12]
240076ea:	681b      	ldr	r3, [r3, #0]
240076ec:	4a32      	ldr	r2, [pc, #200]	; (240077b8 <HAL_DMAEx_MultiBufferStart_IT+0x664>)
240076ee:	4293      	cmp	r3, r2
240076f0:	d040      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
240076f2:	68fb      	ldr	r3, [r7, #12]
240076f4:	681b      	ldr	r3, [r3, #0]
240076f6:	4a31      	ldr	r2, [pc, #196]	; (240077bc <HAL_DMAEx_MultiBufferStart_IT+0x668>)
240076f8:	4293      	cmp	r3, r2
240076fa:	d03b      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
240076fc:	68fb      	ldr	r3, [r7, #12]
240076fe:	681b      	ldr	r3, [r3, #0]
24007700:	4a2f      	ldr	r2, [pc, #188]	; (240077c0 <HAL_DMAEx_MultiBufferStart_IT+0x66c>)
24007702:	4293      	cmp	r3, r2
24007704:	d036      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007706:	68fb      	ldr	r3, [r7, #12]
24007708:	681b      	ldr	r3, [r3, #0]
2400770a:	4a2e      	ldr	r2, [pc, #184]	; (240077c4 <HAL_DMAEx_MultiBufferStart_IT+0x670>)
2400770c:	4293      	cmp	r3, r2
2400770e:	d031      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007710:	68fb      	ldr	r3, [r7, #12]
24007712:	681b      	ldr	r3, [r3, #0]
24007714:	4a2c      	ldr	r2, [pc, #176]	; (240077c8 <HAL_DMAEx_MultiBufferStart_IT+0x674>)
24007716:	4293      	cmp	r3, r2
24007718:	d02c      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
2400771a:	68fb      	ldr	r3, [r7, #12]
2400771c:	681b      	ldr	r3, [r3, #0]
2400771e:	4a2b      	ldr	r2, [pc, #172]	; (240077cc <HAL_DMAEx_MultiBufferStart_IT+0x678>)
24007720:	4293      	cmp	r3, r2
24007722:	d027      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007724:	68fb      	ldr	r3, [r7, #12]
24007726:	681b      	ldr	r3, [r3, #0]
24007728:	4a29      	ldr	r2, [pc, #164]	; (240077d0 <HAL_DMAEx_MultiBufferStart_IT+0x67c>)
2400772a:	4293      	cmp	r3, r2
2400772c:	d022      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
2400772e:	68fb      	ldr	r3, [r7, #12]
24007730:	681b      	ldr	r3, [r3, #0]
24007732:	4a28      	ldr	r2, [pc, #160]	; (240077d4 <HAL_DMAEx_MultiBufferStart_IT+0x680>)
24007734:	4293      	cmp	r3, r2
24007736:	d01d      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007738:	68fb      	ldr	r3, [r7, #12]
2400773a:	681b      	ldr	r3, [r3, #0]
2400773c:	4a26      	ldr	r2, [pc, #152]	; (240077d8 <HAL_DMAEx_MultiBufferStart_IT+0x684>)
2400773e:	4293      	cmp	r3, r2
24007740:	d018      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007742:	68fb      	ldr	r3, [r7, #12]
24007744:	681b      	ldr	r3, [r3, #0]
24007746:	4a25      	ldr	r2, [pc, #148]	; (240077dc <HAL_DMAEx_MultiBufferStart_IT+0x688>)
24007748:	4293      	cmp	r3, r2
2400774a:	d013      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
2400774c:	68fb      	ldr	r3, [r7, #12]
2400774e:	681b      	ldr	r3, [r3, #0]
24007750:	4a23      	ldr	r2, [pc, #140]	; (240077e0 <HAL_DMAEx_MultiBufferStart_IT+0x68c>)
24007752:	4293      	cmp	r3, r2
24007754:	d00e      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007756:	68fb      	ldr	r3, [r7, #12]
24007758:	681b      	ldr	r3, [r3, #0]
2400775a:	4a22      	ldr	r2, [pc, #136]	; (240077e4 <HAL_DMAEx_MultiBufferStart_IT+0x690>)
2400775c:	4293      	cmp	r3, r2
2400775e:	d009      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
24007760:	68fb      	ldr	r3, [r7, #12]
24007762:	681b      	ldr	r3, [r3, #0]
24007764:	4a20      	ldr	r2, [pc, #128]	; (240077e8 <HAL_DMAEx_MultiBufferStart_IT+0x694>)
24007766:	4293      	cmp	r3, r2
24007768:	d004      	beq.n	24007774 <HAL_DMAEx_MultiBufferStart_IT+0x620>
2400776a:	68fb      	ldr	r3, [r7, #12]
2400776c:	681b      	ldr	r3, [r3, #0]
2400776e:	4a1f      	ldr	r2, [pc, #124]	; (240077ec <HAL_DMAEx_MultiBufferStart_IT+0x698>)
24007770:	4293      	cmp	r3, r2
24007772:	d108      	bne.n	24007786 <HAL_DMAEx_MultiBufferStart_IT+0x632>
24007774:	68fb      	ldr	r3, [r7, #12]
24007776:	681b      	ldr	r3, [r3, #0]
24007778:	681a      	ldr	r2, [r3, #0]
2400777a:	68fb      	ldr	r3, [r7, #12]
2400777c:	681b      	ldr	r3, [r3, #0]
2400777e:	f042 0201 	orr.w	r2, r2, #1
24007782:	601a      	str	r2, [r3, #0]
24007784:	e00e      	b.n	240077a4 <HAL_DMAEx_MultiBufferStart_IT+0x650>
24007786:	68fb      	ldr	r3, [r7, #12]
24007788:	681b      	ldr	r3, [r3, #0]
2400778a:	681a      	ldr	r2, [r3, #0]
2400778c:	68fb      	ldr	r3, [r7, #12]
2400778e:	681b      	ldr	r3, [r3, #0]
24007790:	f042 0201 	orr.w	r2, r2, #1
24007794:	601a      	str	r2, [r3, #0]
24007796:	e005      	b.n	240077a4 <HAL_DMAEx_MultiBufferStart_IT+0x650>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24007798:	68fb      	ldr	r3, [r7, #12]
2400779a:	f44f 6200 	mov.w	r2, #2048	; 0x800
2400779e:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    status = HAL_ERROR;
240077a0:	2301      	movs	r3, #1
240077a2:	75fb      	strb	r3, [r7, #23]
  }
  return status;
240077a4:	7dfb      	ldrb	r3, [r7, #23]
}
240077a6:	4618      	mov	r0, r3
240077a8:	3718      	adds	r7, #24
240077aa:	46bd      	mov	sp, r7
240077ac:	bd80      	pop	{r7, pc}
240077ae:	bf00      	nop
240077b0:	40020010 	.word	0x40020010
240077b4:	40020028 	.word	0x40020028
240077b8:	40020040 	.word	0x40020040
240077bc:	40020058 	.word	0x40020058
240077c0:	40020070 	.word	0x40020070
240077c4:	40020088 	.word	0x40020088
240077c8:	400200a0 	.word	0x400200a0
240077cc:	400200b8 	.word	0x400200b8
240077d0:	40020410 	.word	0x40020410
240077d4:	40020428 	.word	0x40020428
240077d8:	40020440 	.word	0x40020440
240077dc:	40020458 	.word	0x40020458
240077e0:	40020470 	.word	0x40020470
240077e4:	40020488 	.word	0x40020488
240077e8:	400204a0 	.word	0x400204a0
240077ec:	400204b8 	.word	0x400204b8
240077f0:	58025408 	.word	0x58025408
240077f4:	5802541c 	.word	0x5802541c
240077f8:	58025430 	.word	0x58025430
240077fc:	58025444 	.word	0x58025444
24007800:	58025458 	.word	0x58025458
24007804:	5802546c 	.word	0x5802546c
24007808:	58025480 	.word	0x58025480
2400780c:	58025494 	.word	0x58025494

24007810 <HAL_DMAEx_ChangeMemory>:
  *         MEMORY1 and the MEMORY1 address can be changed only when the current
  *         transfer use MEMORY0.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_MemoryTypeDef memory)
{
24007810:	b480      	push	{r7}
24007812:	b085      	sub	sp, #20
24007814:	af00      	add	r7, sp, #0
24007816:	60f8      	str	r0, [r7, #12]
24007818:	60b9      	str	r1, [r7, #8]
2400781a:	4613      	mov	r3, r2
2400781c:	71fb      	strb	r3, [r7, #7]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
2400781e:	68fb      	ldr	r3, [r7, #12]
24007820:	681b      	ldr	r3, [r3, #0]
24007822:	4a39      	ldr	r2, [pc, #228]	; (24007908 <HAL_DMAEx_ChangeMemory+0xf8>)
24007824:	4293      	cmp	r3, r2
24007826:	d04a      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007828:	68fb      	ldr	r3, [r7, #12]
2400782a:	681b      	ldr	r3, [r3, #0]
2400782c:	4a37      	ldr	r2, [pc, #220]	; (2400790c <HAL_DMAEx_ChangeMemory+0xfc>)
2400782e:	4293      	cmp	r3, r2
24007830:	d045      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007832:	68fb      	ldr	r3, [r7, #12]
24007834:	681b      	ldr	r3, [r3, #0]
24007836:	4a36      	ldr	r2, [pc, #216]	; (24007910 <HAL_DMAEx_ChangeMemory+0x100>)
24007838:	4293      	cmp	r3, r2
2400783a:	d040      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
2400783c:	68fb      	ldr	r3, [r7, #12]
2400783e:	681b      	ldr	r3, [r3, #0]
24007840:	4a34      	ldr	r2, [pc, #208]	; (24007914 <HAL_DMAEx_ChangeMemory+0x104>)
24007842:	4293      	cmp	r3, r2
24007844:	d03b      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007846:	68fb      	ldr	r3, [r7, #12]
24007848:	681b      	ldr	r3, [r3, #0]
2400784a:	4a33      	ldr	r2, [pc, #204]	; (24007918 <HAL_DMAEx_ChangeMemory+0x108>)
2400784c:	4293      	cmp	r3, r2
2400784e:	d036      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007850:	68fb      	ldr	r3, [r7, #12]
24007852:	681b      	ldr	r3, [r3, #0]
24007854:	4a31      	ldr	r2, [pc, #196]	; (2400791c <HAL_DMAEx_ChangeMemory+0x10c>)
24007856:	4293      	cmp	r3, r2
24007858:	d031      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
2400785a:	68fb      	ldr	r3, [r7, #12]
2400785c:	681b      	ldr	r3, [r3, #0]
2400785e:	4a30      	ldr	r2, [pc, #192]	; (24007920 <HAL_DMAEx_ChangeMemory+0x110>)
24007860:	4293      	cmp	r3, r2
24007862:	d02c      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007864:	68fb      	ldr	r3, [r7, #12]
24007866:	681b      	ldr	r3, [r3, #0]
24007868:	4a2e      	ldr	r2, [pc, #184]	; (24007924 <HAL_DMAEx_ChangeMemory+0x114>)
2400786a:	4293      	cmp	r3, r2
2400786c:	d027      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
2400786e:	68fb      	ldr	r3, [r7, #12]
24007870:	681b      	ldr	r3, [r3, #0]
24007872:	4a2d      	ldr	r2, [pc, #180]	; (24007928 <HAL_DMAEx_ChangeMemory+0x118>)
24007874:	4293      	cmp	r3, r2
24007876:	d022      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007878:	68fb      	ldr	r3, [r7, #12]
2400787a:	681b      	ldr	r3, [r3, #0]
2400787c:	4a2b      	ldr	r2, [pc, #172]	; (2400792c <HAL_DMAEx_ChangeMemory+0x11c>)
2400787e:	4293      	cmp	r3, r2
24007880:	d01d      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007882:	68fb      	ldr	r3, [r7, #12]
24007884:	681b      	ldr	r3, [r3, #0]
24007886:	4a2a      	ldr	r2, [pc, #168]	; (24007930 <HAL_DMAEx_ChangeMemory+0x120>)
24007888:	4293      	cmp	r3, r2
2400788a:	d018      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
2400788c:	68fb      	ldr	r3, [r7, #12]
2400788e:	681b      	ldr	r3, [r3, #0]
24007890:	4a28      	ldr	r2, [pc, #160]	; (24007934 <HAL_DMAEx_ChangeMemory+0x124>)
24007892:	4293      	cmp	r3, r2
24007894:	d013      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
24007896:	68fb      	ldr	r3, [r7, #12]
24007898:	681b      	ldr	r3, [r3, #0]
2400789a:	4a27      	ldr	r2, [pc, #156]	; (24007938 <HAL_DMAEx_ChangeMemory+0x128>)
2400789c:	4293      	cmp	r3, r2
2400789e:	d00e      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
240078a0:	68fb      	ldr	r3, [r7, #12]
240078a2:	681b      	ldr	r3, [r3, #0]
240078a4:	4a25      	ldr	r2, [pc, #148]	; (2400793c <HAL_DMAEx_ChangeMemory+0x12c>)
240078a6:	4293      	cmp	r3, r2
240078a8:	d009      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
240078aa:	68fb      	ldr	r3, [r7, #12]
240078ac:	681b      	ldr	r3, [r3, #0]
240078ae:	4a24      	ldr	r2, [pc, #144]	; (24007940 <HAL_DMAEx_ChangeMemory+0x130>)
240078b0:	4293      	cmp	r3, r2
240078b2:	d004      	beq.n	240078be <HAL_DMAEx_ChangeMemory+0xae>
240078b4:	68fb      	ldr	r3, [r7, #12]
240078b6:	681b      	ldr	r3, [r3, #0]
240078b8:	4a22      	ldr	r2, [pc, #136]	; (24007944 <HAL_DMAEx_ChangeMemory+0x134>)
240078ba:	4293      	cmp	r3, r2
240078bc:	d101      	bne.n	240078c2 <HAL_DMAEx_ChangeMemory+0xb2>
240078be:	2301      	movs	r3, #1
240078c0:	e000      	b.n	240078c4 <HAL_DMAEx_ChangeMemory+0xb4>
240078c2:	2300      	movs	r3, #0
240078c4:	2b00      	cmp	r3, #0
240078c6:	d00c      	beq.n	240078e2 <HAL_DMAEx_ChangeMemory+0xd2>
  {
    if(memory == MEMORY0)
240078c8:	79fb      	ldrb	r3, [r7, #7]
240078ca:	2b00      	cmp	r3, #0
240078cc:	d104      	bne.n	240078d8 <HAL_DMAEx_ChangeMemory+0xc8>
    {
      /* change the memory0 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = Address;
240078ce:	68fb      	ldr	r3, [r7, #12]
240078d0:	681b      	ldr	r3, [r3, #0]
240078d2:	68ba      	ldr	r2, [r7, #8]
240078d4:	60da      	str	r2, [r3, #12]
240078d6:	e010      	b.n	240078fa <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = Address;
240078d8:	68fb      	ldr	r3, [r7, #12]
240078da:	681b      	ldr	r3, [r3, #0]
240078dc:	68ba      	ldr	r2, [r7, #8]
240078de:	611a      	str	r2, [r3, #16]
240078e0:	e00b      	b.n	240078fa <HAL_DMAEx_ChangeMemory+0xea>
    }
  }
  else /* BDMA instance(s) */
  {
    if(memory == MEMORY0)
240078e2:	79fb      	ldrb	r3, [r7, #7]
240078e4:	2b00      	cmp	r3, #0
240078e6:	d104      	bne.n	240078f2 <HAL_DMAEx_ChangeMemory+0xe2>
    {
      /* change the memory0 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = Address;
240078e8:	68fb      	ldr	r3, [r7, #12]
240078ea:	681b      	ldr	r3, [r3, #0]
240078ec:	68ba      	ldr	r2, [r7, #8]
240078ee:	60da      	str	r2, [r3, #12]
240078f0:	e003      	b.n	240078fa <HAL_DMAEx_ChangeMemory+0xea>
    }
    else
    {
      /* change the memory1 address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM1AR = Address;
240078f2:	68fb      	ldr	r3, [r7, #12]
240078f4:	681b      	ldr	r3, [r3, #0]
240078f6:	68ba      	ldr	r2, [r7, #8]
240078f8:	611a      	str	r2, [r3, #16]
    }
  }

  return HAL_OK;
240078fa:	2300      	movs	r3, #0
}
240078fc:	4618      	mov	r0, r3
240078fe:	3714      	adds	r7, #20
24007900:	46bd      	mov	sp, r7
24007902:	f85d 7b04 	ldr.w	r7, [sp], #4
24007906:	4770      	bx	lr
24007908:	40020010 	.word	0x40020010
2400790c:	40020028 	.word	0x40020028
24007910:	40020040 	.word	0x40020040
24007914:	40020058 	.word	0x40020058
24007918:	40020070 	.word	0x40020070
2400791c:	40020088 	.word	0x40020088
24007920:	400200a0 	.word	0x400200a0
24007924:	400200b8 	.word	0x400200b8
24007928:	40020410 	.word	0x40020410
2400792c:	40020428 	.word	0x40020428
24007930:	40020440 	.word	0x40020440
24007934:	40020458 	.word	0x40020458
24007938:	40020470 	.word	0x40020470
2400793c:	40020488 	.word	0x40020488
24007940:	400204a0 	.word	0x400204a0
24007944:	400204b8 	.word	0x400204b8

24007948 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
24007948:	b480      	push	{r7}
2400794a:	b085      	sub	sp, #20
2400794c:	af00      	add	r7, sp, #0
2400794e:	6078      	str	r0, [r7, #4]
24007950:	6039      	str	r1, [r7, #0]
  uint32_t syncSignalID = 0;
24007952:	2300      	movs	r3, #0
24007954:	60fb      	str	r3, [r7, #12]
  uint32_t syncPolarity = 0;
24007956:	2300      	movs	r3, #0
24007958:	60bb      	str	r3, [r7, #8]
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));

  if(pSyncConfig->SyncEnable == ENABLE)
2400795a:	683b      	ldr	r3, [r7, #0]
2400795c:	7a1b      	ldrb	r3, [r3, #8]
2400795e:	2b01      	cmp	r3, #1
24007960:	d154      	bne.n	24007a0c <HAL_DMAEx_ConfigMuxSync+0xc4>
  {
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24007962:	687b      	ldr	r3, [r7, #4]
24007964:	681b      	ldr	r3, [r3, #0]
24007966:	4a4b      	ldr	r2, [pc, #300]	; (24007a94 <HAL_DMAEx_ConfigMuxSync+0x14c>)
24007968:	4293      	cmp	r3, r2
2400796a:	d049      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400796c:	687b      	ldr	r3, [r7, #4]
2400796e:	681b      	ldr	r3, [r3, #0]
24007970:	4a49      	ldr	r2, [pc, #292]	; (24007a98 <HAL_DMAEx_ConfigMuxSync+0x150>)
24007972:	4293      	cmp	r3, r2
24007974:	d044      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007976:	687b      	ldr	r3, [r7, #4]
24007978:	681b      	ldr	r3, [r3, #0]
2400797a:	4a48      	ldr	r2, [pc, #288]	; (24007a9c <HAL_DMAEx_ConfigMuxSync+0x154>)
2400797c:	4293      	cmp	r3, r2
2400797e:	d03f      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007980:	687b      	ldr	r3, [r7, #4]
24007982:	681b      	ldr	r3, [r3, #0]
24007984:	4a46      	ldr	r2, [pc, #280]	; (24007aa0 <HAL_DMAEx_ConfigMuxSync+0x158>)
24007986:	4293      	cmp	r3, r2
24007988:	d03a      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400798a:	687b      	ldr	r3, [r7, #4]
2400798c:	681b      	ldr	r3, [r3, #0]
2400798e:	4a45      	ldr	r2, [pc, #276]	; (24007aa4 <HAL_DMAEx_ConfigMuxSync+0x15c>)
24007990:	4293      	cmp	r3, r2
24007992:	d035      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
24007994:	687b      	ldr	r3, [r7, #4]
24007996:	681b      	ldr	r3, [r3, #0]
24007998:	4a43      	ldr	r2, [pc, #268]	; (24007aa8 <HAL_DMAEx_ConfigMuxSync+0x160>)
2400799a:	4293      	cmp	r3, r2
2400799c:	d030      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
2400799e:	687b      	ldr	r3, [r7, #4]
240079a0:	681b      	ldr	r3, [r3, #0]
240079a2:	4a42      	ldr	r2, [pc, #264]	; (24007aac <HAL_DMAEx_ConfigMuxSync+0x164>)
240079a4:	4293      	cmp	r3, r2
240079a6:	d02b      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079a8:	687b      	ldr	r3, [r7, #4]
240079aa:	681b      	ldr	r3, [r3, #0]
240079ac:	4a40      	ldr	r2, [pc, #256]	; (24007ab0 <HAL_DMAEx_ConfigMuxSync+0x168>)
240079ae:	4293      	cmp	r3, r2
240079b0:	d026      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079b2:	687b      	ldr	r3, [r7, #4]
240079b4:	681b      	ldr	r3, [r3, #0]
240079b6:	4a3f      	ldr	r2, [pc, #252]	; (24007ab4 <HAL_DMAEx_ConfigMuxSync+0x16c>)
240079b8:	4293      	cmp	r3, r2
240079ba:	d021      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079bc:	687b      	ldr	r3, [r7, #4]
240079be:	681b      	ldr	r3, [r3, #0]
240079c0:	4a3d      	ldr	r2, [pc, #244]	; (24007ab8 <HAL_DMAEx_ConfigMuxSync+0x170>)
240079c2:	4293      	cmp	r3, r2
240079c4:	d01c      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079c6:	687b      	ldr	r3, [r7, #4]
240079c8:	681b      	ldr	r3, [r3, #0]
240079ca:	4a3c      	ldr	r2, [pc, #240]	; (24007abc <HAL_DMAEx_ConfigMuxSync+0x174>)
240079cc:	4293      	cmp	r3, r2
240079ce:	d017      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079d0:	687b      	ldr	r3, [r7, #4]
240079d2:	681b      	ldr	r3, [r3, #0]
240079d4:	4a3a      	ldr	r2, [pc, #232]	; (24007ac0 <HAL_DMAEx_ConfigMuxSync+0x178>)
240079d6:	4293      	cmp	r3, r2
240079d8:	d012      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079da:	687b      	ldr	r3, [r7, #4]
240079dc:	681b      	ldr	r3, [r3, #0]
240079de:	4a39      	ldr	r2, [pc, #228]	; (24007ac4 <HAL_DMAEx_ConfigMuxSync+0x17c>)
240079e0:	4293      	cmp	r3, r2
240079e2:	d00d      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079e4:	687b      	ldr	r3, [r7, #4]
240079e6:	681b      	ldr	r3, [r3, #0]
240079e8:	4a37      	ldr	r2, [pc, #220]	; (24007ac8 <HAL_DMAEx_ConfigMuxSync+0x180>)
240079ea:	4293      	cmp	r3, r2
240079ec:	d008      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079ee:	687b      	ldr	r3, [r7, #4]
240079f0:	681b      	ldr	r3, [r3, #0]
240079f2:	4a36      	ldr	r2, [pc, #216]	; (24007acc <HAL_DMAEx_ConfigMuxSync+0x184>)
240079f4:	4293      	cmp	r3, r2
240079f6:	d003      	beq.n	24007a00 <HAL_DMAEx_ConfigMuxSync+0xb8>
240079f8:	687b      	ldr	r3, [r7, #4]
240079fa:	681b      	ldr	r3, [r3, #0]
240079fc:	4a34      	ldr	r2, [pc, #208]	; (24007ad0 <HAL_DMAEx_ConfigMuxSync+0x188>)
240079fe:	4293      	cmp	r3, r2
    }
    else
    {
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
    }
    syncSignalID = pSyncConfig->SyncSignalID;
24007a00:	683b      	ldr	r3, [r7, #0]
24007a02:	681b      	ldr	r3, [r3, #0]
24007a04:	60fb      	str	r3, [r7, #12]
    syncPolarity = pSyncConfig->SyncPolarity;
24007a06:	683b      	ldr	r3, [r7, #0]
24007a08:	685b      	ldr	r3, [r3, #4]
24007a0a:	60bb      	str	r3, [r7, #8]
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
24007a0c:	687b      	ldr	r3, [r7, #4]
24007a0e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24007a12:	b2db      	uxtb	r3, r3
24007a14:	2b01      	cmp	r3, #1
24007a16:	d131      	bne.n	24007a7c <HAL_DMAEx_ConfigMuxSync+0x134>
  {
    /* Process Locked */
    __HAL_LOCK(hdma);
24007a18:	687b      	ldr	r3, [r7, #4]
24007a1a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24007a1e:	2b01      	cmp	r3, #1
24007a20:	d101      	bne.n	24007a26 <HAL_DMAEx_ConfigMuxSync+0xde>
24007a22:	2302      	movs	r3, #2
24007a24:	e02f      	b.n	24007a86 <HAL_DMAEx_ConfigMuxSync+0x13e>
24007a26:	687b      	ldr	r3, [r7, #4]
24007a28:	2201      	movs	r2, #1
24007a2a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the synchronization and event generation before applying a new config */
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
24007a2e:	687b      	ldr	r3, [r7, #4]
24007a30:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007a32:	681a      	ldr	r2, [r3, #0]
24007a34:	687b      	ldr	r3, [r7, #4]
24007a36:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007a38:	f422 3281 	bic.w	r2, r2, #66048	; 0x10200
24007a3c:	601a      	str	r2, [r3, #0]

    /* Set the new synchronization parameters (and keep the request ID filled during the Init)*/
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
24007a3e:	687b      	ldr	r3, [r7, #4]
24007a40:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007a42:	681b      	ldr	r3, [r3, #0]
24007a44:	b2d9      	uxtb	r1, r3
24007a46:	68fb      	ldr	r3, [r7, #12]
24007a48:	061a      	lsls	r2, r3, #24
24007a4a:	683b      	ldr	r3, [r7, #0]
24007a4c:	68db      	ldr	r3, [r3, #12]
24007a4e:	3b01      	subs	r3, #1
24007a50:	04db      	lsls	r3, r3, #19
24007a52:	431a      	orrs	r2, r3
24007a54:	68bb      	ldr	r3, [r7, #8]
24007a56:	431a      	orrs	r2, r3
24007a58:	683b      	ldr	r3, [r7, #0]
24007a5a:	7a1b      	ldrb	r3, [r3, #8]
24007a5c:	041b      	lsls	r3, r3, #16
24007a5e:	431a      	orrs	r2, r3
24007a60:	683b      	ldr	r3, [r7, #0]
24007a62:	7a5b      	ldrb	r3, [r3, #9]
24007a64:	025b      	lsls	r3, r3, #9
24007a66:	431a      	orrs	r2, r3
24007a68:	687b      	ldr	r3, [r7, #4]
24007a6a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007a6c:	430a      	orrs	r2, r1
24007a6e:	601a      	str	r2, [r3, #0]
               ((pSyncConfig->RequestNumber - 1U) << DMAMUX_CxCR_NBREQ_Pos) | \
               syncPolarity | ((uint32_t)pSyncConfig->SyncEnable << DMAMUX_CxCR_SE_Pos)    | \
               ((uint32_t)pSyncConfig->EventEnable << DMAMUX_CxCR_EGE_Pos));

      /* Process Locked */
    __HAL_UNLOCK(hdma);
24007a70:	687b      	ldr	r3, [r7, #4]
24007a72:	2200      	movs	r2, #0
24007a74:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
24007a78:	2300      	movs	r3, #0
24007a7a:	e004      	b.n	24007a86 <HAL_DMAEx_ConfigMuxSync+0x13e>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24007a7c:	687b      	ldr	r3, [r7, #4]
24007a7e:	f44f 6200 	mov.w	r2, #2048	; 0x800
24007a82:	655a      	str	r2, [r3, #84]	; 0x54

    /* Return error status */
    return HAL_ERROR;
24007a84:	2301      	movs	r3, #1
  }
}
24007a86:	4618      	mov	r0, r3
24007a88:	3714      	adds	r7, #20
24007a8a:	46bd      	mov	sp, r7
24007a8c:	f85d 7b04 	ldr.w	r7, [sp], #4
24007a90:	4770      	bx	lr
24007a92:	bf00      	nop
24007a94:	40020010 	.word	0x40020010
24007a98:	40020028 	.word	0x40020028
24007a9c:	40020040 	.word	0x40020040
24007aa0:	40020058 	.word	0x40020058
24007aa4:	40020070 	.word	0x40020070
24007aa8:	40020088 	.word	0x40020088
24007aac:	400200a0 	.word	0x400200a0
24007ab0:	400200b8 	.word	0x400200b8
24007ab4:	40020410 	.word	0x40020410
24007ab8:	40020428 	.word	0x40020428
24007abc:	40020440 	.word	0x40020440
24007ac0:	40020458 	.word	0x40020458
24007ac4:	40020470 	.word	0x40020470
24007ac8:	40020488 	.word	0x40020488
24007acc:	400204a0 	.word	0x400204a0
24007ad0:	400204b8 	.word	0x400204b8

24007ad4 <HAL_DMAEx_ConfigMuxRequestGenerator>:
  *         contains the request generator parameters.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxRequestGenerator (DMA_HandleTypeDef *hdma, HAL_DMA_MuxRequestGeneratorConfigTypeDef *pRequestGeneratorConfig)
{
24007ad4:	b480      	push	{r7}
24007ad6:	b085      	sub	sp, #20
24007ad8:	af00      	add	r7, sp, #0
24007ada:	6078      	str	r0, [r7, #4]
24007adc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  HAL_DMA_StateTypeDef temp_state = hdma->State;
24007ade:	687b      	ldr	r3, [r7, #4]
24007ae0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24007ae4:	73bb      	strb	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24007ae6:	687b      	ldr	r3, [r7, #4]
24007ae8:	681b      	ldr	r3, [r3, #0]
24007aea:	4a46      	ldr	r2, [pc, #280]	; (24007c04 <HAL_DMAEx_ConfigMuxRequestGenerator+0x130>)
24007aec:	4293      	cmp	r3, r2
24007aee:	d049      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007af0:	687b      	ldr	r3, [r7, #4]
24007af2:	681b      	ldr	r3, [r3, #0]
24007af4:	4a44      	ldr	r2, [pc, #272]	; (24007c08 <HAL_DMAEx_ConfigMuxRequestGenerator+0x134>)
24007af6:	4293      	cmp	r3, r2
24007af8:	d044      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007afa:	687b      	ldr	r3, [r7, #4]
24007afc:	681b      	ldr	r3, [r3, #0]
24007afe:	4a43      	ldr	r2, [pc, #268]	; (24007c0c <HAL_DMAEx_ConfigMuxRequestGenerator+0x138>)
24007b00:	4293      	cmp	r3, r2
24007b02:	d03f      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b04:	687b      	ldr	r3, [r7, #4]
24007b06:	681b      	ldr	r3, [r3, #0]
24007b08:	4a41      	ldr	r2, [pc, #260]	; (24007c10 <HAL_DMAEx_ConfigMuxRequestGenerator+0x13c>)
24007b0a:	4293      	cmp	r3, r2
24007b0c:	d03a      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b0e:	687b      	ldr	r3, [r7, #4]
24007b10:	681b      	ldr	r3, [r3, #0]
24007b12:	4a40      	ldr	r2, [pc, #256]	; (24007c14 <HAL_DMAEx_ConfigMuxRequestGenerator+0x140>)
24007b14:	4293      	cmp	r3, r2
24007b16:	d035      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b18:	687b      	ldr	r3, [r7, #4]
24007b1a:	681b      	ldr	r3, [r3, #0]
24007b1c:	4a3e      	ldr	r2, [pc, #248]	; (24007c18 <HAL_DMAEx_ConfigMuxRequestGenerator+0x144>)
24007b1e:	4293      	cmp	r3, r2
24007b20:	d030      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b22:	687b      	ldr	r3, [r7, #4]
24007b24:	681b      	ldr	r3, [r3, #0]
24007b26:	4a3d      	ldr	r2, [pc, #244]	; (24007c1c <HAL_DMAEx_ConfigMuxRequestGenerator+0x148>)
24007b28:	4293      	cmp	r3, r2
24007b2a:	d02b      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b2c:	687b      	ldr	r3, [r7, #4]
24007b2e:	681b      	ldr	r3, [r3, #0]
24007b30:	4a3b      	ldr	r2, [pc, #236]	; (24007c20 <HAL_DMAEx_ConfigMuxRequestGenerator+0x14c>)
24007b32:	4293      	cmp	r3, r2
24007b34:	d026      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b36:	687b      	ldr	r3, [r7, #4]
24007b38:	681b      	ldr	r3, [r3, #0]
24007b3a:	4a3a      	ldr	r2, [pc, #232]	; (24007c24 <HAL_DMAEx_ConfigMuxRequestGenerator+0x150>)
24007b3c:	4293      	cmp	r3, r2
24007b3e:	d021      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b40:	687b      	ldr	r3, [r7, #4]
24007b42:	681b      	ldr	r3, [r3, #0]
24007b44:	4a38      	ldr	r2, [pc, #224]	; (24007c28 <HAL_DMAEx_ConfigMuxRequestGenerator+0x154>)
24007b46:	4293      	cmp	r3, r2
24007b48:	d01c      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b4a:	687b      	ldr	r3, [r7, #4]
24007b4c:	681b      	ldr	r3, [r3, #0]
24007b4e:	4a37      	ldr	r2, [pc, #220]	; (24007c2c <HAL_DMAEx_ConfigMuxRequestGenerator+0x158>)
24007b50:	4293      	cmp	r3, r2
24007b52:	d017      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b54:	687b      	ldr	r3, [r7, #4]
24007b56:	681b      	ldr	r3, [r3, #0]
24007b58:	4a35      	ldr	r2, [pc, #212]	; (24007c30 <HAL_DMAEx_ConfigMuxRequestGenerator+0x15c>)
24007b5a:	4293      	cmp	r3, r2
24007b5c:	d012      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b5e:	687b      	ldr	r3, [r7, #4]
24007b60:	681b      	ldr	r3, [r3, #0]
24007b62:	4a34      	ldr	r2, [pc, #208]	; (24007c34 <HAL_DMAEx_ConfigMuxRequestGenerator+0x160>)
24007b64:	4293      	cmp	r3, r2
24007b66:	d00d      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b68:	687b      	ldr	r3, [r7, #4]
24007b6a:	681b      	ldr	r3, [r3, #0]
24007b6c:	4a32      	ldr	r2, [pc, #200]	; (24007c38 <HAL_DMAEx_ConfigMuxRequestGenerator+0x164>)
24007b6e:	4293      	cmp	r3, r2
24007b70:	d008      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b72:	687b      	ldr	r3, [r7, #4]
24007b74:	681b      	ldr	r3, [r3, #0]
24007b76:	4a31      	ldr	r2, [pc, #196]	; (24007c3c <HAL_DMAEx_ConfigMuxRequestGenerator+0x168>)
24007b78:	4293      	cmp	r3, r2
24007b7a:	d003      	beq.n	24007b84 <HAL_DMAEx_ConfigMuxRequestGenerator+0xb0>
24007b7c:	687b      	ldr	r3, [r7, #4]
24007b7e:	681b      	ldr	r3, [r3, #0]
24007b80:	4a2f      	ldr	r2, [pc, #188]	; (24007c40 <HAL_DMAEx_ConfigMuxRequestGenerator+0x16c>)
24007b82:	4293      	cmp	r3, r2
  assert_param(IS_DMAMUX_REQUEST_GEN_REQUEST_NUMBER(pRequestGeneratorConfig->RequestNumber));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block
  */
  if(hdma->DMAmuxRequestGen == 0U)
24007b84:	687b      	ldr	r3, [r7, #4]
24007b86:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007b88:	2b00      	cmp	r3, #0
24007b8a:	d105      	bne.n	24007b98 <HAL_DMAEx_ConfigMuxRequestGenerator+0xc4>
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
24007b8c:	687b      	ldr	r3, [r7, #4]
24007b8e:	2240      	movs	r2, #64	; 0x40
24007b90:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
24007b92:	2301      	movs	r3, #1
24007b94:	73fb      	strb	r3, [r7, #15]
24007b96:	e02e      	b.n	24007bf6 <HAL_DMAEx_ConfigMuxRequestGenerator+0x122>
  }
  else if(((hdma->DMAmuxRequestGen->RGCR & DMAMUX_RGxCR_GE) == 0U) && (temp_state == HAL_DMA_STATE_READY))
24007b98:	687b      	ldr	r3, [r7, #4]
24007b9a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007b9c:	681b      	ldr	r3, [r3, #0]
24007b9e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24007ba2:	2b00      	cmp	r3, #0
24007ba4:	d121      	bne.n	24007bea <HAL_DMAEx_ConfigMuxRequestGenerator+0x116>
24007ba6:	7bbb      	ldrb	r3, [r7, #14]
24007ba8:	2b01      	cmp	r3, #1
24007baa:	d11e      	bne.n	24007bea <HAL_DMAEx_ConfigMuxRequestGenerator+0x116>
  {
    /* RequestGenerator must be disable prior to the configuration i.e GE bit is 0 */

    /* Process Locked */
    __HAL_LOCK(hdma);
24007bac:	687b      	ldr	r3, [r7, #4]
24007bae:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
24007bb2:	2b01      	cmp	r3, #1
24007bb4:	d101      	bne.n	24007bba <HAL_DMAEx_ConfigMuxRequestGenerator+0xe6>
24007bb6:	2302      	movs	r3, #2
24007bb8:	e01e      	b.n	24007bf8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x124>
24007bba:	687b      	ldr	r3, [r7, #4]
24007bbc:	2201      	movs	r2, #1
24007bbe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Set the request generator new parameters */
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
24007bc2:	683b      	ldr	r3, [r7, #0]
24007bc4:	681a      	ldr	r2, [r3, #0]
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
24007bc6:	683b      	ldr	r3, [r7, #0]
24007bc8:	689b      	ldr	r3, [r3, #8]
24007bca:	3b01      	subs	r3, #1
24007bcc:	04db      	lsls	r3, r3, #19
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
24007bce:	ea42 0103 	orr.w	r1, r2, r3
                                  pRequestGeneratorConfig->Polarity;
24007bd2:	683b      	ldr	r3, [r7, #0]
24007bd4:	685a      	ldr	r2, [r3, #4]
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
24007bd6:	687b      	ldr	r3, [r7, #4]
24007bd8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
                                  ((pRequestGeneratorConfig->RequestNumber - 1U) << DMAMUX_RGxCR_GNBREQ_Pos)| \
24007bda:	430a      	orrs	r2, r1
    hdma->DMAmuxRequestGen->RGCR = pRequestGeneratorConfig->SignalID | \
24007bdc:	601a      	str	r2, [r3, #0]
    /* Process Locked */
    __HAL_UNLOCK(hdma);
24007bde:	687b      	ldr	r3, [r7, #4]
24007be0:	2200      	movs	r2, #0
24007be2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_OK;
24007be6:	2300      	movs	r3, #0
24007be8:	e006      	b.n	24007bf8 <HAL_DMAEx_ConfigMuxRequestGenerator+0x124>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
24007bea:	687b      	ldr	r3, [r7, #4]
24007bec:	f44f 6200 	mov.w	r2, #2048	; 0x800
24007bf0:	655a      	str	r2, [r3, #84]	; 0x54

    /* error status */
    status = HAL_ERROR;
24007bf2:	2301      	movs	r3, #1
24007bf4:	73fb      	strb	r3, [r7, #15]
  }

  return status;
24007bf6:	7bfb      	ldrb	r3, [r7, #15]
}
24007bf8:	4618      	mov	r0, r3
24007bfa:	3714      	adds	r7, #20
24007bfc:	46bd      	mov	sp, r7
24007bfe:	f85d 7b04 	ldr.w	r7, [sp], #4
24007c02:	4770      	bx	lr
24007c04:	40020010 	.word	0x40020010
24007c08:	40020028 	.word	0x40020028
24007c0c:	40020040 	.word	0x40020040
24007c10:	40020058 	.word	0x40020058
24007c14:	40020070 	.word	0x40020070
24007c18:	40020088 	.word	0x40020088
24007c1c:	400200a0 	.word	0x400200a0
24007c20:	400200b8 	.word	0x400200b8
24007c24:	40020410 	.word	0x40020410
24007c28:	40020428 	.word	0x40020428
24007c2c:	40020440 	.word	0x40020440
24007c30:	40020458 	.word	0x40020458
24007c34:	40020470 	.word	0x40020470
24007c38:	40020488 	.word	0x40020488
24007c3c:	400204a0 	.word	0x400204a0
24007c40:	400204b8 	.word	0x400204b8

24007c44 <HAL_DMAEx_EnableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_EnableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
24007c44:	b480      	push	{r7}
24007c46:	b083      	sub	sp, #12
24007c48:	af00      	add	r7, sp, #0
24007c4a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
24007c4c:	687b      	ldr	r3, [r7, #4]
24007c4e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24007c52:	b2db      	uxtb	r3, r3
24007c54:	2b00      	cmp	r3, #0
24007c56:	d00d      	beq.n	24007c74 <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
24007c58:	687b      	ldr	r3, [r7, #4]
24007c5a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007c5c:	2b00      	cmp	r3, #0
24007c5e:	d009      	beq.n	24007c74 <HAL_DMAEx_EnableMuxRequestGenerator+0x30>
  {
    /* Enable the request generator*/
    hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_GE;
24007c60:	687b      	ldr	r3, [r7, #4]
24007c62:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007c64:	681a      	ldr	r2, [r3, #0]
24007c66:	687b      	ldr	r3, [r7, #4]
24007c68:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007c6a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24007c6e:	601a      	str	r2, [r3, #0]

   return HAL_OK;
24007c70:	2300      	movs	r3, #0
24007c72:	e000      	b.n	24007c76 <HAL_DMAEx_EnableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
24007c74:	2301      	movs	r3, #1
 }
}
24007c76:	4618      	mov	r0, r3
24007c78:	370c      	adds	r7, #12
24007c7a:	46bd      	mov	sp, r7
24007c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
24007c80:	4770      	bx	lr

24007c82 <HAL_DMAEx_DisableMuxRequestGenerator>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_DisableMuxRequestGenerator (DMA_HandleTypeDef *hdma)
{
24007c82:	b480      	push	{r7}
24007c84:	b083      	sub	sp, #12
24007c86:	af00      	add	r7, sp, #0
24007c88:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));

  /* check if the DMA state is ready
     and DMA is using a DMAMUX request generator block */
  if((hdma->State != HAL_DMA_STATE_RESET) && (hdma->DMAmuxRequestGen != 0U))
24007c8a:	687b      	ldr	r3, [r7, #4]
24007c8c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
24007c90:	b2db      	uxtb	r3, r3
24007c92:	2b00      	cmp	r3, #0
24007c94:	d00d      	beq.n	24007cb2 <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
24007c96:	687b      	ldr	r3, [r7, #4]
24007c98:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007c9a:	2b00      	cmp	r3, #0
24007c9c:	d009      	beq.n	24007cb2 <HAL_DMAEx_DisableMuxRequestGenerator+0x30>
  {
    /* Disable the request generator*/
    hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_GE;
24007c9e:	687b      	ldr	r3, [r7, #4]
24007ca0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007ca2:	681a      	ldr	r2, [r3, #0]
24007ca4:	687b      	ldr	r3, [r7, #4]
24007ca6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007ca8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
24007cac:	601a      	str	r2, [r3, #0]

   return HAL_OK;
24007cae:	2300      	movs	r3, #0
24007cb0:	e000      	b.n	24007cb4 <HAL_DMAEx_DisableMuxRequestGenerator+0x32>
 }
 else
 {
   return HAL_ERROR;
24007cb2:	2301      	movs	r3, #1
 }
}
24007cb4:	4618      	mov	r0, r3
24007cb6:	370c      	adds	r7, #12
24007cb8:	46bd      	mov	sp, r7
24007cba:	f85d 7b04 	ldr.w	r7, [sp], #4
24007cbe:	4770      	bx	lr

24007cc0 <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
24007cc0:	b580      	push	{r7, lr}
24007cc2:	b082      	sub	sp, #8
24007cc4:	af00      	add	r7, sp, #0
24007cc6:	6078      	str	r0, [r7, #4]
  /* Check for DMAMUX Synchronization overrun */
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
24007cc8:	687b      	ldr	r3, [r7, #4]
24007cca:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24007ccc:	681a      	ldr	r2, [r3, #0]
24007cce:	687b      	ldr	r3, [r7, #4]
24007cd0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24007cd2:	4013      	ands	r3, r2
24007cd4:	2b00      	cmp	r3, #0
24007cd6:	d01a      	beq.n	24007d0e <HAL_DMAEx_MUX_IRQHandler+0x4e>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
24007cd8:	687b      	ldr	r3, [r7, #4]
24007cda:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007cdc:	681a      	ldr	r2, [r3, #0]
24007cde:	687b      	ldr	r3, [r7, #4]
24007ce0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24007ce2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24007ce6:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
24007ce8:	687b      	ldr	r3, [r7, #4]
24007cea:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24007cec:	687a      	ldr	r2, [r7, #4]
24007cee:	6e92      	ldr	r2, [r2, #104]	; 0x68
24007cf0:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
24007cf2:	687b      	ldr	r3, [r7, #4]
24007cf4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24007cf6:	f443 7200 	orr.w	r2, r3, #512	; 0x200
24007cfa:	687b      	ldr	r3, [r7, #4]
24007cfc:	655a      	str	r2, [r3, #84]	; 0x54

    if(hdma->XferErrorCallback != NULL)
24007cfe:	687b      	ldr	r3, [r7, #4]
24007d00:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24007d02:	2b00      	cmp	r3, #0
24007d04:	d003      	beq.n	24007d0e <HAL_DMAEx_MUX_IRQHandler+0x4e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
24007d06:	687b      	ldr	r3, [r7, #4]
24007d08:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24007d0a:	6878      	ldr	r0, [r7, #4]
24007d0c:	4798      	blx	r3
    }
  }

  if(hdma->DMAmuxRequestGen != 0)
24007d0e:	687b      	ldr	r3, [r7, #4]
24007d10:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007d12:	2b00      	cmp	r3, #0
24007d14:	d022      	beq.n	24007d5c <HAL_DMAEx_MUX_IRQHandler+0x9c>
  {
   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
24007d16:	687b      	ldr	r3, [r7, #4]
24007d18:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24007d1a:	681a      	ldr	r2, [r3, #0]
24007d1c:	687b      	ldr	r3, [r7, #4]
24007d1e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24007d20:	4013      	ands	r3, r2
24007d22:	2b00      	cmp	r3, #0
24007d24:	d01a      	beq.n	24007d5c <HAL_DMAEx_MUX_IRQHandler+0x9c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
24007d26:	687b      	ldr	r3, [r7, #4]
24007d28:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007d2a:	681a      	ldr	r2, [r3, #0]
24007d2c:	687b      	ldr	r3, [r7, #4]
24007d2e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24007d30:	f422 7280 	bic.w	r2, r2, #256	; 0x100
24007d34:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
24007d36:	687b      	ldr	r3, [r7, #4]
24007d38:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24007d3a:	687a      	ldr	r2, [r7, #4]
24007d3c:	6f52      	ldr	r2, [r2, #116]	; 0x74
24007d3e:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
24007d40:	687b      	ldr	r3, [r7, #4]
24007d42:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24007d44:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
24007d48:	687b      	ldr	r3, [r7, #4]
24007d4a:	655a      	str	r2, [r3, #84]	; 0x54

      if(hdma->XferErrorCallback != NULL)
24007d4c:	687b      	ldr	r3, [r7, #4]
24007d4e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24007d50:	2b00      	cmp	r3, #0
24007d52:	d003      	beq.n	24007d5c <HAL_DMAEx_MUX_IRQHandler+0x9c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
24007d54:	687b      	ldr	r3, [r7, #4]
24007d56:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24007d58:	6878      	ldr	r0, [r7, #4]
24007d5a:	4798      	blx	r3
      }
    }
  }
}
24007d5c:	bf00      	nop
24007d5e:	3708      	adds	r7, #8
24007d60:	46bd      	mov	sp, r7
24007d62:	bd80      	pop	{r7, pc}

24007d64 <DMA_MultiBufferSetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_MultiBufferSetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
24007d64:	b480      	push	{r7}
24007d66:	b085      	sub	sp, #20
24007d68:	af00      	add	r7, sp, #0
24007d6a:	60f8      	str	r0, [r7, #12]
24007d6c:	60b9      	str	r1, [r7, #8]
24007d6e:	607a      	str	r2, [r7, #4]
24007d70:	603b      	str	r3, [r7, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
24007d72:	68fb      	ldr	r3, [r7, #12]
24007d74:	681b      	ldr	r3, [r3, #0]
24007d76:	4a46      	ldr	r2, [pc, #280]	; (24007e90 <DMA_MultiBufferSetConfig+0x12c>)
24007d78:	4293      	cmp	r3, r2
24007d7a:	d04a      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007d7c:	68fb      	ldr	r3, [r7, #12]
24007d7e:	681b      	ldr	r3, [r3, #0]
24007d80:	4a44      	ldr	r2, [pc, #272]	; (24007e94 <DMA_MultiBufferSetConfig+0x130>)
24007d82:	4293      	cmp	r3, r2
24007d84:	d045      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007d86:	68fb      	ldr	r3, [r7, #12]
24007d88:	681b      	ldr	r3, [r3, #0]
24007d8a:	4a43      	ldr	r2, [pc, #268]	; (24007e98 <DMA_MultiBufferSetConfig+0x134>)
24007d8c:	4293      	cmp	r3, r2
24007d8e:	d040      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007d90:	68fb      	ldr	r3, [r7, #12]
24007d92:	681b      	ldr	r3, [r3, #0]
24007d94:	4a41      	ldr	r2, [pc, #260]	; (24007e9c <DMA_MultiBufferSetConfig+0x138>)
24007d96:	4293      	cmp	r3, r2
24007d98:	d03b      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007d9a:	68fb      	ldr	r3, [r7, #12]
24007d9c:	681b      	ldr	r3, [r3, #0]
24007d9e:	4a40      	ldr	r2, [pc, #256]	; (24007ea0 <DMA_MultiBufferSetConfig+0x13c>)
24007da0:	4293      	cmp	r3, r2
24007da2:	d036      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007da4:	68fb      	ldr	r3, [r7, #12]
24007da6:	681b      	ldr	r3, [r3, #0]
24007da8:	4a3e      	ldr	r2, [pc, #248]	; (24007ea4 <DMA_MultiBufferSetConfig+0x140>)
24007daa:	4293      	cmp	r3, r2
24007dac:	d031      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007dae:	68fb      	ldr	r3, [r7, #12]
24007db0:	681b      	ldr	r3, [r3, #0]
24007db2:	4a3d      	ldr	r2, [pc, #244]	; (24007ea8 <DMA_MultiBufferSetConfig+0x144>)
24007db4:	4293      	cmp	r3, r2
24007db6:	d02c      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007db8:	68fb      	ldr	r3, [r7, #12]
24007dba:	681b      	ldr	r3, [r3, #0]
24007dbc:	4a3b      	ldr	r2, [pc, #236]	; (24007eac <DMA_MultiBufferSetConfig+0x148>)
24007dbe:	4293      	cmp	r3, r2
24007dc0:	d027      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007dc2:	68fb      	ldr	r3, [r7, #12]
24007dc4:	681b      	ldr	r3, [r3, #0]
24007dc6:	4a3a      	ldr	r2, [pc, #232]	; (24007eb0 <DMA_MultiBufferSetConfig+0x14c>)
24007dc8:	4293      	cmp	r3, r2
24007dca:	d022      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007dcc:	68fb      	ldr	r3, [r7, #12]
24007dce:	681b      	ldr	r3, [r3, #0]
24007dd0:	4a38      	ldr	r2, [pc, #224]	; (24007eb4 <DMA_MultiBufferSetConfig+0x150>)
24007dd2:	4293      	cmp	r3, r2
24007dd4:	d01d      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007dd6:	68fb      	ldr	r3, [r7, #12]
24007dd8:	681b      	ldr	r3, [r3, #0]
24007dda:	4a37      	ldr	r2, [pc, #220]	; (24007eb8 <DMA_MultiBufferSetConfig+0x154>)
24007ddc:	4293      	cmp	r3, r2
24007dde:	d018      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007de0:	68fb      	ldr	r3, [r7, #12]
24007de2:	681b      	ldr	r3, [r3, #0]
24007de4:	4a35      	ldr	r2, [pc, #212]	; (24007ebc <DMA_MultiBufferSetConfig+0x158>)
24007de6:	4293      	cmp	r3, r2
24007de8:	d013      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007dea:	68fb      	ldr	r3, [r7, #12]
24007dec:	681b      	ldr	r3, [r3, #0]
24007dee:	4a34      	ldr	r2, [pc, #208]	; (24007ec0 <DMA_MultiBufferSetConfig+0x15c>)
24007df0:	4293      	cmp	r3, r2
24007df2:	d00e      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007df4:	68fb      	ldr	r3, [r7, #12]
24007df6:	681b      	ldr	r3, [r3, #0]
24007df8:	4a32      	ldr	r2, [pc, #200]	; (24007ec4 <DMA_MultiBufferSetConfig+0x160>)
24007dfa:	4293      	cmp	r3, r2
24007dfc:	d009      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007dfe:	68fb      	ldr	r3, [r7, #12]
24007e00:	681b      	ldr	r3, [r3, #0]
24007e02:	4a31      	ldr	r2, [pc, #196]	; (24007ec8 <DMA_MultiBufferSetConfig+0x164>)
24007e04:	4293      	cmp	r3, r2
24007e06:	d004      	beq.n	24007e12 <DMA_MultiBufferSetConfig+0xae>
24007e08:	68fb      	ldr	r3, [r7, #12]
24007e0a:	681b      	ldr	r3, [r3, #0]
24007e0c:	4a2f      	ldr	r2, [pc, #188]	; (24007ecc <DMA_MultiBufferSetConfig+0x168>)
24007e0e:	4293      	cmp	r3, r2
24007e10:	d101      	bne.n	24007e16 <DMA_MultiBufferSetConfig+0xb2>
24007e12:	2301      	movs	r3, #1
24007e14:	e000      	b.n	24007e18 <DMA_MultiBufferSetConfig+0xb4>
24007e16:	2300      	movs	r3, #0
24007e18:	2b00      	cmp	r3, #0
24007e1a:	d019      	beq.n	24007e50 <DMA_MultiBufferSetConfig+0xec>
  {
    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = DataLength;
24007e1c:	68fb      	ldr	r3, [r7, #12]
24007e1e:	681b      	ldr	r3, [r3, #0]
24007e20:	683a      	ldr	r2, [r7, #0]
24007e22:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24007e24:	68fb      	ldr	r3, [r7, #12]
24007e26:	689b      	ldr	r3, [r3, #8]
24007e28:	2b40      	cmp	r3, #64	; 0x40
24007e2a:	d108      	bne.n	24007e3e <DMA_MultiBufferSetConfig+0xda>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = DstAddress;
24007e2c:	68fb      	ldr	r3, [r7, #12]
24007e2e:	681b      	ldr	r3, [r3, #0]
24007e30:	687a      	ldr	r2, [r7, #4]
24007e32:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = SrcAddress;
24007e34:	68fb      	ldr	r3, [r7, #12]
24007e36:	681b      	ldr	r3, [r3, #0]
24007e38:	68ba      	ldr	r2, [r7, #8]
24007e3a:	60da      	str	r2, [r3, #12]

      /* Configure DMA Stream destination address */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
    }
  }
}
24007e3c:	e021      	b.n	24007e82 <DMA_MultiBufferSetConfig+0x11e>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR = SrcAddress;
24007e3e:	68fb      	ldr	r3, [r7, #12]
24007e40:	681b      	ldr	r3, [r3, #0]
24007e42:	68ba      	ldr	r2, [r7, #8]
24007e44:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = DstAddress;
24007e46:	68fb      	ldr	r3, [r7, #12]
24007e48:	681b      	ldr	r3, [r3, #0]
24007e4a:	687a      	ldr	r2, [r7, #4]
24007e4c:	60da      	str	r2, [r3, #12]
}
24007e4e:	e018      	b.n	24007e82 <DMA_MultiBufferSetConfig+0x11e>
    ((BDMA_Channel_TypeDef   *)hdma->Instance)->CNDTR = DataLength;
24007e50:	68fb      	ldr	r3, [r7, #12]
24007e52:	681b      	ldr	r3, [r3, #0]
24007e54:	683a      	ldr	r2, [r7, #0]
24007e56:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
24007e58:	68fb      	ldr	r3, [r7, #12]
24007e5a:	689b      	ldr	r3, [r3, #8]
24007e5c:	2b40      	cmp	r3, #64	; 0x40
24007e5e:	d108      	bne.n	24007e72 <DMA_MultiBufferSetConfig+0x10e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = DstAddress;
24007e60:	68fb      	ldr	r3, [r7, #12]
24007e62:	681b      	ldr	r3, [r3, #0]
24007e64:	687a      	ldr	r2, [r7, #4]
24007e66:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = SrcAddress;
24007e68:	68fb      	ldr	r3, [r7, #12]
24007e6a:	681b      	ldr	r3, [r3, #0]
24007e6c:	68ba      	ldr	r2, [r7, #8]
24007e6e:	60da      	str	r2, [r3, #12]
}
24007e70:	e007      	b.n	24007e82 <DMA_MultiBufferSetConfig+0x11e>
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CPAR = SrcAddress;
24007e72:	68fb      	ldr	r3, [r7, #12]
24007e74:	681b      	ldr	r3, [r3, #0]
24007e76:	68ba      	ldr	r2, [r7, #8]
24007e78:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CM0AR = DstAddress;
24007e7a:	68fb      	ldr	r3, [r7, #12]
24007e7c:	681b      	ldr	r3, [r3, #0]
24007e7e:	687a      	ldr	r2, [r7, #4]
24007e80:	60da      	str	r2, [r3, #12]
}
24007e82:	bf00      	nop
24007e84:	3714      	adds	r7, #20
24007e86:	46bd      	mov	sp, r7
24007e88:	f85d 7b04 	ldr.w	r7, [sp], #4
24007e8c:	4770      	bx	lr
24007e8e:	bf00      	nop
24007e90:	40020010 	.word	0x40020010
24007e94:	40020028 	.word	0x40020028
24007e98:	40020040 	.word	0x40020040
24007e9c:	40020058 	.word	0x40020058
24007ea0:	40020070 	.word	0x40020070
24007ea4:	40020088 	.word	0x40020088
24007ea8:	400200a0 	.word	0x400200a0
24007eac:	400200b8 	.word	0x400200b8
24007eb0:	40020410 	.word	0x40020410
24007eb4:	40020428 	.word	0x40020428
24007eb8:	40020440 	.word	0x40020440
24007ebc:	40020458 	.word	0x40020458
24007ec0:	40020470 	.word	0x40020470
24007ec4:	40020488 	.word	0x40020488
24007ec8:	400204a0 	.word	0x400204a0
24007ecc:	400204b8 	.word	0x400204b8

24007ed0 <HAL_EXTI_SetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on EXTI configuration to be set.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
24007ed0:	b480      	push	{r7}
24007ed2:	b089      	sub	sp, #36	; 0x24
24007ed4:	af00      	add	r7, sp, #0
24007ed6:	6078      	str	r0, [r7, #4]
24007ed8:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
24007eda:	687b      	ldr	r3, [r7, #4]
24007edc:	2b00      	cmp	r3, #0
24007ede:	d002      	beq.n	24007ee6 <HAL_EXTI_SetConfigLine+0x16>
24007ee0:	683b      	ldr	r3, [r7, #0]
24007ee2:	2b00      	cmp	r3, #0
24007ee4:	d101      	bne.n	24007eea <HAL_EXTI_SetConfigLine+0x1a>
  {
    return HAL_ERROR;
24007ee6:	2301      	movs	r3, #1
24007ee8:	e109      	b.n	240080fe <HAL_EXTI_SetConfigLine+0x22e>
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(pExtiConfig->Line));
  assert_param(IS_EXTI_MODE(pExtiConfig->Mode));

  /* Assign line number to handle */
  hexti->Line = pExtiConfig->Line;
24007eea:	683b      	ldr	r3, [r7, #0]
24007eec:	681a      	ldr	r2, [r3, #0]
24007eee:	687b      	ldr	r3, [r7, #4]
24007ef0:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24007ef2:	683b      	ldr	r3, [r7, #0]
24007ef4:	681b      	ldr	r3, [r3, #0]
24007ef6:	0c1b      	lsrs	r3, r3, #16
24007ef8:	f003 0303 	and.w	r3, r3, #3
24007efc:	613b      	str	r3, [r7, #16]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
24007efe:	683b      	ldr	r3, [r7, #0]
24007f00:	681b      	ldr	r3, [r3, #0]
24007f02:	f003 031f 	and.w	r3, r3, #31
24007f06:	60fb      	str	r3, [r7, #12]
  maskline = (1UL << linepos);
24007f08:	2201      	movs	r2, #1
24007f0a:	68fb      	ldr	r3, [r7, #12]
24007f0c:	fa02 f303 	lsl.w	r3, r2, r3
24007f10:	60bb      	str	r3, [r7, #8]

  /* Configure triggers for configurable lines */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
24007f12:	683b      	ldr	r3, [r7, #0]
24007f14:	681b      	ldr	r3, [r3, #0]
24007f16:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24007f1a:	2b00      	cmp	r3, #0
24007f1c:	d064      	beq.n	24007fe8 <HAL_EXTI_SetConfigLine+0x118>
  {
    assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));

    /* Configure rising trigger */
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
24007f1e:	693b      	ldr	r3, [r7, #16]
24007f20:	015b      	lsls	r3, r3, #5
24007f22:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
24007f26:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24007f28:	69fb      	ldr	r3, [r7, #28]
24007f2a:	681b      	ldr	r3, [r3, #0]
24007f2c:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00U)
24007f2e:	683b      	ldr	r3, [r7, #0]
24007f30:	689b      	ldr	r3, [r3, #8]
24007f32:	f003 0301 	and.w	r3, r3, #1
24007f36:	2b00      	cmp	r3, #0
24007f38:	d004      	beq.n	24007f44 <HAL_EXTI_SetConfigLine+0x74>
    {
      regval |= maskline;
24007f3a:	69ba      	ldr	r2, [r7, #24]
24007f3c:	68bb      	ldr	r3, [r7, #8]
24007f3e:	4313      	orrs	r3, r2
24007f40:	61bb      	str	r3, [r7, #24]
24007f42:	e004      	b.n	24007f4e <HAL_EXTI_SetConfigLine+0x7e>
    }
    else
    {
      regval &= ~maskline;
24007f44:	68bb      	ldr	r3, [r7, #8]
24007f46:	43db      	mvns	r3, r3
24007f48:	69ba      	ldr	r2, [r7, #24]
24007f4a:	4013      	ands	r3, r2
24007f4c:	61bb      	str	r3, [r7, #24]
    }

    /* Store rising trigger mode */
    *regaddr = regval;
24007f4e:	69fb      	ldr	r3, [r7, #28]
24007f50:	69ba      	ldr	r2, [r7, #24]
24007f52:	601a      	str	r2, [r3, #0]

    /* Configure falling trigger */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24007f54:	693b      	ldr	r3, [r7, #16]
24007f56:	015a      	lsls	r2, r3, #5
24007f58:	4b6c      	ldr	r3, [pc, #432]	; (2400810c <HAL_EXTI_SetConfigLine+0x23c>)
24007f5a:	4413      	add	r3, r2
24007f5c:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
24007f5e:	69fb      	ldr	r3, [r7, #28]
24007f60:	681b      	ldr	r3, [r3, #0]
24007f62:	61bb      	str	r3, [r7, #24]

    /* Mask or set line */
    if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00U)
24007f64:	683b      	ldr	r3, [r7, #0]
24007f66:	689b      	ldr	r3, [r3, #8]
24007f68:	f003 0302 	and.w	r3, r3, #2
24007f6c:	2b00      	cmp	r3, #0
24007f6e:	d004      	beq.n	24007f7a <HAL_EXTI_SetConfigLine+0xaa>
    {
      regval |= maskline;
24007f70:	69ba      	ldr	r2, [r7, #24]
24007f72:	68bb      	ldr	r3, [r7, #8]
24007f74:	4313      	orrs	r3, r2
24007f76:	61bb      	str	r3, [r7, #24]
24007f78:	e004      	b.n	24007f84 <HAL_EXTI_SetConfigLine+0xb4>
    }
    else
    {
      regval &= ~maskline;
24007f7a:	68bb      	ldr	r3, [r7, #8]
24007f7c:	43db      	mvns	r3, r3
24007f7e:	69ba      	ldr	r2, [r7, #24]
24007f80:	4013      	ands	r3, r2
24007f82:	61bb      	str	r3, [r7, #24]
    }

    /* Store falling trigger mode */
    *regaddr = regval;
24007f84:	69fb      	ldr	r3, [r7, #28]
24007f86:	69ba      	ldr	r2, [r7, #24]
24007f88:	601a      	str	r2, [r3, #0]

    /* Configure gpio port selection in case of gpio exti line */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
24007f8a:	683b      	ldr	r3, [r7, #0]
24007f8c:	681b      	ldr	r3, [r3, #0]
24007f8e:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
24007f92:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
24007f96:	d127      	bne.n	24007fe8 <HAL_EXTI_SetConfigLine+0x118>
    {
      assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24007f98:	4a5d      	ldr	r2, [pc, #372]	; (24008110 <HAL_EXTI_SetConfigLine+0x240>)
24007f9a:	68fb      	ldr	r3, [r7, #12]
24007f9c:	089b      	lsrs	r3, r3, #2
24007f9e:	f003 0303 	and.w	r3, r3, #3
24007fa2:	3302      	adds	r3, #2
24007fa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24007fa8:	61bb      	str	r3, [r7, #24]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
24007faa:	68fb      	ldr	r3, [r7, #12]
24007fac:	f003 0303 	and.w	r3, r3, #3
24007fb0:	009b      	lsls	r3, r3, #2
24007fb2:	220f      	movs	r2, #15
24007fb4:	fa02 f303 	lsl.w	r3, r2, r3
24007fb8:	43db      	mvns	r3, r3
24007fba:	69ba      	ldr	r2, [r7, #24]
24007fbc:	4013      	ands	r3, r2
24007fbe:	61bb      	str	r3, [r7, #24]
      regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03U)));
24007fc0:	683b      	ldr	r3, [r7, #0]
24007fc2:	68da      	ldr	r2, [r3, #12]
24007fc4:	68fb      	ldr	r3, [r7, #12]
24007fc6:	f003 0303 	and.w	r3, r3, #3
24007fca:	009b      	lsls	r3, r3, #2
24007fcc:	fa02 f303 	lsl.w	r3, r2, r3
24007fd0:	69ba      	ldr	r2, [r7, #24]
24007fd2:	4313      	orrs	r3, r2
24007fd4:	61bb      	str	r3, [r7, #24]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
24007fd6:	494e      	ldr	r1, [pc, #312]	; (24008110 <HAL_EXTI_SetConfigLine+0x240>)
24007fd8:	68fb      	ldr	r3, [r7, #12]
24007fda:	089b      	lsrs	r3, r3, #2
24007fdc:	f003 0303 	and.w	r3, r3, #3
24007fe0:	3302      	adds	r3, #2
24007fe2:	69ba      	ldr	r2, [r7, #24]
24007fe4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* Configure interrupt mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24007fe8:	693b      	ldr	r3, [r7, #16]
24007fea:	011a      	lsls	r2, r3, #4
24007fec:	4b49      	ldr	r3, [pc, #292]	; (24008114 <HAL_EXTI_SetConfigLine+0x244>)
24007fee:	4413      	add	r3, r2
24007ff0:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24007ff2:	69fb      	ldr	r3, [r7, #28]
24007ff4:	681b      	ldr	r3, [r3, #0]
24007ff6:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00U)
24007ff8:	683b      	ldr	r3, [r7, #0]
24007ffa:	685b      	ldr	r3, [r3, #4]
24007ffc:	f003 0301 	and.w	r3, r3, #1
24008000:	2b00      	cmp	r3, #0
24008002:	d004      	beq.n	2400800e <HAL_EXTI_SetConfigLine+0x13e>
  {
    regval |= maskline;
24008004:	69ba      	ldr	r2, [r7, #24]
24008006:	68bb      	ldr	r3, [r7, #8]
24008008:	4313      	orrs	r3, r2
2400800a:	61bb      	str	r3, [r7, #24]
2400800c:	e004      	b.n	24008018 <HAL_EXTI_SetConfigLine+0x148>
  }
  else
  {
    regval &= ~maskline;
2400800e:	68bb      	ldr	r3, [r7, #8]
24008010:	43db      	mvns	r3, r3
24008012:	69ba      	ldr	r2, [r7, #24]
24008014:	4013      	ands	r3, r2
24008016:	61bb      	str	r3, [r7, #24]
  }

  /* Store interrupt mode */
  *regaddr = regval;
24008018:	69fb      	ldr	r3, [r7, #28]
2400801a:	69ba      	ldr	r2, [r7, #24]
2400801c:	601a      	str	r2, [r3, #0]

  /* The event mode cannot be configured if the line does not support it */
  assert_param(((pExtiConfig->Line & EXTI_EVENT) == EXTI_EVENT) || ((pExtiConfig->Mode & EXTI_MODE_EVENT) != EXTI_MODE_EVENT));

  /* Configure event mode : read current mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
2400801e:	693b      	ldr	r3, [r7, #16]
24008020:	011a      	lsls	r2, r3, #4
24008022:	4b3d      	ldr	r3, [pc, #244]	; (24008118 <HAL_EXTI_SetConfigLine+0x248>)
24008024:	4413      	add	r3, r2
24008026:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24008028:	69fb      	ldr	r3, [r7, #28]
2400802a:	681b      	ldr	r3, [r3, #0]
2400802c:	61bb      	str	r3, [r7, #24]

  /* Mask or set line */
  if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00U)
2400802e:	683b      	ldr	r3, [r7, #0]
24008030:	685b      	ldr	r3, [r3, #4]
24008032:	f003 0302 	and.w	r3, r3, #2
24008036:	2b00      	cmp	r3, #0
24008038:	d004      	beq.n	24008044 <HAL_EXTI_SetConfigLine+0x174>
  {
    regval |= maskline;
2400803a:	69ba      	ldr	r2, [r7, #24]
2400803c:	68bb      	ldr	r3, [r7, #8]
2400803e:	4313      	orrs	r3, r2
24008040:	61bb      	str	r3, [r7, #24]
24008042:	e004      	b.n	2400804e <HAL_EXTI_SetConfigLine+0x17e>
  }
  else
  {
    regval &= ~maskline;
24008044:	68bb      	ldr	r3, [r7, #8]
24008046:	43db      	mvns	r3, r3
24008048:	69ba      	ldr	r2, [r7, #24]
2400804a:	4013      	ands	r3, r2
2400804c:	61bb      	str	r3, [r7, #24]
  }

  /* Store event mode */
  *regaddr = regval;
2400804e:	69fb      	ldr	r3, [r7, #28]
24008050:	69ba      	ldr	r2, [r7, #24]
24008052:	601a      	str	r2, [r3, #0]
  /* Store event mode */
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* Configure the D3 PendClear source in case of Wakeup target is Any */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24008054:	683b      	ldr	r3, [r7, #0]
24008056:	681b      	ldr	r3, [r3, #0]
24008058:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
2400805c:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24008060:	d14c      	bne.n	240080fc <HAL_EXTI_SetConfigLine+0x22c>
  {
    assert_param(IS_EXTI_D3_PENDCLR_SRC(pExtiConfig->PendClearSource));

    /*Calc the PMR register address for the given line */
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
24008062:	693b      	ldr	r3, [r7, #16]
24008064:	015a      	lsls	r2, r3, #5
24008066:	4b2d      	ldr	r3, [pc, #180]	; (2400811c <HAL_EXTI_SetConfigLine+0x24c>)
24008068:	4413      	add	r3, r2
2400806a:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
2400806c:	69fb      	ldr	r3, [r7, #28]
2400806e:	681b      	ldr	r3, [r3, #0]
24008070:	61bb      	str	r3, [r7, #24]

    if(pExtiConfig->PendClearSource == EXTI_D3_PENDCLR_SRC_NONE)
24008072:	683b      	ldr	r3, [r7, #0]
24008074:	691b      	ldr	r3, [r3, #16]
24008076:	2b00      	cmp	r3, #0
24008078:	d108      	bne.n	2400808c <HAL_EXTI_SetConfigLine+0x1bc>
    {
      /* Clear D3PMRx register for the given line */
      regval &= ~maskline;
2400807a:	68bb      	ldr	r3, [r7, #8]
2400807c:	43db      	mvns	r3, r3
2400807e:	69ba      	ldr	r2, [r7, #24]
24008080:	4013      	ands	r3, r2
24008082:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
24008084:	69fb      	ldr	r3, [r7, #28]
24008086:	69ba      	ldr	r2, [r7, #24]
24008088:	601a      	str	r2, [r3, #0]
2400808a:	e037      	b.n	240080fc <HAL_EXTI_SetConfigLine+0x22c>
    }
    else
    {
      /* Set D3PMRx register to 1 for the given line */
      regval |= maskline;
2400808c:	69ba      	ldr	r2, [r7, #24]
2400808e:	68bb      	ldr	r3, [r7, #8]
24008090:	4313      	orrs	r3, r2
24008092:	61bb      	str	r3, [r7, #24]
      /* Store D3PMRx register value */
      *regaddr = regval;
24008094:	69fb      	ldr	r3, [r7, #28]
24008096:	69ba      	ldr	r2, [r7, #24]
24008098:	601a      	str	r2, [r3, #0]

      if(linepos < 16UL)
2400809a:	68fb      	ldr	r3, [r7, #12]
2400809c:	2b0f      	cmp	r3, #15
2400809e:	d80a      	bhi.n	240080b6 <HAL_EXTI_SetConfigLine+0x1e6>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
240080a0:	693b      	ldr	r3, [r7, #16]
240080a2:	015a      	lsls	r2, r3, #5
240080a4:	4b1e      	ldr	r3, [pc, #120]	; (24008120 <HAL_EXTI_SetConfigLine+0x250>)
240080a6:	4413      	add	r3, r2
240080a8:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
240080aa:	2201      	movs	r2, #1
240080ac:	68fb      	ldr	r3, [r7, #12]
240080ae:	fa02 f303 	lsl.w	r3, r2, r3
240080b2:	617b      	str	r3, [r7, #20]
240080b4:	e00a      	b.n	240080cc <HAL_EXTI_SetConfigLine+0x1fc>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
240080b6:	693b      	ldr	r3, [r7, #16]
240080b8:	015a      	lsls	r2, r3, #5
240080ba:	4b1a      	ldr	r3, [pc, #104]	; (24008124 <HAL_EXTI_SetConfigLine+0x254>)
240080bc:	4413      	add	r3, r2
240080be:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
240080c0:	68fb      	ldr	r3, [r7, #12]
240080c2:	3b10      	subs	r3, #16
240080c4:	2201      	movs	r2, #1
240080c6:	fa02 f303 	lsl.w	r3, r2, r3
240080ca:	617b      	str	r3, [r7, #20]
      }

      regval = (*regaddr & (~(pcrlinepos * pcrlinepos * 3UL))) | (pcrlinepos * pcrlinepos * (pExtiConfig->PendClearSource - 1UL));
240080cc:	69fb      	ldr	r3, [r7, #28]
240080ce:	6819      	ldr	r1, [r3, #0]
240080d0:	697b      	ldr	r3, [r7, #20]
240080d2:	fb03 f203 	mul.w	r2, r3, r3
240080d6:	4613      	mov	r3, r2
240080d8:	005b      	lsls	r3, r3, #1
240080da:	4413      	add	r3, r2
240080dc:	43db      	mvns	r3, r3
240080de:	ea01 0203 	and.w	r2, r1, r3
240080e2:	697b      	ldr	r3, [r7, #20]
240080e4:	fb03 f303 	mul.w	r3, r3, r3
240080e8:	6839      	ldr	r1, [r7, #0]
240080ea:	6909      	ldr	r1, [r1, #16]
240080ec:	3901      	subs	r1, #1
240080ee:	fb01 f303 	mul.w	r3, r1, r3
240080f2:	4313      	orrs	r3, r2
240080f4:	61bb      	str	r3, [r7, #24]
      *regaddr = regval;
240080f6:	69fb      	ldr	r3, [r7, #28]
240080f8:	69ba      	ldr	r2, [r7, #24]
240080fa:	601a      	str	r2, [r3, #0]
    }
  }

  return HAL_OK;
240080fc:	2300      	movs	r3, #0
}
240080fe:	4618      	mov	r0, r3
24008100:	3724      	adds	r7, #36	; 0x24
24008102:	46bd      	mov	sp, r7
24008104:	f85d 7b04 	ldr.w	r7, [sp], #4
24008108:	4770      	bx	lr
2400810a:	bf00      	nop
2400810c:	58000004 	.word	0x58000004
24008110:	58000400 	.word	0x58000400
24008114:	58000080 	.word	0x58000080
24008118:	58000084 	.word	0x58000084
2400811c:	5800000c 	.word	0x5800000c
24008120:	58000010 	.word	0x58000010
24008124:	58000014 	.word	0x58000014

24008128 <HAL_EXTI_GetConfigLine>:
  * @param  hexti Exti handle.
  * @param  pExtiConfig Pointer on structure to store Exti configuration.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
{
24008128:	b480      	push	{r7}
2400812a:	b089      	sub	sp, #36	; 0x24
2400812c:	af00      	add	r7, sp, #0
2400812e:	6078      	str	r0, [r7, #4]
24008130:	6039      	str	r1, [r7, #0]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if ((hexti == NULL) || (pExtiConfig == NULL))
24008132:	687b      	ldr	r3, [r7, #4]
24008134:	2b00      	cmp	r3, #0
24008136:	d002      	beq.n	2400813e <HAL_EXTI_GetConfigLine+0x16>
24008138:	683b      	ldr	r3, [r7, #0]
2400813a:	2b00      	cmp	r3, #0
2400813c:	d101      	bne.n	24008142 <HAL_EXTI_GetConfigLine+0x1a>
  {
    return HAL_ERROR;
2400813e:	2301      	movs	r3, #1
24008140:	e0c4      	b.n	240082cc <HAL_EXTI_GetConfigLine+0x1a4>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* Store handle line number to configuration structure */
  pExtiConfig->Line = hexti->Line;
24008142:	687b      	ldr	r3, [r7, #4]
24008144:	681a      	ldr	r2, [r3, #0]
24008146:	683b      	ldr	r3, [r7, #0]
24008148:	601a      	str	r2, [r3, #0]

  /* compute line register offset and line mask */
  offset = ((pExtiConfig->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2400814a:	683b      	ldr	r3, [r7, #0]
2400814c:	681b      	ldr	r3, [r3, #0]
2400814e:	0c1b      	lsrs	r3, r3, #16
24008150:	f003 0303 	and.w	r3, r3, #3
24008154:	617b      	str	r3, [r7, #20]
  linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
24008156:	683b      	ldr	r3, [r7, #0]
24008158:	681b      	ldr	r3, [r3, #0]
2400815a:	f003 031f 	and.w	r3, r3, #31
2400815e:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
24008160:	2201      	movs	r2, #1
24008162:	693b      	ldr	r3, [r7, #16]
24008164:	fa02 f303 	lsl.w	r3, r2, r3
24008168:	60fb      	str	r3, [r7, #12]

  /* 1] Get core mode : interrupt */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
2400816a:	697b      	ldr	r3, [r7, #20]
2400816c:	011a      	lsls	r2, r3, #4
2400816e:	4b5a      	ldr	r3, [pc, #360]	; (240082d8 <HAL_EXTI_GetConfigLine+0x1b0>)
24008170:	4413      	add	r3, r2
24008172:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
24008174:	69fb      	ldr	r3, [r7, #28]
24008176:	681b      	ldr	r3, [r3, #0]
24008178:	60bb      	str	r3, [r7, #8]

  pExtiConfig->Mode = EXTI_MODE_NONE;
2400817a:	683b      	ldr	r3, [r7, #0]
2400817c:	2200      	movs	r2, #0
2400817e:	605a      	str	r2, [r3, #4]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
24008180:	68ba      	ldr	r2, [r7, #8]
24008182:	68fb      	ldr	r3, [r7, #12]
24008184:	4013      	ands	r3, r2
24008186:	2b00      	cmp	r3, #0
24008188:	d002      	beq.n	24008190 <HAL_EXTI_GetConfigLine+0x68>
  {
    pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
2400818a:	683b      	ldr	r3, [r7, #0]
2400818c:	2201      	movs	r2, #1
2400818e:	605a      	str	r2, [r3, #4]
  }

  /* Get event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
24008190:	697b      	ldr	r3, [r7, #20]
24008192:	011a      	lsls	r2, r3, #4
24008194:	4b51      	ldr	r3, [pc, #324]	; (240082dc <HAL_EXTI_GetConfigLine+0x1b4>)
24008196:	4413      	add	r3, r2
24008198:	61fb      	str	r3, [r7, #28]
  regval = *regaddr;
2400819a:	69fb      	ldr	r3, [r7, #28]
2400819c:	681b      	ldr	r3, [r3, #0]
2400819e:	60bb      	str	r3, [r7, #8]

  /* Check if selected line is enable */
  if ((regval & maskline) != 0x00U)
240081a0:	68ba      	ldr	r2, [r7, #8]
240081a2:	68fb      	ldr	r3, [r7, #12]
240081a4:	4013      	ands	r3, r2
240081a6:	2b00      	cmp	r3, #0
240081a8:	d005      	beq.n	240081b6 <HAL_EXTI_GetConfigLine+0x8e>
  {
    pExtiConfig->Mode |= EXTI_MODE_EVENT;
240081aa:	683b      	ldr	r3, [r7, #0]
240081ac:	685b      	ldr	r3, [r3, #4]
240081ae:	f043 0202 	orr.w	r2, r3, #2
240081b2:	683b      	ldr	r3, [r7, #0]
240081b4:	605a      	str	r2, [r3, #4]
    pExtiConfig->Mode |= EXTI_MODE_CORE2_EVENT;
  }
#endif /*DUAL_CORE*/

  /* Get default Trigger and GPIOSel configuration */
  pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
240081b6:	683b      	ldr	r3, [r7, #0]
240081b8:	2200      	movs	r2, #0
240081ba:	609a      	str	r2, [r3, #8]
  pExtiConfig->GPIOSel = 0x00U;
240081bc:	683b      	ldr	r3, [r7, #0]
240081be:	2200      	movs	r2, #0
240081c0:	60da      	str	r2, [r3, #12]

  /* 2] Get trigger for configurable lines : rising */
  if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00U)
240081c2:	683b      	ldr	r3, [r7, #0]
240081c4:	681b      	ldr	r3, [r3, #0]
240081c6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240081ca:	2b00      	cmp	r3, #0
240081cc:	d03d      	beq.n	2400824a <HAL_EXTI_GetConfigLine+0x122>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
240081ce:	697b      	ldr	r3, [r7, #20]
240081d0:	015b      	lsls	r3, r3, #5
240081d2:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
240081d6:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
240081d8:	69fb      	ldr	r3, [r7, #28]
240081da:	681b      	ldr	r3, [r3, #0]
240081dc:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
240081de:	68ba      	ldr	r2, [r7, #8]
240081e0:	68fb      	ldr	r3, [r7, #12]
240081e2:	4013      	ands	r3, r2
240081e4:	2b00      	cmp	r3, #0
240081e6:	d002      	beq.n	240081ee <HAL_EXTI_GetConfigLine+0xc6>
    {
      pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
240081e8:	683b      	ldr	r3, [r7, #0]
240081ea:	2201      	movs	r2, #1
240081ec:	609a      	str	r2, [r3, #8]
    }

    /* Get falling configuration */
    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
240081ee:	697b      	ldr	r3, [r7, #20]
240081f0:	015a      	lsls	r2, r3, #5
240081f2:	4b3b      	ldr	r3, [pc, #236]	; (240082e0 <HAL_EXTI_GetConfigLine+0x1b8>)
240081f4:	4413      	add	r3, r2
240081f6:	61fb      	str	r3, [r7, #28]
    regval = *regaddr;
240081f8:	69fb      	ldr	r3, [r7, #28]
240081fa:	681b      	ldr	r3, [r3, #0]
240081fc:	60bb      	str	r3, [r7, #8]

    /* Check if configuration of selected line is enable */
    if ((regval & maskline) != 0x00U)
240081fe:	68ba      	ldr	r2, [r7, #8]
24008200:	68fb      	ldr	r3, [r7, #12]
24008202:	4013      	ands	r3, r2
24008204:	2b00      	cmp	r3, #0
24008206:	d005      	beq.n	24008214 <HAL_EXTI_GetConfigLine+0xec>
    {
      pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
24008208:	683b      	ldr	r3, [r7, #0]
2400820a:	689b      	ldr	r3, [r3, #8]
2400820c:	f043 0202 	orr.w	r2, r3, #2
24008210:	683b      	ldr	r3, [r7, #0]
24008212:	609a      	str	r2, [r3, #8]
    }

    /* Get Gpio port selection for gpio lines */
    if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
24008214:	683b      	ldr	r3, [r7, #0]
24008216:	681b      	ldr	r3, [r3, #0]
24008218:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
2400821c:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
24008220:	d113      	bne.n	2400824a <HAL_EXTI_GetConfigLine+0x122>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
24008222:	4a30      	ldr	r2, [pc, #192]	; (240082e4 <HAL_EXTI_GetConfigLine+0x1bc>)
24008224:	693b      	ldr	r3, [r7, #16]
24008226:	089b      	lsrs	r3, r3, #2
24008228:	f003 0303 	and.w	r3, r3, #3
2400822c:	3302      	adds	r3, #2
2400822e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24008232:	60bb      	str	r3, [r7, #8]
      pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3UL - (linepos & 0x03UL)))) >> 24U);
24008234:	693b      	ldr	r3, [r7, #16]
24008236:	43db      	mvns	r3, r3
24008238:	f003 0303 	and.w	r3, r3, #3
2400823c:	009b      	lsls	r3, r3, #2
2400823e:	68ba      	ldr	r2, [r7, #8]
24008240:	fa02 f303 	lsl.w	r3, r2, r3
24008244:	0e1a      	lsrs	r2, r3, #24
24008246:	683b      	ldr	r3, [r7, #0]
24008248:	60da      	str	r2, [r3, #12]
    }
  }

  /* Get default Pend Clear Source */
  pExtiConfig->PendClearSource = EXTI_D3_PENDCLR_SRC_NONE;
2400824a:	683b      	ldr	r3, [r7, #0]
2400824c:	2200      	movs	r2, #0
2400824e:	611a      	str	r2, [r3, #16]

  /* 3] Get D3 Pend Clear source */
  if ((pExtiConfig->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
24008250:	683b      	ldr	r3, [r7, #0]
24008252:	681b      	ldr	r3, [r3, #0]
24008254:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
24008258:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2400825c:	d135      	bne.n	240082ca <HAL_EXTI_GetConfigLine+0x1a2>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
2400825e:	697b      	ldr	r3, [r7, #20]
24008260:	015a      	lsls	r2, r3, #5
24008262:	4b21      	ldr	r3, [pc, #132]	; (240082e8 <HAL_EXTI_GetConfigLine+0x1c0>)
24008264:	4413      	add	r3, r2
24008266:	61fb      	str	r3, [r7, #28]
    if(((*regaddr) & linepos) != 0UL)
24008268:	69fb      	ldr	r3, [r7, #28]
2400826a:	681a      	ldr	r2, [r3, #0]
2400826c:	693b      	ldr	r3, [r7, #16]
2400826e:	4013      	ands	r3, r2
24008270:	2b00      	cmp	r3, #0
24008272:	d02a      	beq.n	240082ca <HAL_EXTI_GetConfigLine+0x1a2>
    {
      /* if wakeup target is any and PMR set, the read pend clear source from  D3PCRxL/H */
      if(linepos < 16UL)
24008274:	693b      	ldr	r3, [r7, #16]
24008276:	2b0f      	cmp	r3, #15
24008278:	d80a      	bhi.n	24008290 <HAL_EXTI_GetConfigLine+0x168>
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
2400827a:	697b      	ldr	r3, [r7, #20]
2400827c:	015a      	lsls	r2, r3, #5
2400827e:	4b1b      	ldr	r3, [pc, #108]	; (240082ec <HAL_EXTI_GetConfigLine+0x1c4>)
24008280:	4413      	add	r3, r2
24008282:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << linepos;
24008284:	2201      	movs	r2, #1
24008286:	693b      	ldr	r3, [r7, #16]
24008288:	fa02 f303 	lsl.w	r3, r2, r3
2400828c:	61bb      	str	r3, [r7, #24]
2400828e:	e00a      	b.n	240082a6 <HAL_EXTI_GetConfigLine+0x17e>
      }
      else
      {
        regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
24008290:	697b      	ldr	r3, [r7, #20]
24008292:	015a      	lsls	r2, r3, #5
24008294:	4b16      	ldr	r3, [pc, #88]	; (240082f0 <HAL_EXTI_GetConfigLine+0x1c8>)
24008296:	4413      	add	r3, r2
24008298:	61fb      	str	r3, [r7, #28]
        pcrlinepos = 1UL << (linepos - 16UL);
2400829a:	693b      	ldr	r3, [r7, #16]
2400829c:	3b10      	subs	r3, #16
2400829e:	2201      	movs	r2, #1
240082a0:	fa02 f303 	lsl.w	r3, r2, r3
240082a4:	61bb      	str	r3, [r7, #24]
      }

      pExtiConfig->PendClearSource = 1UL + ((*regaddr & (pcrlinepos * pcrlinepos * 3UL)) / (pcrlinepos * pcrlinepos));
240082a6:	69fb      	ldr	r3, [r7, #28]
240082a8:	6819      	ldr	r1, [r3, #0]
240082aa:	69bb      	ldr	r3, [r7, #24]
240082ac:	fb03 f203 	mul.w	r2, r3, r3
240082b0:	4613      	mov	r3, r2
240082b2:	005b      	lsls	r3, r3, #1
240082b4:	4413      	add	r3, r2
240082b6:	ea01 0203 	and.w	r2, r1, r3
240082ba:	69bb      	ldr	r3, [r7, #24]
240082bc:	fb03 f303 	mul.w	r3, r3, r3
240082c0:	fbb2 f3f3 	udiv	r3, r2, r3
240082c4:	1c5a      	adds	r2, r3, #1
240082c6:	683b      	ldr	r3, [r7, #0]
240082c8:	611a      	str	r2, [r3, #16]
    }
  }

  return HAL_OK;
240082ca:	2300      	movs	r3, #0
}
240082cc:	4618      	mov	r0, r3
240082ce:	3724      	adds	r7, #36	; 0x24
240082d0:	46bd      	mov	sp, r7
240082d2:	f85d 7b04 	ldr.w	r7, [sp], #4
240082d6:	4770      	bx	lr
240082d8:	58000080 	.word	0x58000080
240082dc:	58000084 	.word	0x58000084
240082e0:	58000004 	.word	0x58000004
240082e4:	58000400 	.word	0x58000400
240082e8:	5800000c 	.word	0x5800000c
240082ec:	58000010 	.word	0x58000010
240082f0:	58000014 	.word	0x58000014

240082f4 <HAL_EXTI_ClearConfigLine>:
  * @brief  Clear whole configuration of a dedicated Exti line.
  * @param  hexti Exti handle.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
{
240082f4:	b480      	push	{r7}
240082f6:	b089      	sub	sp, #36	; 0x24
240082f8:	af00      	add	r7, sp, #0
240082fa:	6078      	str	r0, [r7, #4]
  uint32_t maskline;
  uint32_t offset;
  uint32_t pcrlinepos;

  /* Check null pointer */
  if (hexti == NULL)
240082fc:	687b      	ldr	r3, [r7, #4]
240082fe:	2b00      	cmp	r3, #0
24008300:	d101      	bne.n	24008306 <HAL_EXTI_ClearConfigLine+0x12>
  {
    return HAL_ERROR;
24008302:	2301      	movs	r3, #1
24008304:	e0ab      	b.n	2400845e <HAL_EXTI_ClearConfigLine+0x16a>

  /* Check the parameter */
  assert_param(IS_EXTI_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
24008306:	687b      	ldr	r3, [r7, #4]
24008308:	681b      	ldr	r3, [r3, #0]
2400830a:	0c1b      	lsrs	r3, r3, #16
2400830c:	f003 0303 	and.w	r3, r3, #3
24008310:	617b      	str	r3, [r7, #20]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24008312:	687b      	ldr	r3, [r7, #4]
24008314:	681b      	ldr	r3, [r3, #0]
24008316:	f003 031f 	and.w	r3, r3, #31
2400831a:	613b      	str	r3, [r7, #16]
  maskline = (1UL << linepos);
2400831c:	2201      	movs	r2, #1
2400831e:	693b      	ldr	r3, [r7, #16]
24008320:	fa02 f303 	lsl.w	r3, r2, r3
24008324:	60fb      	str	r3, [r7, #12]

  /* 1] Clear interrupt mode */
  regaddr = (__IO uint32_t *)(&EXTI->IMR1 + (EXTI_MODE_OFFSET * offset));
24008326:	697b      	ldr	r3, [r7, #20]
24008328:	011a      	lsls	r2, r3, #4
2400832a:	4b50      	ldr	r3, [pc, #320]	; (2400846c <HAL_EXTI_ClearConfigLine+0x178>)
2400832c:	4413      	add	r3, r2
2400832e:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
24008330:	69fb      	ldr	r3, [r7, #28]
24008332:	681a      	ldr	r2, [r3, #0]
24008334:	68fb      	ldr	r3, [r7, #12]
24008336:	43db      	mvns	r3, r3
24008338:	4013      	ands	r3, r2
2400833a:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
2400833c:	69fb      	ldr	r3, [r7, #28]
2400833e:	68ba      	ldr	r2, [r7, #8]
24008340:	601a      	str	r2, [r3, #0]

  /* 2] Clear event mode */
  regaddr = (__IO uint32_t *)(&EXTI->EMR1 + (EXTI_MODE_OFFSET * offset));
24008342:	697b      	ldr	r3, [r7, #20]
24008344:	011a      	lsls	r2, r3, #4
24008346:	4b4a      	ldr	r3, [pc, #296]	; (24008470 <HAL_EXTI_ClearConfigLine+0x17c>)
24008348:	4413      	add	r3, r2
2400834a:	61fb      	str	r3, [r7, #28]
  regval = (*regaddr & ~maskline);
2400834c:	69fb      	ldr	r3, [r7, #28]
2400834e:	681a      	ldr	r2, [r3, #0]
24008350:	68fb      	ldr	r3, [r7, #12]
24008352:	43db      	mvns	r3, r3
24008354:	4013      	ands	r3, r2
24008356:	60bb      	str	r3, [r7, #8]
  *regaddr = regval;
24008358:	69fb      	ldr	r3, [r7, #28]
2400835a:	68ba      	ldr	r2, [r7, #8]
2400835c:	601a      	str	r2, [r3, #0]
  regval = (*regaddr & ~maskline);
  *regaddr = regval;
#endif /* DUAL_CORE */

  /* 3] Clear triggers in case of configurable lines */
  if ((hexti->Line & EXTI_CONFIG) != 0x00U)
2400835e:	687b      	ldr	r3, [r7, #4]
24008360:	681b      	ldr	r3, [r3, #0]
24008362:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24008366:	2b00      	cmp	r3, #0
24008368:	d03f      	beq.n	240083ea <HAL_EXTI_ClearConfigLine+0xf6>
  {
    regaddr = (__IO uint32_t *)(&EXTI->RTSR1 + (EXTI_CONFIG_OFFSET * offset));
2400836a:	697b      	ldr	r3, [r7, #20]
2400836c:	015b      	lsls	r3, r3, #5
2400836e:	f103 43b0 	add.w	r3, r3, #1476395008	; 0x58000000
24008372:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
24008374:	69fb      	ldr	r3, [r7, #28]
24008376:	681a      	ldr	r2, [r3, #0]
24008378:	68fb      	ldr	r3, [r7, #12]
2400837a:	43db      	mvns	r3, r3
2400837c:	4013      	ands	r3, r2
2400837e:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
24008380:	69fb      	ldr	r3, [r7, #28]
24008382:	68ba      	ldr	r2, [r7, #8]
24008384:	601a      	str	r2, [r3, #0]

    regaddr = (__IO uint32_t *)(&EXTI->FTSR1 + (EXTI_CONFIG_OFFSET * offset));
24008386:	697b      	ldr	r3, [r7, #20]
24008388:	015a      	lsls	r2, r3, #5
2400838a:	4b3a      	ldr	r3, [pc, #232]	; (24008474 <HAL_EXTI_ClearConfigLine+0x180>)
2400838c:	4413      	add	r3, r2
2400838e:	61fb      	str	r3, [r7, #28]
    regval = (*regaddr & ~maskline);
24008390:	69fb      	ldr	r3, [r7, #28]
24008392:	681a      	ldr	r2, [r3, #0]
24008394:	68fb      	ldr	r3, [r7, #12]
24008396:	43db      	mvns	r3, r3
24008398:	4013      	ands	r3, r2
2400839a:	60bb      	str	r3, [r7, #8]
    *regaddr = regval;
2400839c:	69fb      	ldr	r3, [r7, #28]
2400839e:	68ba      	ldr	r2, [r7, #8]
240083a0:	601a      	str	r2, [r3, #0]

    /* Get Gpio port selection for gpio lines */
    if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
240083a2:	687b      	ldr	r3, [r7, #4]
240083a4:	681b      	ldr	r3, [r3, #0]
240083a6:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
240083aa:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
240083ae:	d11c      	bne.n	240083ea <HAL_EXTI_ClearConfigLine+0xf6>
    {
      assert_param(IS_EXTI_GPIO_PIN(linepos));

      regval = SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL];
240083b0:	4a31      	ldr	r2, [pc, #196]	; (24008478 <HAL_EXTI_ClearConfigLine+0x184>)
240083b2:	693b      	ldr	r3, [r7, #16]
240083b4:	089b      	lsrs	r3, r3, #2
240083b6:	f003 0303 	and.w	r3, r3, #3
240083ba:	3302      	adds	r3, #2
240083bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
240083c0:	60bb      	str	r3, [r7, #8]
      regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03UL)));
240083c2:	693b      	ldr	r3, [r7, #16]
240083c4:	f003 0303 	and.w	r3, r3, #3
240083c8:	009b      	lsls	r3, r3, #2
240083ca:	220f      	movs	r2, #15
240083cc:	fa02 f303 	lsl.w	r3, r2, r3
240083d0:	43db      	mvns	r3, r3
240083d2:	68ba      	ldr	r2, [r7, #8]
240083d4:	4013      	ands	r3, r2
240083d6:	60bb      	str	r3, [r7, #8]
      SYSCFG->EXTICR[(linepos >> 2U) & 0x03UL] = regval;
240083d8:	4927      	ldr	r1, [pc, #156]	; (24008478 <HAL_EXTI_ClearConfigLine+0x184>)
240083da:	693b      	ldr	r3, [r7, #16]
240083dc:	089b      	lsrs	r3, r3, #2
240083de:	f003 0303 	and.w	r3, r3, #3
240083e2:	3302      	adds	r3, #2
240083e4:	68ba      	ldr	r2, [r7, #8]
240083e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
  }

  /* 4] Clear D3 Config lines */
  if ((hexti->Line & EXTI_TARGET_MASK) == EXTI_TARGET_MSK_ALL)
240083ea:	687b      	ldr	r3, [r7, #4]
240083ec:	681b      	ldr	r3, [r3, #0]
240083ee:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
240083f2:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
240083f6:	d131      	bne.n	2400845c <HAL_EXTI_ClearConfigLine+0x168>
  {
    regaddr = (__IO uint32_t *)(&EXTI->D3PMR1 + (EXTI_CONFIG_OFFSET * offset));
240083f8:	697b      	ldr	r3, [r7, #20]
240083fa:	015a      	lsls	r2, r3, #5
240083fc:	4b1f      	ldr	r3, [pc, #124]	; (2400847c <HAL_EXTI_ClearConfigLine+0x188>)
240083fe:	4413      	add	r3, r2
24008400:	61fb      	str	r3, [r7, #28]
    *regaddr = (*regaddr & ~maskline);
24008402:	69fb      	ldr	r3, [r7, #28]
24008404:	681a      	ldr	r2, [r3, #0]
24008406:	68fb      	ldr	r3, [r7, #12]
24008408:	43db      	mvns	r3, r3
2400840a:	401a      	ands	r2, r3
2400840c:	69fb      	ldr	r3, [r7, #28]
2400840e:	601a      	str	r2, [r3, #0]

    if(linepos < 16UL)
24008410:	693b      	ldr	r3, [r7, #16]
24008412:	2b0f      	cmp	r3, #15
24008414:	d80a      	bhi.n	2400842c <HAL_EXTI_ClearConfigLine+0x138>
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1L + (EXTI_CONFIG_OFFSET * offset));
24008416:	697b      	ldr	r3, [r7, #20]
24008418:	015a      	lsls	r2, r3, #5
2400841a:	4b19      	ldr	r3, [pc, #100]	; (24008480 <HAL_EXTI_ClearConfigLine+0x18c>)
2400841c:	4413      	add	r3, r2
2400841e:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << linepos;
24008420:	2201      	movs	r2, #1
24008422:	693b      	ldr	r3, [r7, #16]
24008424:	fa02 f303 	lsl.w	r3, r2, r3
24008428:	61bb      	str	r3, [r7, #24]
2400842a:	e00a      	b.n	24008442 <HAL_EXTI_ClearConfigLine+0x14e>
    }
    else
    {
      regaddr = (__IO uint32_t *)(&EXTI->D3PCR1H + (EXTI_CONFIG_OFFSET * offset));
2400842c:	697b      	ldr	r3, [r7, #20]
2400842e:	015a      	lsls	r2, r3, #5
24008430:	4b14      	ldr	r3, [pc, #80]	; (24008484 <HAL_EXTI_ClearConfigLine+0x190>)
24008432:	4413      	add	r3, r2
24008434:	61fb      	str	r3, [r7, #28]
      pcrlinepos = 1UL << (linepos - 16UL);
24008436:	693b      	ldr	r3, [r7, #16]
24008438:	3b10      	subs	r3, #16
2400843a:	2201      	movs	r2, #1
2400843c:	fa02 f303 	lsl.w	r3, r2, r3
24008440:	61bb      	str	r3, [r7, #24]
    }

    /*Clear D3 PendClear source */
    *regaddr &= (~(pcrlinepos * pcrlinepos * 3UL));
24008442:	69fb      	ldr	r3, [r7, #28]
24008444:	6819      	ldr	r1, [r3, #0]
24008446:	69bb      	ldr	r3, [r7, #24]
24008448:	fb03 f203 	mul.w	r2, r3, r3
2400844c:	4613      	mov	r3, r2
2400844e:	005b      	lsls	r3, r3, #1
24008450:	4413      	add	r3, r2
24008452:	43db      	mvns	r3, r3
24008454:	ea01 0203 	and.w	r2, r1, r3
24008458:	69fb      	ldr	r3, [r7, #28]
2400845a:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
2400845c:	2300      	movs	r3, #0
}
2400845e:	4618      	mov	r0, r3
24008460:	3724      	adds	r7, #36	; 0x24
24008462:	46bd      	mov	sp, r7
24008464:	f85d 7b04 	ldr.w	r7, [sp], #4
24008468:	4770      	bx	lr
2400846a:	bf00      	nop
2400846c:	58000080 	.word	0x58000080
24008470:	58000084 	.word	0x58000084
24008474:	58000004 	.word	0x58000004
24008478:	58000400 	.word	0x58000400
2400847c:	5800000c 	.word	0x5800000c
24008480:	58000010 	.word	0x58000010
24008484:	58000014 	.word	0x58000014

24008488 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
24008488:	b480      	push	{r7}
2400848a:	b087      	sub	sp, #28
2400848c:	af00      	add	r7, sp, #0
2400848e:	60f8      	str	r0, [r7, #12]
24008490:	460b      	mov	r3, r1
24008492:	607a      	str	r2, [r7, #4]
24008494:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
24008496:	2300      	movs	r3, #0
24008498:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
2400849a:	68fb      	ldr	r3, [r7, #12]
2400849c:	2b00      	cmp	r3, #0
2400849e:	d101      	bne.n	240084a4 <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
240084a0:	2301      	movs	r3, #1
240084a2:	e00a      	b.n	240084ba <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
240084a4:	7afb      	ldrb	r3, [r7, #11]
240084a6:	2b00      	cmp	r3, #0
240084a8:	d103      	bne.n	240084b2 <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
240084aa:	68fb      	ldr	r3, [r7, #12]
240084ac:	687a      	ldr	r2, [r7, #4]
240084ae:	605a      	str	r2, [r3, #4]
      break;
240084b0:	e002      	b.n	240084b8 <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
240084b2:	2301      	movs	r3, #1
240084b4:	75fb      	strb	r3, [r7, #23]
      break;
240084b6:	bf00      	nop
  }

  return status;
240084b8:	7dfb      	ldrb	r3, [r7, #23]
}
240084ba:	4618      	mov	r0, r3
240084bc:	371c      	adds	r7, #28
240084be:	46bd      	mov	sp, r7
240084c0:	f85d 7b04 	ldr.w	r7, [sp], #4
240084c4:	4770      	bx	lr

240084c6 <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
240084c6:	b480      	push	{r7}
240084c8:	b083      	sub	sp, #12
240084ca:	af00      	add	r7, sp, #0
240084cc:	6078      	str	r0, [r7, #4]
240084ce:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
240084d0:	687b      	ldr	r3, [r7, #4]
240084d2:	2b00      	cmp	r3, #0
240084d4:	d101      	bne.n	240084da <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
240084d6:	2301      	movs	r3, #1
240084d8:	e003      	b.n	240084e2 <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
240084da:	687b      	ldr	r3, [r7, #4]
240084dc:	683a      	ldr	r2, [r7, #0]
240084de:	601a      	str	r2, [r3, #0]

    return HAL_OK;
240084e0:	2300      	movs	r3, #0
  }
}
240084e2:	4618      	mov	r0, r3
240084e4:	370c      	adds	r7, #12
240084e6:	46bd      	mov	sp, r7
240084e8:	f85d 7b04 	ldr.w	r7, [sp], #4
240084ec:	4770      	bx	lr
	...

240084f0 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
240084f0:	b580      	push	{r7, lr}
240084f2:	b086      	sub	sp, #24
240084f4:	af00      	add	r7, sp, #0
240084f6:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240084f8:	687b      	ldr	r3, [r7, #4]
240084fa:	681b      	ldr	r3, [r3, #0]
240084fc:	0c1b      	lsrs	r3, r3, #16
240084fe:	f003 0303 	and.w	r3, r3, #3
24008502:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24008504:	687b      	ldr	r3, [r7, #4]
24008506:	681b      	ldr	r3, [r3, #0]
24008508:	f003 031f 	and.w	r3, r3, #31
2400850c:	2201      	movs	r2, #1
2400850e:	fa02 f303 	lsl.w	r3, r2, r3
24008512:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
24008514:	697b      	ldr	r3, [r7, #20]
24008516:	011a      	lsls	r2, r3, #4
24008518:	4b0c      	ldr	r3, [pc, #48]	; (2400854c <HAL_EXTI_IRQHandler+0x5c>)
2400851a:	4413      	add	r3, r2
2400851c:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
2400851e:	68fb      	ldr	r3, [r7, #12]
24008520:	681b      	ldr	r3, [r3, #0]
24008522:	693a      	ldr	r2, [r7, #16]
24008524:	4013      	ands	r3, r2
24008526:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
24008528:	68bb      	ldr	r3, [r7, #8]
2400852a:	2b00      	cmp	r3, #0
2400852c:	d009      	beq.n	24008542 <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
2400852e:	68fb      	ldr	r3, [r7, #12]
24008530:	693a      	ldr	r2, [r7, #16]
24008532:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
24008534:	687b      	ldr	r3, [r7, #4]
24008536:	685b      	ldr	r3, [r3, #4]
24008538:	2b00      	cmp	r3, #0
2400853a:	d002      	beq.n	24008542 <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
2400853c:	687b      	ldr	r3, [r7, #4]
2400853e:	685b      	ldr	r3, [r3, #4]
24008540:	4798      	blx	r3
    }
  }
}
24008542:	bf00      	nop
24008544:	3718      	adds	r7, #24
24008546:	46bd      	mov	sp, r7
24008548:	bd80      	pop	{r7, pc}
2400854a:	bf00      	nop
2400854c:	58000088 	.word	0x58000088

24008550 <HAL_EXTI_GetPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval 1 if interrupt is pending else 0.
  */
uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
24008550:	b480      	push	{r7}
24008552:	b089      	sub	sp, #36	; 0x24
24008554:	af00      	add	r7, sp, #0
24008556:	6078      	str	r0, [r7, #4]
24008558:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
2400855a:	687b      	ldr	r3, [r7, #4]
2400855c:	681b      	ldr	r3, [r3, #0]
2400855e:	0c1b      	lsrs	r3, r3, #16
24008560:	f003 0303 	and.w	r3, r3, #3
24008564:	61fb      	str	r3, [r7, #28]
  linepos = (hexti->Line & EXTI_PIN_MASK);
24008566:	687b      	ldr	r3, [r7, #4]
24008568:	681b      	ldr	r3, [r3, #0]
2400856a:	f003 031f 	and.w	r3, r3, #31
2400856e:	61bb      	str	r3, [r7, #24]
  maskline = (1UL << linepos);
24008570:	2201      	movs	r2, #1
24008572:	69bb      	ldr	r3, [r7, #24]
24008574:	fa02 f303 	lsl.w	r3, r2, r3
24008578:	617b      	str	r3, [r7, #20]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
2400857a:	69fb      	ldr	r3, [r7, #28]
2400857c:	011a      	lsls	r2, r3, #4
2400857e:	4b09      	ldr	r3, [pc, #36]	; (240085a4 <HAL_EXTI_GetPending+0x54>)
24008580:	4413      	add	r3, r2
24008582:	613b      	str	r3, [r7, #16]
#endif /* DUAL_CORE */

  /* return 1 if bit is set else 0 */
  regval = ((*regaddr & maskline) >> linepos);
24008584:	693b      	ldr	r3, [r7, #16]
24008586:	681a      	ldr	r2, [r3, #0]
24008588:	697b      	ldr	r3, [r7, #20]
2400858a:	401a      	ands	r2, r3
2400858c:	69bb      	ldr	r3, [r7, #24]
2400858e:	fa22 f303 	lsr.w	r3, r2, r3
24008592:	60fb      	str	r3, [r7, #12]
  return regval;
24008594:	68fb      	ldr	r3, [r7, #12]
}
24008596:	4618      	mov	r0, r3
24008598:	3724      	adds	r7, #36	; 0x24
2400859a:	46bd      	mov	sp, r7
2400859c:	f85d 7b04 	ldr.w	r7, [sp], #4
240085a0:	4770      	bx	lr
240085a2:	bf00      	nop
240085a4:	58000088 	.word	0x58000088

240085a8 <HAL_EXTI_ClearPending>:
  *           @arg @ref EXTI_TRIGGER_RISING_FALLING
  *         This parameter is kept for compatibility with other series.
  * @retval None.
  */
void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
{
240085a8:	b480      	push	{r7}
240085aa:	b087      	sub	sp, #28
240085ac:	af00      	add	r7, sp, #0
240085ae:	6078      	str	r0, [r7, #4]
240085b0:	6039      	str	r1, [r7, #0]
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
  assert_param(IS_EXTI_PENDING_EDGE(Edge));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240085b2:	687b      	ldr	r3, [r7, #4]
240085b4:	681b      	ldr	r3, [r3, #0]
240085b6:	0c1b      	lsrs	r3, r3, #16
240085b8:	f003 0303 	and.w	r3, r3, #3
240085bc:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
240085be:	687b      	ldr	r3, [r7, #4]
240085c0:	681b      	ldr	r3, [r3, #0]
240085c2:	f003 031f 	and.w	r3, r3, #31
240085c6:	2201      	movs	r2, #1
240085c8:	fa02 f303 	lsl.w	r3, r2, r3
240085cc:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
240085ce:	697b      	ldr	r3, [r7, #20]
240085d0:	011a      	lsls	r2, r3, #4
240085d2:	4b06      	ldr	r3, [pc, #24]	; (240085ec <HAL_EXTI_ClearPending+0x44>)
240085d4:	4413      	add	r3, r2
240085d6:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Clear Pending bit */
  *regaddr =  maskline;
240085d8:	68fb      	ldr	r3, [r7, #12]
240085da:	693a      	ldr	r2, [r7, #16]
240085dc:	601a      	str	r2, [r3, #0]
}
240085de:	bf00      	nop
240085e0:	371c      	adds	r7, #28
240085e2:	46bd      	mov	sp, r7
240085e4:	f85d 7b04 	ldr.w	r7, [sp], #4
240085e8:	4770      	bx	lr
240085ea:	bf00      	nop
240085ec:	58000088 	.word	0x58000088

240085f0 <HAL_EXTI_GenerateSWI>:
  * @brief  Generate a software interrupt for a dedicated line.
  * @param  hexti Exti handle.
  * @retval None.
  */
void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
{
240085f0:	b480      	push	{r7}
240085f2:	b087      	sub	sp, #28
240085f4:	af00      	add	r7, sp, #0
240085f6:	6078      	str	r0, [r7, #4]
  /* Check parameters */
  assert_param(IS_EXTI_LINE(hexti->Line));
  assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));

  /* compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
240085f8:	687b      	ldr	r3, [r7, #4]
240085fa:	681b      	ldr	r3, [r3, #0]
240085fc:	0c1b      	lsrs	r3, r3, #16
240085fe:	f003 0303 	and.w	r3, r3, #3
24008602:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
24008604:	687b      	ldr	r3, [r7, #4]
24008606:	681b      	ldr	r3, [r3, #0]
24008608:	f003 031f 	and.w	r3, r3, #31
2400860c:	2201      	movs	r2, #1
2400860e:	fa02 f303 	lsl.w	r3, r2, r3
24008612:	613b      	str	r3, [r7, #16]

  regaddr = (__IO uint32_t *)(&EXTI->SWIER1 + (EXTI_CONFIG_OFFSET * offset));
24008614:	697b      	ldr	r3, [r7, #20]
24008616:	015a      	lsls	r2, r3, #5
24008618:	4b05      	ldr	r3, [pc, #20]	; (24008630 <HAL_EXTI_GenerateSWI+0x40>)
2400861a:	4413      	add	r3, r2
2400861c:	60fb      	str	r3, [r7, #12]
  *regaddr = maskline;
2400861e:	68fb      	ldr	r3, [r7, #12]
24008620:	693a      	ldr	r2, [r7, #16]
24008622:	601a      	str	r2, [r3, #0]
}
24008624:	bf00      	nop
24008626:	371c      	adds	r7, #28
24008628:	46bd      	mov	sp, r7
2400862a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400862e:	4770      	bx	lr
24008630:	58000008 	.word	0x58000008

24008634 <HAL_FLASH_Program>:
  *         This parameter shall be 32-bit aligned
  *
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
24008634:	b580      	push	{r7, lr}
24008636:	b08a      	sub	sp, #40	; 0x28
24008638:	af00      	add	r7, sp, #0
2400863a:	60f8      	str	r0, [r7, #12]
2400863c:	60b9      	str	r1, [r7, #8]
2400863e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t *)FlashAddress;
24008640:	68bb      	ldr	r3, [r7, #8]
24008642:	623b      	str	r3, [r7, #32]
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24008644:	687b      	ldr	r3, [r7, #4]
24008646:	61fb      	str	r3, [r7, #28]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24008648:	2308      	movs	r3, #8
2400864a:	76fb      	strb	r3, [r7, #27]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2400864c:	4b2e      	ldr	r3, [pc, #184]	; (24008708 <HAL_FLASH_Program+0xd4>)
2400864e:	7d1b      	ldrb	r3, [r3, #20]
24008650:	2b01      	cmp	r3, #1
24008652:	d101      	bne.n	24008658 <HAL_FLASH_Program+0x24>
24008654:	2302      	movs	r3, #2
24008656:	e053      	b.n	24008700 <HAL_FLASH_Program+0xcc>
24008658:	4b2b      	ldr	r3, [pc, #172]	; (24008708 <HAL_FLASH_Program+0xd4>)
2400865a:	2201      	movs	r2, #1
2400865c:	751a      	strb	r2, [r3, #20]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
2400865e:	68bb      	ldr	r3, [r7, #8]
24008660:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24008664:	d315      	bcc.n	24008692 <HAL_FLASH_Program+0x5e>
24008666:	68bb      	ldr	r3, [r7, #8]
24008668:	4a28      	ldr	r2, [pc, #160]	; (2400870c <HAL_FLASH_Program+0xd8>)
2400866a:	4293      	cmp	r3, r2
2400866c:	d811      	bhi.n	24008692 <HAL_FLASH_Program+0x5e>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
2400866e:	2301      	movs	r3, #1
24008670:	617b      	str	r3, [r7, #20]
  {
    return HAL_ERROR;
  }

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24008672:	4b25      	ldr	r3, [pc, #148]	; (24008708 <HAL_FLASH_Program+0xd4>)
24008674:	2200      	movs	r2, #0
24008676:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24008678:	6979      	ldr	r1, [r7, #20]
2400867a:	f24c 3050 	movw	r0, #50000	; 0xc350
2400867e:	f000 fa1d 	bl	24008abc <FLASH_WaitForLastOperation>
24008682:	4603      	mov	r3, r0
24008684:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  if(status == HAL_OK)
24008688:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
2400868c:	2b00      	cmp	r3, #0
2400868e:	d002      	beq.n	24008696 <HAL_FLASH_Program+0x62>
24008690:	e031      	b.n	240086f6 <HAL_FLASH_Program+0xc2>
    return HAL_ERROR;
24008692:	2301      	movs	r3, #1
24008694:	e034      	b.n	24008700 <HAL_FLASH_Program+0xcc>
      }
      else
#endif /* FLASH_OPTCR_PG_OTP */
      {
        /* Set PG bit */
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
24008696:	4b1e      	ldr	r3, [pc, #120]	; (24008710 <HAL_FLASH_Program+0xdc>)
24008698:	68db      	ldr	r3, [r3, #12]
2400869a:	4a1d      	ldr	r2, [pc, #116]	; (24008710 <HAL_FLASH_Program+0xdc>)
2400869c:	f043 0302 	orr.w	r3, r3, #2
240086a0:	60d3      	str	r3, [r2, #12]
  __ASM volatile ("isb 0xF":::"memory");
240086a2:	f3bf 8f6f 	isb	sy
}
240086a6:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
240086a8:	f3bf 8f4f 	dsb	sy
}
240086ac:	bf00      	nop
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
240086ae:	69fb      	ldr	r3, [r7, #28]
240086b0:	681a      	ldr	r2, [r3, #0]
240086b2:	6a3b      	ldr	r3, [r7, #32]
240086b4:	601a      	str	r2, [r3, #0]
        dest_addr++;
240086b6:	6a3b      	ldr	r3, [r7, #32]
240086b8:	3304      	adds	r3, #4
240086ba:	623b      	str	r3, [r7, #32]
        src_addr++;
240086bc:	69fb      	ldr	r3, [r7, #28]
240086be:	3304      	adds	r3, #4
240086c0:	61fb      	str	r3, [r7, #28]
        row_index--;
240086c2:	7efb      	ldrb	r3, [r7, #27]
240086c4:	3b01      	subs	r3, #1
240086c6:	76fb      	strb	r3, [r7, #27]
     } while (row_index != 0U);
240086c8:	7efb      	ldrb	r3, [r7, #27]
240086ca:	2b00      	cmp	r3, #0
240086cc:	d1ef      	bne.n	240086ae <HAL_FLASH_Program+0x7a>
  __ASM volatile ("isb 0xF":::"memory");
240086ce:	f3bf 8f6f 	isb	sy
}
240086d2:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
240086d4:	f3bf 8f4f 	dsb	sy
}
240086d8:	bf00      	nop

    __ISB();
    __DSB();

    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
240086da:	6979      	ldr	r1, [r7, #20]
240086dc:	f24c 3050 	movw	r0, #50000	; 0xc350
240086e0:	f000 f9ec 	bl	24008abc <FLASH_WaitForLastOperation>
240086e4:	4603      	mov	r3, r0
240086e6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }
    else
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* If the program operation is completed, disable the PG */
      CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
240086ea:	4b09      	ldr	r3, [pc, #36]	; (24008710 <HAL_FLASH_Program+0xdc>)
240086ec:	68db      	ldr	r3, [r3, #12]
240086ee:	4a08      	ldr	r2, [pc, #32]	; (24008710 <HAL_FLASH_Program+0xdc>)
240086f0:	f023 0302 	bic.w	r3, r3, #2
240086f4:	60d3      	str	r3, [r2, #12]
    }
#endif /* DUAL_BANK */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
240086f6:	4b04      	ldr	r3, [pc, #16]	; (24008708 <HAL_FLASH_Program+0xd4>)
240086f8:	2200      	movs	r2, #0
240086fa:	751a      	strb	r2, [r3, #20]

  return status;
240086fc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
24008700:	4618      	mov	r0, r3
24008702:	3728      	adds	r7, #40	; 0x28
24008704:	46bd      	mov	sp, r7
24008706:	bd80      	pop	{r7, pc}
24008708:	24000590 	.word	0x24000590
2400870c:	0801ffff 	.word	0x0801ffff
24008710:	52002000 	.word	0x52002000

24008714 <HAL_FLASH_Program_IT>:
  *         This parameter shall be 32-bit aligned
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t FlashAddress, uint32_t DataAddress)
{
24008714:	b580      	push	{r7, lr}
24008716:	b08a      	sub	sp, #40	; 0x28
24008718:	af00      	add	r7, sp, #0
2400871a:	60f8      	str	r0, [r7, #12]
2400871c:	60b9      	str	r1, [r7, #8]
2400871e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  __IO uint32_t *dest_addr = (__IO uint32_t*)FlashAddress;
24008720:	68bb      	ldr	r3, [r7, #8]
24008722:	627b      	str	r3, [r7, #36]	; 0x24
  __IO uint32_t *src_addr = (__IO uint32_t*)DataAddress;
24008724:	687b      	ldr	r3, [r7, #4]
24008726:	623b      	str	r3, [r7, #32]
  uint32_t bank;
  uint8_t row_index = FLASH_NB_32BITWORD_IN_FLASHWORD;
24008728:	2308      	movs	r3, #8
2400872a:	77fb      	strb	r3, [r7, #31]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
2400872c:	4b2c      	ldr	r3, [pc, #176]	; (240087e0 <HAL_FLASH_Program_IT+0xcc>)
2400872e:	7d1b      	ldrb	r3, [r3, #20]
24008730:	2b01      	cmp	r3, #1
24008732:	d101      	bne.n	24008738 <HAL_FLASH_Program_IT+0x24>
24008734:	2302      	movs	r3, #2
24008736:	e04f      	b.n	240087d8 <HAL_FLASH_Program_IT+0xc4>
24008738:	4b29      	ldr	r3, [pc, #164]	; (240087e0 <HAL_FLASH_Program_IT+0xcc>)
2400873a:	2201      	movs	r2, #1
2400873c:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
2400873e:	4b28      	ldr	r3, [pc, #160]	; (240087e0 <HAL_FLASH_Program_IT+0xcc>)
24008740:	2200      	movs	r2, #0
24008742:	619a      	str	r2, [r3, #24]

#if defined (FLASH_OPTCR_PG_OTP)
  if((IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress)) || (IS_FLASH_PROGRAM_ADDRESS_OTP(FlashAddress)))
#else
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
24008744:	68bb      	ldr	r3, [r7, #8]
24008746:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
2400874a:	d310      	bcc.n	2400876e <HAL_FLASH_Program_IT+0x5a>
2400874c:	68bb      	ldr	r3, [r7, #8]
2400874e:	4a25      	ldr	r2, [pc, #148]	; (240087e4 <HAL_FLASH_Program_IT+0xd0>)
24008750:	4293      	cmp	r3, r2
24008752:	d80c      	bhi.n	2400876e <HAL_FLASH_Program_IT+0x5a>
#endif /* FLASH_OPTCR_PG_OTP */
  {
    bank = FLASH_BANK_1;
24008754:	2301      	movs	r3, #1
24008756:	61bb      	str	r3, [r7, #24]
  {
    return HAL_ERROR;
  }

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
24008758:	69b9      	ldr	r1, [r7, #24]
2400875a:	f24c 3050 	movw	r0, #50000	; 0xc350
2400875e:	f000 f9ad 	bl	24008abc <FLASH_WaitForLastOperation>
24008762:	4603      	mov	r3, r0
24008764:	75fb      	strb	r3, [r7, #23]

  if (status != HAL_OK)
24008766:	7dfb      	ldrb	r3, [r7, #23]
24008768:	2b00      	cmp	r3, #0
2400876a:	d102      	bne.n	24008772 <HAL_FLASH_Program_IT+0x5e>
2400876c:	e005      	b.n	2400877a <HAL_FLASH_Program_IT+0x66>
    return HAL_ERROR;
2400876e:	2301      	movs	r3, #1
24008770:	e032      	b.n	240087d8 <HAL_FLASH_Program_IT+0xc4>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24008772:	4b1b      	ldr	r3, [pc, #108]	; (240087e0 <HAL_FLASH_Program_IT+0xcc>)
24008774:	2200      	movs	r2, #0
24008776:	751a      	strb	r2, [r3, #20]
24008778:	e02d      	b.n	240087d6 <HAL_FLASH_Program_IT+0xc2>
  }
  else
  {
    pFlash.Address = FlashAddress;
2400877a:	4a19      	ldr	r2, [pc, #100]	; (240087e0 <HAL_FLASH_Program_IT+0xcc>)
2400877c:	68bb      	ldr	r3, [r7, #8]
2400877e:	6113      	str	r3, [r2, #16]
                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */
    }
#else /* Single Bank */
    /* Set internal variables used by the IRQ handler */
    pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM_BANK1;
24008780:	4b17      	ldr	r3, [pc, #92]	; (240087e0 <HAL_FLASH_Program_IT+0xcc>)
24008782:	2203      	movs	r2, #3
24008784:	701a      	strb	r2, [r3, #0]
    }
    else
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Set PG bit */
      SET_BIT(FLASH->CR1, FLASH_CR_PG);
24008786:	4b18      	ldr	r3, [pc, #96]	; (240087e8 <HAL_FLASH_Program_IT+0xd4>)
24008788:	68db      	ldr	r3, [r3, #12]
2400878a:	4a17      	ldr	r2, [pc, #92]	; (240087e8 <HAL_FLASH_Program_IT+0xd4>)
2400878c:	f043 0302 	orr.w	r3, r3, #2
24008790:	60d3      	str	r3, [r2, #12]
    }

      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24008792:	4b15      	ldr	r3, [pc, #84]	; (240087e8 <HAL_FLASH_Program_IT+0xd4>)
24008794:	68db      	ldr	r3, [r3, #12]
24008796:	4a14      	ldr	r2, [pc, #80]	; (240087e8 <HAL_FLASH_Program_IT+0xd4>)
24008798:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
2400879c:	60d3      	str	r3, [r2, #12]
  __ASM volatile ("isb 0xF":::"memory");
2400879e:	f3bf 8f6f 	isb	sy
}
240087a2:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
240087a4:	f3bf 8f4f 	dsb	sy
}
240087a8:	bf00      	nop
#endif /* FLASH_OPTCR_PG_OTP */
    {
      /* Program the flash word */
      do
      {
        *dest_addr = *src_addr;
240087aa:	6a3b      	ldr	r3, [r7, #32]
240087ac:	681a      	ldr	r2, [r3, #0]
240087ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240087b0:	601a      	str	r2, [r3, #0]
        dest_addr++;
240087b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240087b4:	3304      	adds	r3, #4
240087b6:	627b      	str	r3, [r7, #36]	; 0x24
        src_addr++;
240087b8:	6a3b      	ldr	r3, [r7, #32]
240087ba:	3304      	adds	r3, #4
240087bc:	623b      	str	r3, [r7, #32]
        row_index--;
240087be:	7ffb      	ldrb	r3, [r7, #31]
240087c0:	3b01      	subs	r3, #1
240087c2:	77fb      	strb	r3, [r7, #31]
      } while (row_index != 0U);
240087c4:	7ffb      	ldrb	r3, [r7, #31]
240087c6:	2b00      	cmp	r3, #0
240087c8:	d1ef      	bne.n	240087aa <HAL_FLASH_Program_IT+0x96>
  __ASM volatile ("isb 0xF":::"memory");
240087ca:	f3bf 8f6f 	isb	sy
}
240087ce:	bf00      	nop
  __ASM volatile ("dsb 0xF":::"memory");
240087d0:	f3bf 8f4f 	dsb	sy
}
240087d4:	bf00      	nop

    __ISB();
    __DSB();
  }

  return status;
240087d6:	7dfb      	ldrb	r3, [r7, #23]
}
240087d8:	4618      	mov	r0, r3
240087da:	3728      	adds	r7, #40	; 0x28
240087dc:	46bd      	mov	sp, r7
240087de:	bd80      	pop	{r7, pc}
240087e0:	24000590 	.word	0x24000590
240087e4:	0801ffff 	.word	0x0801ffff
240087e8:	52002000 	.word	0x52002000

240087ec <HAL_FLASH_IRQHandler>:
/**
  * @brief This function handles FLASH interrupt request.
  * @retval None
  */
void HAL_FLASH_IRQHandler(void)
{
240087ec:	b580      	push	{r7, lr}
240087ee:	b084      	sub	sp, #16
240087f0:	af00      	add	r7, sp, #0
  uint32_t temp;
  uint32_t errorflag;
  FLASH_ProcedureTypeDef procedure;

  /* Check FLASH Bank1 End of Operation flag  */
  if(__HAL_FLASH_GET_FLAG_BANK1(FLASH_SR_EOP) != RESET)
240087f2:	4b53      	ldr	r3, [pc, #332]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
240087f4:	691b      	ldr	r3, [r3, #16]
240087f6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240087fa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240087fe:	d15c      	bne.n	240088ba <HAL_FLASH_IRQHandler+0xce>
  {
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE_BANK1)
24008800:	4b50      	ldr	r3, [pc, #320]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008802:	781b      	ldrb	r3, [r3, #0]
24008804:	b2db      	uxtb	r3, r3
24008806:	2b01      	cmp	r3, #1
24008808:	d132      	bne.n	24008870 <HAL_FLASH_IRQHandler+0x84>
    {
      /* Nb of sector to erased can be decreased */
      pFlash.NbSectorsToErase--;
2400880a:	4b4e      	ldr	r3, [pc, #312]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
2400880c:	685b      	ldr	r3, [r3, #4]
2400880e:	3b01      	subs	r3, #1
24008810:	4a4c      	ldr	r2, [pc, #304]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008812:	6053      	str	r3, [r2, #4]

      /* Check if there are still sectors to erase */
      if(pFlash.NbSectorsToErase != 0U)
24008814:	4b4b      	ldr	r3, [pc, #300]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008816:	685b      	ldr	r3, [r3, #4]
24008818:	2b00      	cmp	r3, #0
2400881a:	d018      	beq.n	2400884e <HAL_FLASH_IRQHandler+0x62>
      {
        /* Indicate user which sector has been erased */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2400881c:	4b49      	ldr	r3, [pc, #292]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
2400881e:	68db      	ldr	r3, [r3, #12]
24008820:	4618      	mov	r0, r3
24008822:	f000 f891 	bl	24008948 <HAL_FLASH_EndOfOperationCallback>

        /* Clear bank 1 End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24008826:	4b46      	ldr	r3, [pc, #280]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
24008828:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2400882c:	615a      	str	r2, [r3, #20]

        /* Increment sector number */
        pFlash.Sector++;
2400882e:	4b45      	ldr	r3, [pc, #276]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008830:	68db      	ldr	r3, [r3, #12]
24008832:	3301      	adds	r3, #1
24008834:	4a43      	ldr	r2, [pc, #268]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008836:	60d3      	str	r3, [r2, #12]
        temp = pFlash.Sector;
24008838:	4b42      	ldr	r3, [pc, #264]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
2400883a:	68db      	ldr	r3, [r3, #12]
2400883c:	60fb      	str	r3, [r7, #12]
        FLASH_Erase_Sector(temp, FLASH_BANK_1, pFlash.VoltageForErase);
2400883e:	4b41      	ldr	r3, [pc, #260]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008840:	689b      	ldr	r3, [r3, #8]
24008842:	461a      	mov	r2, r3
24008844:	2101      	movs	r1, #1
24008846:	68f8      	ldr	r0, [r7, #12]
24008848:	f000 fcd6 	bl	240091f8 <FLASH_Erase_Sector>
2400884c:	e035      	b.n	240088ba <HAL_FLASH_IRQHandler+0xce>
      }
      else
      {
        /* No more sectors to Erase, user callback can be called */
        /* Reset Sector and stop Erase sectors procedure */
        pFlash.Sector = 0xFFFFFFFFU;
2400884e:	4b3d      	ldr	r3, [pc, #244]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008850:	f04f 32ff 	mov.w	r2, #4294967295
24008854:	60da      	str	r2, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24008856:	4b3b      	ldr	r3, [pc, #236]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008858:	2200      	movs	r2, #0
2400885a:	701a      	strb	r2, [r3, #0]

        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Sector);
2400885c:	4b39      	ldr	r3, [pc, #228]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
2400885e:	68db      	ldr	r3, [r3, #12]
24008860:	4618      	mov	r0, r3
24008862:	f000 f871 	bl	24008948 <HAL_FLASH_EndOfOperationCallback>

        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24008866:	4b36      	ldr	r3, [pc, #216]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
24008868:	f44f 3280 	mov.w	r2, #65536	; 0x10000
2400886c:	615a      	str	r2, [r3, #20]
2400886e:	e024      	b.n	240088ba <HAL_FLASH_IRQHandler+0xce>
      }
    }
    else
    {
      procedure = pFlash.ProcedureOnGoing;
24008870:	4b34      	ldr	r3, [pc, #208]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008872:	781b      	ldrb	r3, [r3, #0]
24008874:	72fb      	strb	r3, [r7, #11]

      if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
24008876:	7afb      	ldrb	r3, [r7, #11]
24008878:	2b02      	cmp	r3, #2
2400887a:	d002      	beq.n	24008882 <HAL_FLASH_IRQHandler+0x96>
2400887c:	7afb      	ldrb	r3, [r7, #11]
2400887e:	2b07      	cmp	r3, #7
24008880:	d103      	bne.n	2400888a <HAL_FLASH_IRQHandler+0x9e>
      {
        /* MassErase ended. Return the selected bank */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(FLASH_BANK_1);
24008882:	2001      	movs	r0, #1
24008884:	f000 f860 	bl	24008948 <HAL_FLASH_EndOfOperationCallback>
24008888:	e007      	b.n	2400889a <HAL_FLASH_IRQHandler+0xae>
      }
      else if(procedure == FLASH_PROC_PROGRAM_BANK1)
2400888a:	7afb      	ldrb	r3, [r7, #11]
2400888c:	2b03      	cmp	r3, #3
2400888e:	d104      	bne.n	2400889a <HAL_FLASH_IRQHandler+0xae>
      {
        /* Program ended. Return the selected address */
        /* FLASH EOP interrupt user callback */
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
24008890:	4b2c      	ldr	r3, [pc, #176]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008892:	691b      	ldr	r3, [r3, #16]
24008894:	4618      	mov	r0, r3
24008896:	f000 f857 	bl	24008948 <HAL_FLASH_EndOfOperationCallback>
      else
      {
        /* Nothing to do */
      }

      if((procedure != FLASH_PROC_SECTERASE_BANK2) && \
2400889a:	7afb      	ldrb	r3, [r7, #11]
2400889c:	2b04      	cmp	r3, #4
2400889e:	d00c      	beq.n	240088ba <HAL_FLASH_IRQHandler+0xce>
240088a0:	7afb      	ldrb	r3, [r7, #11]
240088a2:	2b05      	cmp	r3, #5
240088a4:	d009      	beq.n	240088ba <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_MASSERASE_BANK2) && \
240088a6:	7afb      	ldrb	r3, [r7, #11]
240088a8:	2b06      	cmp	r3, #6
240088aa:	d006      	beq.n	240088ba <HAL_FLASH_IRQHandler+0xce>
         (procedure != FLASH_PROC_PROGRAM_BANK2))
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
240088ac:	4b25      	ldr	r3, [pc, #148]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
240088ae:	2200      	movs	r2, #0
240088b0:	701a      	strb	r2, [r3, #0]
        /* Clear FLASH End of Operation pending bit */
        __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
240088b2:	4b23      	ldr	r3, [pc, #140]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
240088b4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240088b8:	615a      	str	r2, [r3, #20]
  }
#endif /* DUAL_BANK */

  /* Check FLASH Bank1 operation error flags */
#if defined (FLASH_SR_OPERR)
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
240088ba:	4b21      	ldr	r3, [pc, #132]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
240088bc:	691b      	ldr	r3, [r3, #16]
240088be:	f403 03dc 	and.w	r3, r3, #7208960	; 0x6e0000
240088c2:	607b      	str	r3, [r7, #4]
#else
  errorflag = FLASH->SR1 & (FLASH_FLAG_WRPERR_BANK1 | FLASH_FLAG_PGSERR_BANK1 | FLASH_FLAG_STRBERR_BANK1 | \
                            FLASH_FLAG_INCERR_BANK1);
#endif /* FLASH_SR_OPERR */

  if(errorflag != 0U)
240088c4:	687b      	ldr	r3, [r7, #4]
240088c6:	2b00      	cmp	r3, #0
240088c8:	d028      	beq.n	2400891c <HAL_FLASH_IRQHandler+0x130>
  {
    /* Save the error code */
    pFlash.ErrorCode |= errorflag;
240088ca:	4b1e      	ldr	r3, [pc, #120]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
240088cc:	699a      	ldr	r2, [r3, #24]
240088ce:	687b      	ldr	r3, [r7, #4]
240088d0:	4313      	orrs	r3, r2
240088d2:	4a1c      	ldr	r2, [pc, #112]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
240088d4:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG_BANK1(errorflag);
240088d6:	4a1a      	ldr	r2, [pc, #104]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
240088d8:	687b      	ldr	r3, [r7, #4]
240088da:	6153      	str	r3, [r2, #20]

    procedure = pFlash.ProcedureOnGoing;
240088dc:	4b19      	ldr	r3, [pc, #100]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
240088de:	781b      	ldrb	r3, [r3, #0]
240088e0:	72fb      	strb	r3, [r7, #11]

    if(procedure == FLASH_PROC_SECTERASE_BANK1)
240088e2:	7afb      	ldrb	r3, [r7, #11]
240088e4:	2b01      	cmp	r3, #1
240088e6:	d107      	bne.n	240088f8 <HAL_FLASH_IRQHandler+0x10c>
    {
      /* Return the faulty sector */
      temp = pFlash.Sector;
240088e8:	4b16      	ldr	r3, [pc, #88]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
240088ea:	68db      	ldr	r3, [r3, #12]
240088ec:	60fb      	str	r3, [r7, #12]
      pFlash.Sector = 0xFFFFFFFFU;
240088ee:	4b15      	ldr	r3, [pc, #84]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
240088f0:	f04f 32ff 	mov.w	r2, #4294967295
240088f4:	60da      	str	r2, [r3, #12]
240088f6:	e00b      	b.n	24008910 <HAL_FLASH_IRQHandler+0x124>
    }
    else if((procedure == FLASH_PROC_MASSERASE_BANK1) || (procedure == FLASH_PROC_ALLBANK_MASSERASE))
240088f8:	7afb      	ldrb	r3, [r7, #11]
240088fa:	2b02      	cmp	r3, #2
240088fc:	d002      	beq.n	24008904 <HAL_FLASH_IRQHandler+0x118>
240088fe:	7afb      	ldrb	r3, [r7, #11]
24008900:	2b07      	cmp	r3, #7
24008902:	d102      	bne.n	2400890a <HAL_FLASH_IRQHandler+0x11e>
    {
      /* Return the faulty bank */
      temp = FLASH_BANK_1;
24008904:	2301      	movs	r3, #1
24008906:	60fb      	str	r3, [r7, #12]
24008908:	e002      	b.n	24008910 <HAL_FLASH_IRQHandler+0x124>
    }
    else
    {
      /* Return the faulty address */
      temp = pFlash.Address;
2400890a:	4b0e      	ldr	r3, [pc, #56]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
2400890c:	691b      	ldr	r3, [r3, #16]
2400890e:	60fb      	str	r3, [r7, #12]
    }

    /* Stop the procedure ongoing*/
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
24008910:	4b0c      	ldr	r3, [pc, #48]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008912:	2200      	movs	r2, #0
24008914:	701a      	strb	r2, [r3, #0]

    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
24008916:	68f8      	ldr	r0, [r7, #12]
24008918:	f000 f820 	bl	2400895c <HAL_FLASH_OperationErrorCallback>
    /* FLASH error interrupt user callback */
    HAL_FLASH_OperationErrorCallback(temp);
  }
#endif /* DUAL_BANK */

  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
2400891c:	4b09      	ldr	r3, [pc, #36]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
2400891e:	781b      	ldrb	r3, [r3, #0]
24008920:	b2db      	uxtb	r3, r3
24008922:	2b00      	cmp	r3, #0
24008924:	d108      	bne.n	24008938 <HAL_FLASH_IRQHandler+0x14c>
  {
#if defined (FLASH_CR_OPERRIE)
    /* Disable Bank1 Operation and Error source interrupt */
    __HAL_FLASH_DISABLE_IT_BANK1(FLASH_IT_EOP_BANK1    | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24008926:	4b06      	ldr	r3, [pc, #24]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
24008928:	68db      	ldr	r3, [r3, #12]
2400892a:	4a05      	ldr	r2, [pc, #20]	; (24008940 <HAL_FLASH_IRQHandler+0x154>)
2400892c:	f423 03de 	bic.w	r3, r3, #7274496	; 0x6f0000
24008930:	60d3      	str	r3, [r2, #12]
                                 FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* DUAL_BANK */
#endif /* FLASH_CR_OPERRIE */

    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24008932:	4b04      	ldr	r3, [pc, #16]	; (24008944 <HAL_FLASH_IRQHandler+0x158>)
24008934:	2200      	movs	r2, #0
24008936:	751a      	strb	r2, [r3, #20]
  }
}
24008938:	bf00      	nop
2400893a:	3710      	adds	r7, #16
2400893c:	46bd      	mov	sp, r7
2400893e:	bd80      	pop	{r7, pc}
24008940:	52002000 	.word	0x52002000
24008944:	24000590 	.word	0x24000590

24008948 <HAL_FLASH_EndOfOperationCallback>:
  *                    (if 0xFFFFFFFF, it means that all the selected sectors have been erased)
  *                  Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
{
24008948:	b480      	push	{r7}
2400894a:	b083      	sub	sp, #12
2400894c:	af00      	add	r7, sp, #0
2400894e:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
24008950:	bf00      	nop
24008952:	370c      	adds	r7, #12
24008954:	46bd      	mov	sp, r7
24008956:	f85d 7b04 	ldr.w	r7, [sp], #4
2400895a:	4770      	bx	lr

2400895c <HAL_FLASH_OperationErrorCallback>:
  *                 Sectors Erase: Sector number which returned an error
  *                 Program: Address which was selected for data program
  * @retval None
  */
__weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
{
2400895c:	b480      	push	{r7}
2400895e:	b083      	sub	sp, #12
24008960:	af00      	add	r7, sp, #0
24008962:	6078      	str	r0, [r7, #4]
  UNUSED(ReturnValue);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_FLASH_OperationErrorCallback could be implemented in the user file
   */
}
24008964:	bf00      	nop
24008966:	370c      	adds	r7, #12
24008968:	46bd      	mov	sp, r7
2400896a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400896e:	4770      	bx	lr

24008970 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
24008970:	b480      	push	{r7}
24008972:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24008974:	4b0c      	ldr	r3, [pc, #48]	; (240089a8 <HAL_FLASH_Unlock+0x38>)
24008976:	68db      	ldr	r3, [r3, #12]
24008978:	f003 0301 	and.w	r3, r3, #1
2400897c:	2b00      	cmp	r3, #0
2400897e:	d00d      	beq.n	2400899c <HAL_FLASH_Unlock+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24008980:	4b09      	ldr	r3, [pc, #36]	; (240089a8 <HAL_FLASH_Unlock+0x38>)
24008982:	4a0a      	ldr	r2, [pc, #40]	; (240089ac <HAL_FLASH_Unlock+0x3c>)
24008984:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
24008986:	4b08      	ldr	r3, [pc, #32]	; (240089a8 <HAL_FLASH_Unlock+0x38>)
24008988:	4a09      	ldr	r2, [pc, #36]	; (240089b0 <HAL_FLASH_Unlock+0x40>)
2400898a:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
2400898c:	4b06      	ldr	r3, [pc, #24]	; (240089a8 <HAL_FLASH_Unlock+0x38>)
2400898e:	68db      	ldr	r3, [r3, #12]
24008990:	f003 0301 	and.w	r3, r3, #1
24008994:	2b00      	cmp	r3, #0
24008996:	d001      	beq.n	2400899c <HAL_FLASH_Unlock+0x2c>
    {
      return HAL_ERROR;
24008998:	2301      	movs	r3, #1
2400899a:	e000      	b.n	2400899e <HAL_FLASH_Unlock+0x2e>
      return HAL_ERROR;
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
2400899c:	2300      	movs	r3, #0
}
2400899e:	4618      	mov	r0, r3
240089a0:	46bd      	mov	sp, r7
240089a2:	f85d 7b04 	ldr.w	r7, [sp], #4
240089a6:	4770      	bx	lr
240089a8:	52002000 	.word	0x52002000
240089ac:	45670123 	.word	0x45670123
240089b0:	cdef89ab 	.word	0xcdef89ab

240089b4 <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
240089b4:	b480      	push	{r7}
240089b6:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Control Register access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
240089b8:	4b09      	ldr	r3, [pc, #36]	; (240089e0 <HAL_FLASH_Lock+0x2c>)
240089ba:	68db      	ldr	r3, [r3, #12]
240089bc:	4a08      	ldr	r2, [pc, #32]	; (240089e0 <HAL_FLASH_Lock+0x2c>)
240089be:	f043 0301 	orr.w	r3, r3, #1
240089c2:	60d3      	str	r3, [r2, #12]

  /* Verify Flash Bank1 is locked */
  if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) == 0U)
240089c4:	4b06      	ldr	r3, [pc, #24]	; (240089e0 <HAL_FLASH_Lock+0x2c>)
240089c6:	68db      	ldr	r3, [r3, #12]
240089c8:	f003 0301 	and.w	r3, r3, #1
240089cc:	2b00      	cmp	r3, #0
240089ce:	d101      	bne.n	240089d4 <HAL_FLASH_Lock+0x20>
  {
    return HAL_ERROR;
240089d0:	2301      	movs	r3, #1
240089d2:	e000      	b.n	240089d6 <HAL_FLASH_Lock+0x22>
  {
    return HAL_ERROR;
  }
#endif /* DUAL_BANK */

  return HAL_OK;
240089d4:	2300      	movs	r3, #0
}
240089d6:	4618      	mov	r0, r3
240089d8:	46bd      	mov	sp, r7
240089da:	f85d 7b04 	ldr.w	r7, [sp], #4
240089de:	4770      	bx	lr
240089e0:	52002000 	.word	0x52002000

240089e4 <HAL_FLASH_OB_Unlock>:
/**
  * @brief  Unlock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
240089e4:	b480      	push	{r7}
240089e6:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
240089e8:	4b0c      	ldr	r3, [pc, #48]	; (24008a1c <HAL_FLASH_OB_Unlock+0x38>)
240089ea:	699b      	ldr	r3, [r3, #24]
240089ec:	f003 0301 	and.w	r3, r3, #1
240089f0:	2b00      	cmp	r3, #0
240089f2:	d00d      	beq.n	24008a10 <HAL_FLASH_OB_Unlock+0x2c>
  {
    /* Authorizes the Option Byte registers programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY1);
240089f4:	4b09      	ldr	r3, [pc, #36]	; (24008a1c <HAL_FLASH_OB_Unlock+0x38>)
240089f6:	4a0a      	ldr	r2, [pc, #40]	; (24008a20 <HAL_FLASH_OB_Unlock+0x3c>)
240089f8:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPT_KEY2);
240089fa:	4b08      	ldr	r3, [pc, #32]	; (24008a1c <HAL_FLASH_OB_Unlock+0x38>)
240089fc:	4a09      	ldr	r2, [pc, #36]	; (24008a24 <HAL_FLASH_OB_Unlock+0x40>)
240089fe:	609a      	str	r2, [r3, #8]

    /* Verify that the Option Bytes are unlocked */
    if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) != 0U)
24008a00:	4b06      	ldr	r3, [pc, #24]	; (24008a1c <HAL_FLASH_OB_Unlock+0x38>)
24008a02:	699b      	ldr	r3, [r3, #24]
24008a04:	f003 0301 	and.w	r3, r3, #1
24008a08:	2b00      	cmp	r3, #0
24008a0a:	d001      	beq.n	24008a10 <HAL_FLASH_OB_Unlock+0x2c>
    {
      return HAL_ERROR;
24008a0c:	2301      	movs	r3, #1
24008a0e:	e000      	b.n	24008a12 <HAL_FLASH_OB_Unlock+0x2e>
    }
  }

  return HAL_OK;
24008a10:	2300      	movs	r3, #0
}
24008a12:	4618      	mov	r0, r3
24008a14:	46bd      	mov	sp, r7
24008a16:	f85d 7b04 	ldr.w	r7, [sp], #4
24008a1a:	4770      	bx	lr
24008a1c:	52002000 	.word	0x52002000
24008a20:	08192a3b 	.word	0x08192a3b
24008a24:	4c5d6e7f 	.word	0x4c5d6e7f

24008a28 <HAL_FLASH_OB_Lock>:
/**
  * @brief  Lock the FLASH Option Control Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
{
24008a28:	b480      	push	{r7}
24008a2a:	af00      	add	r7, sp, #0
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK);
24008a2c:	4b09      	ldr	r3, [pc, #36]	; (24008a54 <HAL_FLASH_OB_Lock+0x2c>)
24008a2e:	699b      	ldr	r3, [r3, #24]
24008a30:	4a08      	ldr	r2, [pc, #32]	; (24008a54 <HAL_FLASH_OB_Lock+0x2c>)
24008a32:	f043 0301 	orr.w	r3, r3, #1
24008a36:	6193      	str	r3, [r2, #24]

  /* Verify that the Option Bytes are locked */
  if (READ_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTLOCK) == 0U)
24008a38:	4b06      	ldr	r3, [pc, #24]	; (24008a54 <HAL_FLASH_OB_Lock+0x2c>)
24008a3a:	699b      	ldr	r3, [r3, #24]
24008a3c:	f003 0301 	and.w	r3, r3, #1
24008a40:	2b00      	cmp	r3, #0
24008a42:	d101      	bne.n	24008a48 <HAL_FLASH_OB_Lock+0x20>
  {
    return HAL_ERROR;
24008a44:	2301      	movs	r3, #1
24008a46:	e000      	b.n	24008a4a <HAL_FLASH_OB_Lock+0x22>
  }

  return HAL_OK;
24008a48:	2300      	movs	r3, #0
}
24008a4a:	4618      	mov	r0, r3
24008a4c:	46bd      	mov	sp, r7
24008a4e:	f85d 7b04 	ldr.w	r7, [sp], #4
24008a52:	4770      	bx	lr
24008a54:	52002000 	.word	0x52002000

24008a58 <HAL_FLASH_OB_Launch>:
/**
  * @brief  Launch the option bytes loading.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
{
24008a58:	b580      	push	{r7, lr}
24008a5a:	b082      	sub	sp, #8
24008a5c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;

  /* Wait for CRC computation to be completed */
  if (FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008a5e:	2101      	movs	r1, #1
24008a60:	f24c 3050 	movw	r0, #50000	; 0xc350
24008a64:	f000 f8bc 	bl	24008be0 <FLASH_CRC_WaitForLastOperation>
24008a68:	4603      	mov	r3, r0
24008a6a:	2b00      	cmp	r3, #0
24008a6c:	d002      	beq.n	24008a74 <HAL_FLASH_OB_Launch+0x1c>
  {
    status = HAL_ERROR;
24008a6e:	2301      	movs	r3, #1
24008a70:	71fb      	strb	r3, [r7, #7]
24008a72:	e001      	b.n	24008a78 <HAL_FLASH_OB_Launch+0x20>
    status = HAL_ERROR;
  }
#endif /* DUAL_BANK */
  else
  {
    status = HAL_OK;
24008a74:	2300      	movs	r3, #0
24008a76:	71fb      	strb	r3, [r7, #7]
  }

  if (status == HAL_OK)
24008a78:	79fb      	ldrb	r3, [r7, #7]
24008a7a:	2b00      	cmp	r3, #0
24008a7c:	d10b      	bne.n	24008a96 <HAL_FLASH_OB_Launch+0x3e>
  {
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->OPTCR, FLASH_OPTCR_OPTSTART);
24008a7e:	4b08      	ldr	r3, [pc, #32]	; (24008aa0 <HAL_FLASH_OB_Launch+0x48>)
24008a80:	699b      	ldr	r3, [r3, #24]
24008a82:	4a07      	ldr	r2, [pc, #28]	; (24008aa0 <HAL_FLASH_OB_Launch+0x48>)
24008a84:	f043 0302 	orr.w	r3, r3, #2
24008a88:	6193      	str	r3, [r2, #24]

    /* Wait for OB change operation to be completed */
    status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
24008a8a:	f24c 3050 	movw	r0, #50000	; 0xc350
24008a8e:	f000 f86b 	bl	24008b68 <FLASH_OB_WaitForLastOperation>
24008a92:	4603      	mov	r3, r0
24008a94:	71fb      	strb	r3, [r7, #7]
  }

  return status;
24008a96:	79fb      	ldrb	r3, [r7, #7]
}
24008a98:	4618      	mov	r0, r3
24008a9a:	3708      	adds	r7, #8
24008a9c:	46bd      	mov	sp, r7
24008a9e:	bd80      	pop	{r7, pc}
24008aa0:	52002000 	.word	0x52002000

24008aa4 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_DBECC_BANK2: Double Detection ECC on Bank 2
  *            @arg HAL_FLASH_ERROR_CRCRD_BANK2: CRC Read Error on Bank 2
*/

uint32_t HAL_FLASH_GetError(void)
{
24008aa4:	b480      	push	{r7}
24008aa6:	af00      	add	r7, sp, #0
   return pFlash.ErrorCode;
24008aa8:	4b03      	ldr	r3, [pc, #12]	; (24008ab8 <HAL_FLASH_GetError+0x14>)
24008aaa:	699b      	ldr	r3, [r3, #24]
}
24008aac:	4618      	mov	r0, r3
24008aae:	46bd      	mov	sp, r7
24008ab0:	f85d 7b04 	ldr.w	r7, [sp], #4
24008ab4:	4770      	bx	lr
24008ab6:	bf00      	nop
24008ab8:	24000590 	.word	0x24000590

24008abc <FLASH_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
24008abc:	b580      	push	{r7, lr}
24008abe:	b086      	sub	sp, #24
24008ac0:	af00      	add	r7, sp, #0
24008ac2:	6078      	str	r0, [r7, #4]
24008ac4:	6039      	str	r1, [r7, #0]
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag = FLASH_FLAG_QW_BANK1;
24008ac6:	2304      	movs	r3, #4
24008ac8:	613b      	str	r3, [r7, #16]
  uint32_t errorflag = 0;
24008aca:	2300      	movs	r3, #0
24008acc:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
24008ace:	f7f9 fc39 	bl	24002344 <HAL_GetTick>
24008ad2:	60f8      	str	r0, [r7, #12]
    /* Select bsyflag depending on Bank */
    bsyflag = FLASH_FLAG_QW_BANK2;
  }
#endif /* DUAL_BANK */

  while(__HAL_FLASH_GET_FLAG(bsyflag))
24008ad4:	e010      	b.n	24008af8 <FLASH_WaitForLastOperation+0x3c>
  {
    if(Timeout != HAL_MAX_DELAY)
24008ad6:	687b      	ldr	r3, [r7, #4]
24008ad8:	f1b3 3fff 	cmp.w	r3, #4294967295
24008adc:	d00c      	beq.n	24008af8 <FLASH_WaitForLastOperation+0x3c>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24008ade:	f7f9 fc31 	bl	24002344 <HAL_GetTick>
24008ae2:	4602      	mov	r2, r0
24008ae4:	68fb      	ldr	r3, [r7, #12]
24008ae6:	1ad3      	subs	r3, r2, r3
24008ae8:	687a      	ldr	r2, [r7, #4]
24008aea:	429a      	cmp	r2, r3
24008aec:	d302      	bcc.n	24008af4 <FLASH_WaitForLastOperation+0x38>
24008aee:	687b      	ldr	r3, [r7, #4]
24008af0:	2b00      	cmp	r3, #0
24008af2:	d101      	bne.n	24008af8 <FLASH_WaitForLastOperation+0x3c>
      {
        return HAL_TIMEOUT;
24008af4:	2303      	movs	r3, #3
24008af6:	e02d      	b.n	24008b54 <FLASH_WaitForLastOperation+0x98>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24008af8:	4b18      	ldr	r3, [pc, #96]	; (24008b5c <FLASH_WaitForLastOperation+0xa0>)
24008afa:	691a      	ldr	r2, [r3, #16]
24008afc:	693b      	ldr	r3, [r7, #16]
24008afe:	4013      	ands	r3, r2
24008b00:	693a      	ldr	r2, [r7, #16]
24008b02:	429a      	cmp	r2, r3
24008b04:	d0e7      	beq.n	24008ad6 <FLASH_WaitForLastOperation+0x1a>
      }
    }
  }

  /* Get Error Flags */
  if (Bank == FLASH_BANK_1)
24008b06:	683b      	ldr	r3, [r7, #0]
24008b08:	2b01      	cmp	r3, #1
24008b0a:	d104      	bne.n	24008b16 <FLASH_WaitForLastOperation+0x5a>
  {
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
24008b0c:	4b13      	ldr	r3, [pc, #76]	; (24008b5c <FLASH_WaitForLastOperation+0xa0>)
24008b0e:	691a      	ldr	r2, [r3, #16]
24008b10:	4b13      	ldr	r3, [pc, #76]	; (24008b60 <FLASH_WaitForLastOperation+0xa4>)
24008b12:	4013      	ands	r3, r2
24008b14:	617b      	str	r3, [r7, #20]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
  }
#endif /* DUAL_BANK */

  /* In case of error reported in Flash SR1 or SR2 register */
  if((errorflag & 0x7FFFFFFFU) != 0U)
24008b16:	697b      	ldr	r3, [r7, #20]
24008b18:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
24008b1c:	2b00      	cmp	r3, #0
24008b1e:	d00a      	beq.n	24008b36 <FLASH_WaitForLastOperation+0x7a>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= errorflag;
24008b20:	4b10      	ldr	r3, [pc, #64]	; (24008b64 <FLASH_WaitForLastOperation+0xa8>)
24008b22:	699a      	ldr	r2, [r3, #24]
24008b24:	697b      	ldr	r3, [r7, #20]
24008b26:	4313      	orrs	r3, r2
24008b28:	4a0e      	ldr	r2, [pc, #56]	; (24008b64 <FLASH_WaitForLastOperation+0xa8>)
24008b2a:	6193      	str	r3, [r2, #24]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(errorflag);
24008b2c:	4a0b      	ldr	r2, [pc, #44]	; (24008b5c <FLASH_WaitForLastOperation+0xa0>)
24008b2e:	697b      	ldr	r3, [r7, #20]
24008b30:	6153      	str	r3, [r2, #20]

    return HAL_ERROR;
24008b32:	2301      	movs	r3, #1
24008b34:	e00e      	b.n	24008b54 <FLASH_WaitForLastOperation+0x98>
  }

  /* Check FLASH End of Operation flag  */
  if(Bank == FLASH_BANK_1)
24008b36:	683b      	ldr	r3, [r7, #0]
24008b38:	2b01      	cmp	r3, #1
24008b3a:	d10a      	bne.n	24008b52 <FLASH_WaitForLastOperation+0x96>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
24008b3c:	4b07      	ldr	r3, [pc, #28]	; (24008b5c <FLASH_WaitForLastOperation+0xa0>)
24008b3e:	691b      	ldr	r3, [r3, #16]
24008b40:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24008b44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24008b48:	d103      	bne.n	24008b52 <FLASH_WaitForLastOperation+0x96>
    {
      /* Clear FLASH End of Operation pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
24008b4a:	4b04      	ldr	r3, [pc, #16]	; (24008b5c <FLASH_WaitForLastOperation+0xa0>)
24008b4c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
24008b50:	615a      	str	r2, [r3, #20]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }
#endif /* DUAL_BANK */

  return HAL_OK;
24008b52:	2300      	movs	r3, #0
}
24008b54:	4618      	mov	r0, r3
24008b56:	3718      	adds	r7, #24
24008b58:	46bd      	mov	sp, r7
24008b5a:	bd80      	pop	{r7, pc}
24008b5c:	52002000 	.word	0x52002000
24008b60:	17ee0000 	.word	0x17ee0000
24008b64:	24000590 	.word	0x24000590

24008b68 <FLASH_OB_WaitForLastOperation>:
  * @brief  Wait for a FLASH Option Bytes change operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_OB_WaitForLastOperation(uint32_t Timeout)
{
24008b68:	b580      	push	{r7, lr}
24008b6a:	b084      	sub	sp, #16
24008b6c:	af00      	add	r7, sp, #0
24008b6e:	6078      	str	r0, [r7, #4]
  /* Get timeout */
  uint32_t tickstart = HAL_GetTick();
24008b70:	f7f9 fbe8 	bl	24002344 <HAL_GetTick>
24008b74:	60f8      	str	r0, [r7, #12]

  /* Wait for the FLASH Option Bytes change operation to complete by polling on OPT_BUSY flag to be reset */
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
24008b76:	e010      	b.n	24008b9a <FLASH_OB_WaitForLastOperation+0x32>
  {
    if(Timeout != HAL_MAX_DELAY)
24008b78:	687b      	ldr	r3, [r7, #4]
24008b7a:	f1b3 3fff 	cmp.w	r3, #4294967295
24008b7e:	d00c      	beq.n	24008b9a <FLASH_OB_WaitForLastOperation+0x32>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24008b80:	f7f9 fbe0 	bl	24002344 <HAL_GetTick>
24008b84:	4602      	mov	r2, r0
24008b86:	68fb      	ldr	r3, [r7, #12]
24008b88:	1ad3      	subs	r3, r2, r3
24008b8a:	687a      	ldr	r2, [r7, #4]
24008b8c:	429a      	cmp	r2, r3
24008b8e:	d302      	bcc.n	24008b96 <FLASH_OB_WaitForLastOperation+0x2e>
24008b90:	687b      	ldr	r3, [r7, #4]
24008b92:	2b00      	cmp	r3, #0
24008b94:	d101      	bne.n	24008b9a <FLASH_OB_WaitForLastOperation+0x32>
      {
        return HAL_TIMEOUT;
24008b96:	2303      	movs	r3, #3
24008b98:	e01a      	b.n	24008bd0 <FLASH_OB_WaitForLastOperation+0x68>
  while(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPT_BUSY) != 0U)
24008b9a:	4b0f      	ldr	r3, [pc, #60]	; (24008bd8 <FLASH_OB_WaitForLastOperation+0x70>)
24008b9c:	69db      	ldr	r3, [r3, #28]
24008b9e:	f003 0301 	and.w	r3, r3, #1
24008ba2:	2b00      	cmp	r3, #0
24008ba4:	d1e8      	bne.n	24008b78 <FLASH_OB_WaitForLastOperation+0x10>
      }
    }
  }

  /* Check option byte change error */
  if(READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_OPTCHANGEERR) != 0U)
24008ba6:	4b0c      	ldr	r3, [pc, #48]	; (24008bd8 <FLASH_OB_WaitForLastOperation+0x70>)
24008ba8:	69db      	ldr	r3, [r3, #28]
24008baa:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
24008bae:	2b00      	cmp	r3, #0
24008bb0:	d00d      	beq.n	24008bce <FLASH_OB_WaitForLastOperation+0x66>
  {
    /* Save the error code */
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OB_CHANGE;
24008bb2:	4b0a      	ldr	r3, [pc, #40]	; (24008bdc <FLASH_OB_WaitForLastOperation+0x74>)
24008bb4:	699b      	ldr	r3, [r3, #24]
24008bb6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24008bba:	4a08      	ldr	r2, [pc, #32]	; (24008bdc <FLASH_OB_WaitForLastOperation+0x74>)
24008bbc:	6193      	str	r3, [r2, #24]

    /* Clear the OB error flag */
    FLASH->OPTCCR |= FLASH_OPTCCR_CLR_OPTCHANGEERR;
24008bbe:	4b06      	ldr	r3, [pc, #24]	; (24008bd8 <FLASH_OB_WaitForLastOperation+0x70>)
24008bc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24008bc2:	4a05      	ldr	r2, [pc, #20]	; (24008bd8 <FLASH_OB_WaitForLastOperation+0x70>)
24008bc4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24008bc8:	6253      	str	r3, [r2, #36]	; 0x24

    return HAL_ERROR;
24008bca:	2301      	movs	r3, #1
24008bcc:	e000      	b.n	24008bd0 <FLASH_OB_WaitForLastOperation+0x68>
  }

  /* If there is no error flag set */
  return HAL_OK;
24008bce:	2300      	movs	r3, #0
}
24008bd0:	4618      	mov	r0, r3
24008bd2:	3710      	adds	r7, #16
24008bd4:	46bd      	mov	sp, r7
24008bd6:	bd80      	pop	{r7, pc}
24008bd8:	52002000 	.word	0x52002000
24008bdc:	24000590 	.word	0x24000590

24008be0 <FLASH_CRC_WaitForLastOperation>:
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_CRC_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
{
24008be0:	b580      	push	{r7, lr}
24008be2:	b084      	sub	sp, #16
24008be4:	af00      	add	r7, sp, #0
24008be6:	6078      	str	r0, [r7, #4]
24008be8:	6039      	str	r1, [r7, #0]
  uint32_t bsyflag;
  uint32_t tickstart = HAL_GetTick();
24008bea:	f7f9 fbab 	bl	24002344 <HAL_GetTick>
24008bee:	60b8      	str	r0, [r7, #8]

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
24008bf0:	683b      	ldr	r3, [r7, #0]
24008bf2:	2b01      	cmp	r3, #1
24008bf4:	d102      	bne.n	24008bfc <FLASH_CRC_WaitForLastOperation+0x1c>
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK1;
24008bf6:	2308      	movs	r3, #8
24008bf8:	60fb      	str	r3, [r7, #12]
24008bfa:	e013      	b.n	24008c24 <FLASH_CRC_WaitForLastOperation+0x44>
  }
  else
  {
    bsyflag = FLASH_FLAG_CRC_BUSY_BANK2;
24008bfc:	4b1a      	ldr	r3, [pc, #104]	; (24008c68 <FLASH_CRC_WaitForLastOperation+0x88>)
24008bfe:	60fb      	str	r3, [r7, #12]
  }

  /* Wait for the FLASH CRC computation to complete by polling on CRC_BUSY flag to be reset */
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24008c00:	e010      	b.n	24008c24 <FLASH_CRC_WaitForLastOperation+0x44>
  {
    if(Timeout != HAL_MAX_DELAY)
24008c02:	687b      	ldr	r3, [r7, #4]
24008c04:	f1b3 3fff 	cmp.w	r3, #4294967295
24008c08:	d00c      	beq.n	24008c24 <FLASH_CRC_WaitForLastOperation+0x44>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24008c0a:	f7f9 fb9b 	bl	24002344 <HAL_GetTick>
24008c0e:	4602      	mov	r2, r0
24008c10:	68bb      	ldr	r3, [r7, #8]
24008c12:	1ad3      	subs	r3, r2, r3
24008c14:	687a      	ldr	r2, [r7, #4]
24008c16:	429a      	cmp	r2, r3
24008c18:	d302      	bcc.n	24008c20 <FLASH_CRC_WaitForLastOperation+0x40>
24008c1a:	687b      	ldr	r3, [r7, #4]
24008c1c:	2b00      	cmp	r3, #0
24008c1e:	d101      	bne.n	24008c24 <FLASH_CRC_WaitForLastOperation+0x44>
      {
        return HAL_TIMEOUT;
24008c20:	2303      	movs	r3, #3
24008c22:	e01d      	b.n	24008c60 <FLASH_CRC_WaitForLastOperation+0x80>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
24008c24:	4b11      	ldr	r3, [pc, #68]	; (24008c6c <FLASH_CRC_WaitForLastOperation+0x8c>)
24008c26:	691a      	ldr	r2, [r3, #16]
24008c28:	68fb      	ldr	r3, [r7, #12]
24008c2a:	4013      	ands	r3, r2
24008c2c:	68fa      	ldr	r2, [r7, #12]
24008c2e:	429a      	cmp	r2, r3
24008c30:	d0e7      	beq.n	24008c02 <FLASH_CRC_WaitForLastOperation+0x22>
      }
    }
  }

  /* Check FLASH CRC read error flag  */
  if(Bank == FLASH_BANK_1)
24008c32:	683b      	ldr	r3, [r7, #0]
24008c34:	2b01      	cmp	r3, #1
24008c36:	d112      	bne.n	24008c5e <FLASH_CRC_WaitForLastOperation+0x7e>
  {
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1))
24008c38:	4b0c      	ldr	r3, [pc, #48]	; (24008c6c <FLASH_CRC_WaitForLastOperation+0x8c>)
24008c3a:	691b      	ldr	r3, [r3, #16]
24008c3c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
24008c40:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24008c44:	d10b      	bne.n	24008c5e <FLASH_CRC_WaitForLastOperation+0x7e>
    {
      /* Save the error code */
      pFlash.ErrorCode |= HAL_FLASH_ERROR_CRCRD_BANK1;
24008c46:	4b0a      	ldr	r3, [pc, #40]	; (24008c70 <FLASH_CRC_WaitForLastOperation+0x90>)
24008c48:	699b      	ldr	r3, [r3, #24]
24008c4a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
24008c4e:	4a08      	ldr	r2, [pc, #32]	; (24008c70 <FLASH_CRC_WaitForLastOperation+0x90>)
24008c50:	6193      	str	r3, [r2, #24]

      /* Clear FLASH CRC read error pending bit */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCRDERR_BANK1);
24008c52:	4b06      	ldr	r3, [pc, #24]	; (24008c6c <FLASH_CRC_WaitForLastOperation+0x8c>)
24008c54:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
24008c58:	615a      	str	r2, [r3, #20]

      return HAL_ERROR;
24008c5a:	2301      	movs	r3, #1
24008c5c:	e000      	b.n	24008c60 <FLASH_CRC_WaitForLastOperation+0x80>
    }
  }
#endif /* DUAL_BANK */

  /* If there is no error flag set */
  return HAL_OK;
24008c5e:	2300      	movs	r3, #0
}
24008c60:	4618      	mov	r0, r3
24008c62:	3710      	adds	r7, #16
24008c64:	46bd      	mov	sp, r7
24008c66:	bd80      	pop	{r7, pc}
24008c68:	80000008 	.word	0x80000008
24008c6c:	52002000 	.word	0x52002000
24008c70:	24000590 	.word	0x24000590

24008c74 <HAL_FLASHEx_Erase>:
  *          the sectors have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
24008c74:	b580      	push	{r7, lr}
24008c76:	b084      	sub	sp, #16
24008c78:	af00      	add	r7, sp, #0
24008c7a:	6078      	str	r0, [r7, #4]
24008c7c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24008c7e:	2300      	movs	r3, #0
24008c80:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24008c82:	4b3f      	ldr	r3, [pc, #252]	; (24008d80 <HAL_FLASHEx_Erase+0x10c>)
24008c84:	7d1b      	ldrb	r3, [r3, #20]
24008c86:	2b01      	cmp	r3, #1
24008c88:	d101      	bne.n	24008c8e <HAL_FLASHEx_Erase+0x1a>
24008c8a:	2302      	movs	r3, #2
24008c8c:	e074      	b.n	24008d78 <HAL_FLASHEx_Erase+0x104>
24008c8e:	4b3c      	ldr	r3, [pc, #240]	; (24008d80 <HAL_FLASHEx_Erase+0x10c>)
24008c90:	2201      	movs	r2, #1
24008c92:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24008c94:	4b3a      	ldr	r3, [pc, #232]	; (24008d80 <HAL_FLASHEx_Erase+0x10c>)
24008c96:	2200      	movs	r2, #0
24008c98:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed on Bank1 */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008c9a:	687b      	ldr	r3, [r7, #4]
24008c9c:	685b      	ldr	r3, [r3, #4]
24008c9e:	f003 0301 	and.w	r3, r3, #1
24008ca2:	2b00      	cmp	r3, #0
24008ca4:	d009      	beq.n	24008cba <HAL_FLASHEx_Erase+0x46>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008ca6:	2101      	movs	r1, #1
24008ca8:	f24c 3050 	movw	r0, #50000	; 0xc350
24008cac:	f7ff ff06 	bl	24008abc <FLASH_WaitForLastOperation>
24008cb0:	4603      	mov	r3, r0
24008cb2:	2b00      	cmp	r3, #0
24008cb4:	d001      	beq.n	24008cba <HAL_FLASHEx_Erase+0x46>
    {
      status = HAL_ERROR;
24008cb6:	2301      	movs	r3, #1
24008cb8:	73fb      	strb	r3, [r7, #15]
      status = HAL_ERROR;
    }
  }
#endif /* DUAL_BANK */

  if(status == HAL_OK)
24008cba:	7bfb      	ldrb	r3, [r7, #15]
24008cbc:	2b00      	cmp	r3, #0
24008cbe:	d157      	bne.n	24008d70 <HAL_FLASHEx_Erase+0xfc>
  {
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
24008cc0:	687b      	ldr	r3, [r7, #4]
24008cc2:	681b      	ldr	r3, [r3, #0]
24008cc4:	2b01      	cmp	r3, #1
24008cc6:	d11e      	bne.n	24008d06 <HAL_FLASHEx_Erase+0x92>
    {
      /* Mass erase to be done */
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
24008cc8:	687b      	ldr	r3, [r7, #4]
24008cca:	691a      	ldr	r2, [r3, #16]
24008ccc:	687b      	ldr	r3, [r7, #4]
24008cce:	685b      	ldr	r3, [r3, #4]
24008cd0:	4619      	mov	r1, r3
24008cd2:	4610      	mov	r0, r2
24008cd4:	f000 fa6c 	bl	240091b0 <FLASH_MassErase>

      /* Wait for last operation to be completed on Bank 1 */
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008cd8:	687b      	ldr	r3, [r7, #4]
24008cda:	685b      	ldr	r3, [r3, #4]
24008cdc:	f003 0301 	and.w	r3, r3, #1
24008ce0:	2b00      	cmp	r3, #0
24008ce2:	d045      	beq.n	24008d70 <HAL_FLASHEx_Erase+0xfc>
      {
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008ce4:	2101      	movs	r1, #1
24008ce6:	f24c 3050 	movw	r0, #50000	; 0xc350
24008cea:	f7ff fee7 	bl	24008abc <FLASH_WaitForLastOperation>
24008cee:	4603      	mov	r3, r0
24008cf0:	2b00      	cmp	r3, #0
24008cf2:	d001      	beq.n	24008cf8 <HAL_FLASHEx_Erase+0x84>
        {
          status = HAL_ERROR;
24008cf4:	2301      	movs	r3, #1
24008cf6:	73fb      	strb	r3, [r7, #15]
        }
        /* if the erase operation is completed, disable the Bank1 BER Bit */
        FLASH->CR1 &= (~FLASH_CR_BER);
24008cf8:	4b22      	ldr	r3, [pc, #136]	; (24008d84 <HAL_FLASHEx_Erase+0x110>)
24008cfa:	68db      	ldr	r3, [r3, #12]
24008cfc:	4a21      	ldr	r2, [pc, #132]	; (24008d84 <HAL_FLASHEx_Erase+0x110>)
24008cfe:	f023 0308 	bic.w	r3, r3, #8
24008d02:	60d3      	str	r3, [r2, #12]
24008d04:	e034      	b.n	24008d70 <HAL_FLASHEx_Erase+0xfc>
#endif /* DUAL_BANK */
    }
    else
    {
      /*Initialization of SectorError variable*/
      *SectorError = 0xFFFFFFFFU;
24008d06:	683b      	ldr	r3, [r7, #0]
24008d08:	f04f 32ff 	mov.w	r2, #4294967295
24008d0c:	601a      	str	r2, [r3, #0]

      /* Erase by sector by sector to be done*/
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
24008d0e:	687b      	ldr	r3, [r7, #4]
24008d10:	689b      	ldr	r3, [r3, #8]
24008d12:	60bb      	str	r3, [r7, #8]
24008d14:	e024      	b.n	24008d60 <HAL_FLASHEx_Erase+0xec>
      {
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
24008d16:	687b      	ldr	r3, [r7, #4]
24008d18:	6859      	ldr	r1, [r3, #4]
24008d1a:	687b      	ldr	r3, [r7, #4]
24008d1c:	691b      	ldr	r3, [r3, #16]
24008d1e:	461a      	mov	r2, r3
24008d20:	68b8      	ldr	r0, [r7, #8]
24008d22:	f000 fa69 	bl	240091f8 <FLASH_Erase_Sector>

        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008d26:	687b      	ldr	r3, [r7, #4]
24008d28:	685b      	ldr	r3, [r3, #4]
24008d2a:	f003 0301 	and.w	r3, r3, #1
24008d2e:	2b00      	cmp	r3, #0
24008d30:	d00c      	beq.n	24008d4c <HAL_FLASHEx_Erase+0xd8>
        {
          /* Wait for last operation to be completed */
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24008d32:	2101      	movs	r1, #1
24008d34:	f24c 3050 	movw	r0, #50000	; 0xc350
24008d38:	f7ff fec0 	bl	24008abc <FLASH_WaitForLastOperation>
24008d3c:	4603      	mov	r3, r0
24008d3e:	73fb      	strb	r3, [r7, #15]

          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
24008d40:	4b10      	ldr	r3, [pc, #64]	; (24008d84 <HAL_FLASHEx_Erase+0x110>)
24008d42:	68da      	ldr	r2, [r3, #12]
24008d44:	490f      	ldr	r1, [pc, #60]	; (24008d84 <HAL_FLASHEx_Erase+0x110>)
24008d46:	4b10      	ldr	r3, [pc, #64]	; (24008d88 <HAL_FLASHEx_Erase+0x114>)
24008d48:	4013      	ands	r3, r2
24008d4a:	60cb      	str	r3, [r1, #12]
          /* If the erase operation is completed, disable the SER Bit */
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
        }
#endif /* DUAL_BANK */

        if(status != HAL_OK)
24008d4c:	7bfb      	ldrb	r3, [r7, #15]
24008d4e:	2b00      	cmp	r3, #0
24008d50:	d003      	beq.n	24008d5a <HAL_FLASHEx_Erase+0xe6>
        {
          /* In case of error, stop erase procedure and return the faulty sector */
          *SectorError = sector_index;
24008d52:	683b      	ldr	r3, [r7, #0]
24008d54:	68ba      	ldr	r2, [r7, #8]
24008d56:	601a      	str	r2, [r3, #0]
          break;
24008d58:	e00a      	b.n	24008d70 <HAL_FLASHEx_Erase+0xfc>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
24008d5a:	68bb      	ldr	r3, [r7, #8]
24008d5c:	3301      	adds	r3, #1
24008d5e:	60bb      	str	r3, [r7, #8]
24008d60:	687b      	ldr	r3, [r7, #4]
24008d62:	68da      	ldr	r2, [r3, #12]
24008d64:	687b      	ldr	r3, [r7, #4]
24008d66:	689b      	ldr	r3, [r3, #8]
24008d68:	4413      	add	r3, r2
24008d6a:	68ba      	ldr	r2, [r7, #8]
24008d6c:	429a      	cmp	r2, r3
24008d6e:	d3d2      	bcc.n	24008d16 <HAL_FLASHEx_Erase+0xa2>
      }
    }
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24008d70:	4b03      	ldr	r3, [pc, #12]	; (24008d80 <HAL_FLASHEx_Erase+0x10c>)
24008d72:	2200      	movs	r2, #0
24008d74:	751a      	strb	r2, [r3, #20]

  return status;
24008d76:	7bfb      	ldrb	r3, [r7, #15]
}
24008d78:	4618      	mov	r0, r3
24008d7a:	3710      	adds	r7, #16
24008d7c:	46bd      	mov	sp, r7
24008d7e:	bd80      	pop	{r7, pc}
24008d80:	24000590 	.word	0x24000590
24008d84:	52002000 	.word	0x52002000
24008d88:	fffff8fb 	.word	0xfffff8fb

24008d8c <HAL_FLASHEx_Erase_IT>:
  *         contains the configuration information for the erasing.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
{
24008d8c:	b580      	push	{r7, lr}
24008d8e:	b084      	sub	sp, #16
24008d90:	af00      	add	r7, sp, #0
24008d92:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24008d94:	2300      	movs	r3, #0
24008d96:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24008d98:	4b31      	ldr	r3, [pc, #196]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008d9a:	7d1b      	ldrb	r3, [r3, #20]
24008d9c:	2b01      	cmp	r3, #1
24008d9e:	d101      	bne.n	24008da4 <HAL_FLASHEx_Erase_IT+0x18>
24008da0:	2302      	movs	r3, #2
24008da2:	e059      	b.n	24008e58 <HAL_FLASHEx_Erase_IT+0xcc>
24008da4:	4b2e      	ldr	r3, [pc, #184]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008da6:	2201      	movs	r2, #1
24008da8:	751a      	strb	r2, [r3, #20]

  /* Reset error code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24008daa:	4b2d      	ldr	r3, [pc, #180]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008dac:	2200      	movs	r2, #0
24008dae:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed on Bank 1 */
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008db0:	687b      	ldr	r3, [r7, #4]
24008db2:	685b      	ldr	r3, [r3, #4]
24008db4:	f003 0301 	and.w	r3, r3, #1
24008db8:	2b00      	cmp	r3, #0
24008dba:	d009      	beq.n	24008dd0 <HAL_FLASHEx_Erase_IT+0x44>
  {
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008dbc:	2101      	movs	r1, #1
24008dbe:	f24c 3050 	movw	r0, #50000	; 0xc350
24008dc2:	f7ff fe7b 	bl	24008abc <FLASH_WaitForLastOperation>
24008dc6:	4603      	mov	r3, r0
24008dc8:	2b00      	cmp	r3, #0
24008dca:	d001      	beq.n	24008dd0 <HAL_FLASHEx_Erase_IT+0x44>
    {
      status = HAL_ERROR;
24008dcc:	2301      	movs	r3, #1
24008dce:	73fb      	strb	r3, [r7, #15]
      status = HAL_ERROR;
    }
  }
#endif /* DUAL_BANK */

  if (status != HAL_OK)
24008dd0:	7bfb      	ldrb	r3, [r7, #15]
24008dd2:	2b00      	cmp	r3, #0
24008dd4:	d003      	beq.n	24008dde <HAL_FLASHEx_Erase_IT+0x52>
  {
    /* Process Unlocked */
    __HAL_UNLOCK(&pFlash);
24008dd6:	4b22      	ldr	r3, [pc, #136]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008dd8:	2200      	movs	r2, #0
24008dda:	751a      	strb	r2, [r3, #20]
24008ddc:	e03b      	b.n	24008e56 <HAL_FLASHEx_Erase_IT+0xca>
  }
  else
  {
    if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
24008dde:	687b      	ldr	r3, [r7, #4]
24008de0:	685b      	ldr	r3, [r3, #4]
24008de2:	f003 0301 	and.w	r3, r3, #1
24008de6:	2b00      	cmp	r3, #0
24008de8:	d005      	beq.n	24008df6 <HAL_FLASHEx_Erase_IT+0x6a>
    {
      /* Enable End of Operation and Error interrupts for Bank 1 */
#if defined (FLASH_CR_OPERRIE)
      __HAL_FLASH_ENABLE_IT_BANK1(FLASH_IT_EOP_BANK1     | FLASH_IT_WRPERR_BANK1 | FLASH_IT_PGSERR_BANK1 | \
24008dea:	4b1e      	ldr	r3, [pc, #120]	; (24008e64 <HAL_FLASHEx_Erase_IT+0xd8>)
24008dec:	68db      	ldr	r3, [r3, #12]
24008dee:	4a1d      	ldr	r2, [pc, #116]	; (24008e64 <HAL_FLASHEx_Erase_IT+0xd8>)
24008df0:	f443 03de 	orr.w	r3, r3, #7274496	; 0x6f0000
24008df4:	60d3      	str	r3, [r2, #12]
                                  FLASH_IT_STRBERR_BANK2 | FLASH_IT_INCERR_BANK2);
#endif /* FLASH_CR_OPERRIE */
    }
#endif /* DUAL_BANK */

    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
24008df6:	687b      	ldr	r3, [r7, #4]
24008df8:	681b      	ldr	r3, [r3, #0]
24008dfa:	2b01      	cmp	r3, #1
24008dfc:	d113      	bne.n	24008e26 <HAL_FLASHEx_Erase_IT+0x9a>
    {
      /*Mass erase to be done*/
      if(pEraseInit->Banks == FLASH_BANK_1)
24008dfe:	687b      	ldr	r3, [r7, #4]
24008e00:	685b      	ldr	r3, [r3, #4]
24008e02:	2b01      	cmp	r3, #1
24008e04:	d103      	bne.n	24008e0e <HAL_FLASHEx_Erase_IT+0x82>
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK1;
24008e06:	4b16      	ldr	r3, [pc, #88]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008e08:	2202      	movs	r2, #2
24008e0a:	701a      	strb	r2, [r3, #0]
24008e0c:	e002      	b.n	24008e14 <HAL_FLASHEx_Erase_IT+0x88>
        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE_BANK2;
      }
#endif /* DUAL_BANK */
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_ALLBANK_MASSERASE;
24008e0e:	4b14      	ldr	r3, [pc, #80]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008e10:	2207      	movs	r2, #7
24008e12:	701a      	strb	r2, [r3, #0]
      }

      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
24008e14:	687b      	ldr	r3, [r7, #4]
24008e16:	691a      	ldr	r2, [r3, #16]
24008e18:	687b      	ldr	r3, [r7, #4]
24008e1a:	685b      	ldr	r3, [r3, #4]
24008e1c:	4619      	mov	r1, r3
24008e1e:	4610      	mov	r0, r2
24008e20:	f000 f9c6 	bl	240091b0 <FLASH_MassErase>
24008e24:	e017      	b.n	24008e56 <HAL_FLASHEx_Erase_IT+0xca>
      else
      {
        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK2;
      }
#else
      pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE_BANK1;
24008e26:	4b0e      	ldr	r3, [pc, #56]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008e28:	2201      	movs	r2, #1
24008e2a:	701a      	strb	r2, [r3, #0]
#endif /* DUAL_BANK */

      pFlash.NbSectorsToErase = pEraseInit->NbSectors;
24008e2c:	687b      	ldr	r3, [r7, #4]
24008e2e:	68db      	ldr	r3, [r3, #12]
24008e30:	4a0b      	ldr	r2, [pc, #44]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008e32:	6053      	str	r3, [r2, #4]
      pFlash.Sector = pEraseInit->Sector;
24008e34:	687b      	ldr	r3, [r7, #4]
24008e36:	689b      	ldr	r3, [r3, #8]
24008e38:	4a09      	ldr	r2, [pc, #36]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008e3a:	60d3      	str	r3, [r2, #12]
      pFlash.VoltageForErase = pEraseInit->VoltageRange;
24008e3c:	687b      	ldr	r3, [r7, #4]
24008e3e:	691b      	ldr	r3, [r3, #16]
24008e40:	4a07      	ldr	r2, [pc, #28]	; (24008e60 <HAL_FLASHEx_Erase_IT+0xd4>)
24008e42:	6093      	str	r3, [r2, #8]

      /* Erase first sector and wait for IT */
      FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->Banks, pEraseInit->VoltageRange);
24008e44:	687b      	ldr	r3, [r7, #4]
24008e46:	6898      	ldr	r0, [r3, #8]
24008e48:	687b      	ldr	r3, [r7, #4]
24008e4a:	6859      	ldr	r1, [r3, #4]
24008e4c:	687b      	ldr	r3, [r7, #4]
24008e4e:	691b      	ldr	r3, [r3, #16]
24008e50:	461a      	mov	r2, r3
24008e52:	f000 f9d1 	bl	240091f8 <FLASH_Erase_Sector>
    }
  }

  return status;
24008e56:	7bfb      	ldrb	r3, [r7, #15]
}
24008e58:	4618      	mov	r0, r3
24008e5a:	3710      	adds	r7, #16
24008e5c:	46bd      	mov	sp, r7
24008e5e:	bd80      	pop	{r7, pc}
24008e60:	24000590 	.word	0x24000590
24008e64:	52002000 	.word	0x52002000

24008e68 <HAL_FLASHEx_OBProgram>:
  *         contains the configuration information for the programming.
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
24008e68:	b580      	push	{r7, lr}
24008e6a:	b084      	sub	sp, #16
24008e6c:	af00      	add	r7, sp, #0
24008e6e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));

  /* Process Locked */
  __HAL_LOCK(&pFlash);
24008e70:	4b48      	ldr	r3, [pc, #288]	; (24008f94 <HAL_FLASHEx_OBProgram+0x12c>)
24008e72:	7d1b      	ldrb	r3, [r3, #20]
24008e74:	2b01      	cmp	r3, #1
24008e76:	d101      	bne.n	24008e7c <HAL_FLASHEx_OBProgram+0x14>
24008e78:	2302      	movs	r3, #2
24008e7a:	e087      	b.n	24008f8c <HAL_FLASHEx_OBProgram+0x124>
24008e7c:	4b45      	ldr	r3, [pc, #276]	; (24008f94 <HAL_FLASHEx_OBProgram+0x12c>)
24008e7e:	2201      	movs	r2, #1
24008e80:	751a      	strb	r2, [r3, #20]

  /* Reset Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
24008e82:	4b44      	ldr	r3, [pc, #272]	; (24008f94 <HAL_FLASHEx_OBProgram+0x12c>)
24008e84:	2200      	movs	r2, #0
24008e86:	619a      	str	r2, [r3, #24]

  /* Wait for last operation to be completed */
  if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
24008e88:	2101      	movs	r1, #1
24008e8a:	f24c 3050 	movw	r0, #50000	; 0xc350
24008e8e:	f7ff fe15 	bl	24008abc <FLASH_WaitForLastOperation>
24008e92:	4603      	mov	r3, r0
24008e94:	2b00      	cmp	r3, #0
24008e96:	d002      	beq.n	24008e9e <HAL_FLASHEx_OBProgram+0x36>
  {
    status = HAL_ERROR;
24008e98:	2301      	movs	r3, #1
24008e9a:	73fb      	strb	r3, [r7, #15]
24008e9c:	e001      	b.n	24008ea2 <HAL_FLASHEx_OBProgram+0x3a>
    status = HAL_ERROR;
  }
#endif /* DUAL_BANK */
  else
  {
    status = HAL_OK;
24008e9e:	2300      	movs	r3, #0
24008ea0:	73fb      	strb	r3, [r7, #15]
  }

  if(status == HAL_OK)
24008ea2:	7bfb      	ldrb	r3, [r7, #15]
24008ea4:	2b00      	cmp	r3, #0
24008ea6:	d16d      	bne.n	24008f84 <HAL_FLASHEx_OBProgram+0x11c>
  {
    /*Write protection configuration*/
    if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
24008ea8:	687b      	ldr	r3, [r7, #4]
24008eaa:	681b      	ldr	r3, [r3, #0]
24008eac:	f003 0301 	and.w	r3, r3, #1
24008eb0:	2b00      	cmp	r3, #0
24008eb2:	d014      	beq.n	24008ede <HAL_FLASHEx_OBProgram+0x76>
    {
      assert_param(IS_WRPSTATE(pOBInit->WRPState));

      if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
24008eb4:	687b      	ldr	r3, [r7, #4]
24008eb6:	685b      	ldr	r3, [r3, #4]
24008eb8:	2b01      	cmp	r3, #1
24008eba:	d108      	bne.n	24008ece <HAL_FLASHEx_OBProgram+0x66>
      {
        /*Enable of Write protection on the selected Sector*/
        FLASH_OB_EnableWRP(pOBInit->WRPSector,pOBInit->Banks);
24008ebc:	687b      	ldr	r3, [r7, #4]
24008ebe:	689a      	ldr	r2, [r3, #8]
24008ec0:	687b      	ldr	r3, [r7, #4]
24008ec2:	69db      	ldr	r3, [r3, #28]
24008ec4:	4619      	mov	r1, r3
24008ec6:	4610      	mov	r0, r2
24008ec8:	f000 f9ba 	bl	24009240 <FLASH_OB_EnableWRP>
24008ecc:	e007      	b.n	24008ede <HAL_FLASHEx_OBProgram+0x76>
      }
      else
      {
        /*Disable of Write protection on the selected Sector*/
        FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
24008ece:	687b      	ldr	r3, [r7, #4]
24008ed0:	689a      	ldr	r2, [r3, #8]
24008ed2:	687b      	ldr	r3, [r7, #4]
24008ed4:	69db      	ldr	r3, [r3, #28]
24008ed6:	4619      	mov	r1, r3
24008ed8:	4610      	mov	r0, r2
24008eda:	f000 f9cb 	bl	24009274 <FLASH_OB_DisableWRP>
      }
    }

    /* Read protection configuration */
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
24008ede:	687b      	ldr	r3, [r7, #4]
24008ee0:	681b      	ldr	r3, [r3, #0]
24008ee2:	f003 0302 	and.w	r3, r3, #2
24008ee6:	2b00      	cmp	r3, #0
24008ee8:	d004      	beq.n	24008ef4 <HAL_FLASHEx_OBProgram+0x8c>
    {
      /* Configure the Read protection level */
      FLASH_OB_RDPConfig(pOBInit->RDPLevel);
24008eea:	687b      	ldr	r3, [r7, #4]
24008eec:	68db      	ldr	r3, [r3, #12]
24008eee:	4618      	mov	r0, r3
24008ef0:	f000 fa00 	bl	240092f4 <FLASH_OB_RDPConfig>
    }

    /* User Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
24008ef4:	687b      	ldr	r3, [r7, #4]
24008ef6:	681b      	ldr	r3, [r3, #0]
24008ef8:	f003 0304 	and.w	r3, r3, #4
24008efc:	2b00      	cmp	r3, #0
24008efe:	d007      	beq.n	24008f10 <HAL_FLASHEx_OBProgram+0xa8>
    {
      /* Configure the user option bytes */
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
24008f00:	687b      	ldr	r3, [r7, #4]
24008f02:	695a      	ldr	r2, [r3, #20]
24008f04:	687b      	ldr	r3, [r7, #4]
24008f06:	699b      	ldr	r3, [r3, #24]
24008f08:	4619      	mov	r1, r3
24008f0a:	4610      	mov	r0, r2
24008f0c:	f000 fa22 	bl	24009354 <FLASH_OB_UserConfig>
    }

    /* PCROP Configuration */
    if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
24008f10:	687b      	ldr	r3, [r7, #4]
24008f12:	681b      	ldr	r3, [r3, #0]
24008f14:	f003 0308 	and.w	r3, r3, #8
24008f18:	2b00      	cmp	r3, #0
24008f1a:	d009      	beq.n	24008f30 <HAL_FLASHEx_OBProgram+0xc8>
    {
      assert_param(IS_FLASH_BANK(pOBInit->Banks));

      /*Configure the Proprietary code readout protection */
      FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr, pOBInit->Banks);
24008f1c:	687b      	ldr	r3, [r7, #4]
24008f1e:	6a18      	ldr	r0, [r3, #32]
24008f20:	687b      	ldr	r3, [r7, #4]
24008f22:	6a59      	ldr	r1, [r3, #36]	; 0x24
24008f24:	687b      	ldr	r3, [r7, #4]
24008f26:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24008f28:	687b      	ldr	r3, [r7, #4]
24008f2a:	69db      	ldr	r3, [r3, #28]
24008f2c:	f000 faba 	bl	240094a4 <FLASH_OB_PCROPConfig>
    }

    /* BOR Level configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
24008f30:	687b      	ldr	r3, [r7, #4]
24008f32:	681b      	ldr	r3, [r3, #0]
24008f34:	f003 0310 	and.w	r3, r3, #16
24008f38:	2b00      	cmp	r3, #0
24008f3a:	d004      	beq.n	24008f46 <HAL_FLASHEx_OBProgram+0xde>
    {
      FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
24008f3c:	687b      	ldr	r3, [r7, #4]
24008f3e:	691b      	ldr	r3, [r3, #16]
24008f40:	4618      	mov	r0, r3
24008f42:	f000 fb09 	bl	24009558 <FLASH_OB_BOR_LevelConfig>
    {
      FLASH_OB_CM4BootAddConfig(pOBInit->CM4BootConfig, pOBInit->CM4BootAddr0, pOBInit->CM4BootAddr1);
    }
#else /* Single Core*/
    /* Boot Address  configuration */
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADD) == OPTIONBYTE_BOOTADD)
24008f46:	687b      	ldr	r3, [r7, #4]
24008f48:	681b      	ldr	r3, [r3, #0]
24008f4a:	f003 0340 	and.w	r3, r3, #64	; 0x40
24008f4e:	2b00      	cmp	r3, #0
24008f50:	d008      	beq.n	24008f64 <HAL_FLASHEx_OBProgram+0xfc>
    {
      FLASH_OB_BootAddConfig(pOBInit->BootConfig, pOBInit->BootAddr0, pOBInit->BootAddr1);
24008f52:	687b      	ldr	r3, [r7, #4]
24008f54:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
24008f56:	687b      	ldr	r3, [r7, #4]
24008f58:	6b19      	ldr	r1, [r3, #48]	; 0x30
24008f5a:	687b      	ldr	r3, [r7, #4]
24008f5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24008f5e:	461a      	mov	r2, r3
24008f60:	f000 fb1c 	bl	2400959c <FLASH_OB_BootAddConfig>
    }
#endif /*DUAL_CORE*/

    /* Secure area configuration */
    if((pOBInit->OptionType & OPTIONBYTE_SECURE_AREA) == OPTIONBYTE_SECURE_AREA)
24008f64:	687b      	ldr	r3, [r7, #4]
24008f66:	681b      	ldr	r3, [r3, #0]
24008f68:	f003 0320 	and.w	r3, r3, #32
24008f6c:	2b00      	cmp	r3, #0
24008f6e:	d009      	beq.n	24008f84 <HAL_FLASHEx_OBProgram+0x11c>
    {
      FLASH_OB_SecureAreaConfig(pOBInit->SecureAreaConfig, pOBInit->SecureAreaStartAddr, pOBInit->SecureAreaEndAddr,pOBInit->Banks);
24008f70:	687b      	ldr	r3, [r7, #4]
24008f72:	6b98      	ldr	r0, [r3, #56]	; 0x38
24008f74:	687b      	ldr	r3, [r7, #4]
24008f76:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
24008f78:	687b      	ldr	r3, [r7, #4]
24008f7a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
24008f7c:	687b      	ldr	r3, [r7, #4]
24008f7e:	69db      	ldr	r3, [r3, #28]
24008f80:	f000 fb52 	bl	24009628 <FLASH_OB_SecureAreaConfig>
    }
#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
24008f84:	4b03      	ldr	r3, [pc, #12]	; (24008f94 <HAL_FLASHEx_OBProgram+0x12c>)
24008f86:	2200      	movs	r2, #0
24008f88:	751a      	strb	r2, [r3, #20]

  return status;
24008f8a:	7bfb      	ldrb	r3, [r7, #15]
}
24008f8c:	4618      	mov	r0, r3
24008f8e:	3710      	adds	r7, #16
24008f90:	46bd      	mov	sp, r7
24008f92:	bd80      	pop	{r7, pc}
24008f94:	24000590 	.word	0x24000590

24008f98 <HAL_FLASHEx_OBGetConfig>:
  *         as this parameter is use to get the given Bank WRP, PCROP and secured area configuration.
  *
  * @retval None
  */
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
{
24008f98:	b580      	push	{r7, lr}
24008f9a:	b082      	sub	sp, #8
24008f9c:	af00      	add	r7, sp, #0
24008f9e:	6078      	str	r0, [r7, #4]
  pOBInit->OptionType = (OPTIONBYTE_USER | OPTIONBYTE_RDP | OPTIONBYTE_BOR);
24008fa0:	687b      	ldr	r3, [r7, #4]
24008fa2:	2216      	movs	r2, #22
24008fa4:	601a      	str	r2, [r3, #0]

  /* Get Read protection level */
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
24008fa6:	f000 f9b9 	bl	2400931c <FLASH_OB_GetRDP>
24008faa:	4602      	mov	r2, r0
24008fac:	687b      	ldr	r3, [r7, #4]
24008fae:	60da      	str	r2, [r3, #12]

  /* Get the user option bytes */
  pOBInit->USERConfig = FLASH_OB_GetUser();
24008fb0:	f000 fa62 	bl	24009478 <FLASH_OB_GetUser>
24008fb4:	4602      	mov	r2, r0
24008fb6:	687b      	ldr	r3, [r7, #4]
24008fb8:	619a      	str	r2, [r3, #24]

  /*Get BOR Level*/
  pOBInit->BORLevel = FLASH_OB_GetBOR();
24008fba:	f000 fae1 	bl	24009580 <FLASH_OB_GetBOR>
24008fbe:	4602      	mov	r2, r0
24008fc0:	687b      	ldr	r3, [r7, #4]
24008fc2:	611a      	str	r2, [r3, #16]

#if defined (DUAL_BANK)
  if ((pOBInit->Banks == FLASH_BANK_1) || (pOBInit->Banks == FLASH_BANK_2))
#else
  if (pOBInit->Banks == FLASH_BANK_1)
24008fc4:	687b      	ldr	r3, [r7, #4]
24008fc6:	69db      	ldr	r3, [r3, #28]
24008fc8:	2b01      	cmp	r3, #1
24008fca:	d129      	bne.n	24009020 <HAL_FLASHEx_OBGetConfig+0x88>
#endif /* DUAL_BANK */
  {
    pOBInit->OptionType |= (OPTIONBYTE_WRP | OPTIONBYTE_PCROP | OPTIONBYTE_SECURE_AREA);
24008fcc:	687b      	ldr	r3, [r7, #4]
24008fce:	681b      	ldr	r3, [r3, #0]
24008fd0:	f043 0229 	orr.w	r2, r3, #41	; 0x29
24008fd4:	687b      	ldr	r3, [r7, #4]
24008fd6:	601a      	str	r2, [r3, #0]

    /* Get write protection on the selected area */
    FLASH_OB_GetWRP(&(pOBInit->WRPState), &(pOBInit->WRPSector), pOBInit->Banks);
24008fd8:	687b      	ldr	r3, [r7, #4]
24008fda:	1d18      	adds	r0, r3, #4
24008fdc:	687b      	ldr	r3, [r7, #4]
24008fde:	f103 0108 	add.w	r1, r3, #8
24008fe2:	687b      	ldr	r3, [r7, #4]
24008fe4:	69db      	ldr	r3, [r3, #28]
24008fe6:	461a      	mov	r2, r3
24008fe8:	f000 f95e 	bl	240092a8 <FLASH_OB_GetWRP>

    /* Get the Proprietary code readout protection */
    FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROPStartAddr), &(pOBInit->PCROPEndAddr), pOBInit->Banks);
24008fec:	687b      	ldr	r3, [r7, #4]
24008fee:	f103 0020 	add.w	r0, r3, #32
24008ff2:	687b      	ldr	r3, [r7, #4]
24008ff4:	f103 0124 	add.w	r1, r3, #36	; 0x24
24008ff8:	687b      	ldr	r3, [r7, #4]
24008ffa:	f103 0228 	add.w	r2, r3, #40	; 0x28
24008ffe:	687b      	ldr	r3, [r7, #4]
24009000:	69db      	ldr	r3, [r3, #28]
24009002:	f000 fa71 	bl	240094e8 <FLASH_OB_GetPCROP>

    /*Get Bank Secure area*/
    FLASH_OB_GetSecureArea(&(pOBInit->SecureAreaConfig), &(pOBInit->SecureAreaStartAddr), &(pOBInit->SecureAreaEndAddr), pOBInit->Banks);
24009006:	687b      	ldr	r3, [r7, #4]
24009008:	f103 0038 	add.w	r0, r3, #56	; 0x38
2400900c:	687b      	ldr	r3, [r7, #4]
2400900e:	f103 013c 	add.w	r1, r3, #60	; 0x3c
24009012:	687b      	ldr	r3, [r7, #4]
24009014:	f103 0240 	add.w	r2, r3, #64	; 0x40
24009018:	687b      	ldr	r3, [r7, #4]
2400901a:	69db      	ldr	r3, [r3, #28]
2400901c:	f000 fb28 	bl	24009670 <FLASH_OB_GetSecureArea>
  }

  /*Get Boot Address*/
  FLASH_OB_GetBootAdd(&(pOBInit->BootAddr0), &(pOBInit->BootAddr1));
24009020:	687b      	ldr	r3, [r7, #4]
24009022:	f103 0230 	add.w	r2, r3, #48	; 0x30
24009026:	687b      	ldr	r3, [r7, #4]
24009028:	3334      	adds	r3, #52	; 0x34
2400902a:	4619      	mov	r1, r3
2400902c:	4610      	mov	r0, r2
2400902e:	f000 fadf 	bl	240095f0 <FLASH_OB_GetBootAdd>
  pOBInit->OptionType |= OPTIONBYTE_CM7_BOOTADD | OPTIONBYTE_CM4_BOOTADD;

  /*Get CM4 Boot Address*/
  FLASH_OB_GetCM4BootAdd(&(pOBInit->CM4BootAddr0), &(pOBInit->CM4BootAddr1));
#else
  pOBInit->OptionType |= OPTIONBYTE_BOOTADD;
24009032:	687b      	ldr	r3, [r7, #4]
24009034:	681b      	ldr	r3, [r3, #0]
24009036:	f043 0240 	orr.w	r2, r3, #64	; 0x40
2400903a:	687b      	ldr	r3, [r7, #4]
2400903c:	601a      	str	r2, [r3, #0]
  pOBInit->OptionType |= OPTIONBYTE_FREQ_BOOST;

  /* Get CPU Frequency Boost */
  pOBInit->FreqBoostState = FLASH_OB_CPUFreq_GetBoost();
#endif /* FLASH_OPTSR2_CPUFREQ_BOOST */
}
2400903e:	bf00      	nop
24009040:	3708      	adds	r7, #8
24009042:	46bd      	mov	sp, r7
24009044:	bd80      	pop	{r7, pc}
	...

24009048 <HAL_FLASHEx_Unlock_Bank1>:
/**
  * @brief  Unlock the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Unlock_Bank1(void)
{
24009048:	b480      	push	{r7}
2400904a:	af00      	add	r7, sp, #0
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
2400904c:	4b0c      	ldr	r3, [pc, #48]	; (24009080 <HAL_FLASHEx_Unlock_Bank1+0x38>)
2400904e:	68db      	ldr	r3, [r3, #12]
24009050:	f003 0301 	and.w	r3, r3, #1
24009054:	2b00      	cmp	r3, #0
24009056:	d00d      	beq.n	24009074 <HAL_FLASHEx_Unlock_Bank1+0x2c>
  {
    /* Authorize the FLASH Bank1 Registers access */
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
24009058:	4b09      	ldr	r3, [pc, #36]	; (24009080 <HAL_FLASHEx_Unlock_Bank1+0x38>)
2400905a:	4a0a      	ldr	r2, [pc, #40]	; (24009084 <HAL_FLASHEx_Unlock_Bank1+0x3c>)
2400905c:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
2400905e:	4b08      	ldr	r3, [pc, #32]	; (24009080 <HAL_FLASHEx_Unlock_Bank1+0x38>)
24009060:	4a09      	ldr	r2, [pc, #36]	; (24009088 <HAL_FLASHEx_Unlock_Bank1+0x40>)
24009062:	605a      	str	r2, [r3, #4]

    /* Verify Flash Bank1 is unlocked */
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
24009064:	4b06      	ldr	r3, [pc, #24]	; (24009080 <HAL_FLASHEx_Unlock_Bank1+0x38>)
24009066:	68db      	ldr	r3, [r3, #12]
24009068:	f003 0301 	and.w	r3, r3, #1
2400906c:	2b00      	cmp	r3, #0
2400906e:	d001      	beq.n	24009074 <HAL_FLASHEx_Unlock_Bank1+0x2c>
    {
      return HAL_ERROR;
24009070:	2301      	movs	r3, #1
24009072:	e000      	b.n	24009076 <HAL_FLASHEx_Unlock_Bank1+0x2e>
    }
  }

  return HAL_OK;
24009074:	2300      	movs	r3, #0
}
24009076:	4618      	mov	r0, r3
24009078:	46bd      	mov	sp, r7
2400907a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400907e:	4770      	bx	lr
24009080:	52002000 	.word	0x52002000
24009084:	45670123 	.word	0x45670123
24009088:	cdef89ab 	.word	0xcdef89ab

2400908c <HAL_FLASHEx_Lock_Bank1>:
/**
  * @brief  Locks the FLASH Bank1 control registers access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Lock_Bank1(void)
{
2400908c:	b480      	push	{r7}
2400908e:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Bank1 Registers access */
  SET_BIT(FLASH->CR1, FLASH_CR_LOCK);
24009090:	4b05      	ldr	r3, [pc, #20]	; (240090a8 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24009092:	68db      	ldr	r3, [r3, #12]
24009094:	4a04      	ldr	r2, [pc, #16]	; (240090a8 <HAL_FLASHEx_Lock_Bank1+0x1c>)
24009096:	f043 0301 	orr.w	r3, r3, #1
2400909a:	60d3      	str	r3, [r2, #12]
  return HAL_OK;
2400909c:	2300      	movs	r3, #0
}
2400909e:	4618      	mov	r0, r3
240090a0:	46bd      	mov	sp, r7
240090a2:	f85d 7b04 	ldr.w	r7, [sp], #4
240090a6:	4770      	bx	lr
240090a8:	52002000 	.word	0x52002000

240090ac <HAL_FLASHEx_ComputeCRC>:
  *         A special error flag (CRC read error: CRCRDERR) can be used to
  *         detect such a case.
  * @retval HAL Status
*/
HAL_StatusTypeDef HAL_FLASHEx_ComputeCRC(FLASH_CRCInitTypeDef *pCRCInit, uint32_t *CRC_Result)
{
240090ac:	b580      	push	{r7, lr}
240090ae:	b084      	sub	sp, #16
240090b0:	af00      	add	r7, sp, #0
240090b2:	6078      	str	r0, [r7, #4]
240090b4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK_EXCLUSIVE(pCRCInit->Bank));
  assert_param(IS_FLASH_TYPECRC(pCRCInit->TypeCRC));

  /* Wait for OB change operation to be completed */
  status = FLASH_OB_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
240090b6:	f24c 3050 	movw	r0, #50000	; 0xc350
240090ba:	f7ff fd55 	bl	24008b68 <FLASH_OB_WaitForLastOperation>
240090be:	4603      	mov	r3, r0
240090c0:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
240090c2:	7bfb      	ldrb	r3, [r7, #15]
240090c4:	2b00      	cmp	r3, #0
240090c6:	d169      	bne.n	2400919c <HAL_FLASHEx_ComputeCRC+0xf0>
  {
    if (pCRCInit->Bank == FLASH_BANK_1)
240090c8:	687b      	ldr	r3, [r7, #4]
240090ca:	689b      	ldr	r3, [r3, #8]
240090cc:	2b01      	cmp	r3, #1
240090ce:	d165      	bne.n	2400919c <HAL_FLASHEx_ComputeCRC+0xf0>
    {
      /* Enable CRC feature */
      FLASH->CR1 |= FLASH_CR_CRC_EN;
240090d0:	4b35      	ldr	r3, [pc, #212]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
240090d2:	68db      	ldr	r3, [r3, #12]
240090d4:	4a34      	ldr	r2, [pc, #208]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
240090d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
240090da:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags in Status Register: CRC end of calculation and CRC read error */
      FLASH->CCR1 |= (FLASH_CCR_CLR_CRCEND | FLASH_CCR_CLR_CRCRDERR);
240090dc:	4b32      	ldr	r3, [pc, #200]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
240090de:	695b      	ldr	r3, [r3, #20]
240090e0:	4a31      	ldr	r2, [pc, #196]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
240090e2:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
240090e6:	6153      	str	r3, [r2, #20]

      /* Clear current CRC result, program burst size and define memory area on which CRC has to be computed */
      FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_CRC | pCRCInit->BurstSize | pCRCInit->TypeCRC;
240090e8:	4b2f      	ldr	r3, [pc, #188]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
240090ea:	6d1a      	ldr	r2, [r3, #80]	; 0x50
240090ec:	687b      	ldr	r3, [r7, #4]
240090ee:	6859      	ldr	r1, [r3, #4]
240090f0:	687b      	ldr	r3, [r7, #4]
240090f2:	681b      	ldr	r3, [r3, #0]
240090f4:	430b      	orrs	r3, r1
240090f6:	4313      	orrs	r3, r2
240090f8:	4a2b      	ldr	r2, [pc, #172]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
240090fa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240090fe:	6513      	str	r3, [r2, #80]	; 0x50

      if (pCRCInit->TypeCRC == FLASH_CRC_SECTORS)
24009100:	687b      	ldr	r3, [r7, #4]
24009102:	681b      	ldr	r3, [r3, #0]
24009104:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24009108:	d119      	bne.n	2400913e <HAL_FLASHEx_ComputeCRC+0x92>
      {
        /* Clear sectors list */
        FLASH->CRCCR1 |= FLASH_CRCCR_CLEAN_SECT;
2400910a:	4b27      	ldr	r3, [pc, #156]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
2400910c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400910e:	4a26      	ldr	r2, [pc, #152]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
24009110:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
24009114:	6513      	str	r3, [r2, #80]	; 0x50

        /* Select CRC sectors */
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24009116:	687b      	ldr	r3, [r7, #4]
24009118:	68db      	ldr	r3, [r3, #12]
2400911a:	60bb      	str	r3, [r7, #8]
2400911c:	e006      	b.n	2400912c <HAL_FLASHEx_ComputeCRC+0x80>
        {
          FLASH_CRC_AddSector(sector_index, FLASH_BANK_1);
2400911e:	2101      	movs	r1, #1
24009120:	68b8      	ldr	r0, [r7, #8]
24009122:	f000 fadd 	bl	240096e0 <FLASH_CRC_AddSector>
        for(sector_index = pCRCInit->Sector; sector_index < (pCRCInit->NbSectors + pCRCInit->Sector); sector_index++)
24009126:	68bb      	ldr	r3, [r7, #8]
24009128:	3301      	adds	r3, #1
2400912a:	60bb      	str	r3, [r7, #8]
2400912c:	687b      	ldr	r3, [r7, #4]
2400912e:	691a      	ldr	r2, [r3, #16]
24009130:	687b      	ldr	r3, [r7, #4]
24009132:	68db      	ldr	r3, [r3, #12]
24009134:	4413      	add	r3, r2
24009136:	68ba      	ldr	r2, [r7, #8]
24009138:	429a      	cmp	r2, r3
2400913a:	d3f0      	bcc.n	2400911e <HAL_FLASHEx_ComputeCRC+0x72>
2400913c:	e013      	b.n	24009166 <HAL_FLASHEx_ComputeCRC+0xba>
        }
      }
      else if (pCRCInit->TypeCRC == FLASH_CRC_BANK)
2400913e:	687b      	ldr	r3, [r7, #4]
24009140:	681b      	ldr	r3, [r3, #0]
24009142:	4a1a      	ldr	r2, [pc, #104]	; (240091ac <HAL_FLASHEx_ComputeCRC+0x100>)
24009144:	4293      	cmp	r3, r2
24009146:	d106      	bne.n	24009156 <HAL_FLASHEx_ComputeCRC+0xaa>
      {
        /* Enable Bank 1 CRC select bit */
        FLASH->CRCCR1 |= FLASH_CRCCR_ALL_BANK;
24009148:	4b17      	ldr	r3, [pc, #92]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
2400914a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400914c:	4a16      	ldr	r2, [pc, #88]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
2400914e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24009152:	6513      	str	r3, [r2, #80]	; 0x50
24009154:	e007      	b.n	24009166 <HAL_FLASHEx_ComputeCRC+0xba>
      }
      else
      {
        /* Select CRC start and end addresses */
        FLASH_CRC_SelectAddress(pCRCInit->CRCStartAddr, pCRCInit->CRCEndAddr, FLASH_BANK_1);
24009156:	687b      	ldr	r3, [r7, #4]
24009158:	6958      	ldr	r0, [r3, #20]
2400915a:	687b      	ldr	r3, [r7, #4]
2400915c:	699b      	ldr	r3, [r3, #24]
2400915e:	2201      	movs	r2, #1
24009160:	4619      	mov	r1, r3
24009162:	f000 fadb 	bl	2400971c <FLASH_CRC_SelectAddress>
      }

      /* Start the CRC calculation */
      FLASH->CRCCR1 |= FLASH_CRCCR_START_CRC;
24009166:	4b10      	ldr	r3, [pc, #64]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
24009168:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400916a:	4a0f      	ldr	r2, [pc, #60]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
2400916c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24009170:	6513      	str	r3, [r2, #80]	; 0x50

      /* Wait on CRC busy flag */
      status = FLASH_CRC_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
24009172:	2101      	movs	r1, #1
24009174:	f24c 3050 	movw	r0, #50000	; 0xc350
24009178:	f7ff fd32 	bl	24008be0 <FLASH_CRC_WaitForLastOperation>
2400917c:	4603      	mov	r3, r0
2400917e:	73fb      	strb	r3, [r7, #15]

      /* Return CRC result */
      (*CRC_Result) = FLASH->CRCDATA;
24009180:	4b09      	ldr	r3, [pc, #36]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
24009182:	6dda      	ldr	r2, [r3, #92]	; 0x5c
24009184:	683b      	ldr	r3, [r7, #0]
24009186:	601a      	str	r2, [r3, #0]

      /* Disable CRC feature */
      FLASH->CR1 &= (~FLASH_CR_CRC_EN);
24009188:	4b07      	ldr	r3, [pc, #28]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
2400918a:	68db      	ldr	r3, [r3, #12]
2400918c:	4a06      	ldr	r2, [pc, #24]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
2400918e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
24009192:	60d3      	str	r3, [r2, #12]

      /* Clear CRC flags */
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_CRCEND_BANK1 | FLASH_FLAG_CRCRDERR_BANK1);
24009194:	4b04      	ldr	r3, [pc, #16]	; (240091a8 <HAL_FLASHEx_ComputeCRC+0xfc>)
24009196:	f04f 52c0 	mov.w	r2, #402653184	; 0x18000000
2400919a:	615a      	str	r2, [r3, #20]
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_CRCEND_BANK2 | FLASH_FLAG_CRCRDERR_BANK2);
    }
#endif /* DUAL_BANK */
  }

  return status;
2400919c:	7bfb      	ldrb	r3, [r7, #15]
}
2400919e:	4618      	mov	r0, r3
240091a0:	3710      	adds	r7, #16
240091a2:	46bd      	mov	sp, r7
240091a4:	bd80      	pop	{r7, pc}
240091a6:	bf00      	nop
240091a8:	52002000 	.word	0x52002000
240091ac:	00400100 	.word	0x00400100

240091b0 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
240091b0:	b480      	push	{r7}
240091b2:	b083      	sub	sp, #12
240091b4:	af00      	add	r7, sp, #0
240091b6:	6078      	str	r0, [r7, #4]
240091b8:	6039      	str	r1, [r7, #0]
  }
  else
#endif /* DUAL_BANK */
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
240091ba:	683b      	ldr	r3, [r7, #0]
240091bc:	f003 0301 	and.w	r3, r3, #1
240091c0:	2b00      	cmp	r3, #0
240091c2:	d011      	beq.n	240091e8 <FLASH_MassErase+0x38>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
240091c4:	4b0b      	ldr	r3, [pc, #44]	; (240091f4 <FLASH_MassErase+0x44>)
240091c6:	68db      	ldr	r3, [r3, #12]
240091c8:	4a0a      	ldr	r2, [pc, #40]	; (240091f4 <FLASH_MassErase+0x44>)
240091ca:	f023 0330 	bic.w	r3, r3, #48	; 0x30
240091ce:	60d3      	str	r3, [r2, #12]
      FLASH->CR1 |=  VoltageRange;
240091d0:	4b08      	ldr	r3, [pc, #32]	; (240091f4 <FLASH_MassErase+0x44>)
240091d2:	68da      	ldr	r2, [r3, #12]
240091d4:	4907      	ldr	r1, [pc, #28]	; (240091f4 <FLASH_MassErase+0x44>)
240091d6:	687b      	ldr	r3, [r7, #4]
240091d8:	4313      	orrs	r3, r2
240091da:	60cb      	str	r3, [r1, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
240091dc:	4b05      	ldr	r3, [pc, #20]	; (240091f4 <FLASH_MassErase+0x44>)
240091de:	68db      	ldr	r3, [r3, #12]
240091e0:	4a04      	ldr	r2, [pc, #16]	; (240091f4 <FLASH_MassErase+0x44>)
240091e2:	f043 0388 	orr.w	r3, r3, #136	; 0x88
240091e6:	60d3      	str	r3, [r2, #12]
      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
    }
#endif /* DUAL_BANK */
  }
}
240091e8:	bf00      	nop
240091ea:	370c      	adds	r7, #12
240091ec:	46bd      	mov	sp, r7
240091ee:	f85d 7b04 	ldr.w	r7, [sp], #4
240091f2:	4770      	bx	lr
240091f4:	52002000 	.word	0x52002000

240091f8 <FLASH_Erase_Sector>:
  *            @arg FLASH_VOLTAGE_RANGE_4 : Flash program/erase by 64 bits
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
240091f8:	b480      	push	{r7}
240091fa:	b085      	sub	sp, #20
240091fc:	af00      	add	r7, sp, #0
240091fe:	60f8      	str	r0, [r7, #12]
24009200:	60b9      	str	r1, [r7, #8]
24009202:	607a      	str	r2, [r7, #4]
  assert_param(IS_VOLTAGERANGE(VoltageRange));
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24009204:	68bb      	ldr	r3, [r7, #8]
24009206:	f003 0301 	and.w	r3, r3, #1
2400920a:	2b00      	cmp	r3, #0
2400920c:	d010      	beq.n	24009230 <FLASH_Erase_Sector+0x38>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
2400920e:	4b0b      	ldr	r3, [pc, #44]	; (2400923c <FLASH_Erase_Sector+0x44>)
24009210:	68db      	ldr	r3, [r3, #12]
24009212:	4a0a      	ldr	r2, [pc, #40]	; (2400923c <FLASH_Erase_Sector+0x44>)
24009214:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
24009218:	60d3      	str	r3, [r2, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
2400921a:	4b08      	ldr	r3, [pc, #32]	; (2400923c <FLASH_Erase_Sector+0x44>)
2400921c:	68da      	ldr	r2, [r3, #12]
2400921e:	68fb      	ldr	r3, [r7, #12]
24009220:	0219      	lsls	r1, r3, #8
24009222:	687b      	ldr	r3, [r7, #4]
24009224:	430b      	orrs	r3, r1
24009226:	4313      	orrs	r3, r2
24009228:	4a04      	ldr	r2, [pc, #16]	; (2400923c <FLASH_Erase_Sector+0x44>)
2400922a:	f043 0384 	orr.w	r3, r3, #132	; 0x84
2400922e:	60d3      	str	r3, [r2, #12]

    FLASH->CR2 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }
#endif /* DUAL_BANK */
}
24009230:	bf00      	nop
24009232:	3714      	adds	r7, #20
24009234:	46bd      	mov	sp, r7
24009236:	f85d 7b04 	ldr.w	r7, [sp], #4
2400923a:	4770      	bx	lr
2400923c:	52002000 	.word	0x52002000

24009240 <FLASH_OB_EnableWRP>:
  *            @arg FLASH_BANK_BOTH: enable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
{
24009240:	b480      	push	{r7}
24009242:	b083      	sub	sp, #12
24009244:	af00      	add	r7, sp, #0
24009246:	6078      	str	r0, [r7, #4]
24009248:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400924a:	683b      	ldr	r3, [r7, #0]
2400924c:	f003 0301 	and.w	r3, r3, #1
24009250:	2b00      	cmp	r3, #0
24009252:	d007      	beq.n	24009264 <FLASH_OB_EnableWRP+0x24>
  {
    /* Enable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 &= (~(WRPSector & FLASH_WPSN_WRPSN));
24009254:	4b06      	ldr	r3, [pc, #24]	; (24009270 <FLASH_OB_EnableWRP+0x30>)
24009256:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24009258:	687b      	ldr	r3, [r7, #4]
2400925a:	b2db      	uxtb	r3, r3
2400925c:	43db      	mvns	r3, r3
2400925e:	4904      	ldr	r1, [pc, #16]	; (24009270 <FLASH_OB_EnableWRP+0x30>)
24009260:	4013      	ands	r3, r2
24009262:	63cb      	str	r3, [r1, #60]	; 0x3c
  {
    /* Enable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 &= (~(WRPSector & FLASH_WPSN_WRPSN));
  }
#endif /* DUAL_BANK */
}
24009264:	bf00      	nop
24009266:	370c      	adds	r7, #12
24009268:	46bd      	mov	sp, r7
2400926a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400926e:	4770      	bx	lr
24009270:	52002000 	.word	0x52002000

24009274 <FLASH_OB_DisableWRP>:
  *            @arg FLASH_BANK_BOTH: disable WRP on both bank1 and bank2 specified sectors
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
{
24009274:	b480      	push	{r7}
24009276:	b083      	sub	sp, #12
24009278:	af00      	add	r7, sp, #0
2400927a:	6078      	str	r0, [r7, #4]
2400927c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_OB_WRP_SECTOR(WRPSector));
  assert_param(IS_FLASH_BANK(Banks));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
2400927e:	683b      	ldr	r3, [r7, #0]
24009280:	f003 0301 	and.w	r3, r3, #1
24009284:	2b00      	cmp	r3, #0
24009286:	d006      	beq.n	24009296 <FLASH_OB_DisableWRP+0x22>
  {
    /* Disable Write Protection for bank 1 */
    FLASH->WPSN_PRG1 |= (WRPSector & FLASH_WPSN_WRPSN);
24009288:	4b06      	ldr	r3, [pc, #24]	; (240092a4 <FLASH_OB_DisableWRP+0x30>)
2400928a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2400928c:	687b      	ldr	r3, [r7, #4]
2400928e:	b2db      	uxtb	r3, r3
24009290:	4904      	ldr	r1, [pc, #16]	; (240092a4 <FLASH_OB_DisableWRP+0x30>)
24009292:	4313      	orrs	r3, r2
24009294:	63cb      	str	r3, [r1, #60]	; 0x3c
  {
    /* Disable Write Protection for bank 2 */
    FLASH->WPSN_PRG2 |= (WRPSector & FLASH_WPSN_WRPSN);
  }
#endif /* DUAL_BANK */
}
24009296:	bf00      	nop
24009298:	370c      	adds	r7, #12
2400929a:	46bd      	mov	sp, r7
2400929c:	f85d 7b04 	ldr.w	r7, [sp], #4
240092a0:	4770      	bx	lr
240092a2:	bf00      	nop
240092a4:	52002000 	.word	0x52002000

240092a8 <FLASH_OB_GetWRP>:
  *            @arg FLASH_BANK_BOTH: note allowed in this functions
  *
  * @retval HAL FLASH State
  */
static void FLASH_OB_GetWRP(uint32_t *WRPState, uint32_t *WRPSector, uint32_t Bank)
{
240092a8:	b480      	push	{r7}
240092aa:	b087      	sub	sp, #28
240092ac:	af00      	add	r7, sp, #0
240092ae:	60f8      	str	r0, [r7, #12]
240092b0:	60b9      	str	r1, [r7, #8]
240092b2:	607a      	str	r2, [r7, #4]
  uint32_t regvalue = 0U;
240092b4:	2300      	movs	r3, #0
240092b6:	617b      	str	r3, [r7, #20]

  if(Bank == FLASH_BANK_1)
240092b8:	687b      	ldr	r3, [r7, #4]
240092ba:	2b01      	cmp	r3, #1
240092bc:	d102      	bne.n	240092c4 <FLASH_OB_GetWRP+0x1c>
  {
    regvalue = FLASH->WPSN_CUR1;
240092be:	4b0c      	ldr	r3, [pc, #48]	; (240092f0 <FLASH_OB_GetWRP+0x48>)
240092c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240092c2:	617b      	str	r3, [r7, #20]
  {
    regvalue = FLASH->WPSN_CUR2;
  }
#endif /* DUAL_BANK */

  (*WRPSector) = (~regvalue) & FLASH_WPSN_WRPSN;
240092c4:	697b      	ldr	r3, [r7, #20]
240092c6:	43db      	mvns	r3, r3
240092c8:	b2da      	uxtb	r2, r3
240092ca:	68bb      	ldr	r3, [r7, #8]
240092cc:	601a      	str	r2, [r3, #0]

  if(*WRPSector == 0U)
240092ce:	68bb      	ldr	r3, [r7, #8]
240092d0:	681b      	ldr	r3, [r3, #0]
240092d2:	2b00      	cmp	r3, #0
240092d4:	d103      	bne.n	240092de <FLASH_OB_GetWRP+0x36>
  {
    (*WRPState) = OB_WRPSTATE_DISABLE;
240092d6:	68fb      	ldr	r3, [r7, #12]
240092d8:	2200      	movs	r2, #0
240092da:	601a      	str	r2, [r3, #0]
  }
  else
  {
    (*WRPState) = OB_WRPSTATE_ENABLE;
  }
}
240092dc:	e002      	b.n	240092e4 <FLASH_OB_GetWRP+0x3c>
    (*WRPState) = OB_WRPSTATE_ENABLE;
240092de:	68fb      	ldr	r3, [r7, #12]
240092e0:	2201      	movs	r2, #1
240092e2:	601a      	str	r2, [r3, #0]
}
240092e4:	bf00      	nop
240092e6:	371c      	adds	r7, #28
240092e8:	46bd      	mov	sp, r7
240092ea:	f85d 7b04 	ldr.w	r7, [sp], #4
240092ee:	4770      	bx	lr
240092f0:	52002000 	.word	0x52002000

240092f4 <FLASH_OB_RDPConfig>:
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  *
  * @retval HAL status
  */
static void FLASH_OB_RDPConfig(uint32_t RDPLevel)
{
240092f4:	b480      	push	{r7}
240092f6:	b083      	sub	sp, #12
240092f8:	af00      	add	r7, sp, #0
240092fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_RDP, RDPLevel);
240092fc:	4b06      	ldr	r3, [pc, #24]	; (24009318 <FLASH_OB_RDPConfig+0x24>)
240092fe:	6a1b      	ldr	r3, [r3, #32]
24009300:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
24009304:	4904      	ldr	r1, [pc, #16]	; (24009318 <FLASH_OB_RDPConfig+0x24>)
24009306:	687b      	ldr	r3, [r7, #4]
24009308:	4313      	orrs	r3, r2
2400930a:	620b      	str	r3, [r1, #32]
}
2400930c:	bf00      	nop
2400930e:	370c      	adds	r7, #12
24009310:	46bd      	mov	sp, r7
24009312:	f85d 7b04 	ldr.w	r7, [sp], #4
24009316:	4770      	bx	lr
24009318:	52002000 	.word	0x52002000

2400931c <FLASH_OB_GetRDP>:
  *            @arg OB_RDP_LEVEL_0: No protection
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
2400931c:	b480      	push	{r7}
2400931e:	b083      	sub	sp, #12
24009320:	af00      	add	r7, sp, #0
  uint32_t rdp_level = READ_BIT(FLASH->OPTSR_CUR, FLASH_OPTSR_RDP);
24009322:	4b0b      	ldr	r3, [pc, #44]	; (24009350 <FLASH_OB_GetRDP+0x34>)
24009324:	69db      	ldr	r3, [r3, #28]
24009326:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
2400932a:	607b      	str	r3, [r7, #4]
  
  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_2))
2400932c:	687b      	ldr	r3, [r7, #4]
2400932e:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
24009332:	d006      	beq.n	24009342 <FLASH_OB_GetRDP+0x26>
24009334:	687b      	ldr	r3, [r7, #4]
24009336:	f5b3 4f4c 	cmp.w	r3, #52224	; 0xcc00
2400933a:	d002      	beq.n	24009342 <FLASH_OB_GetRDP+0x26>
  {
    return (OB_RDP_LEVEL_1);
2400933c:	f44f 43aa 	mov.w	r3, #21760	; 0x5500
24009340:	e000      	b.n	24009344 <FLASH_OB_GetRDP+0x28>
  }
  else
  {
    return rdp_level;
24009342:	687b      	ldr	r3, [r7, #4]
  }
}
24009344:	4618      	mov	r0, r3
24009346:	370c      	adds	r7, #12
24009348:	46bd      	mov	sp, r7
2400934a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400934e:	4770      	bx	lr
24009350:	52002000 	.word	0x52002000

24009354 <FLASH_OB_UserConfig>:
  *
  * @retval HAL status
  */
#endif /*DUAL_CORE*/
static void FLASH_OB_UserConfig(uint32_t UserType, uint32_t UserConfig)
{
24009354:	b480      	push	{r7}
24009356:	b085      	sub	sp, #20
24009358:	af00      	add	r7, sp, #0
2400935a:	6078      	str	r0, [r7, #4]
2400935c:	6039      	str	r1, [r7, #0]
  uint32_t optr_reg_val = 0;
2400935e:	2300      	movs	r3, #0
24009360:	60fb      	str	r3, [r7, #12]
  uint32_t optr_reg_mask = 0;
24009362:	2300      	movs	r3, #0
24009364:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_IWDG1_SW) != 0U)
24009366:	687b      	ldr	r3, [r7, #4]
24009368:	f003 0301 	and.w	r3, r3, #1
2400936c:	2b00      	cmp	r3, #0
2400936e:	d009      	beq.n	24009384 <FLASH_OB_UserConfig+0x30>
  {
    /* IWDG_HW option byte should be modified */
    assert_param(IS_OB_IWDG1_SOURCE(UserConfig & FLASH_OPTSR_IWDG1_SW));

    /* Set value and mask for IWDG_HW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG1_SW);
24009370:	683b      	ldr	r3, [r7, #0]
24009372:	f003 0310 	and.w	r3, r3, #16
24009376:	68fa      	ldr	r2, [r7, #12]
24009378:	4313      	orrs	r3, r2
2400937a:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IWDG1_SW;
2400937c:	68bb      	ldr	r3, [r7, #8]
2400937e:	f043 0310 	orr.w	r3, r3, #16
24009382:	60bb      	str	r3, [r7, #8]
    /* Set value and mask for IWDG2_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IWDG2_SW);
    optr_reg_mask |= FLASH_OPTSR_IWDG2_SW;
  }
#endif /*DUAL_CORE*/
  if((UserType & OB_USER_NRST_STOP_D1) != 0U)
24009384:	687b      	ldr	r3, [r7, #4]
24009386:	f003 0302 	and.w	r3, r3, #2
2400938a:	2b00      	cmp	r3, #0
2400938c:	d009      	beq.n	240093a2 <FLASH_OB_UserConfig+0x4e>
  {
    /* NRST_STOP option byte should be modified */
    assert_param(IS_OB_STOP_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STOP_D1));

    /* Set value and mask for NRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STOP_D1);
2400938e:	683b      	ldr	r3, [r7, #0]
24009390:	f003 0340 	and.w	r3, r3, #64	; 0x40
24009394:	68fa      	ldr	r2, [r7, #12]
24009396:	4313      	orrs	r3, r2
24009398:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STOP_D1;
2400939a:	68bb      	ldr	r3, [r7, #8]
2400939c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
240093a0:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_NRST_STDBY_D1) != 0U)
240093a2:	687b      	ldr	r3, [r7, #4]
240093a4:	f003 0304 	and.w	r3, r3, #4
240093a8:	2b00      	cmp	r3, #0
240093aa:	d009      	beq.n	240093c0 <FLASH_OB_UserConfig+0x6c>
  {
    /* NRST_STDBY option byte should be modified */
    assert_param(IS_OB_STDBY_D1_RESET(UserConfig & FLASH_OPTSR_NRST_STBY_D1));

    /* Set value and mask for NRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_NRST_STBY_D1);
240093ac:	683b      	ldr	r3, [r7, #0]
240093ae:	f003 0380 	and.w	r3, r3, #128	; 0x80
240093b2:	68fa      	ldr	r2, [r7, #12]
240093b4:	4313      	orrs	r3, r2
240093b6:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_NRST_STBY_D1;
240093b8:	68bb      	ldr	r3, [r7, #8]
240093ba:	f043 0380 	orr.w	r3, r3, #128	; 0x80
240093be:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
240093c0:	687b      	ldr	r3, [r7, #4]
240093c2:	f003 0308 	and.w	r3, r3, #8
240093c6:	2b00      	cmp	r3, #0
240093c8:	d009      	beq.n	240093de <FLASH_OB_UserConfig+0x8a>
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTSR_FZ_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_STOP);
240093ca:	683b      	ldr	r3, [r7, #0]
240093cc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240093d0:	68fa      	ldr	r2, [r7, #12]
240093d2:	4313      	orrs	r3, r2
240093d4:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_STOP;
240093d6:	68bb      	ldr	r3, [r7, #8]
240093d8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240093dc:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
240093de:	687b      	ldr	r3, [r7, #4]
240093e0:	f003 0310 	and.w	r3, r3, #16
240093e4:	2b00      	cmp	r3, #0
240093e6:	d009      	beq.n	240093fc <FLASH_OB_UserConfig+0xa8>
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_FZ_IWDG_SDBY);
240093e8:	683b      	ldr	r3, [r7, #0]
240093ea:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
240093ee:	68fa      	ldr	r2, [r7, #12]
240093f0:	4313      	orrs	r3, r2
240093f2:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_FZ_IWDG_SDBY;
240093f4:	68bb      	ldr	r3, [r7, #8]
240093f6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
240093fa:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_ST_RAM_SIZE) != 0U)
240093fc:	687b      	ldr	r3, [r7, #4]
240093fe:	f003 0320 	and.w	r3, r3, #32
24009402:	2b00      	cmp	r3, #0
24009404:	d009      	beq.n	2400941a <FLASH_OB_UserConfig+0xc6>
  {
    /* ST_RAM_SIZE option byte should be modified */
    assert_param(IS_OB_USER_ST_RAM_SIZE(UserConfig & FLASH_OPTSR_ST_RAM_SIZE));

    /* Set value and mask for ST_RAM_SIZE option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_ST_RAM_SIZE);
24009406:	683b      	ldr	r3, [r7, #0]
24009408:	f403 13c0 	and.w	r3, r3, #1572864	; 0x180000
2400940c:	68fa      	ldr	r2, [r7, #12]
2400940e:	4313      	orrs	r3, r2
24009410:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_ST_RAM_SIZE;
24009412:	68bb      	ldr	r3, [r7, #8]
24009414:	f443 13c0 	orr.w	r3, r3, #1572864	; 0x180000
24009418:	60bb      	str	r3, [r7, #8]
  }

  if((UserType & OB_USER_SECURITY) != 0U)
2400941a:	687b      	ldr	r3, [r7, #4]
2400941c:	f003 0340 	and.w	r3, r3, #64	; 0x40
24009420:	2b00      	cmp	r3, #0
24009422:	d009      	beq.n	24009438 <FLASH_OB_UserConfig+0xe4>
  {
    /* SECURITY option byte should be modified */
    assert_param(IS_OB_USER_SECURITY(UserConfig & FLASH_OPTSR_SECURITY));

    /* Set value and mask for SECURITY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SECURITY);
24009424:	683b      	ldr	r3, [r7, #0]
24009426:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2400942a:	68fa      	ldr	r2, [r7, #12]
2400942c:	4313      	orrs	r3, r2
2400942e:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_SECURITY;
24009430:	68bb      	ldr	r3, [r7, #8]
24009432:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
24009436:	60bb      	str	r3, [r7, #8]
    optr_reg_val |= (UserConfig & FLASH_OPTSR_SWAP_BANK_OPT);
    optr_reg_mask |= FLASH_OPTSR_SWAP_BANK_OPT;
  }
#endif /* DUAL_BANK */

  if((UserType & OB_USER_IOHSLV) != 0U)
24009438:	687b      	ldr	r3, [r7, #4]
2400943a:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400943e:	2b00      	cmp	r3, #0
24009440:	d009      	beq.n	24009456 <FLASH_OB_UserConfig+0x102>
  {
    /* IOHSLV_OPT option byte should be modified */
    assert_param(IS_OB_USER_IOHSLV(UserConfig & FLASH_OPTSR_IO_HSLV));

    /* Set value and mask for IOHSLV_OPT option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTSR_IO_HSLV);
24009442:	683b      	ldr	r3, [r7, #0]
24009444:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24009448:	68fa      	ldr	r2, [r7, #12]
2400944a:	4313      	orrs	r3, r2
2400944c:	60fb      	str	r3, [r7, #12]
    optr_reg_mask |= FLASH_OPTSR_IO_HSLV;
2400944e:	68bb      	ldr	r3, [r7, #8]
24009450:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
24009454:	60bb      	str	r3, [r7, #8]
    optr_reg_mask |= FLASH_OPTSR_VDDMMC_HSLV;
  }
#endif /* FLASH_OPTSR_VDDMMC_HSLV */

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTSR_PRG, optr_reg_mask, optr_reg_val);
24009456:	4b07      	ldr	r3, [pc, #28]	; (24009474 <FLASH_OB_UserConfig+0x120>)
24009458:	6a1a      	ldr	r2, [r3, #32]
2400945a:	68bb      	ldr	r3, [r7, #8]
2400945c:	43db      	mvns	r3, r3
2400945e:	401a      	ands	r2, r3
24009460:	4904      	ldr	r1, [pc, #16]	; (24009474 <FLASH_OB_UserConfig+0x120>)
24009462:	68fb      	ldr	r3, [r7, #12]
24009464:	4313      	orrs	r3, r2
24009466:	620b      	str	r3, [r1, #32]
}
24009468:	bf00      	nop
2400946a:	3714      	adds	r7, #20
2400946c:	46bd      	mov	sp, r7
2400946e:	f85d 7b04 	ldr.w	r7, [sp], #4
24009472:	4770      	bx	lr
24009474:	52002000 	.word	0x52002000

24009478 <FLASH_OB_GetUser>:
  *         FZ_IWDG_STOP(Bit 17), FZ_IWDG_SDBY(Bit 18), ST_RAM_SIZE(Bit[19:20]),
  *         SECURITY(Bit 21), IO_HSLV (Bit 29) and SWAP_BANK_OPT(Bit 31).
  */
#endif /*DUAL_CORE*/
static uint32_t FLASH_OB_GetUser(void)
{
24009478:	b480      	push	{r7}
2400947a:	b083      	sub	sp, #12
2400947c:	af00      	add	r7, sp, #0
  uint32_t userConfig = READ_REG(FLASH->OPTSR_CUR);
2400947e:	4b07      	ldr	r3, [pc, #28]	; (2400949c <FLASH_OB_GetUser+0x24>)
24009480:	69db      	ldr	r3, [r3, #28]
24009482:	607b      	str	r3, [r7, #4]
  userConfig &= (~(FLASH_OPTSR_BOR_LEV | FLASH_OPTSR_RDP));
24009484:	687a      	ldr	r2, [r7, #4]
24009486:	4b06      	ldr	r3, [pc, #24]	; (240094a0 <FLASH_OB_GetUser+0x28>)
24009488:	4013      	ands	r3, r2
2400948a:	607b      	str	r3, [r7, #4]

  return userConfig;
2400948c:	687b      	ldr	r3, [r7, #4]
}
2400948e:	4618      	mov	r0, r3
24009490:	370c      	adds	r7, #12
24009492:	46bd      	mov	sp, r7
24009494:	f85d 7b04 	ldr.w	r7, [sp], #4
24009498:	4770      	bx	lr
2400949a:	bf00      	nop
2400949c:	52002000 	.word	0x52002000
240094a0:	ffff00f3 	.word	0xffff00f3

240094a4 <FLASH_OB_PCROPConfig>:
  *            @arg FLASH_BANK_BOTH: PCROP on specified bank1 and bank2 area (same config will be applied on both banks)
  *
  * @retval None
  */
static void FLASH_OB_PCROPConfig(uint32_t PCROPConfig, uint32_t PCROPStartAddr, uint32_t PCROPEndAddr, uint32_t Banks)
{
240094a4:	b480      	push	{r7}
240094a6:	b085      	sub	sp, #20
240094a8:	af00      	add	r7, sp, #0
240094aa:	60f8      	str	r0, [r7, #12]
240094ac:	60b9      	str	r1, [r7, #8]
240094ae:	607a      	str	r2, [r7, #4]
240094b0:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_PCROP_RDP(PCROPConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
240094b2:	683b      	ldr	r3, [r7, #0]
240094b4:	f003 0301 	and.w	r3, r3, #1
240094b8:	2b00      	cmp	r3, #0
240094ba:	d00d      	beq.n	240094d8 <FLASH_OB_PCROPConfig+0x34>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(PCROPEndAddr));

    /* Configure the Proprietary code readout protection */
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
240094bc:	68bb      	ldr	r3, [r7, #8]
240094be:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
240094c2:	0a1a      	lsrs	r2, r3, #8
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
240094c4:	687b      	ldr	r3, [r7, #4]
240094c6:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
240094ca:	0a1b      	lsrs	r3, r3, #8
240094cc:	041b      	lsls	r3, r3, #16
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
240094ce:	431a      	orrs	r2, r3
240094d0:	4904      	ldr	r1, [pc, #16]	; (240094e4 <FLASH_OB_PCROPConfig+0x40>)
                       (((PCROPEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
240094d2:	68fb      	ldr	r3, [r7, #12]
240094d4:	4313      	orrs	r3, r2
    FLASH->PRAR_PRG1 = ((PCROPStartAddr - FLASH_BANK1_BASE) >> 8)                                 | \
240094d6:	62cb      	str	r3, [r1, #44]	; 0x2c
    FLASH->PRAR_PRG2 = ((PCROPStartAddr - FLASH_BANK2_BASE) >> 8)                                 | \
                       (((PCROPEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_PRAR_PROT_AREA_END_Pos) | \
                       PCROPConfig;
  }
#endif /* DUAL_BANK */
}
240094d8:	bf00      	nop
240094da:	3714      	adds	r7, #20
240094dc:	46bd      	mov	sp, r7
240094de:	f85d 7b04 	ldr.w	r7, [sp], #4
240094e2:	4770      	bx	lr
240094e4:	52002000 	.word	0x52002000

240094e8 <FLASH_OB_GetPCROP>:
  *            @arg FLASH_BANK_BOTH: is  not allowed here
  *
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROPStartAddr, uint32_t *PCROPEndAddr, uint32_t Bank)
{
240094e8:	b480      	push	{r7}
240094ea:	b087      	sub	sp, #28
240094ec:	af00      	add	r7, sp, #0
240094ee:	60f8      	str	r0, [r7, #12]
240094f0:	60b9      	str	r1, [r7, #8]
240094f2:	607a      	str	r2, [r7, #4]
240094f4:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
240094f6:	2300      	movs	r3, #0
240094f8:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
240094fa:	2300      	movs	r3, #0
240094fc:	613b      	str	r3, [r7, #16]

  if(Bank == FLASH_BANK_1)
240094fe:	683b      	ldr	r3, [r7, #0]
24009500:	2b01      	cmp	r3, #1
24009502:	d105      	bne.n	24009510 <FLASH_OB_GetPCROP+0x28>
  {
    regvalue = FLASH->PRAR_CUR1;
24009504:	4b12      	ldr	r3, [pc, #72]	; (24009550 <FLASH_OB_GetPCROP+0x68>)
24009506:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24009508:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
2400950a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
2400950e:	613b      	str	r3, [r7, #16]
    regvalue = FLASH->PRAR_CUR2;
    bankBase = FLASH_BANK2_BASE;
  }
#endif /* DUAL_BANK */

  (*PCROPConfig) =  (regvalue & FLASH_PRAR_DMEP);
24009510:	697b      	ldr	r3, [r7, #20]
24009512:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
24009516:	68fb      	ldr	r3, [r7, #12]
24009518:	601a      	str	r2, [r3, #0]

  (*PCROPStartAddr) = ((regvalue & FLASH_PRAR_PROT_AREA_START) << 8) + bankBase;
2400951a:	697b      	ldr	r3, [r7, #20]
2400951c:	021a      	lsls	r2, r3, #8
2400951e:	4b0d      	ldr	r3, [pc, #52]	; (24009554 <FLASH_OB_GetPCROP+0x6c>)
24009520:	4013      	ands	r3, r2
24009522:	693a      	ldr	r2, [r7, #16]
24009524:	441a      	add	r2, r3
24009526:	68bb      	ldr	r3, [r7, #8]
24009528:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = (regvalue & FLASH_PRAR_PROT_AREA_END) >> FLASH_PRAR_PROT_AREA_END_Pos;
2400952a:	697b      	ldr	r3, [r7, #20]
2400952c:	0c1b      	lsrs	r3, r3, #16
2400952e:	f3c3 020b 	ubfx	r2, r3, #0, #12
24009532:	687b      	ldr	r3, [r7, #4]
24009534:	601a      	str	r2, [r3, #0]
  (*PCROPEndAddr) = ((*PCROPEndAddr) << 8) + bankBase;
24009536:	687b      	ldr	r3, [r7, #4]
24009538:	681b      	ldr	r3, [r3, #0]
2400953a:	021a      	lsls	r2, r3, #8
2400953c:	693b      	ldr	r3, [r7, #16]
2400953e:	441a      	add	r2, r3
24009540:	687b      	ldr	r3, [r7, #4]
24009542:	601a      	str	r2, [r3, #0]
}
24009544:	bf00      	nop
24009546:	371c      	adds	r7, #28
24009548:	46bd      	mov	sp, r7
2400954a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400954e:	4770      	bx	lr
24009550:	52002000 	.word	0x52002000
24009554:	000fff00 	.word	0x000fff00

24009558 <FLASH_OB_BOR_LevelConfig>:
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  * @retval None
  */
static void FLASH_OB_BOR_LevelConfig(uint32_t Level)
{
24009558:	b480      	push	{r7}
2400955a:	b083      	sub	sp, #12
2400955c:	af00      	add	r7, sp, #0
2400955e:	6078      	str	r0, [r7, #4]
  assert_param(IS_OB_BOR_LEVEL(Level));

  /* Configure BOR_LEV option byte */
  MODIFY_REG(FLASH->OPTSR_PRG, FLASH_OPTSR_BOR_LEV, Level);
24009560:	4b06      	ldr	r3, [pc, #24]	; (2400957c <FLASH_OB_BOR_LevelConfig+0x24>)
24009562:	6a1b      	ldr	r3, [r3, #32]
24009564:	f023 020c 	bic.w	r2, r3, #12
24009568:	4904      	ldr	r1, [pc, #16]	; (2400957c <FLASH_OB_BOR_LevelConfig+0x24>)
2400956a:	687b      	ldr	r3, [r7, #4]
2400956c:	4313      	orrs	r3, r2
2400956e:	620b      	str	r3, [r1, #32]
}
24009570:	bf00      	nop
24009572:	370c      	adds	r7, #12
24009574:	46bd      	mov	sp, r7
24009576:	f85d 7b04 	ldr.w	r7, [sp], #4
2400957a:	4770      	bx	lr
2400957c:	52002000 	.word	0x52002000

24009580 <FLASH_OB_GetBOR>:
  *            @arg OB_BOR_LEVEL1: Reset level threshold is set to 2.1V
  *            @arg OB_BOR_LEVEL2: Reset level threshold is set to 2.4V
  *            @arg OB_BOR_LEVEL3: Reset level threshold is set to 2.7V
  */
static uint32_t FLASH_OB_GetBOR(void)
{
24009580:	b480      	push	{r7}
24009582:	af00      	add	r7, sp, #0
  return (FLASH->OPTSR_CUR & FLASH_OPTSR_BOR_LEV);
24009584:	4b04      	ldr	r3, [pc, #16]	; (24009598 <FLASH_OB_GetBOR+0x18>)
24009586:	69db      	ldr	r3, [r3, #28]
24009588:	f003 030c 	and.w	r3, r3, #12
}
2400958c:	4618      	mov	r0, r3
2400958e:	46bd      	mov	sp, r7
24009590:	f85d 7b04 	ldr.w	r7, [sp], #4
24009594:	4770      	bx	lr
24009596:	bf00      	nop
24009598:	52002000 	.word	0x52002000

2400959c <FLASH_OB_BootAddConfig>:
  * @param  BootAddress0 Specifies the Boot Address 0
  * @param  BootAddress1 Specifies the Boot Address 1
  * @retval HAL Status
  */
static void FLASH_OB_BootAddConfig(uint32_t BootOption, uint32_t BootAddress0, uint32_t BootAddress1)
{
2400959c:	b480      	push	{r7}
2400959e:	b085      	sub	sp, #20
240095a0:	af00      	add	r7, sp, #0
240095a2:	60f8      	str	r0, [r7, #12]
240095a4:	60b9      	str	r1, [r7, #8]
240095a6:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_OB_BOOT_ADD_OPTION(BootOption));

  if((BootOption & OB_BOOT_ADD0) == OB_BOOT_ADD0)
240095a8:	68fb      	ldr	r3, [r7, #12]
240095aa:	f003 0301 	and.w	r3, r3, #1
240095ae:	2b00      	cmp	r3, #0
240095b0:	d008      	beq.n	240095c4 <FLASH_OB_BootAddConfig+0x28>

    /* Configure CM7 BOOT ADD0 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD0, (BootAddress0 >> 16));
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD0, (BootAddress0 >> 16));
240095b2:	4b0d      	ldr	r3, [pc, #52]	; (240095e8 <FLASH_OB_BootAddConfig+0x4c>)
240095b4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
240095b6:	4b0d      	ldr	r3, [pc, #52]	; (240095ec <FLASH_OB_BootAddConfig+0x50>)
240095b8:	4013      	ands	r3, r2
240095ba:	68ba      	ldr	r2, [r7, #8]
240095bc:	0c12      	lsrs	r2, r2, #16
240095be:	490a      	ldr	r1, [pc, #40]	; (240095e8 <FLASH_OB_BootAddConfig+0x4c>)
240095c0:	4313      	orrs	r3, r2
240095c2:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }

  if((BootOption & OB_BOOT_ADD1) == OB_BOOT_ADD1)
240095c4:	68fb      	ldr	r3, [r7, #12]
240095c6:	f003 0302 	and.w	r3, r3, #2
240095ca:	2b00      	cmp	r3, #0
240095cc:	d006      	beq.n	240095dc <FLASH_OB_BootAddConfig+0x40>

    /* Configure CM7 BOOT ADD1 */
#if defined(DUAL_CORE)
    MODIFY_REG(FLASH->BOOT7_PRG, FLASH_BOOT7_BCM7_ADD1, BootAddress1);
#else /* Single Core*/
    MODIFY_REG(FLASH->BOOT_PRG, FLASH_BOOT_ADD1, BootAddress1);
240095ce:	4b06      	ldr	r3, [pc, #24]	; (240095e8 <FLASH_OB_BootAddConfig+0x4c>)
240095d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240095d2:	b29a      	uxth	r2, r3
240095d4:	4904      	ldr	r1, [pc, #16]	; (240095e8 <FLASH_OB_BootAddConfig+0x4c>)
240095d6:	687b      	ldr	r3, [r7, #4]
240095d8:	4313      	orrs	r3, r2
240095da:	644b      	str	r3, [r1, #68]	; 0x44
#endif /* DUAL_CORE */
  }
}
240095dc:	bf00      	nop
240095de:	3714      	adds	r7, #20
240095e0:	46bd      	mov	sp, r7
240095e2:	f85d 7b04 	ldr.w	r7, [sp], #4
240095e6:	4770      	bx	lr
240095e8:	52002000 	.word	0x52002000
240095ec:	ffff0000 	.word	0xffff0000

240095f0 <FLASH_OB_GetBootAdd>:
  * @param  BootAddress0 Specifies the Boot Address 0.
  * @param  BootAddress1 Specifies the Boot Address 1.
  * @retval HAL Status
  */
static void FLASH_OB_GetBootAdd(uint32_t *BootAddress0, uint32_t *BootAddress1)
{
240095f0:	b480      	push	{r7}
240095f2:	b085      	sub	sp, #20
240095f4:	af00      	add	r7, sp, #0
240095f6:	6078      	str	r0, [r7, #4]
240095f8:	6039      	str	r1, [r7, #0]
  regvalue = FLASH->BOOT7_CUR;

  (*BootAddress0) = (regvalue & FLASH_BOOT7_BCM7_ADD0) << 16;
  (*BootAddress1) = (regvalue & FLASH_BOOT7_BCM7_ADD1);
#else /* Single Core */
  regvalue = FLASH->BOOT_CUR;
240095fa:	4b09      	ldr	r3, [pc, #36]	; (24009620 <FLASH_OB_GetBootAdd+0x30>)
240095fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240095fe:	60fb      	str	r3, [r7, #12]

  (*BootAddress0) = (regvalue & FLASH_BOOT_ADD0) << 16;
24009600:	68fb      	ldr	r3, [r7, #12]
24009602:	041a      	lsls	r2, r3, #16
24009604:	687b      	ldr	r3, [r7, #4]
24009606:	601a      	str	r2, [r3, #0]
  (*BootAddress1) = (regvalue & FLASH_BOOT_ADD1);
24009608:	68fa      	ldr	r2, [r7, #12]
2400960a:	4b06      	ldr	r3, [pc, #24]	; (24009624 <FLASH_OB_GetBootAdd+0x34>)
2400960c:	4013      	ands	r3, r2
2400960e:	683a      	ldr	r2, [r7, #0]
24009610:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE */
}
24009612:	bf00      	nop
24009614:	3714      	adds	r7, #20
24009616:	46bd      	mov	sp, r7
24009618:	f85d 7b04 	ldr.w	r7, [sp], #4
2400961c:	4770      	bx	lr
2400961e:	bf00      	nop
24009620:	52002000 	.word	0x52002000
24009624:	ffff0000 	.word	0xffff0000

24009628 <FLASH_OB_SecureAreaConfig>:
  *            @arg FLASH_BANK_2: Secure area on specified bank2 area
  *            @arg FLASH_BANK_BOTH: Secure area on specified bank1 and bank2 area (same config will be applied on both banks)
  * @retval None
  */
static void FLASH_OB_SecureAreaConfig(uint32_t SecureAreaConfig, uint32_t SecureAreaStartAddr, uint32_t SecureAreaEndAddr, uint32_t Banks)
{
24009628:	b480      	push	{r7}
2400962a:	b085      	sub	sp, #20
2400962c:	af00      	add	r7, sp, #0
2400962e:	60f8      	str	r0, [r7, #12]
24009630:	60b9      	str	r1, [r7, #8]
24009632:	607a      	str	r2, [r7, #4]
24009634:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_BANK(Banks));
  assert_param(IS_OB_SECURE_RDP(SecureAreaConfig));

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
24009636:	683b      	ldr	r3, [r7, #0]
24009638:	f003 0301 	and.w	r3, r3, #1
2400963c:	2b00      	cmp	r3, #0
2400963e:	d00f      	beq.n	24009660 <FLASH_OB_SecureAreaConfig+0x38>
    /* Check the parameters */
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(SecureAreaEndAddr));

    /* Configure the secure area */
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24009640:	68bb      	ldr	r3, [r7, #8]
24009642:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
24009646:	0a1a      	lsrs	r2, r3, #8
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
24009648:	687b      	ldr	r3, [r7, #4]
2400964a:	f103 4378 	add.w	r3, r3, #4160749568	; 0xf8000000
2400964e:	0a1b      	lsrs	r3, r3, #8
24009650:	041b      	lsls	r3, r3, #16
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
24009652:	431a      	orrs	r2, r3
                       (SecureAreaConfig & FLASH_SCAR_DMES);
24009654:	68fb      	ldr	r3, [r7, #12]
24009656:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400965a:	4904      	ldr	r1, [pc, #16]	; (2400966c <FLASH_OB_SecureAreaConfig+0x44>)
                       (((SecureAreaEndAddr - FLASH_BANK1_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
2400965c:	4313      	orrs	r3, r2
    FLASH->SCAR_PRG1 = ((SecureAreaStartAddr - FLASH_BANK1_BASE) >> 8)                                | \
2400965e:	634b      	str	r3, [r1, #52]	; 0x34
    FLASH->SCAR_PRG2 = ((SecureAreaStartAddr - FLASH_BANK2_BASE) >> 8)                                | \
                       (((SecureAreaEndAddr - FLASH_BANK2_BASE) >> 8) << FLASH_SCAR_SEC_AREA_END_Pos) | \
                       (SecureAreaConfig & FLASH_SCAR_DMES);
  }
#endif /* DUAL_BANK */
}
24009660:	bf00      	nop
24009662:	3714      	adds	r7, #20
24009664:	46bd      	mov	sp, r7
24009666:	f85d 7b04 	ldr.w	r7, [sp], #4
2400966a:	4770      	bx	lr
2400966c:	52002000 	.word	0x52002000

24009670 <FLASH_OB_GetSecureArea>:
  * @param  SecureAreaEndAddr gives the secure area end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_OB_GetSecureArea(uint32_t *SecureAreaConfig, uint32_t *SecureAreaStartAddr, uint32_t *SecureAreaEndAddr, uint32_t Bank)
{
24009670:	b480      	push	{r7}
24009672:	b087      	sub	sp, #28
24009674:	af00      	add	r7, sp, #0
24009676:	60f8      	str	r0, [r7, #12]
24009678:	60b9      	str	r1, [r7, #8]
2400967a:	607a      	str	r2, [r7, #4]
2400967c:	603b      	str	r3, [r7, #0]
  uint32_t regvalue = 0;
2400967e:	2300      	movs	r3, #0
24009680:	617b      	str	r3, [r7, #20]
  uint32_t bankBase = 0;
24009682:	2300      	movs	r3, #0
24009684:	613b      	str	r3, [r7, #16]

  /* Check Bank parameter value */
  if(Bank == FLASH_BANK_1)
24009686:	683b      	ldr	r3, [r7, #0]
24009688:	2b01      	cmp	r3, #1
2400968a:	d105      	bne.n	24009698 <FLASH_OB_GetSecureArea+0x28>
  {
    regvalue = FLASH->SCAR_CUR1;
2400968c:	4b12      	ldr	r3, [pc, #72]	; (240096d8 <FLASH_OB_GetSecureArea+0x68>)
2400968e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24009690:	617b      	str	r3, [r7, #20]
    bankBase = FLASH_BANK1_BASE;
24009692:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
24009696:	613b      	str	r3, [r7, #16]
    bankBase = FLASH_BANK2_BASE;
  }
#endif /* DUAL_BANK */

  /* Get the secure area settings */
  (*SecureAreaConfig) = (regvalue & FLASH_SCAR_DMES);
24009698:	697b      	ldr	r3, [r7, #20]
2400969a:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
2400969e:	68fb      	ldr	r3, [r7, #12]
240096a0:	601a      	str	r2, [r3, #0]
  (*SecureAreaStartAddr) = ((regvalue & FLASH_SCAR_SEC_AREA_START) << 8) + bankBase;
240096a2:	697b      	ldr	r3, [r7, #20]
240096a4:	021a      	lsls	r2, r3, #8
240096a6:	4b0d      	ldr	r3, [pc, #52]	; (240096dc <FLASH_OB_GetSecureArea+0x6c>)
240096a8:	4013      	ands	r3, r2
240096aa:	693a      	ldr	r2, [r7, #16]
240096ac:	441a      	add	r2, r3
240096ae:	68bb      	ldr	r3, [r7, #8]
240096b0:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = (regvalue & FLASH_SCAR_SEC_AREA_END) >> FLASH_SCAR_SEC_AREA_END_Pos;
240096b2:	697b      	ldr	r3, [r7, #20]
240096b4:	0c1b      	lsrs	r3, r3, #16
240096b6:	f3c3 020b 	ubfx	r2, r3, #0, #12
240096ba:	687b      	ldr	r3, [r7, #4]
240096bc:	601a      	str	r2, [r3, #0]
  (*SecureAreaEndAddr) = ((*SecureAreaEndAddr) << 8) + bankBase;
240096be:	687b      	ldr	r3, [r7, #4]
240096c0:	681b      	ldr	r3, [r3, #0]
240096c2:	021a      	lsls	r2, r3, #8
240096c4:	693b      	ldr	r3, [r7, #16]
240096c6:	441a      	add	r2, r3
240096c8:	687b      	ldr	r3, [r7, #4]
240096ca:	601a      	str	r2, [r3, #0]
}
240096cc:	bf00      	nop
240096ce:	371c      	adds	r7, #28
240096d0:	46bd      	mov	sp, r7
240096d2:	f85d 7b04 	ldr.w	r7, [sp], #4
240096d6:	4770      	bx	lr
240096d8:	52002000 	.word	0x52002000
240096dc:	000fff00 	.word	0x000fff00

240096e0 <FLASH_CRC_AddSector>:
  * @param  Sector Specifies the CRC sector number
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_AddSector(uint32_t Sector, uint32_t Bank)
{
240096e0:	b480      	push	{r7}
240096e2:	b083      	sub	sp, #12
240096e4:	af00      	add	r7, sp, #0
240096e6:	6078      	str	r0, [r7, #4]
240096e8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));

  if (Bank == FLASH_BANK_1)
240096ea:	683b      	ldr	r3, [r7, #0]
240096ec:	2b01      	cmp	r3, #1
240096ee:	d10d      	bne.n	2400970c <FLASH_CRC_AddSector+0x2c>
  {
    /* Clear CRC sector */
    FLASH->CRCCR1 &= (~FLASH_CRCCR_CRC_SECT);
240096f0:	4b09      	ldr	r3, [pc, #36]	; (24009718 <FLASH_CRC_AddSector+0x38>)
240096f2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240096f4:	4a08      	ldr	r2, [pc, #32]	; (24009718 <FLASH_CRC_AddSector+0x38>)
240096f6:	f023 0307 	bic.w	r3, r3, #7
240096fa:	6513      	str	r3, [r2, #80]	; 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR1 |= Sector | FLASH_CRCCR_ADD_SECT;
240096fc:	4b06      	ldr	r3, [pc, #24]	; (24009718 <FLASH_CRC_AddSector+0x38>)
240096fe:	6d1a      	ldr	r2, [r3, #80]	; 0x50
24009700:	687b      	ldr	r3, [r7, #4]
24009702:	4313      	orrs	r3, r2
24009704:	4a04      	ldr	r2, [pc, #16]	; (24009718 <FLASH_CRC_AddSector+0x38>)
24009706:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2400970a:	6513      	str	r3, [r2, #80]	; 0x50

    /* Select CRC Sector and activate ADD_SECT bit */
    FLASH->CRCCR2 |= Sector | FLASH_CRCCR_ADD_SECT;
  }
#endif /* DUAL_BANK */
}
2400970c:	bf00      	nop
2400970e:	370c      	adds	r7, #12
24009710:	46bd      	mov	sp, r7
24009712:	f85d 7b04 	ldr.w	r7, [sp], #4
24009716:	4770      	bx	lr
24009718:	52002000 	.word	0x52002000

2400971c <FLASH_CRC_SelectAddress>:
  * @param  CRCEndAddr Specifies the CRC end address
  * @param  Bank Specifies the Bank
  * @retval None
  */
static void FLASH_CRC_SelectAddress(uint32_t CRCStartAddr, uint32_t CRCEndAddr, uint32_t Bank)
{
2400971c:	b480      	push	{r7}
2400971e:	b085      	sub	sp, #20
24009720:	af00      	add	r7, sp, #0
24009722:	60f8      	str	r0, [r7, #12]
24009724:	60b9      	str	r1, [r7, #8]
24009726:	607a      	str	r2, [r7, #4]
  if (Bank == FLASH_BANK_1)
24009728:	687b      	ldr	r3, [r7, #4]
2400972a:	2b01      	cmp	r3, #1
2400972c:	d105      	bne.n	2400973a <FLASH_CRC_SelectAddress+0x1e>
  {
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCStartAddr));
    assert_param(IS_FLASH_PROGRAM_ADDRESS_BANK1(CRCEndAddr));

    /* Write CRC Start and End addresses */
    FLASH->CRCSADD1 = CRCStartAddr;
2400972e:	4a06      	ldr	r2, [pc, #24]	; (24009748 <FLASH_CRC_SelectAddress+0x2c>)
24009730:	68fb      	ldr	r3, [r7, #12]
24009732:	6553      	str	r3, [r2, #84]	; 0x54
    FLASH->CRCEADD1 = CRCEndAddr;
24009734:	4a04      	ldr	r2, [pc, #16]	; (24009748 <FLASH_CRC_SelectAddress+0x2c>)
24009736:	68bb      	ldr	r3, [r7, #8]
24009738:	6593      	str	r3, [r2, #88]	; 0x58
    /* Write CRC Start and End addresses */
    FLASH->CRCSADD2 = CRCStartAddr;
    FLASH->CRCEADD2 = CRCEndAddr;
  }
#endif /* DUAL_BANK */
}
2400973a:	bf00      	nop
2400973c:	3714      	adds	r7, #20
2400973e:	46bd      	mov	sp, r7
24009740:	f85d 7b04 	ldr.w	r7, [sp], #4
24009744:	4770      	bx	lr
24009746:	bf00      	nop
24009748:	52002000 	.word	0x52002000

2400974c <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
2400974c:	b480      	push	{r7}
2400974e:	b089      	sub	sp, #36	; 0x24
24009750:	af00      	add	r7, sp, #0
24009752:	6078      	str	r0, [r7, #4]
24009754:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
24009756:	2300      	movs	r3, #0
24009758:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
2400975a:	4b89      	ldr	r3, [pc, #548]	; (24009980 <HAL_GPIO_Init+0x234>)
2400975c:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
2400975e:	e194      	b.n	24009a8a <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
24009760:	683b      	ldr	r3, [r7, #0]
24009762:	681a      	ldr	r2, [r3, #0]
24009764:	2101      	movs	r1, #1
24009766:	69fb      	ldr	r3, [r7, #28]
24009768:	fa01 f303 	lsl.w	r3, r1, r3
2400976c:	4013      	ands	r3, r2
2400976e:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
24009770:	693b      	ldr	r3, [r7, #16]
24009772:	2b00      	cmp	r3, #0
24009774:	f000 8186 	beq.w	24009a84 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
24009778:	683b      	ldr	r3, [r7, #0]
2400977a:	685b      	ldr	r3, [r3, #4]
2400977c:	f003 0303 	and.w	r3, r3, #3
24009780:	2b01      	cmp	r3, #1
24009782:	d005      	beq.n	24009790 <HAL_GPIO_Init+0x44>
24009784:	683b      	ldr	r3, [r7, #0]
24009786:	685b      	ldr	r3, [r3, #4]
24009788:	f003 0303 	and.w	r3, r3, #3
2400978c:	2b02      	cmp	r3, #2
2400978e:	d130      	bne.n	240097f2 <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
24009790:	687b      	ldr	r3, [r7, #4]
24009792:	689b      	ldr	r3, [r3, #8]
24009794:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
24009796:	69fb      	ldr	r3, [r7, #28]
24009798:	005b      	lsls	r3, r3, #1
2400979a:	2203      	movs	r2, #3
2400979c:	fa02 f303 	lsl.w	r3, r2, r3
240097a0:	43db      	mvns	r3, r3
240097a2:	69ba      	ldr	r2, [r7, #24]
240097a4:	4013      	ands	r3, r2
240097a6:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
240097a8:	683b      	ldr	r3, [r7, #0]
240097aa:	68da      	ldr	r2, [r3, #12]
240097ac:	69fb      	ldr	r3, [r7, #28]
240097ae:	005b      	lsls	r3, r3, #1
240097b0:	fa02 f303 	lsl.w	r3, r2, r3
240097b4:	69ba      	ldr	r2, [r7, #24]
240097b6:	4313      	orrs	r3, r2
240097b8:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
240097ba:	687b      	ldr	r3, [r7, #4]
240097bc:	69ba      	ldr	r2, [r7, #24]
240097be:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
240097c0:	687b      	ldr	r3, [r7, #4]
240097c2:	685b      	ldr	r3, [r3, #4]
240097c4:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
240097c6:	2201      	movs	r2, #1
240097c8:	69fb      	ldr	r3, [r7, #28]
240097ca:	fa02 f303 	lsl.w	r3, r2, r3
240097ce:	43db      	mvns	r3, r3
240097d0:	69ba      	ldr	r2, [r7, #24]
240097d2:	4013      	ands	r3, r2
240097d4:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
240097d6:	683b      	ldr	r3, [r7, #0]
240097d8:	685b      	ldr	r3, [r3, #4]
240097da:	091b      	lsrs	r3, r3, #4
240097dc:	f003 0201 	and.w	r2, r3, #1
240097e0:	69fb      	ldr	r3, [r7, #28]
240097e2:	fa02 f303 	lsl.w	r3, r2, r3
240097e6:	69ba      	ldr	r2, [r7, #24]
240097e8:	4313      	orrs	r3, r2
240097ea:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
240097ec:	687b      	ldr	r3, [r7, #4]
240097ee:	69ba      	ldr	r2, [r7, #24]
240097f0:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
240097f2:	683b      	ldr	r3, [r7, #0]
240097f4:	685b      	ldr	r3, [r3, #4]
240097f6:	f003 0303 	and.w	r3, r3, #3
240097fa:	2b03      	cmp	r3, #3
240097fc:	d017      	beq.n	2400982e <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
240097fe:	687b      	ldr	r3, [r7, #4]
24009800:	68db      	ldr	r3, [r3, #12]
24009802:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
24009804:	69fb      	ldr	r3, [r7, #28]
24009806:	005b      	lsls	r3, r3, #1
24009808:	2203      	movs	r2, #3
2400980a:	fa02 f303 	lsl.w	r3, r2, r3
2400980e:	43db      	mvns	r3, r3
24009810:	69ba      	ldr	r2, [r7, #24]
24009812:	4013      	ands	r3, r2
24009814:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
24009816:	683b      	ldr	r3, [r7, #0]
24009818:	689a      	ldr	r2, [r3, #8]
2400981a:	69fb      	ldr	r3, [r7, #28]
2400981c:	005b      	lsls	r3, r3, #1
2400981e:	fa02 f303 	lsl.w	r3, r2, r3
24009822:	69ba      	ldr	r2, [r7, #24]
24009824:	4313      	orrs	r3, r2
24009826:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
24009828:	687b      	ldr	r3, [r7, #4]
2400982a:	69ba      	ldr	r2, [r7, #24]
2400982c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
2400982e:	683b      	ldr	r3, [r7, #0]
24009830:	685b      	ldr	r3, [r3, #4]
24009832:	f003 0303 	and.w	r3, r3, #3
24009836:	2b02      	cmp	r3, #2
24009838:	d123      	bne.n	24009882 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
2400983a:	69fb      	ldr	r3, [r7, #28]
2400983c:	08da      	lsrs	r2, r3, #3
2400983e:	687b      	ldr	r3, [r7, #4]
24009840:	3208      	adds	r2, #8
24009842:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
24009846:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
24009848:	69fb      	ldr	r3, [r7, #28]
2400984a:	f003 0307 	and.w	r3, r3, #7
2400984e:	009b      	lsls	r3, r3, #2
24009850:	220f      	movs	r2, #15
24009852:	fa02 f303 	lsl.w	r3, r2, r3
24009856:	43db      	mvns	r3, r3
24009858:	69ba      	ldr	r2, [r7, #24]
2400985a:	4013      	ands	r3, r2
2400985c:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
2400985e:	683b      	ldr	r3, [r7, #0]
24009860:	691a      	ldr	r2, [r3, #16]
24009862:	69fb      	ldr	r3, [r7, #28]
24009864:	f003 0307 	and.w	r3, r3, #7
24009868:	009b      	lsls	r3, r3, #2
2400986a:	fa02 f303 	lsl.w	r3, r2, r3
2400986e:	69ba      	ldr	r2, [r7, #24]
24009870:	4313      	orrs	r3, r2
24009872:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
24009874:	69fb      	ldr	r3, [r7, #28]
24009876:	08da      	lsrs	r2, r3, #3
24009878:	687b      	ldr	r3, [r7, #4]
2400987a:	3208      	adds	r2, #8
2400987c:	69b9      	ldr	r1, [r7, #24]
2400987e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
24009882:	687b      	ldr	r3, [r7, #4]
24009884:	681b      	ldr	r3, [r3, #0]
24009886:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
24009888:	69fb      	ldr	r3, [r7, #28]
2400988a:	005b      	lsls	r3, r3, #1
2400988c:	2203      	movs	r2, #3
2400988e:	fa02 f303 	lsl.w	r3, r2, r3
24009892:	43db      	mvns	r3, r3
24009894:	69ba      	ldr	r2, [r7, #24]
24009896:	4013      	ands	r3, r2
24009898:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
2400989a:	683b      	ldr	r3, [r7, #0]
2400989c:	685b      	ldr	r3, [r3, #4]
2400989e:	f003 0203 	and.w	r2, r3, #3
240098a2:	69fb      	ldr	r3, [r7, #28]
240098a4:	005b      	lsls	r3, r3, #1
240098a6:	fa02 f303 	lsl.w	r3, r2, r3
240098aa:	69ba      	ldr	r2, [r7, #24]
240098ac:	4313      	orrs	r3, r2
240098ae:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
240098b0:	687b      	ldr	r3, [r7, #4]
240098b2:	69ba      	ldr	r2, [r7, #24]
240098b4:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
240098b6:	683b      	ldr	r3, [r7, #0]
240098b8:	685b      	ldr	r3, [r3, #4]
240098ba:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
240098be:	2b00      	cmp	r3, #0
240098c0:	f000 80e0 	beq.w	24009a84 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
240098c4:	4b2f      	ldr	r3, [pc, #188]	; (24009984 <HAL_GPIO_Init+0x238>)
240098c6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
240098ca:	4a2e      	ldr	r2, [pc, #184]	; (24009984 <HAL_GPIO_Init+0x238>)
240098cc:	f043 0302 	orr.w	r3, r3, #2
240098d0:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
240098d4:	4b2b      	ldr	r3, [pc, #172]	; (24009984 <HAL_GPIO_Init+0x238>)
240098d6:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
240098da:	f003 0302 	and.w	r3, r3, #2
240098de:	60fb      	str	r3, [r7, #12]
240098e0:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
240098e2:	4a29      	ldr	r2, [pc, #164]	; (24009988 <HAL_GPIO_Init+0x23c>)
240098e4:	69fb      	ldr	r3, [r7, #28]
240098e6:	089b      	lsrs	r3, r3, #2
240098e8:	3302      	adds	r3, #2
240098ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
240098ee:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
240098f0:	69fb      	ldr	r3, [r7, #28]
240098f2:	f003 0303 	and.w	r3, r3, #3
240098f6:	009b      	lsls	r3, r3, #2
240098f8:	220f      	movs	r2, #15
240098fa:	fa02 f303 	lsl.w	r3, r2, r3
240098fe:	43db      	mvns	r3, r3
24009900:	69ba      	ldr	r2, [r7, #24]
24009902:	4013      	ands	r3, r2
24009904:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
24009906:	687b      	ldr	r3, [r7, #4]
24009908:	4a20      	ldr	r2, [pc, #128]	; (2400998c <HAL_GPIO_Init+0x240>)
2400990a:	4293      	cmp	r3, r2
2400990c:	d052      	beq.n	240099b4 <HAL_GPIO_Init+0x268>
2400990e:	687b      	ldr	r3, [r7, #4]
24009910:	4a1f      	ldr	r2, [pc, #124]	; (24009990 <HAL_GPIO_Init+0x244>)
24009912:	4293      	cmp	r3, r2
24009914:	d031      	beq.n	2400997a <HAL_GPIO_Init+0x22e>
24009916:	687b      	ldr	r3, [r7, #4]
24009918:	4a1e      	ldr	r2, [pc, #120]	; (24009994 <HAL_GPIO_Init+0x248>)
2400991a:	4293      	cmp	r3, r2
2400991c:	d02b      	beq.n	24009976 <HAL_GPIO_Init+0x22a>
2400991e:	687b      	ldr	r3, [r7, #4]
24009920:	4a1d      	ldr	r2, [pc, #116]	; (24009998 <HAL_GPIO_Init+0x24c>)
24009922:	4293      	cmp	r3, r2
24009924:	d025      	beq.n	24009972 <HAL_GPIO_Init+0x226>
24009926:	687b      	ldr	r3, [r7, #4]
24009928:	4a1c      	ldr	r2, [pc, #112]	; (2400999c <HAL_GPIO_Init+0x250>)
2400992a:	4293      	cmp	r3, r2
2400992c:	d01f      	beq.n	2400996e <HAL_GPIO_Init+0x222>
2400992e:	687b      	ldr	r3, [r7, #4]
24009930:	4a1b      	ldr	r2, [pc, #108]	; (240099a0 <HAL_GPIO_Init+0x254>)
24009932:	4293      	cmp	r3, r2
24009934:	d019      	beq.n	2400996a <HAL_GPIO_Init+0x21e>
24009936:	687b      	ldr	r3, [r7, #4]
24009938:	4a1a      	ldr	r2, [pc, #104]	; (240099a4 <HAL_GPIO_Init+0x258>)
2400993a:	4293      	cmp	r3, r2
2400993c:	d013      	beq.n	24009966 <HAL_GPIO_Init+0x21a>
2400993e:	687b      	ldr	r3, [r7, #4]
24009940:	4a19      	ldr	r2, [pc, #100]	; (240099a8 <HAL_GPIO_Init+0x25c>)
24009942:	4293      	cmp	r3, r2
24009944:	d00d      	beq.n	24009962 <HAL_GPIO_Init+0x216>
24009946:	687b      	ldr	r3, [r7, #4]
24009948:	4a18      	ldr	r2, [pc, #96]	; (240099ac <HAL_GPIO_Init+0x260>)
2400994a:	4293      	cmp	r3, r2
2400994c:	d007      	beq.n	2400995e <HAL_GPIO_Init+0x212>
2400994e:	687b      	ldr	r3, [r7, #4]
24009950:	4a17      	ldr	r2, [pc, #92]	; (240099b0 <HAL_GPIO_Init+0x264>)
24009952:	4293      	cmp	r3, r2
24009954:	d101      	bne.n	2400995a <HAL_GPIO_Init+0x20e>
24009956:	2309      	movs	r3, #9
24009958:	e02d      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
2400995a:	230a      	movs	r3, #10
2400995c:	e02b      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
2400995e:	2308      	movs	r3, #8
24009960:	e029      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
24009962:	2307      	movs	r3, #7
24009964:	e027      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
24009966:	2306      	movs	r3, #6
24009968:	e025      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
2400996a:	2305      	movs	r3, #5
2400996c:	e023      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
2400996e:	2304      	movs	r3, #4
24009970:	e021      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
24009972:	2303      	movs	r3, #3
24009974:	e01f      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
24009976:	2302      	movs	r3, #2
24009978:	e01d      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
2400997a:	2301      	movs	r3, #1
2400997c:	e01b      	b.n	240099b6 <HAL_GPIO_Init+0x26a>
2400997e:	bf00      	nop
24009980:	58000080 	.word	0x58000080
24009984:	58024400 	.word	0x58024400
24009988:	58000400 	.word	0x58000400
2400998c:	58020000 	.word	0x58020000
24009990:	58020400 	.word	0x58020400
24009994:	58020800 	.word	0x58020800
24009998:	58020c00 	.word	0x58020c00
2400999c:	58021000 	.word	0x58021000
240099a0:	58021400 	.word	0x58021400
240099a4:	58021800 	.word	0x58021800
240099a8:	58021c00 	.word	0x58021c00
240099ac:	58022000 	.word	0x58022000
240099b0:	58022400 	.word	0x58022400
240099b4:	2300      	movs	r3, #0
240099b6:	69fa      	ldr	r2, [r7, #28]
240099b8:	f002 0203 	and.w	r2, r2, #3
240099bc:	0092      	lsls	r2, r2, #2
240099be:	4093      	lsls	r3, r2
240099c0:	69ba      	ldr	r2, [r7, #24]
240099c2:	4313      	orrs	r3, r2
240099c4:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
240099c6:	4938      	ldr	r1, [pc, #224]	; (24009aa8 <HAL_GPIO_Init+0x35c>)
240099c8:	69fb      	ldr	r3, [r7, #28]
240099ca:	089b      	lsrs	r3, r3, #2
240099cc:	3302      	adds	r3, #2
240099ce:	69ba      	ldr	r2, [r7, #24]
240099d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
240099d4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240099d8:	681b      	ldr	r3, [r3, #0]
240099da:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
240099dc:	693b      	ldr	r3, [r7, #16]
240099de:	43db      	mvns	r3, r3
240099e0:	69ba      	ldr	r2, [r7, #24]
240099e2:	4013      	ands	r3, r2
240099e4:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
240099e6:	683b      	ldr	r3, [r7, #0]
240099e8:	685b      	ldr	r3, [r3, #4]
240099ea:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
240099ee:	2b00      	cmp	r3, #0
240099f0:	d003      	beq.n	240099fa <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
240099f2:	69ba      	ldr	r2, [r7, #24]
240099f4:	693b      	ldr	r3, [r7, #16]
240099f6:	4313      	orrs	r3, r2
240099f8:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
240099fa:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240099fe:	69bb      	ldr	r3, [r7, #24]
24009a00:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
24009a02:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24009a06:	685b      	ldr	r3, [r3, #4]
24009a08:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24009a0a:	693b      	ldr	r3, [r7, #16]
24009a0c:	43db      	mvns	r3, r3
24009a0e:	69ba      	ldr	r2, [r7, #24]
24009a10:	4013      	ands	r3, r2
24009a12:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
24009a14:	683b      	ldr	r3, [r7, #0]
24009a16:	685b      	ldr	r3, [r3, #4]
24009a18:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
24009a1c:	2b00      	cmp	r3, #0
24009a1e:	d003      	beq.n	24009a28 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
24009a20:	69ba      	ldr	r2, [r7, #24]
24009a22:	693b      	ldr	r3, [r7, #16]
24009a24:	4313      	orrs	r3, r2
24009a26:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
24009a28:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24009a2c:	69bb      	ldr	r3, [r7, #24]
24009a2e:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
24009a30:	697b      	ldr	r3, [r7, #20]
24009a32:	685b      	ldr	r3, [r3, #4]
24009a34:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24009a36:	693b      	ldr	r3, [r7, #16]
24009a38:	43db      	mvns	r3, r3
24009a3a:	69ba      	ldr	r2, [r7, #24]
24009a3c:	4013      	ands	r3, r2
24009a3e:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
24009a40:	683b      	ldr	r3, [r7, #0]
24009a42:	685b      	ldr	r3, [r3, #4]
24009a44:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24009a48:	2b00      	cmp	r3, #0
24009a4a:	d003      	beq.n	24009a54 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
24009a4c:	69ba      	ldr	r2, [r7, #24]
24009a4e:	693b      	ldr	r3, [r7, #16]
24009a50:	4313      	orrs	r3, r2
24009a52:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
24009a54:	697b      	ldr	r3, [r7, #20]
24009a56:	69ba      	ldr	r2, [r7, #24]
24009a58:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
24009a5a:	697b      	ldr	r3, [r7, #20]
24009a5c:	681b      	ldr	r3, [r3, #0]
24009a5e:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
24009a60:	693b      	ldr	r3, [r7, #16]
24009a62:	43db      	mvns	r3, r3
24009a64:	69ba      	ldr	r2, [r7, #24]
24009a66:	4013      	ands	r3, r2
24009a68:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
24009a6a:	683b      	ldr	r3, [r7, #0]
24009a6c:	685b      	ldr	r3, [r3, #4]
24009a6e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24009a72:	2b00      	cmp	r3, #0
24009a74:	d003      	beq.n	24009a7e <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
24009a76:	69ba      	ldr	r2, [r7, #24]
24009a78:	693b      	ldr	r3, [r7, #16]
24009a7a:	4313      	orrs	r3, r2
24009a7c:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
24009a7e:	697b      	ldr	r3, [r7, #20]
24009a80:	69ba      	ldr	r2, [r7, #24]
24009a82:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
24009a84:	69fb      	ldr	r3, [r7, #28]
24009a86:	3301      	adds	r3, #1
24009a88:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
24009a8a:	683b      	ldr	r3, [r7, #0]
24009a8c:	681a      	ldr	r2, [r3, #0]
24009a8e:	69fb      	ldr	r3, [r7, #28]
24009a90:	fa22 f303 	lsr.w	r3, r2, r3
24009a94:	2b00      	cmp	r3, #0
24009a96:	f47f ae63 	bne.w	24009760 <HAL_GPIO_Init+0x14>
  }
}
24009a9a:	bf00      	nop
24009a9c:	bf00      	nop
24009a9e:	3724      	adds	r7, #36	; 0x24
24009aa0:	46bd      	mov	sp, r7
24009aa2:	f85d 7b04 	ldr.w	r7, [sp], #4
24009aa6:	4770      	bx	lr
24009aa8:	58000400 	.word	0x58000400

24009aac <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
24009aac:	b480      	push	{r7}
24009aae:	b087      	sub	sp, #28
24009ab0:	af00      	add	r7, sp, #0
24009ab2:	6078      	str	r0, [r7, #4]
24009ab4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
24009ab6:	2300      	movs	r3, #0
24009ab8:	617b      	str	r3, [r7, #20]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
24009aba:	4b75      	ldr	r3, [pc, #468]	; (24009c90 <HAL_GPIO_DeInit+0x1e4>)
24009abc:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
24009abe:	e0d9      	b.n	24009c74 <HAL_GPIO_DeInit+0x1c8>
  {
    /* Get current io position */
    iocurrent = GPIO_Pin & (1UL << position) ;
24009ac0:	2201      	movs	r2, #1
24009ac2:	697b      	ldr	r3, [r7, #20]
24009ac4:	fa02 f303 	lsl.w	r3, r2, r3
24009ac8:	683a      	ldr	r2, [r7, #0]
24009aca:	4013      	ands	r3, r2
24009acc:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
24009ace:	68fb      	ldr	r3, [r7, #12]
24009ad0:	2b00      	cmp	r3, #0
24009ad2:	f000 80cc 	beq.w	24009c6e <HAL_GPIO_DeInit+0x1c2>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
24009ad6:	4a6f      	ldr	r2, [pc, #444]	; (24009c94 <HAL_GPIO_DeInit+0x1e8>)
24009ad8:	697b      	ldr	r3, [r7, #20]
24009ada:	089b      	lsrs	r3, r3, #2
24009adc:	3302      	adds	r3, #2
24009ade:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24009ae2:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
24009ae4:	697b      	ldr	r3, [r7, #20]
24009ae6:	f003 0303 	and.w	r3, r3, #3
24009aea:	009b      	lsls	r3, r3, #2
24009aec:	220f      	movs	r2, #15
24009aee:	fa02 f303 	lsl.w	r3, r2, r3
24009af2:	68ba      	ldr	r2, [r7, #8]
24009af4:	4013      	ands	r3, r2
24009af6:	60bb      	str	r3, [r7, #8]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
24009af8:	687b      	ldr	r3, [r7, #4]
24009afa:	4a67      	ldr	r2, [pc, #412]	; (24009c98 <HAL_GPIO_DeInit+0x1ec>)
24009afc:	4293      	cmp	r3, r2
24009afe:	d037      	beq.n	24009b70 <HAL_GPIO_DeInit+0xc4>
24009b00:	687b      	ldr	r3, [r7, #4]
24009b02:	4a66      	ldr	r2, [pc, #408]	; (24009c9c <HAL_GPIO_DeInit+0x1f0>)
24009b04:	4293      	cmp	r3, r2
24009b06:	d031      	beq.n	24009b6c <HAL_GPIO_DeInit+0xc0>
24009b08:	687b      	ldr	r3, [r7, #4]
24009b0a:	4a65      	ldr	r2, [pc, #404]	; (24009ca0 <HAL_GPIO_DeInit+0x1f4>)
24009b0c:	4293      	cmp	r3, r2
24009b0e:	d02b      	beq.n	24009b68 <HAL_GPIO_DeInit+0xbc>
24009b10:	687b      	ldr	r3, [r7, #4]
24009b12:	4a64      	ldr	r2, [pc, #400]	; (24009ca4 <HAL_GPIO_DeInit+0x1f8>)
24009b14:	4293      	cmp	r3, r2
24009b16:	d025      	beq.n	24009b64 <HAL_GPIO_DeInit+0xb8>
24009b18:	687b      	ldr	r3, [r7, #4]
24009b1a:	4a63      	ldr	r2, [pc, #396]	; (24009ca8 <HAL_GPIO_DeInit+0x1fc>)
24009b1c:	4293      	cmp	r3, r2
24009b1e:	d01f      	beq.n	24009b60 <HAL_GPIO_DeInit+0xb4>
24009b20:	687b      	ldr	r3, [r7, #4]
24009b22:	4a62      	ldr	r2, [pc, #392]	; (24009cac <HAL_GPIO_DeInit+0x200>)
24009b24:	4293      	cmp	r3, r2
24009b26:	d019      	beq.n	24009b5c <HAL_GPIO_DeInit+0xb0>
24009b28:	687b      	ldr	r3, [r7, #4]
24009b2a:	4a61      	ldr	r2, [pc, #388]	; (24009cb0 <HAL_GPIO_DeInit+0x204>)
24009b2c:	4293      	cmp	r3, r2
24009b2e:	d013      	beq.n	24009b58 <HAL_GPIO_DeInit+0xac>
24009b30:	687b      	ldr	r3, [r7, #4]
24009b32:	4a60      	ldr	r2, [pc, #384]	; (24009cb4 <HAL_GPIO_DeInit+0x208>)
24009b34:	4293      	cmp	r3, r2
24009b36:	d00d      	beq.n	24009b54 <HAL_GPIO_DeInit+0xa8>
24009b38:	687b      	ldr	r3, [r7, #4]
24009b3a:	4a5f      	ldr	r2, [pc, #380]	; (24009cb8 <HAL_GPIO_DeInit+0x20c>)
24009b3c:	4293      	cmp	r3, r2
24009b3e:	d007      	beq.n	24009b50 <HAL_GPIO_DeInit+0xa4>
24009b40:	687b      	ldr	r3, [r7, #4]
24009b42:	4a5e      	ldr	r2, [pc, #376]	; (24009cbc <HAL_GPIO_DeInit+0x210>)
24009b44:	4293      	cmp	r3, r2
24009b46:	d101      	bne.n	24009b4c <HAL_GPIO_DeInit+0xa0>
24009b48:	2309      	movs	r3, #9
24009b4a:	e012      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b4c:	230a      	movs	r3, #10
24009b4e:	e010      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b50:	2308      	movs	r3, #8
24009b52:	e00e      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b54:	2307      	movs	r3, #7
24009b56:	e00c      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b58:	2306      	movs	r3, #6
24009b5a:	e00a      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b5c:	2305      	movs	r3, #5
24009b5e:	e008      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b60:	2304      	movs	r3, #4
24009b62:	e006      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b64:	2303      	movs	r3, #3
24009b66:	e004      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b68:	2302      	movs	r3, #2
24009b6a:	e002      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b6c:	2301      	movs	r3, #1
24009b6e:	e000      	b.n	24009b72 <HAL_GPIO_DeInit+0xc6>
24009b70:	2300      	movs	r3, #0
24009b72:	697a      	ldr	r2, [r7, #20]
24009b74:	f002 0203 	and.w	r2, r2, #3
24009b78:	0092      	lsls	r2, r2, #2
24009b7a:	4093      	lsls	r3, r2
24009b7c:	68ba      	ldr	r2, [r7, #8]
24009b7e:	429a      	cmp	r2, r3
24009b80:	d136      	bne.n	24009bf0 <HAL_GPIO_DeInit+0x144>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
24009b82:	693b      	ldr	r3, [r7, #16]
24009b84:	681a      	ldr	r2, [r3, #0]
24009b86:	68fb      	ldr	r3, [r7, #12]
24009b88:	43db      	mvns	r3, r3
24009b8a:	401a      	ands	r2, r3
24009b8c:	693b      	ldr	r3, [r7, #16]
24009b8e:	601a      	str	r2, [r3, #0]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
24009b90:	693b      	ldr	r3, [r7, #16]
24009b92:	685a      	ldr	r2, [r3, #4]
24009b94:	68fb      	ldr	r3, [r7, #12]
24009b96:	43db      	mvns	r3, r3
24009b98:	401a      	ands	r2, r3
24009b9a:	693b      	ldr	r3, [r7, #16]
24009b9c:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->FTSR1 &= ~(iocurrent);
24009b9e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24009ba2:	685a      	ldr	r2, [r3, #4]
24009ba4:	68fb      	ldr	r3, [r7, #12]
24009ba6:	43db      	mvns	r3, r3
24009ba8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
24009bac:	4013      	ands	r3, r2
24009bae:	604b      	str	r3, [r1, #4]
        EXTI->RTSR1 &= ~(iocurrent);
24009bb0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24009bb4:	681a      	ldr	r2, [r3, #0]
24009bb6:	68fb      	ldr	r3, [r7, #12]
24009bb8:	43db      	mvns	r3, r3
24009bba:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
24009bbe:	4013      	ands	r3, r2
24009bc0:	600b      	str	r3, [r1, #0]

        tmp = 0x0FUL << (4U * (position & 0x03U));
24009bc2:	697b      	ldr	r3, [r7, #20]
24009bc4:	f003 0303 	and.w	r3, r3, #3
24009bc8:	009b      	lsls	r3, r3, #2
24009bca:	220f      	movs	r2, #15
24009bcc:	fa02 f303 	lsl.w	r3, r2, r3
24009bd0:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
24009bd2:	4a30      	ldr	r2, [pc, #192]	; (24009c94 <HAL_GPIO_DeInit+0x1e8>)
24009bd4:	697b      	ldr	r3, [r7, #20]
24009bd6:	089b      	lsrs	r3, r3, #2
24009bd8:	3302      	adds	r3, #2
24009bda:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
24009bde:	68bb      	ldr	r3, [r7, #8]
24009be0:	43da      	mvns	r2, r3
24009be2:	482c      	ldr	r0, [pc, #176]	; (24009c94 <HAL_GPIO_DeInit+0x1e8>)
24009be4:	697b      	ldr	r3, [r7, #20]
24009be6:	089b      	lsrs	r3, r3, #2
24009be8:	400a      	ands	r2, r1
24009bea:	3302      	adds	r3, #2
24009bec:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
24009bf0:	687b      	ldr	r3, [r7, #4]
24009bf2:	681a      	ldr	r2, [r3, #0]
24009bf4:	697b      	ldr	r3, [r7, #20]
24009bf6:	005b      	lsls	r3, r3, #1
24009bf8:	2103      	movs	r1, #3
24009bfa:	fa01 f303 	lsl.w	r3, r1, r3
24009bfe:	431a      	orrs	r2, r3
24009c00:	687b      	ldr	r3, [r7, #4]
24009c02:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
24009c04:	697b      	ldr	r3, [r7, #20]
24009c06:	08da      	lsrs	r2, r3, #3
24009c08:	687b      	ldr	r3, [r7, #4]
24009c0a:	3208      	adds	r2, #8
24009c0c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
24009c10:	697b      	ldr	r3, [r7, #20]
24009c12:	f003 0307 	and.w	r3, r3, #7
24009c16:	009b      	lsls	r3, r3, #2
24009c18:	220f      	movs	r2, #15
24009c1a:	fa02 f303 	lsl.w	r3, r2, r3
24009c1e:	43db      	mvns	r3, r3
24009c20:	697a      	ldr	r2, [r7, #20]
24009c22:	08d2      	lsrs	r2, r2, #3
24009c24:	4019      	ands	r1, r3
24009c26:	687b      	ldr	r3, [r7, #4]
24009c28:	3208      	adds	r2, #8
24009c2a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
24009c2e:	687b      	ldr	r3, [r7, #4]
24009c30:	68da      	ldr	r2, [r3, #12]
24009c32:	697b      	ldr	r3, [r7, #20]
24009c34:	005b      	lsls	r3, r3, #1
24009c36:	2103      	movs	r1, #3
24009c38:	fa01 f303 	lsl.w	r3, r1, r3
24009c3c:	43db      	mvns	r3, r3
24009c3e:	401a      	ands	r2, r3
24009c40:	687b      	ldr	r3, [r7, #4]
24009c42:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
24009c44:	687b      	ldr	r3, [r7, #4]
24009c46:	685a      	ldr	r2, [r3, #4]
24009c48:	2101      	movs	r1, #1
24009c4a:	697b      	ldr	r3, [r7, #20]
24009c4c:	fa01 f303 	lsl.w	r3, r1, r3
24009c50:	43db      	mvns	r3, r3
24009c52:	401a      	ands	r2, r3
24009c54:	687b      	ldr	r3, [r7, #4]
24009c56:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
24009c58:	687b      	ldr	r3, [r7, #4]
24009c5a:	689a      	ldr	r2, [r3, #8]
24009c5c:	697b      	ldr	r3, [r7, #20]
24009c5e:	005b      	lsls	r3, r3, #1
24009c60:	2103      	movs	r1, #3
24009c62:	fa01 f303 	lsl.w	r3, r1, r3
24009c66:	43db      	mvns	r3, r3
24009c68:	401a      	ands	r2, r3
24009c6a:	687b      	ldr	r3, [r7, #4]
24009c6c:	609a      	str	r2, [r3, #8]
    }

    position++;
24009c6e:	697b      	ldr	r3, [r7, #20]
24009c70:	3301      	adds	r3, #1
24009c72:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00U)
24009c74:	683a      	ldr	r2, [r7, #0]
24009c76:	697b      	ldr	r3, [r7, #20]
24009c78:	fa22 f303 	lsr.w	r3, r2, r3
24009c7c:	2b00      	cmp	r3, #0
24009c7e:	f47f af1f 	bne.w	24009ac0 <HAL_GPIO_DeInit+0x14>
  }
}
24009c82:	bf00      	nop
24009c84:	bf00      	nop
24009c86:	371c      	adds	r7, #28
24009c88:	46bd      	mov	sp, r7
24009c8a:	f85d 7b04 	ldr.w	r7, [sp], #4
24009c8e:	4770      	bx	lr
24009c90:	58000080 	.word	0x58000080
24009c94:	58000400 	.word	0x58000400
24009c98:	58020000 	.word	0x58020000
24009c9c:	58020400 	.word	0x58020400
24009ca0:	58020800 	.word	0x58020800
24009ca4:	58020c00 	.word	0x58020c00
24009ca8:	58021000 	.word	0x58021000
24009cac:	58021400 	.word	0x58021400
24009cb0:	58021800 	.word	0x58021800
24009cb4:	58021c00 	.word	0x58021c00
24009cb8:	58022000 	.word	0x58022000
24009cbc:	58022400 	.word	0x58022400

24009cc0 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24009cc0:	b480      	push	{r7}
24009cc2:	b085      	sub	sp, #20
24009cc4:	af00      	add	r7, sp, #0
24009cc6:	6078      	str	r0, [r7, #4]
24009cc8:	460b      	mov	r3, r1
24009cca:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
24009ccc:	687b      	ldr	r3, [r7, #4]
24009cce:	691a      	ldr	r2, [r3, #16]
24009cd0:	887b      	ldrh	r3, [r7, #2]
24009cd2:	4013      	ands	r3, r2
24009cd4:	2b00      	cmp	r3, #0
24009cd6:	d002      	beq.n	24009cde <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
24009cd8:	2301      	movs	r3, #1
24009cda:	73fb      	strb	r3, [r7, #15]
24009cdc:	e001      	b.n	24009ce2 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
24009cde:	2300      	movs	r3, #0
24009ce0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
24009ce2:	7bfb      	ldrb	r3, [r7, #15]
}
24009ce4:	4618      	mov	r0, r3
24009ce6:	3714      	adds	r7, #20
24009ce8:	46bd      	mov	sp, r7
24009cea:	f85d 7b04 	ldr.w	r7, [sp], #4
24009cee:	4770      	bx	lr

24009cf0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
24009cf0:	b480      	push	{r7}
24009cf2:	b083      	sub	sp, #12
24009cf4:	af00      	add	r7, sp, #0
24009cf6:	6078      	str	r0, [r7, #4]
24009cf8:	460b      	mov	r3, r1
24009cfa:	807b      	strh	r3, [r7, #2]
24009cfc:	4613      	mov	r3, r2
24009cfe:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
24009d00:	787b      	ldrb	r3, [r7, #1]
24009d02:	2b00      	cmp	r3, #0
24009d04:	d003      	beq.n	24009d0e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
24009d06:	887a      	ldrh	r2, [r7, #2]
24009d08:	687b      	ldr	r3, [r7, #4]
24009d0a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
24009d0c:	e003      	b.n	24009d16 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
24009d0e:	887b      	ldrh	r3, [r7, #2]
24009d10:	041a      	lsls	r2, r3, #16
24009d12:	687b      	ldr	r3, [r7, #4]
24009d14:	619a      	str	r2, [r3, #24]
}
24009d16:	bf00      	nop
24009d18:	370c      	adds	r7, #12
24009d1a:	46bd      	mov	sp, r7
24009d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
24009d20:	4770      	bx	lr

24009d22 <HAL_GPIO_TogglePin>:
  * @param  GPIOx: Where x can be (A..K) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24009d22:	b480      	push	{r7}
24009d24:	b085      	sub	sp, #20
24009d26:	af00      	add	r7, sp, #0
24009d28:	6078      	str	r0, [r7, #4]
24009d2a:	460b      	mov	r3, r1
24009d2c:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
24009d2e:	687b      	ldr	r3, [r7, #4]
24009d30:	695b      	ldr	r3, [r3, #20]
24009d32:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
24009d34:	887a      	ldrh	r2, [r7, #2]
24009d36:	68fb      	ldr	r3, [r7, #12]
24009d38:	4013      	ands	r3, r2
24009d3a:	041a      	lsls	r2, r3, #16
24009d3c:	68fb      	ldr	r3, [r7, #12]
24009d3e:	43d9      	mvns	r1, r3
24009d40:	887b      	ldrh	r3, [r7, #2]
24009d42:	400b      	ands	r3, r1
24009d44:	431a      	orrs	r2, r3
24009d46:	687b      	ldr	r3, [r7, #4]
24009d48:	619a      	str	r2, [r3, #24]
}
24009d4a:	bf00      	nop
24009d4c:	3714      	adds	r7, #20
24009d4e:	46bd      	mov	sp, r7
24009d50:	f85d 7b04 	ldr.w	r7, [sp], #4
24009d54:	4770      	bx	lr

24009d56 <HAL_GPIO_LockPin>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
24009d56:	b480      	push	{r7}
24009d58:	b085      	sub	sp, #20
24009d5a:	af00      	add	r7, sp, #0
24009d5c:	6078      	str	r0, [r7, #4]
24009d5e:	460b      	mov	r3, r1
24009d60:	807b      	strh	r3, [r7, #2]
  __IO uint32_t tmp = GPIO_LCKR_LCKK;
24009d62:	f44f 3380 	mov.w	r3, #65536	; 0x10000
24009d66:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Apply lock key write sequence */
  tmp |= GPIO_Pin;
24009d68:	887a      	ldrh	r2, [r7, #2]
24009d6a:	68fb      	ldr	r3, [r7, #12]
24009d6c:	4313      	orrs	r3, r2
24009d6e:	60fb      	str	r3, [r7, #12]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24009d70:	68fa      	ldr	r2, [r7, #12]
24009d72:	687b      	ldr	r3, [r7, #4]
24009d74:	61da      	str	r2, [r3, #28]
  /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
  GPIOx->LCKR = GPIO_Pin;
24009d76:	887a      	ldrh	r2, [r7, #2]
24009d78:	687b      	ldr	r3, [r7, #4]
24009d7a:	61da      	str	r2, [r3, #28]
  /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
  GPIOx->LCKR = tmp;
24009d7c:	68fa      	ldr	r2, [r7, #12]
24009d7e:	687b      	ldr	r3, [r7, #4]
24009d80:	61da      	str	r2, [r3, #28]
  /* Read LCKK register. This read is mandatory to complete key lock sequence*/
  tmp = GPIOx->LCKR;
24009d82:	687b      	ldr	r3, [r7, #4]
24009d84:	69db      	ldr	r3, [r3, #28]
24009d86:	60fb      	str	r3, [r7, #12]

  /* read again in order to confirm lock is active */
  if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00U)
24009d88:	687b      	ldr	r3, [r7, #4]
24009d8a:	69db      	ldr	r3, [r3, #28]
24009d8c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24009d90:	2b00      	cmp	r3, #0
24009d92:	d001      	beq.n	24009d98 <HAL_GPIO_LockPin+0x42>
  {
    return HAL_OK;
24009d94:	2300      	movs	r3, #0
24009d96:	e000      	b.n	24009d9a <HAL_GPIO_LockPin+0x44>
  }
  else
  {
    return HAL_ERROR;
24009d98:	2301      	movs	r3, #1
  }
}
24009d9a:	4618      	mov	r0, r3
24009d9c:	3714      	adds	r7, #20
24009d9e:	46bd      	mov	sp, r7
24009da0:	f85d 7b04 	ldr.w	r7, [sp], #4
24009da4:	4770      	bx	lr

24009da6 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
24009da6:	b580      	push	{r7, lr}
24009da8:	b082      	sub	sp, #8
24009daa:	af00      	add	r7, sp, #0
24009dac:	4603      	mov	r3, r0
24009dae:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
24009db0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24009db4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
24009db8:	88fb      	ldrh	r3, [r7, #6]
24009dba:	4013      	ands	r3, r2
24009dbc:	2b00      	cmp	r3, #0
24009dbe:	d008      	beq.n	24009dd2 <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
24009dc0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24009dc4:	88fb      	ldrh	r3, [r7, #6]
24009dc6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
24009dca:	88fb      	ldrh	r3, [r7, #6]
24009dcc:	4618      	mov	r0, r3
24009dce:	f000 f804 	bl	24009dda <HAL_GPIO_EXTI_Callback>
  }
#endif
}
24009dd2:	bf00      	nop
24009dd4:	3708      	adds	r7, #8
24009dd6:	46bd      	mov	sp, r7
24009dd8:	bd80      	pop	{r7, pc}

24009dda <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
24009dda:	b480      	push	{r7}
24009ddc:	b083      	sub	sp, #12
24009dde:	af00      	add	r7, sp, #0
24009de0:	4603      	mov	r3, r0
24009de2:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
24009de4:	bf00      	nop
24009de6:	370c      	adds	r7, #12
24009de8:	46bd      	mov	sp, r7
24009dea:	f85d 7b04 	ldr.w	r7, [sp], #4
24009dee:	4770      	bx	lr

24009df0 <HAL_HSEM_Take>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  HAL_HSEM_Take(uint32_t SemID, uint32_t ProcessID)
{
24009df0:	b480      	push	{r7}
24009df2:	b083      	sub	sp, #12
24009df4:	af00      	add	r7, sp, #0
24009df6:	6078      	str	r0, [r7, #4]
24009df8:	6039      	str	r1, [r7, #0]
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
  }
#else
  /* First step  write R register with MasterID, processID and take bit=1*/
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK);
24009dfa:	490c      	ldr	r1, [pc, #48]	; (24009e2c <HAL_HSEM_Take+0x3c>)
24009dfc:	683a      	ldr	r2, [r7, #0]
24009dfe:	4b0c      	ldr	r3, [pc, #48]	; (24009e30 <HAL_HSEM_Take+0x40>)
24009e00:	4313      	orrs	r3, r2
24009e02:	687a      	ldr	r2, [r7, #4]
24009e04:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

  /* second step : read the R register . Take achieved if MasterID and processID match and take bit set to 1 */
  if (HSEM->R[SemID] == (ProcessID | HSEM_CR_COREID_CURRENT | HSEM_R_LOCK))
24009e08:	4a08      	ldr	r2, [pc, #32]	; (24009e2c <HAL_HSEM_Take+0x3c>)
24009e0a:	687b      	ldr	r3, [r7, #4]
24009e0c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
24009e10:	6839      	ldr	r1, [r7, #0]
24009e12:	4b07      	ldr	r3, [pc, #28]	; (24009e30 <HAL_HSEM_Take+0x40>)
24009e14:	430b      	orrs	r3, r1
24009e16:	429a      	cmp	r2, r3
24009e18:	d101      	bne.n	24009e1e <HAL_HSEM_Take+0x2e>
  {
    /*take success when MasterID and ProcessID match and take bit set*/
    return HAL_OK;
24009e1a:	2300      	movs	r3, #0
24009e1c:	e000      	b.n	24009e20 <HAL_HSEM_Take+0x30>
  }
#endif

  /* Semaphore take fails*/
  return HAL_ERROR;
24009e1e:	2301      	movs	r3, #1
}
24009e20:	4618      	mov	r0, r3
24009e22:	370c      	adds	r7, #12
24009e24:	46bd      	mov	sp, r7
24009e26:	f85d 7b04 	ldr.w	r7, [sp], #4
24009e2a:	4770      	bx	lr
24009e2c:	58026400 	.word	0x58026400
24009e30:	80000300 	.word	0x80000300

24009e34 <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
24009e34:	b480      	push	{r7}
24009e36:	b083      	sub	sp, #12
24009e38:	af00      	add	r7, sp, #0
24009e3a:	6078      	str	r0, [r7, #4]
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else  
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
24009e3c:	4a08      	ldr	r2, [pc, #32]	; (24009e60 <HAL_HSEM_FastTake+0x2c>)
24009e3e:	687b      	ldr	r3, [r7, #4]
24009e40:	3320      	adds	r3, #32
24009e42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24009e46:	4a07      	ldr	r2, [pc, #28]	; (24009e64 <HAL_HSEM_FastTake+0x30>)
24009e48:	4293      	cmp	r3, r2
24009e4a:	d101      	bne.n	24009e50 <HAL_HSEM_FastTake+0x1c>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
24009e4c:	2300      	movs	r3, #0
24009e4e:	e000      	b.n	24009e52 <HAL_HSEM_FastTake+0x1e>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
24009e50:	2301      	movs	r3, #1
}
24009e52:	4618      	mov	r0, r3
24009e54:	370c      	adds	r7, #12
24009e56:	46bd      	mov	sp, r7
24009e58:	f85d 7b04 	ldr.w	r7, [sp], #4
24009e5c:	4770      	bx	lr
24009e5e:	bf00      	nop
24009e60:	58026400 	.word	0x58026400
24009e64:	80000300 	.word	0x80000300

24009e68 <HAL_HSEM_IsSemTaken>:
  * @brief  Check semaphore state Taken or not.
  * @param  SemID: semaphore ID
  * @retval HAL HSEM state
  */
uint32_t HAL_HSEM_IsSemTaken(uint32_t SemID)
{
24009e68:	b480      	push	{r7}
24009e6a:	b083      	sub	sp, #12
24009e6c:	af00      	add	r7, sp, #0
24009e6e:	6078      	str	r0, [r7, #4]
  return (((HSEM->R[SemID] & HSEM_R_LOCK) != 0U) ? 1UL : 0UL);
24009e70:	4a07      	ldr	r2, [pc, #28]	; (24009e90 <HAL_HSEM_IsSemTaken+0x28>)
24009e72:	687b      	ldr	r3, [r7, #4]
24009e74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
24009e78:	2b00      	cmp	r3, #0
24009e7a:	da01      	bge.n	24009e80 <HAL_HSEM_IsSemTaken+0x18>
24009e7c:	2301      	movs	r3, #1
24009e7e:	e000      	b.n	24009e82 <HAL_HSEM_IsSemTaken+0x1a>
24009e80:	2300      	movs	r3, #0
}
24009e82:	4618      	mov	r0, r3
24009e84:	370c      	adds	r7, #12
24009e86:	46bd      	mov	sp, r7
24009e88:	f85d 7b04 	ldr.w	r7, [sp], #4
24009e8c:	4770      	bx	lr
24009e8e:	bf00      	nop
24009e90:	58026400 	.word	0x58026400

24009e94 <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
24009e94:	b480      	push	{r7}
24009e96:	b083      	sub	sp, #12
24009e98:	af00      	add	r7, sp, #0
24009e9a:	6078      	str	r0, [r7, #4]
24009e9c:	6039      	str	r1, [r7, #0]

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
24009e9e:	4906      	ldr	r1, [pc, #24]	; (24009eb8 <HAL_HSEM_Release+0x24>)
24009ea0:	683b      	ldr	r3, [r7, #0]
24009ea2:	f443 7240 	orr.w	r2, r3, #768	; 0x300
24009ea6:	687b      	ldr	r3, [r7, #4]
24009ea8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
24009eac:	bf00      	nop
24009eae:	370c      	adds	r7, #12
24009eb0:	46bd      	mov	sp, r7
24009eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
24009eb6:	4770      	bx	lr
24009eb8:	58026400 	.word	0x58026400

24009ebc <HAL_HSEM_ReleaseAll>:
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @param  CoreID: CoreID of the CPU that is using semaphores to be released
  * @retval None
  */
void HAL_HSEM_ReleaseAll(uint32_t Key, uint32_t CoreID)
{
24009ebc:	b480      	push	{r7}
24009ebe:	b083      	sub	sp, #12
24009ec0:	af00      	add	r7, sp, #0
24009ec2:	6078      	str	r0, [r7, #4]
24009ec4:	6039      	str	r1, [r7, #0]
  assert_param(IS_HSEM_KEY(Key));
  assert_param(IS_HSEM_COREID(CoreID));

  HSEM->CR = ((Key << HSEM_CR_KEY_Pos) | (CoreID << HSEM_CR_COREID_Pos));
24009ec6:	687b      	ldr	r3, [r7, #4]
24009ec8:	041a      	lsls	r2, r3, #16
24009eca:	683b      	ldr	r3, [r7, #0]
24009ecc:	021b      	lsls	r3, r3, #8
24009ece:	4905      	ldr	r1, [pc, #20]	; (24009ee4 <HAL_HSEM_ReleaseAll+0x28>)
24009ed0:	4313      	orrs	r3, r2
24009ed2:	f8c1 3140 	str.w	r3, [r1, #320]	; 0x140
}
24009ed6:	bf00      	nop
24009ed8:	370c      	adds	r7, #12
24009eda:	46bd      	mov	sp, r7
24009edc:	f85d 7b04 	ldr.w	r7, [sp], #4
24009ee0:	4770      	bx	lr
24009ee2:	bf00      	nop
24009ee4:	58026400 	.word	0x58026400

24009ee8 <HAL_HSEM_SetClearKey>:
  * @brief  Set semaphore Key .
  * @param  Key: Semaphore Key , value from 0 to 0xFFFF
  * @retval None
  */
void  HAL_HSEM_SetClearKey(uint32_t Key)
{
24009ee8:	b480      	push	{r7}
24009eea:	b083      	sub	sp, #12
24009eec:	af00      	add	r7, sp, #0
24009eee:	6078      	str	r0, [r7, #4]
  assert_param(IS_HSEM_KEY(Key));

  MODIFY_REG(HSEM->KEYR, HSEM_KEYR_KEY, (Key << HSEM_KEYR_KEY_Pos));
24009ef0:	4b07      	ldr	r3, [pc, #28]	; (24009f10 <HAL_HSEM_SetClearKey+0x28>)
24009ef2:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24009ef6:	b29a      	uxth	r2, r3
24009ef8:	687b      	ldr	r3, [r7, #4]
24009efa:	041b      	lsls	r3, r3, #16
24009efc:	4904      	ldr	r1, [pc, #16]	; (24009f10 <HAL_HSEM_SetClearKey+0x28>)
24009efe:	4313      	orrs	r3, r2
24009f00:	f8c1 3144 	str.w	r3, [r1, #324]	; 0x144

}
24009f04:	bf00      	nop
24009f06:	370c      	adds	r7, #12
24009f08:	46bd      	mov	sp, r7
24009f0a:	f85d 7b04 	ldr.w	r7, [sp], #4
24009f0e:	4770      	bx	lr
24009f10:	58026400 	.word	0x58026400

24009f14 <HAL_HSEM_GetClearKey>:
/**
  * @brief  Get semaphore Key .
  * @retval Semaphore Key , value from 0 to 0xFFFF
  */
uint32_t HAL_HSEM_GetClearKey(void)
{
24009f14:	b480      	push	{r7}
24009f16:	af00      	add	r7, sp, #0
  return (HSEM->KEYR >> HSEM_KEYR_KEY_Pos);
24009f18:	4b04      	ldr	r3, [pc, #16]	; (24009f2c <HAL_HSEM_GetClearKey+0x18>)
24009f1a:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
24009f1e:	0c1b      	lsrs	r3, r3, #16
}
24009f20:	4618      	mov	r0, r3
24009f22:	46bd      	mov	sp, r7
24009f24:	f85d 7b04 	ldr.w	r7, [sp], #4
24009f28:	4770      	bx	lr
24009f2a:	bf00      	nop
24009f2c:	58026400 	.word	0x58026400

24009f30 <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
24009f30:	b480      	push	{r7}
24009f32:	b083      	sub	sp, #12
24009f34:	af00      	add	r7, sp, #0
24009f36:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
24009f38:	4b05      	ldr	r3, [pc, #20]	; (24009f50 <HAL_HSEM_ActivateNotification+0x20>)
24009f3a:	681a      	ldr	r2, [r3, #0]
24009f3c:	4904      	ldr	r1, [pc, #16]	; (24009f50 <HAL_HSEM_ActivateNotification+0x20>)
24009f3e:	687b      	ldr	r3, [r7, #4]
24009f40:	4313      	orrs	r3, r2
24009f42:	600b      	str	r3, [r1, #0]
#endif
}
24009f44:	bf00      	nop
24009f46:	370c      	adds	r7, #12
24009f48:	46bd      	mov	sp, r7
24009f4a:	f85d 7b04 	ldr.w	r7, [sp], #4
24009f4e:	4770      	bx	lr
24009f50:	58026500 	.word	0x58026500

24009f54 <HAL_HSEM_DeactivateNotification>:
  * @brief  Deactivate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_DeactivateNotification(uint32_t SemMask)
{
24009f54:	b480      	push	{r7}
24009f56:	b083      	sub	sp, #12
24009f58:	af00      	add	r7, sp, #0
24009f5a:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER &= ~SemMask;
  }
#else
  HSEM_COMMON->IER &= ~SemMask;
24009f5c:	4b06      	ldr	r3, [pc, #24]	; (24009f78 <HAL_HSEM_DeactivateNotification+0x24>)
24009f5e:	681a      	ldr	r2, [r3, #0]
24009f60:	687b      	ldr	r3, [r7, #4]
24009f62:	43db      	mvns	r3, r3
24009f64:	4904      	ldr	r1, [pc, #16]	; (24009f78 <HAL_HSEM_DeactivateNotification+0x24>)
24009f66:	4013      	ands	r3, r2
24009f68:	600b      	str	r3, [r1, #0]
#endif
}
24009f6a:	bf00      	nop
24009f6c:	370c      	adds	r7, #12
24009f6e:	46bd      	mov	sp, r7
24009f70:	f85d 7b04 	ldr.w	r7, [sp], #4
24009f74:	4770      	bx	lr
24009f76:	bf00      	nop
24009f78:	58026500 	.word	0x58026500

24009f7c <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
24009f7c:	b580      	push	{r7, lr}
24009f7e:	b082      	sub	sp, #8
24009f80:	af00      	add	r7, sp, #0
    /*Clear Flags*/
    HSEM->C2ICR = ((uint32_t)statusreg);
  }
#else
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
24009f82:	4b0a      	ldr	r3, [pc, #40]	; (24009fac <HAL_HSEM_IRQHandler+0x30>)
24009f84:	68db      	ldr	r3, [r3, #12]
24009f86:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
24009f88:	4b08      	ldr	r3, [pc, #32]	; (24009fac <HAL_HSEM_IRQHandler+0x30>)
24009f8a:	681a      	ldr	r2, [r3, #0]
24009f8c:	687b      	ldr	r3, [r7, #4]
24009f8e:	43db      	mvns	r3, r3
24009f90:	4906      	ldr	r1, [pc, #24]	; (24009fac <HAL_HSEM_IRQHandler+0x30>)
24009f92:	4013      	ands	r3, r2
24009f94:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
24009f96:	4a05      	ldr	r2, [pc, #20]	; (24009fac <HAL_HSEM_IRQHandler+0x30>)
24009f98:	687b      	ldr	r3, [r7, #4]
24009f9a:	6053      	str	r3, [r2, #4]

#endif
  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
24009f9c:	6878      	ldr	r0, [r7, #4]
24009f9e:	f000 f807 	bl	24009fb0 <HAL_HSEM_FreeCallback>
}
24009fa2:	bf00      	nop
24009fa4:	3708      	adds	r7, #8
24009fa6:	46bd      	mov	sp, r7
24009fa8:	bd80      	pop	{r7, pc}
24009faa:	bf00      	nop
24009fac:	58026500 	.word	0x58026500

24009fb0 <HAL_HSEM_FreeCallback>:
  * @brief Semaphore Released Callback.
  * @param SemMask: Mask of Released semaphores
  * @retval None
  */
__weak void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
24009fb0:	b480      	push	{r7}
24009fb2:	b083      	sub	sp, #12
24009fb4:	af00      	add	r7, sp, #0
24009fb6:	6078      	str	r0, [r7, #4]
  UNUSED(SemMask);

  /* NOTE : This function should not be modified, when the callback is needed,
  the HAL_HSEM_FreeCallback can be implemented in the user file
    */
}
24009fb8:	bf00      	nop
24009fba:	370c      	adds	r7, #12
24009fbc:	46bd      	mov	sp, r7
24009fbe:	f85d 7b04 	ldr.w	r7, [sp], #4
24009fc2:	4770      	bx	lr

24009fc4 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
24009fc4:	b580      	push	{r7, lr}
24009fc6:	b082      	sub	sp, #8
24009fc8:	af00      	add	r7, sp, #0
24009fca:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
24009fcc:	687b      	ldr	r3, [r7, #4]
24009fce:	2b00      	cmp	r3, #0
24009fd0:	d101      	bne.n	24009fd6 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
24009fd2:	2301      	movs	r3, #1
24009fd4:	e07f      	b.n	2400a0d6 <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
24009fd6:	687b      	ldr	r3, [r7, #4]
24009fd8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24009fdc:	b2db      	uxtb	r3, r3
24009fde:	2b00      	cmp	r3, #0
24009fe0:	d106      	bne.n	24009ff0 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
24009fe2:	687b      	ldr	r3, [r7, #4]
24009fe4:	2200      	movs	r2, #0
24009fe6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
24009fea:	6878      	ldr	r0, [r7, #4]
24009fec:	f000 f8a9 	bl	2400a142 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
24009ff0:	687b      	ldr	r3, [r7, #4]
24009ff2:	2224      	movs	r2, #36	; 0x24
24009ff4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
24009ff8:	687b      	ldr	r3, [r7, #4]
24009ffa:	681b      	ldr	r3, [r3, #0]
24009ffc:	681a      	ldr	r2, [r3, #0]
24009ffe:	687b      	ldr	r3, [r7, #4]
2400a000:	681b      	ldr	r3, [r3, #0]
2400a002:	f022 0201 	bic.w	r2, r2, #1
2400a006:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
2400a008:	687b      	ldr	r3, [r7, #4]
2400a00a:	685a      	ldr	r2, [r3, #4]
2400a00c:	687b      	ldr	r3, [r7, #4]
2400a00e:	681b      	ldr	r3, [r3, #0]
2400a010:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
2400a014:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
2400a016:	687b      	ldr	r3, [r7, #4]
2400a018:	681b      	ldr	r3, [r3, #0]
2400a01a:	689a      	ldr	r2, [r3, #8]
2400a01c:	687b      	ldr	r3, [r7, #4]
2400a01e:	681b      	ldr	r3, [r3, #0]
2400a020:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a024:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
2400a026:	687b      	ldr	r3, [r7, #4]
2400a028:	68db      	ldr	r3, [r3, #12]
2400a02a:	2b01      	cmp	r3, #1
2400a02c:	d107      	bne.n	2400a03e <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
2400a02e:	687b      	ldr	r3, [r7, #4]
2400a030:	689a      	ldr	r2, [r3, #8]
2400a032:	687b      	ldr	r3, [r7, #4]
2400a034:	681b      	ldr	r3, [r3, #0]
2400a036:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a03a:	609a      	str	r2, [r3, #8]
2400a03c:	e006      	b.n	2400a04c <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
2400a03e:	687b      	ldr	r3, [r7, #4]
2400a040:	689a      	ldr	r2, [r3, #8]
2400a042:	687b      	ldr	r3, [r7, #4]
2400a044:	681b      	ldr	r3, [r3, #0]
2400a046:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
2400a04a:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400a04c:	687b      	ldr	r3, [r7, #4]
2400a04e:	68db      	ldr	r3, [r3, #12]
2400a050:	2b02      	cmp	r3, #2
2400a052:	d104      	bne.n	2400a05e <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
2400a054:	687b      	ldr	r3, [r7, #4]
2400a056:	681b      	ldr	r3, [r3, #0]
2400a058:	f44f 6200 	mov.w	r2, #2048	; 0x800
2400a05c:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
2400a05e:	687b      	ldr	r3, [r7, #4]
2400a060:	681b      	ldr	r3, [r3, #0]
2400a062:	6859      	ldr	r1, [r3, #4]
2400a064:	687b      	ldr	r3, [r7, #4]
2400a066:	681a      	ldr	r2, [r3, #0]
2400a068:	4b1d      	ldr	r3, [pc, #116]	; (2400a0e0 <HAL_I2C_Init+0x11c>)
2400a06a:	430b      	orrs	r3, r1
2400a06c:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
2400a06e:	687b      	ldr	r3, [r7, #4]
2400a070:	681b      	ldr	r3, [r3, #0]
2400a072:	68da      	ldr	r2, [r3, #12]
2400a074:	687b      	ldr	r3, [r7, #4]
2400a076:	681b      	ldr	r3, [r3, #0]
2400a078:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a07c:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
2400a07e:	687b      	ldr	r3, [r7, #4]
2400a080:	691a      	ldr	r2, [r3, #16]
2400a082:	687b      	ldr	r3, [r7, #4]
2400a084:	695b      	ldr	r3, [r3, #20]
2400a086:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
2400a08a:	687b      	ldr	r3, [r7, #4]
2400a08c:	699b      	ldr	r3, [r3, #24]
2400a08e:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
2400a090:	687b      	ldr	r3, [r7, #4]
2400a092:	681b      	ldr	r3, [r3, #0]
2400a094:	430a      	orrs	r2, r1
2400a096:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
2400a098:	687b      	ldr	r3, [r7, #4]
2400a09a:	69d9      	ldr	r1, [r3, #28]
2400a09c:	687b      	ldr	r3, [r7, #4]
2400a09e:	6a1a      	ldr	r2, [r3, #32]
2400a0a0:	687b      	ldr	r3, [r7, #4]
2400a0a2:	681b      	ldr	r3, [r3, #0]
2400a0a4:	430a      	orrs	r2, r1
2400a0a6:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
2400a0a8:	687b      	ldr	r3, [r7, #4]
2400a0aa:	681b      	ldr	r3, [r3, #0]
2400a0ac:	681a      	ldr	r2, [r3, #0]
2400a0ae:	687b      	ldr	r3, [r7, #4]
2400a0b0:	681b      	ldr	r3, [r3, #0]
2400a0b2:	f042 0201 	orr.w	r2, r2, #1
2400a0b6:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a0b8:	687b      	ldr	r3, [r7, #4]
2400a0ba:	2200      	movs	r2, #0
2400a0bc:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
2400a0be:	687b      	ldr	r3, [r7, #4]
2400a0c0:	2220      	movs	r2, #32
2400a0c2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
2400a0c6:	687b      	ldr	r3, [r7, #4]
2400a0c8:	2200      	movs	r2, #0
2400a0ca:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400a0cc:	687b      	ldr	r3, [r7, #4]
2400a0ce:	2200      	movs	r2, #0
2400a0d0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
2400a0d4:	2300      	movs	r3, #0
}
2400a0d6:	4618      	mov	r0, r3
2400a0d8:	3708      	adds	r7, #8
2400a0da:	46bd      	mov	sp, r7
2400a0dc:	bd80      	pop	{r7, pc}
2400a0de:	bf00      	nop
2400a0e0:	02008000 	.word	0x02008000

2400a0e4 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
2400a0e4:	b580      	push	{r7, lr}
2400a0e6:	b082      	sub	sp, #8
2400a0e8:	af00      	add	r7, sp, #0
2400a0ea:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
2400a0ec:	687b      	ldr	r3, [r7, #4]
2400a0ee:	2b00      	cmp	r3, #0
2400a0f0:	d101      	bne.n	2400a0f6 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
2400a0f2:	2301      	movs	r3, #1
2400a0f4:	e021      	b.n	2400a13a <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
2400a0f6:	687b      	ldr	r3, [r7, #4]
2400a0f8:	2224      	movs	r2, #36	; 0x24
2400a0fa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
2400a0fe:	687b      	ldr	r3, [r7, #4]
2400a100:	681b      	ldr	r3, [r3, #0]
2400a102:	681a      	ldr	r2, [r3, #0]
2400a104:	687b      	ldr	r3, [r7, #4]
2400a106:	681b      	ldr	r3, [r3, #0]
2400a108:	f022 0201 	bic.w	r2, r2, #1
2400a10c:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
2400a10e:	6878      	ldr	r0, [r7, #4]
2400a110:	f000 f821 	bl	2400a156 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a114:	687b      	ldr	r3, [r7, #4]
2400a116:	2200      	movs	r2, #0
2400a118:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
2400a11a:	687b      	ldr	r3, [r7, #4]
2400a11c:	2200      	movs	r2, #0
2400a11e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
2400a122:	687b      	ldr	r3, [r7, #4]
2400a124:	2200      	movs	r2, #0
2400a126:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400a128:	687b      	ldr	r3, [r7, #4]
2400a12a:	2200      	movs	r2, #0
2400a12c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
2400a130:	687b      	ldr	r3, [r7, #4]
2400a132:	2200      	movs	r2, #0
2400a134:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400a138:	2300      	movs	r3, #0
}
2400a13a:	4618      	mov	r0, r3
2400a13c:	3708      	adds	r7, #8
2400a13e:	46bd      	mov	sp, r7
2400a140:	bd80      	pop	{r7, pc}

2400a142 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
2400a142:	b480      	push	{r7}
2400a144:	b083      	sub	sp, #12
2400a146:	af00      	add	r7, sp, #0
2400a148:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
2400a14a:	bf00      	nop
2400a14c:	370c      	adds	r7, #12
2400a14e:	46bd      	mov	sp, r7
2400a150:	f85d 7b04 	ldr.w	r7, [sp], #4
2400a154:	4770      	bx	lr

2400a156 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
2400a156:	b480      	push	{r7}
2400a158:	b083      	sub	sp, #12
2400a15a:	af00      	add	r7, sp, #0
2400a15c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
2400a15e:	bf00      	nop
2400a160:	370c      	adds	r7, #12
2400a162:	46bd      	mov	sp, r7
2400a164:	f85d 7b04 	ldr.w	r7, [sp], #4
2400a168:	4770      	bx	lr
	...

2400a16c <HAL_I2C_Master_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                          uint16_t Size, uint32_t Timeout)
{
2400a16c:	b580      	push	{r7, lr}
2400a16e:	b088      	sub	sp, #32
2400a170:	af02      	add	r7, sp, #8
2400a172:	60f8      	str	r0, [r7, #12]
2400a174:	607a      	str	r2, [r7, #4]
2400a176:	461a      	mov	r2, r3
2400a178:	460b      	mov	r3, r1
2400a17a:	817b      	strh	r3, [r7, #10]
2400a17c:	4613      	mov	r3, r2
2400a17e:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a180:	68fb      	ldr	r3, [r7, #12]
2400a182:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a186:	b2db      	uxtb	r3, r3
2400a188:	2b20      	cmp	r3, #32
2400a18a:	f040 80da 	bne.w	2400a342 <HAL_I2C_Master_Transmit+0x1d6>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a18e:	68fb      	ldr	r3, [r7, #12]
2400a190:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a194:	2b01      	cmp	r3, #1
2400a196:	d101      	bne.n	2400a19c <HAL_I2C_Master_Transmit+0x30>
2400a198:	2302      	movs	r3, #2
2400a19a:	e0d3      	b.n	2400a344 <HAL_I2C_Master_Transmit+0x1d8>
2400a19c:	68fb      	ldr	r3, [r7, #12]
2400a19e:	2201      	movs	r2, #1
2400a1a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a1a4:	f7f8 f8ce 	bl	24002344 <HAL_GetTick>
2400a1a8:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400a1aa:	697b      	ldr	r3, [r7, #20]
2400a1ac:	9300      	str	r3, [sp, #0]
2400a1ae:	2319      	movs	r3, #25
2400a1b0:	2201      	movs	r2, #1
2400a1b2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a1b6:	68f8      	ldr	r0, [r7, #12]
2400a1b8:	f004 fd04 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a1bc:	4603      	mov	r3, r0
2400a1be:	2b00      	cmp	r3, #0
2400a1c0:	d001      	beq.n	2400a1c6 <HAL_I2C_Master_Transmit+0x5a>
    {
      return HAL_ERROR;
2400a1c2:	2301      	movs	r3, #1
2400a1c4:	e0be      	b.n	2400a344 <HAL_I2C_Master_Transmit+0x1d8>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400a1c6:	68fb      	ldr	r3, [r7, #12]
2400a1c8:	2221      	movs	r2, #33	; 0x21
2400a1ca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400a1ce:	68fb      	ldr	r3, [r7, #12]
2400a1d0:	2210      	movs	r2, #16
2400a1d2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a1d6:	68fb      	ldr	r3, [r7, #12]
2400a1d8:	2200      	movs	r2, #0
2400a1da:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a1dc:	68fb      	ldr	r3, [r7, #12]
2400a1de:	687a      	ldr	r2, [r7, #4]
2400a1e0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a1e2:	68fb      	ldr	r3, [r7, #12]
2400a1e4:	893a      	ldrh	r2, [r7, #8]
2400a1e6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a1e8:	68fb      	ldr	r3, [r7, #12]
2400a1ea:	2200      	movs	r2, #0
2400a1ec:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a1ee:	68fb      	ldr	r3, [r7, #12]
2400a1f0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a1f2:	b29b      	uxth	r3, r3
2400a1f4:	2bff      	cmp	r3, #255	; 0xff
2400a1f6:	d90e      	bls.n	2400a216 <HAL_I2C_Master_Transmit+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a1f8:	68fb      	ldr	r3, [r7, #12]
2400a1fa:	22ff      	movs	r2, #255	; 0xff
2400a1fc:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400a1fe:	68fb      	ldr	r3, [r7, #12]
2400a200:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a202:	b2da      	uxtb	r2, r3
2400a204:	8979      	ldrh	r1, [r7, #10]
2400a206:	4b51      	ldr	r3, [pc, #324]	; (2400a34c <HAL_I2C_Master_Transmit+0x1e0>)
2400a208:	9300      	str	r3, [sp, #0]
2400a20a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a20e:	68f8      	ldr	r0, [r7, #12]
2400a210:	f004 fefa 	bl	2400f008 <I2C_TransferConfig>
2400a214:	e06c      	b.n	2400a2f0 <HAL_I2C_Master_Transmit+0x184>
                         I2C_GENERATE_START_WRITE);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a216:	68fb      	ldr	r3, [r7, #12]
2400a218:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a21a:	b29a      	uxth	r2, r3
2400a21c:	68fb      	ldr	r3, [r7, #12]
2400a21e:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400a220:	68fb      	ldr	r3, [r7, #12]
2400a222:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a224:	b2da      	uxtb	r2, r3
2400a226:	8979      	ldrh	r1, [r7, #10]
2400a228:	4b48      	ldr	r3, [pc, #288]	; (2400a34c <HAL_I2C_Master_Transmit+0x1e0>)
2400a22a:	9300      	str	r3, [sp, #0]
2400a22c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a230:	68f8      	ldr	r0, [r7, #12]
2400a232:	f004 fee9 	bl	2400f008 <I2C_TransferConfig>
                         I2C_GENERATE_START_WRITE);
    }

    while (hi2c->XferCount > 0U)
2400a236:	e05b      	b.n	2400a2f0 <HAL_I2C_Master_Transmit+0x184>
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a238:	697a      	ldr	r2, [r7, #20]
2400a23a:	6a39      	ldr	r1, [r7, #32]
2400a23c:	68f8      	ldr	r0, [r7, #12]
2400a23e:	f004 fd01 	bl	2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>
2400a242:	4603      	mov	r3, r0
2400a244:	2b00      	cmp	r3, #0
2400a246:	d001      	beq.n	2400a24c <HAL_I2C_Master_Transmit+0xe0>
      {
        return HAL_ERROR;
2400a248:	2301      	movs	r3, #1
2400a24a:	e07b      	b.n	2400a344 <HAL_I2C_Master_Transmit+0x1d8>
      }
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400a24c:	68fb      	ldr	r3, [r7, #12]
2400a24e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a250:	781a      	ldrb	r2, [r3, #0]
2400a252:	68fb      	ldr	r3, [r7, #12]
2400a254:	681b      	ldr	r3, [r3, #0]
2400a256:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a258:	68fb      	ldr	r3, [r7, #12]
2400a25a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a25c:	1c5a      	adds	r2, r3, #1
2400a25e:	68fb      	ldr	r3, [r7, #12]
2400a260:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a262:	68fb      	ldr	r3, [r7, #12]
2400a264:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a266:	b29b      	uxth	r3, r3
2400a268:	3b01      	subs	r3, #1
2400a26a:	b29a      	uxth	r2, r3
2400a26c:	68fb      	ldr	r3, [r7, #12]
2400a26e:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400a270:	68fb      	ldr	r3, [r7, #12]
2400a272:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a274:	3b01      	subs	r3, #1
2400a276:	b29a      	uxth	r2, r3
2400a278:	68fb      	ldr	r3, [r7, #12]
2400a27a:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400a27c:	68fb      	ldr	r3, [r7, #12]
2400a27e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a280:	b29b      	uxth	r3, r3
2400a282:	2b00      	cmp	r3, #0
2400a284:	d034      	beq.n	2400a2f0 <HAL_I2C_Master_Transmit+0x184>
2400a286:	68fb      	ldr	r3, [r7, #12]
2400a288:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a28a:	2b00      	cmp	r3, #0
2400a28c:	d130      	bne.n	2400a2f0 <HAL_I2C_Master_Transmit+0x184>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400a28e:	697b      	ldr	r3, [r7, #20]
2400a290:	9300      	str	r3, [sp, #0]
2400a292:	6a3b      	ldr	r3, [r7, #32]
2400a294:	2200      	movs	r2, #0
2400a296:	2180      	movs	r1, #128	; 0x80
2400a298:	68f8      	ldr	r0, [r7, #12]
2400a29a:	f004 fc93 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a29e:	4603      	mov	r3, r0
2400a2a0:	2b00      	cmp	r3, #0
2400a2a2:	d001      	beq.n	2400a2a8 <HAL_I2C_Master_Transmit+0x13c>
        {
          return HAL_ERROR;
2400a2a4:	2301      	movs	r3, #1
2400a2a6:	e04d      	b.n	2400a344 <HAL_I2C_Master_Transmit+0x1d8>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a2a8:	68fb      	ldr	r3, [r7, #12]
2400a2aa:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2ac:	b29b      	uxth	r3, r3
2400a2ae:	2bff      	cmp	r3, #255	; 0xff
2400a2b0:	d90e      	bls.n	2400a2d0 <HAL_I2C_Master_Transmit+0x164>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400a2b2:	68fb      	ldr	r3, [r7, #12]
2400a2b4:	22ff      	movs	r2, #255	; 0xff
2400a2b6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400a2b8:	68fb      	ldr	r3, [r7, #12]
2400a2ba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a2bc:	b2da      	uxtb	r2, r3
2400a2be:	8979      	ldrh	r1, [r7, #10]
2400a2c0:	2300      	movs	r3, #0
2400a2c2:	9300      	str	r3, [sp, #0]
2400a2c4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a2c8:	68f8      	ldr	r0, [r7, #12]
2400a2ca:	f004 fe9d 	bl	2400f008 <I2C_TransferConfig>
2400a2ce:	e00f      	b.n	2400a2f0 <HAL_I2C_Master_Transmit+0x184>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400a2d0:	68fb      	ldr	r3, [r7, #12]
2400a2d2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2d4:	b29a      	uxth	r2, r3
2400a2d6:	68fb      	ldr	r3, [r7, #12]
2400a2d8:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400a2da:	68fb      	ldr	r3, [r7, #12]
2400a2dc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a2de:	b2da      	uxtb	r2, r3
2400a2e0:	8979      	ldrh	r1, [r7, #10]
2400a2e2:	2300      	movs	r3, #0
2400a2e4:	9300      	str	r3, [sp, #0]
2400a2e6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a2ea:	68f8      	ldr	r0, [r7, #12]
2400a2ec:	f004 fe8c 	bl	2400f008 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
2400a2f0:	68fb      	ldr	r3, [r7, #12]
2400a2f2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a2f4:	b29b      	uxth	r3, r3
2400a2f6:	2b00      	cmp	r3, #0
2400a2f8:	d19e      	bne.n	2400a238 <HAL_I2C_Master_Transmit+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a2fa:	697a      	ldr	r2, [r7, #20]
2400a2fc:	6a39      	ldr	r1, [r7, #32]
2400a2fe:	68f8      	ldr	r0, [r7, #12]
2400a300:	f004 fce0 	bl	2400ecc4 <I2C_WaitOnSTOPFlagUntilTimeout>
2400a304:	4603      	mov	r3, r0
2400a306:	2b00      	cmp	r3, #0
2400a308:	d001      	beq.n	2400a30e <HAL_I2C_Master_Transmit+0x1a2>
    {
      return HAL_ERROR;
2400a30a:	2301      	movs	r3, #1
2400a30c:	e01a      	b.n	2400a344 <HAL_I2C_Master_Transmit+0x1d8>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a30e:	68fb      	ldr	r3, [r7, #12]
2400a310:	681b      	ldr	r3, [r3, #0]
2400a312:	2220      	movs	r2, #32
2400a314:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400a316:	68fb      	ldr	r3, [r7, #12]
2400a318:	681b      	ldr	r3, [r3, #0]
2400a31a:	6859      	ldr	r1, [r3, #4]
2400a31c:	68fb      	ldr	r3, [r7, #12]
2400a31e:	681a      	ldr	r2, [r3, #0]
2400a320:	4b0b      	ldr	r3, [pc, #44]	; (2400a350 <HAL_I2C_Master_Transmit+0x1e4>)
2400a322:	400b      	ands	r3, r1
2400a324:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a326:	68fb      	ldr	r3, [r7, #12]
2400a328:	2220      	movs	r2, #32
2400a32a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a32e:	68fb      	ldr	r3, [r7, #12]
2400a330:	2200      	movs	r2, #0
2400a332:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a336:	68fb      	ldr	r3, [r7, #12]
2400a338:	2200      	movs	r2, #0
2400a33a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a33e:	2300      	movs	r3, #0
2400a340:	e000      	b.n	2400a344 <HAL_I2C_Master_Transmit+0x1d8>
  }
  else
  {
    return HAL_BUSY;
2400a342:	2302      	movs	r3, #2
  }
}
2400a344:	4618      	mov	r0, r3
2400a346:	3718      	adds	r7, #24
2400a348:	46bd      	mov	sp, r7
2400a34a:	bd80      	pop	{r7, pc}
2400a34c:	80002000 	.word	0x80002000
2400a350:	fe00e800 	.word	0xfe00e800

2400a354 <HAL_I2C_Master_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                         uint16_t Size, uint32_t Timeout)
{
2400a354:	b580      	push	{r7, lr}
2400a356:	b088      	sub	sp, #32
2400a358:	af02      	add	r7, sp, #8
2400a35a:	60f8      	str	r0, [r7, #12]
2400a35c:	607a      	str	r2, [r7, #4]
2400a35e:	461a      	mov	r2, r3
2400a360:	460b      	mov	r3, r1
2400a362:	817b      	strh	r3, [r7, #10]
2400a364:	4613      	mov	r3, r2
2400a366:	813b      	strh	r3, [r7, #8]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a368:	68fb      	ldr	r3, [r7, #12]
2400a36a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a36e:	b2db      	uxtb	r3, r3
2400a370:	2b20      	cmp	r3, #32
2400a372:	f040 80db 	bne.w	2400a52c <HAL_I2C_Master_Receive+0x1d8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a376:	68fb      	ldr	r3, [r7, #12]
2400a378:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a37c:	2b01      	cmp	r3, #1
2400a37e:	d101      	bne.n	2400a384 <HAL_I2C_Master_Receive+0x30>
2400a380:	2302      	movs	r3, #2
2400a382:	e0d4      	b.n	2400a52e <HAL_I2C_Master_Receive+0x1da>
2400a384:	68fb      	ldr	r3, [r7, #12]
2400a386:	2201      	movs	r2, #1
2400a388:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a38c:	f7f7 ffda 	bl	24002344 <HAL_GetTick>
2400a390:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400a392:	697b      	ldr	r3, [r7, #20]
2400a394:	9300      	str	r3, [sp, #0]
2400a396:	2319      	movs	r3, #25
2400a398:	2201      	movs	r2, #1
2400a39a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a39e:	68f8      	ldr	r0, [r7, #12]
2400a3a0:	f004 fc10 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a3a4:	4603      	mov	r3, r0
2400a3a6:	2b00      	cmp	r3, #0
2400a3a8:	d001      	beq.n	2400a3ae <HAL_I2C_Master_Receive+0x5a>
    {
      return HAL_ERROR;
2400a3aa:	2301      	movs	r3, #1
2400a3ac:	e0bf      	b.n	2400a52e <HAL_I2C_Master_Receive+0x1da>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400a3ae:	68fb      	ldr	r3, [r7, #12]
2400a3b0:	2222      	movs	r2, #34	; 0x22
2400a3b2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400a3b6:	68fb      	ldr	r3, [r7, #12]
2400a3b8:	2210      	movs	r2, #16
2400a3ba:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a3be:	68fb      	ldr	r3, [r7, #12]
2400a3c0:	2200      	movs	r2, #0
2400a3c2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a3c4:	68fb      	ldr	r3, [r7, #12]
2400a3c6:	687a      	ldr	r2, [r7, #4]
2400a3c8:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a3ca:	68fb      	ldr	r3, [r7, #12]
2400a3cc:	893a      	ldrh	r2, [r7, #8]
2400a3ce:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a3d0:	68fb      	ldr	r3, [r7, #12]
2400a3d2:	2200      	movs	r2, #0
2400a3d4:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a3d6:	68fb      	ldr	r3, [r7, #12]
2400a3d8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a3da:	b29b      	uxth	r3, r3
2400a3dc:	2bff      	cmp	r3, #255	; 0xff
2400a3de:	d90e      	bls.n	2400a3fe <HAL_I2C_Master_Receive+0xaa>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400a3e0:	68fb      	ldr	r3, [r7, #12]
2400a3e2:	22ff      	movs	r2, #255	; 0xff
2400a3e4:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400a3e6:	68fb      	ldr	r3, [r7, #12]
2400a3e8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a3ea:	b2da      	uxtb	r2, r3
2400a3ec:	8979      	ldrh	r1, [r7, #10]
2400a3ee:	4b52      	ldr	r3, [pc, #328]	; (2400a538 <HAL_I2C_Master_Receive+0x1e4>)
2400a3f0:	9300      	str	r3, [sp, #0]
2400a3f2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a3f6:	68f8      	ldr	r0, [r7, #12]
2400a3f8:	f004 fe06 	bl	2400f008 <I2C_TransferConfig>
2400a3fc:	e06d      	b.n	2400a4da <HAL_I2C_Master_Receive+0x186>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400a3fe:	68fb      	ldr	r3, [r7, #12]
2400a400:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a402:	b29a      	uxth	r2, r3
2400a404:	68fb      	ldr	r3, [r7, #12]
2400a406:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400a408:	68fb      	ldr	r3, [r7, #12]
2400a40a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a40c:	b2da      	uxtb	r2, r3
2400a40e:	8979      	ldrh	r1, [r7, #10]
2400a410:	4b49      	ldr	r3, [pc, #292]	; (2400a538 <HAL_I2C_Master_Receive+0x1e4>)
2400a412:	9300      	str	r3, [sp, #0]
2400a414:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a418:	68f8      	ldr	r0, [r7, #12]
2400a41a:	f004 fdf5 	bl	2400f008 <I2C_TransferConfig>
                         I2C_GENERATE_START_READ);
    }

    while (hi2c->XferCount > 0U)
2400a41e:	e05c      	b.n	2400a4da <HAL_I2C_Master_Receive+0x186>
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a420:	697a      	ldr	r2, [r7, #20]
2400a422:	6a39      	ldr	r1, [r7, #32]
2400a424:	68f8      	ldr	r0, [r7, #12]
2400a426:	f004 fc89 	bl	2400ed3c <I2C_WaitOnRXNEFlagUntilTimeout>
2400a42a:	4603      	mov	r3, r0
2400a42c:	2b00      	cmp	r3, #0
2400a42e:	d001      	beq.n	2400a434 <HAL_I2C_Master_Receive+0xe0>
      {
        return HAL_ERROR;
2400a430:	2301      	movs	r3, #1
2400a432:	e07c      	b.n	2400a52e <HAL_I2C_Master_Receive+0x1da>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a434:	68fb      	ldr	r3, [r7, #12]
2400a436:	681b      	ldr	r3, [r3, #0]
2400a438:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a43a:	68fb      	ldr	r3, [r7, #12]
2400a43c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a43e:	b2d2      	uxtb	r2, r2
2400a440:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a442:	68fb      	ldr	r3, [r7, #12]
2400a444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a446:	1c5a      	adds	r2, r3, #1
2400a448:	68fb      	ldr	r3, [r7, #12]
2400a44a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400a44c:	68fb      	ldr	r3, [r7, #12]
2400a44e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a450:	3b01      	subs	r3, #1
2400a452:	b29a      	uxth	r2, r3
2400a454:	68fb      	ldr	r3, [r7, #12]
2400a456:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400a458:	68fb      	ldr	r3, [r7, #12]
2400a45a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a45c:	b29b      	uxth	r3, r3
2400a45e:	3b01      	subs	r3, #1
2400a460:	b29a      	uxth	r2, r3
2400a462:	68fb      	ldr	r3, [r7, #12]
2400a464:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400a466:	68fb      	ldr	r3, [r7, #12]
2400a468:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a46a:	b29b      	uxth	r3, r3
2400a46c:	2b00      	cmp	r3, #0
2400a46e:	d034      	beq.n	2400a4da <HAL_I2C_Master_Receive+0x186>
2400a470:	68fb      	ldr	r3, [r7, #12]
2400a472:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a474:	2b00      	cmp	r3, #0
2400a476:	d130      	bne.n	2400a4da <HAL_I2C_Master_Receive+0x186>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400a478:	697b      	ldr	r3, [r7, #20]
2400a47a:	9300      	str	r3, [sp, #0]
2400a47c:	6a3b      	ldr	r3, [r7, #32]
2400a47e:	2200      	movs	r2, #0
2400a480:	2180      	movs	r1, #128	; 0x80
2400a482:	68f8      	ldr	r0, [r7, #12]
2400a484:	f004 fb9e 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a488:	4603      	mov	r3, r0
2400a48a:	2b00      	cmp	r3, #0
2400a48c:	d001      	beq.n	2400a492 <HAL_I2C_Master_Receive+0x13e>
        {
          return HAL_ERROR;
2400a48e:	2301      	movs	r3, #1
2400a490:	e04d      	b.n	2400a52e <HAL_I2C_Master_Receive+0x1da>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400a492:	68fb      	ldr	r3, [r7, #12]
2400a494:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a496:	b29b      	uxth	r3, r3
2400a498:	2bff      	cmp	r3, #255	; 0xff
2400a49a:	d90e      	bls.n	2400a4ba <HAL_I2C_Master_Receive+0x166>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400a49c:	68fb      	ldr	r3, [r7, #12]
2400a49e:	22ff      	movs	r2, #255	; 0xff
2400a4a0:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400a4a2:	68fb      	ldr	r3, [r7, #12]
2400a4a4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a4a6:	b2da      	uxtb	r2, r3
2400a4a8:	8979      	ldrh	r1, [r7, #10]
2400a4aa:	2300      	movs	r3, #0
2400a4ac:	9300      	str	r3, [sp, #0]
2400a4ae:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400a4b2:	68f8      	ldr	r0, [r7, #12]
2400a4b4:	f004 fda8 	bl	2400f008 <I2C_TransferConfig>
2400a4b8:	e00f      	b.n	2400a4da <HAL_I2C_Master_Receive+0x186>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400a4ba:	68fb      	ldr	r3, [r7, #12]
2400a4bc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4be:	b29a      	uxth	r2, r3
2400a4c0:	68fb      	ldr	r3, [r7, #12]
2400a4c2:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400a4c4:	68fb      	ldr	r3, [r7, #12]
2400a4c6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a4c8:	b2da      	uxtb	r2, r3
2400a4ca:	8979      	ldrh	r1, [r7, #10]
2400a4cc:	2300      	movs	r3, #0
2400a4ce:	9300      	str	r3, [sp, #0]
2400a4d0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400a4d4:	68f8      	ldr	r0, [r7, #12]
2400a4d6:	f004 fd97 	bl	2400f008 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
2400a4da:	68fb      	ldr	r3, [r7, #12]
2400a4dc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a4de:	b29b      	uxth	r3, r3
2400a4e0:	2b00      	cmp	r3, #0
2400a4e2:	d19d      	bne.n	2400a420 <HAL_I2C_Master_Receive+0xcc>
      }
    }

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a4e4:	697a      	ldr	r2, [r7, #20]
2400a4e6:	6a39      	ldr	r1, [r7, #32]
2400a4e8:	68f8      	ldr	r0, [r7, #12]
2400a4ea:	f004 fbeb 	bl	2400ecc4 <I2C_WaitOnSTOPFlagUntilTimeout>
2400a4ee:	4603      	mov	r3, r0
2400a4f0:	2b00      	cmp	r3, #0
2400a4f2:	d001      	beq.n	2400a4f8 <HAL_I2C_Master_Receive+0x1a4>
    {
      return HAL_ERROR;
2400a4f4:	2301      	movs	r3, #1
2400a4f6:	e01a      	b.n	2400a52e <HAL_I2C_Master_Receive+0x1da>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a4f8:	68fb      	ldr	r3, [r7, #12]
2400a4fa:	681b      	ldr	r3, [r3, #0]
2400a4fc:	2220      	movs	r2, #32
2400a4fe:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400a500:	68fb      	ldr	r3, [r7, #12]
2400a502:	681b      	ldr	r3, [r3, #0]
2400a504:	6859      	ldr	r1, [r3, #4]
2400a506:	68fb      	ldr	r3, [r7, #12]
2400a508:	681a      	ldr	r2, [r3, #0]
2400a50a:	4b0c      	ldr	r3, [pc, #48]	; (2400a53c <HAL_I2C_Master_Receive+0x1e8>)
2400a50c:	400b      	ands	r3, r1
2400a50e:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a510:	68fb      	ldr	r3, [r7, #12]
2400a512:	2220      	movs	r2, #32
2400a514:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a518:	68fb      	ldr	r3, [r7, #12]
2400a51a:	2200      	movs	r2, #0
2400a51c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a520:	68fb      	ldr	r3, [r7, #12]
2400a522:	2200      	movs	r2, #0
2400a524:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a528:	2300      	movs	r3, #0
2400a52a:	e000      	b.n	2400a52e <HAL_I2C_Master_Receive+0x1da>
  }
  else
  {
    return HAL_BUSY;
2400a52c:	2302      	movs	r3, #2
  }
}
2400a52e:	4618      	mov	r0, r3
2400a530:	3718      	adds	r7, #24
2400a532:	46bd      	mov	sp, r7
2400a534:	bd80      	pop	{r7, pc}
2400a536:	bf00      	nop
2400a538:	80002400 	.word	0x80002400
2400a53c:	fe00e800 	.word	0xfe00e800

2400a540 <HAL_I2C_Slave_Transmit>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                         uint32_t Timeout)
{
2400a540:	b580      	push	{r7, lr}
2400a542:	b088      	sub	sp, #32
2400a544:	af02      	add	r7, sp, #8
2400a546:	60f8      	str	r0, [r7, #12]
2400a548:	60b9      	str	r1, [r7, #8]
2400a54a:	603b      	str	r3, [r7, #0]
2400a54c:	4613      	mov	r3, r2
2400a54e:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a550:	68fb      	ldr	r3, [r7, #12]
2400a552:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a556:	b2db      	uxtb	r3, r3
2400a558:	2b20      	cmp	r3, #32
2400a55a:	f040 8109 	bne.w	2400a770 <HAL_I2C_Slave_Transmit+0x230>
  {
    if ((pData == NULL) || (Size == 0U))
2400a55e:	68bb      	ldr	r3, [r7, #8]
2400a560:	2b00      	cmp	r3, #0
2400a562:	d002      	beq.n	2400a56a <HAL_I2C_Slave_Transmit+0x2a>
2400a564:	88fb      	ldrh	r3, [r7, #6]
2400a566:	2b00      	cmp	r3, #0
2400a568:	d105      	bne.n	2400a576 <HAL_I2C_Slave_Transmit+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a56a:	68fb      	ldr	r3, [r7, #12]
2400a56c:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a570:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a572:	2301      	movs	r3, #1
2400a574:	e0fd      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a576:	68fb      	ldr	r3, [r7, #12]
2400a578:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a57c:	2b01      	cmp	r3, #1
2400a57e:	d101      	bne.n	2400a584 <HAL_I2C_Slave_Transmit+0x44>
2400a580:	2302      	movs	r3, #2
2400a582:	e0f6      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
2400a584:	68fb      	ldr	r3, [r7, #12]
2400a586:	2201      	movs	r2, #1
2400a588:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a58c:	f7f7 feda 	bl	24002344 <HAL_GetTick>
2400a590:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400a592:	68fb      	ldr	r3, [r7, #12]
2400a594:	2221      	movs	r2, #33	; 0x21
2400a596:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400a59a:	68fb      	ldr	r3, [r7, #12]
2400a59c:	2220      	movs	r2, #32
2400a59e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a5a2:	68fb      	ldr	r3, [r7, #12]
2400a5a4:	2200      	movs	r2, #0
2400a5a6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a5a8:	68fb      	ldr	r3, [r7, #12]
2400a5aa:	68ba      	ldr	r2, [r7, #8]
2400a5ac:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a5ae:	68fb      	ldr	r3, [r7, #12]
2400a5b0:	88fa      	ldrh	r2, [r7, #6]
2400a5b2:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400a5b4:	68fb      	ldr	r3, [r7, #12]
2400a5b6:	2200      	movs	r2, #0
2400a5b8:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a5ba:	68fb      	ldr	r3, [r7, #12]
2400a5bc:	681b      	ldr	r3, [r3, #0]
2400a5be:	685a      	ldr	r2, [r3, #4]
2400a5c0:	68fb      	ldr	r3, [r7, #12]
2400a5c2:	681b      	ldr	r3, [r3, #0]
2400a5c4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a5c8:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400a5ca:	697b      	ldr	r3, [r7, #20]
2400a5cc:	9300      	str	r3, [sp, #0]
2400a5ce:	683b      	ldr	r3, [r7, #0]
2400a5d0:	2200      	movs	r2, #0
2400a5d2:	2108      	movs	r1, #8
2400a5d4:	68f8      	ldr	r0, [r7, #12]
2400a5d6:	f004 faf5 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a5da:	4603      	mov	r3, r0
2400a5dc:	2b00      	cmp	r3, #0
2400a5de:	d009      	beq.n	2400a5f4 <HAL_I2C_Slave_Transmit+0xb4>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a5e0:	68fb      	ldr	r3, [r7, #12]
2400a5e2:	681b      	ldr	r3, [r3, #0]
2400a5e4:	685a      	ldr	r2, [r3, #4]
2400a5e6:	68fb      	ldr	r3, [r7, #12]
2400a5e8:	681b      	ldr	r3, [r3, #0]
2400a5ea:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a5ee:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a5f0:	2301      	movs	r3, #1
2400a5f2:	e0be      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400a5f4:	68fb      	ldr	r3, [r7, #12]
2400a5f6:	681b      	ldr	r3, [r3, #0]
2400a5f8:	2208      	movs	r2, #8
2400a5fa:	61da      	str	r2, [r3, #28]

    /* If 10bit addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400a5fc:	68fb      	ldr	r3, [r7, #12]
2400a5fe:	68db      	ldr	r3, [r3, #12]
2400a600:	2b02      	cmp	r3, #2
2400a602:	d118      	bne.n	2400a636 <HAL_I2C_Slave_Transmit+0xf6>
    {
      /* Wait until ADDR flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400a604:	697b      	ldr	r3, [r7, #20]
2400a606:	9300      	str	r3, [sp, #0]
2400a608:	683b      	ldr	r3, [r7, #0]
2400a60a:	2200      	movs	r2, #0
2400a60c:	2108      	movs	r1, #8
2400a60e:	68f8      	ldr	r0, [r7, #12]
2400a610:	f004 fad8 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a614:	4603      	mov	r3, r0
2400a616:	2b00      	cmp	r3, #0
2400a618:	d009      	beq.n	2400a62e <HAL_I2C_Slave_Transmit+0xee>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a61a:	68fb      	ldr	r3, [r7, #12]
2400a61c:	681b      	ldr	r3, [r3, #0]
2400a61e:	685a      	ldr	r2, [r3, #4]
2400a620:	68fb      	ldr	r3, [r7, #12]
2400a622:	681b      	ldr	r3, [r3, #0]
2400a624:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a628:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2400a62a:	2301      	movs	r3, #1
2400a62c:	e0a1      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
      }

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400a62e:	68fb      	ldr	r3, [r7, #12]
2400a630:	681b      	ldr	r3, [r3, #0]
2400a632:	2208      	movs	r2, #8
2400a634:	61da      	str	r2, [r3, #28]
    }

    /* Wait until DIR flag is set Transmitter mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout, tickstart) != HAL_OK)
2400a636:	697b      	ldr	r3, [r7, #20]
2400a638:	9300      	str	r3, [sp, #0]
2400a63a:	683b      	ldr	r3, [r7, #0]
2400a63c:	2200      	movs	r2, #0
2400a63e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2400a642:	68f8      	ldr	r0, [r7, #12]
2400a644:	f004 fabe 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a648:	4603      	mov	r3, r0
2400a64a:	2b00      	cmp	r3, #0
2400a64c:	d02d      	beq.n	2400a6aa <HAL_I2C_Slave_Transmit+0x16a>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a64e:	68fb      	ldr	r3, [r7, #12]
2400a650:	681b      	ldr	r3, [r3, #0]
2400a652:	685a      	ldr	r2, [r3, #4]
2400a654:	68fb      	ldr	r3, [r7, #12]
2400a656:	681b      	ldr	r3, [r3, #0]
2400a658:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a65c:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a65e:	2301      	movs	r3, #1
2400a660:	e087      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a662:	697a      	ldr	r2, [r7, #20]
2400a664:	6839      	ldr	r1, [r7, #0]
2400a666:	68f8      	ldr	r0, [r7, #12]
2400a668:	f004 faec 	bl	2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>
2400a66c:	4603      	mov	r3, r0
2400a66e:	2b00      	cmp	r3, #0
2400a670:	d009      	beq.n	2400a686 <HAL_I2C_Slave_Transmit+0x146>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a672:	68fb      	ldr	r3, [r7, #12]
2400a674:	681b      	ldr	r3, [r3, #0]
2400a676:	685a      	ldr	r2, [r3, #4]
2400a678:	68fb      	ldr	r3, [r7, #12]
2400a67a:	681b      	ldr	r3, [r3, #0]
2400a67c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a680:	605a      	str	r2, [r3, #4]
        return HAL_ERROR;
2400a682:	2301      	movs	r3, #1
2400a684:	e075      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400a686:	68fb      	ldr	r3, [r7, #12]
2400a688:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a68a:	781a      	ldrb	r2, [r3, #0]
2400a68c:	68fb      	ldr	r3, [r7, #12]
2400a68e:	681b      	ldr	r3, [r3, #0]
2400a690:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a692:	68fb      	ldr	r3, [r7, #12]
2400a694:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a696:	1c5a      	adds	r2, r3, #1
2400a698:	68fb      	ldr	r3, [r7, #12]
2400a69a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a69c:	68fb      	ldr	r3, [r7, #12]
2400a69e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a6a0:	b29b      	uxth	r3, r3
2400a6a2:	3b01      	subs	r3, #1
2400a6a4:	b29a      	uxth	r2, r3
2400a6a6:	68fb      	ldr	r3, [r7, #12]
2400a6a8:	855a      	strh	r2, [r3, #42]	; 0x2a
    while (hi2c->XferCount > 0U)
2400a6aa:	68fb      	ldr	r3, [r7, #12]
2400a6ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a6ae:	b29b      	uxth	r3, r3
2400a6b0:	2b00      	cmp	r3, #0
2400a6b2:	d1d6      	bne.n	2400a662 <HAL_I2C_Slave_Transmit+0x122>
    }

    /* Wait until AF flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
2400a6b4:	697b      	ldr	r3, [r7, #20]
2400a6b6:	9300      	str	r3, [sp, #0]
2400a6b8:	683b      	ldr	r3, [r7, #0]
2400a6ba:	2200      	movs	r2, #0
2400a6bc:	2110      	movs	r1, #16
2400a6be:	68f8      	ldr	r0, [r7, #12]
2400a6c0:	f004 fa80 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a6c4:	4603      	mov	r3, r0
2400a6c6:	2b00      	cmp	r3, #0
2400a6c8:	d009      	beq.n	2400a6de <HAL_I2C_Slave_Transmit+0x19e>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a6ca:	68fb      	ldr	r3, [r7, #12]
2400a6cc:	681b      	ldr	r3, [r3, #0]
2400a6ce:	685a      	ldr	r2, [r3, #4]
2400a6d0:	68fb      	ldr	r3, [r7, #12]
2400a6d2:	681b      	ldr	r3, [r3, #0]
2400a6d4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a6d8:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a6da:	2301      	movs	r3, #1
2400a6dc:	e049      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
    }

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400a6de:	68f8      	ldr	r0, [r7, #12]
2400a6e0:	f003 ff8b 	bl	2400e5fa <I2C_Flush_TXDR>

    /* Clear AF flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400a6e4:	68fb      	ldr	r3, [r7, #12]
2400a6e6:	681b      	ldr	r3, [r3, #0]
2400a6e8:	2210      	movs	r2, #16
2400a6ea:	61da      	str	r2, [r3, #28]

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a6ec:	697a      	ldr	r2, [r7, #20]
2400a6ee:	6839      	ldr	r1, [r7, #0]
2400a6f0:	68f8      	ldr	r0, [r7, #12]
2400a6f2:	f004 fae7 	bl	2400ecc4 <I2C_WaitOnSTOPFlagUntilTimeout>
2400a6f6:	4603      	mov	r3, r0
2400a6f8:	2b00      	cmp	r3, #0
2400a6fa:	d009      	beq.n	2400a710 <HAL_I2C_Slave_Transmit+0x1d0>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a6fc:	68fb      	ldr	r3, [r7, #12]
2400a6fe:	681b      	ldr	r3, [r3, #0]
2400a700:	685a      	ldr	r2, [r3, #4]
2400a702:	68fb      	ldr	r3, [r7, #12]
2400a704:	681b      	ldr	r3, [r3, #0]
2400a706:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a70a:	605a      	str	r2, [r3, #4]

      return HAL_ERROR;
2400a70c:	2301      	movs	r3, #1
2400a70e:	e030      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a710:	68fb      	ldr	r3, [r7, #12]
2400a712:	681b      	ldr	r3, [r3, #0]
2400a714:	2220      	movs	r2, #32
2400a716:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
2400a718:	697b      	ldr	r3, [r7, #20]
2400a71a:	9300      	str	r3, [sp, #0]
2400a71c:	683b      	ldr	r3, [r7, #0]
2400a71e:	2201      	movs	r2, #1
2400a720:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a724:	68f8      	ldr	r0, [r7, #12]
2400a726:	f004 fa4d 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a72a:	4603      	mov	r3, r0
2400a72c:	2b00      	cmp	r3, #0
2400a72e:	d009      	beq.n	2400a744 <HAL_I2C_Slave_Transmit+0x204>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a730:	68fb      	ldr	r3, [r7, #12]
2400a732:	681b      	ldr	r3, [r3, #0]
2400a734:	685a      	ldr	r2, [r3, #4]
2400a736:	68fb      	ldr	r3, [r7, #12]
2400a738:	681b      	ldr	r3, [r3, #0]
2400a73a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a73e:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a740:	2301      	movs	r3, #1
2400a742:	e016      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a744:	68fb      	ldr	r3, [r7, #12]
2400a746:	681b      	ldr	r3, [r3, #0]
2400a748:	685a      	ldr	r2, [r3, #4]
2400a74a:	68fb      	ldr	r3, [r7, #12]
2400a74c:	681b      	ldr	r3, [r3, #0]
2400a74e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a752:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a754:	68fb      	ldr	r3, [r7, #12]
2400a756:	2220      	movs	r2, #32
2400a758:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a75c:	68fb      	ldr	r3, [r7, #12]
2400a75e:	2200      	movs	r2, #0
2400a760:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a764:	68fb      	ldr	r3, [r7, #12]
2400a766:	2200      	movs	r2, #0
2400a768:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a76c:	2300      	movs	r3, #0
2400a76e:	e000      	b.n	2400a772 <HAL_I2C_Slave_Transmit+0x232>
  }
  else
  {
    return HAL_BUSY;
2400a770:	2302      	movs	r3, #2
  }
}
2400a772:	4618      	mov	r0, r3
2400a774:	3718      	adds	r7, #24
2400a776:	46bd      	mov	sp, r7
2400a778:	bd80      	pop	{r7, pc}

2400a77a <HAL_I2C_Slave_Receive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                        uint32_t Timeout)
{
2400a77a:	b580      	push	{r7, lr}
2400a77c:	b088      	sub	sp, #32
2400a77e:	af02      	add	r7, sp, #8
2400a780:	60f8      	str	r0, [r7, #12]
2400a782:	60b9      	str	r1, [r7, #8]
2400a784:	603b      	str	r3, [r7, #0]
2400a786:	4613      	mov	r3, r2
2400a788:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a78a:	68fb      	ldr	r3, [r7, #12]
2400a78c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a790:	b2db      	uxtb	r3, r3
2400a792:	2b20      	cmp	r3, #32
2400a794:	f040 80fc 	bne.w	2400a990 <HAL_I2C_Slave_Receive+0x216>
  {
    if ((pData == NULL) || (Size == 0U))
2400a798:	68bb      	ldr	r3, [r7, #8]
2400a79a:	2b00      	cmp	r3, #0
2400a79c:	d002      	beq.n	2400a7a4 <HAL_I2C_Slave_Receive+0x2a>
2400a79e:	88fb      	ldrh	r3, [r7, #6]
2400a7a0:	2b00      	cmp	r3, #0
2400a7a2:	d105      	bne.n	2400a7b0 <HAL_I2C_Slave_Receive+0x36>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400a7a4:	68fb      	ldr	r3, [r7, #12]
2400a7a6:	f44f 7200 	mov.w	r2, #512	; 0x200
2400a7aa:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400a7ac:	2301      	movs	r3, #1
2400a7ae:	e0f0      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a7b0:	68fb      	ldr	r3, [r7, #12]
2400a7b2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a7b6:	2b01      	cmp	r3, #1
2400a7b8:	d101      	bne.n	2400a7be <HAL_I2C_Slave_Receive+0x44>
2400a7ba:	2302      	movs	r3, #2
2400a7bc:	e0e9      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
2400a7be:	68fb      	ldr	r3, [r7, #12]
2400a7c0:	2201      	movs	r2, #1
2400a7c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400a7c6:	f7f7 fdbd 	bl	24002344 <HAL_GetTick>
2400a7ca:	6178      	str	r0, [r7, #20]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400a7cc:	68fb      	ldr	r3, [r7, #12]
2400a7ce:	2222      	movs	r2, #34	; 0x22
2400a7d0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400a7d4:	68fb      	ldr	r3, [r7, #12]
2400a7d6:	2220      	movs	r2, #32
2400a7d8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400a7dc:	68fb      	ldr	r3, [r7, #12]
2400a7de:	2200      	movs	r2, #0
2400a7e0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400a7e2:	68fb      	ldr	r3, [r7, #12]
2400a7e4:	68ba      	ldr	r2, [r7, #8]
2400a7e6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400a7e8:	68fb      	ldr	r3, [r7, #12]
2400a7ea:	88fa      	ldrh	r2, [r7, #6]
2400a7ec:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize = hi2c->XferCount;
2400a7ee:	68fb      	ldr	r3, [r7, #12]
2400a7f0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a7f2:	b29a      	uxth	r2, r3
2400a7f4:	68fb      	ldr	r3, [r7, #12]
2400a7f6:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferISR   = NULL;
2400a7f8:	68fb      	ldr	r3, [r7, #12]
2400a7fa:	2200      	movs	r2, #0
2400a7fc:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400a7fe:	68fb      	ldr	r3, [r7, #12]
2400a800:	681b      	ldr	r3, [r3, #0]
2400a802:	685a      	ldr	r2, [r3, #4]
2400a804:	68fb      	ldr	r3, [r7, #12]
2400a806:	681b      	ldr	r3, [r3, #0]
2400a808:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400a80c:	605a      	str	r2, [r3, #4]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
2400a80e:	697b      	ldr	r3, [r7, #20]
2400a810:	9300      	str	r3, [sp, #0]
2400a812:	683b      	ldr	r3, [r7, #0]
2400a814:	2200      	movs	r2, #0
2400a816:	2108      	movs	r1, #8
2400a818:	68f8      	ldr	r0, [r7, #12]
2400a81a:	f004 f9d3 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a81e:	4603      	mov	r3, r0
2400a820:	2b00      	cmp	r3, #0
2400a822:	d009      	beq.n	2400a838 <HAL_I2C_Slave_Receive+0xbe>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a824:	68fb      	ldr	r3, [r7, #12]
2400a826:	681b      	ldr	r3, [r3, #0]
2400a828:	685a      	ldr	r2, [r3, #4]
2400a82a:	68fb      	ldr	r3, [r7, #12]
2400a82c:	681b      	ldr	r3, [r3, #0]
2400a82e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a832:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a834:	2301      	movs	r3, #1
2400a836:	e0ac      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400a838:	68fb      	ldr	r3, [r7, #12]
2400a83a:	681b      	ldr	r3, [r3, #0]
2400a83c:	2208      	movs	r2, #8
2400a83e:	61da      	str	r2, [r3, #28]

    /* Wait until DIR flag is reset Receiver mode */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout, tickstart) != HAL_OK)
2400a840:	697b      	ldr	r3, [r7, #20]
2400a842:	9300      	str	r3, [sp, #0]
2400a844:	683b      	ldr	r3, [r7, #0]
2400a846:	2201      	movs	r2, #1
2400a848:	f44f 3180 	mov.w	r1, #65536	; 0x10000
2400a84c:	68f8      	ldr	r0, [r7, #12]
2400a84e:	f004 f9b9 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a852:	4603      	mov	r3, r0
2400a854:	2b00      	cmp	r3, #0
2400a856:	d054      	beq.n	2400a902 <HAL_I2C_Slave_Receive+0x188>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a858:	68fb      	ldr	r3, [r7, #12]
2400a85a:	681b      	ldr	r3, [r3, #0]
2400a85c:	685a      	ldr	r2, [r3, #4]
2400a85e:	68fb      	ldr	r3, [r7, #12]
2400a860:	681b      	ldr	r3, [r3, #0]
2400a862:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a866:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a868:	2301      	movs	r3, #1
2400a86a:	e092      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
    }

    while (hi2c->XferCount > 0U)
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a86c:	697a      	ldr	r2, [r7, #20]
2400a86e:	6839      	ldr	r1, [r7, #0]
2400a870:	68f8      	ldr	r0, [r7, #12]
2400a872:	f004 fa63 	bl	2400ed3c <I2C_WaitOnRXNEFlagUntilTimeout>
2400a876:	4603      	mov	r3, r0
2400a878:	2b00      	cmp	r3, #0
2400a87a:	d029      	beq.n	2400a8d0 <HAL_I2C_Slave_Receive+0x156>
      {
        /* Disable Address Acknowledge */
        hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a87c:	68fb      	ldr	r3, [r7, #12]
2400a87e:	681b      	ldr	r3, [r3, #0]
2400a880:	685a      	ldr	r2, [r3, #4]
2400a882:	68fb      	ldr	r3, [r7, #12]
2400a884:	681b      	ldr	r3, [r3, #0]
2400a886:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a88a:	605a      	str	r2, [r3, #4]

        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
2400a88c:	68fb      	ldr	r3, [r7, #12]
2400a88e:	681b      	ldr	r3, [r3, #0]
2400a890:	699b      	ldr	r3, [r3, #24]
2400a892:	f003 0304 	and.w	r3, r3, #4
2400a896:	2b04      	cmp	r3, #4
2400a898:	d118      	bne.n	2400a8cc <HAL_I2C_Slave_Receive+0x152>
        {
          /* Read data from RXDR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a89a:	68fb      	ldr	r3, [r7, #12]
2400a89c:	681b      	ldr	r3, [r3, #0]
2400a89e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a8a0:	68fb      	ldr	r3, [r7, #12]
2400a8a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a8a4:	b2d2      	uxtb	r2, r2
2400a8a6:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
2400a8a8:	68fb      	ldr	r3, [r7, #12]
2400a8aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a8ac:	1c5a      	adds	r2, r3, #1
2400a8ae:	68fb      	ldr	r3, [r7, #12]
2400a8b0:	625a      	str	r2, [r3, #36]	; 0x24

          hi2c->XferCount--;
2400a8b2:	68fb      	ldr	r3, [r7, #12]
2400a8b4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a8b6:	b29b      	uxth	r3, r3
2400a8b8:	3b01      	subs	r3, #1
2400a8ba:	b29a      	uxth	r2, r3
2400a8bc:	68fb      	ldr	r3, [r7, #12]
2400a8be:	855a      	strh	r2, [r3, #42]	; 0x2a
          hi2c->XferSize--;
2400a8c0:	68fb      	ldr	r3, [r7, #12]
2400a8c2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a8c4:	3b01      	subs	r3, #1
2400a8c6:	b29a      	uxth	r2, r3
2400a8c8:	68fb      	ldr	r3, [r7, #12]
2400a8ca:	851a      	strh	r2, [r3, #40]	; 0x28
        }

        return HAL_ERROR;
2400a8cc:	2301      	movs	r3, #1
2400a8ce:	e060      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400a8d0:	68fb      	ldr	r3, [r7, #12]
2400a8d2:	681b      	ldr	r3, [r3, #0]
2400a8d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400a8d6:	68fb      	ldr	r3, [r7, #12]
2400a8d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a8da:	b2d2      	uxtb	r2, r2
2400a8dc:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400a8de:	68fb      	ldr	r3, [r7, #12]
2400a8e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400a8e2:	1c5a      	adds	r2, r3, #1
2400a8e4:	68fb      	ldr	r3, [r7, #12]
2400a8e6:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400a8e8:	68fb      	ldr	r3, [r7, #12]
2400a8ea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a8ec:	b29b      	uxth	r3, r3
2400a8ee:	3b01      	subs	r3, #1
2400a8f0:	b29a      	uxth	r2, r3
2400a8f2:	68fb      	ldr	r3, [r7, #12]
2400a8f4:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400a8f6:	68fb      	ldr	r3, [r7, #12]
2400a8f8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400a8fa:	3b01      	subs	r3, #1
2400a8fc:	b29a      	uxth	r2, r3
2400a8fe:	68fb      	ldr	r3, [r7, #12]
2400a900:	851a      	strh	r2, [r3, #40]	; 0x28
    while (hi2c->XferCount > 0U)
2400a902:	68fb      	ldr	r3, [r7, #12]
2400a904:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400a906:	b29b      	uxth	r3, r3
2400a908:	2b00      	cmp	r3, #0
2400a90a:	d1af      	bne.n	2400a86c <HAL_I2C_Slave_Receive+0xf2>
    }

    /* Wait until STOP flag is set */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400a90c:	697a      	ldr	r2, [r7, #20]
2400a90e:	6839      	ldr	r1, [r7, #0]
2400a910:	68f8      	ldr	r0, [r7, #12]
2400a912:	f004 f9d7 	bl	2400ecc4 <I2C_WaitOnSTOPFlagUntilTimeout>
2400a916:	4603      	mov	r3, r0
2400a918:	2b00      	cmp	r3, #0
2400a91a:	d009      	beq.n	2400a930 <HAL_I2C_Slave_Receive+0x1b6>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a91c:	68fb      	ldr	r3, [r7, #12]
2400a91e:	681b      	ldr	r3, [r3, #0]
2400a920:	685a      	ldr	r2, [r3, #4]
2400a922:	68fb      	ldr	r3, [r7, #12]
2400a924:	681b      	ldr	r3, [r3, #0]
2400a926:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a92a:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a92c:	2301      	movs	r3, #1
2400a92e:	e030      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
    }

    /* Clear STOP flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400a930:	68fb      	ldr	r3, [r7, #12]
2400a932:	681b      	ldr	r3, [r3, #0]
2400a934:	2220      	movs	r2, #32
2400a936:	61da      	str	r2, [r3, #28]

    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout, tickstart) != HAL_OK)
2400a938:	697b      	ldr	r3, [r7, #20]
2400a93a:	9300      	str	r3, [sp, #0]
2400a93c:	683b      	ldr	r3, [r7, #0]
2400a93e:	2201      	movs	r2, #1
2400a940:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400a944:	68f8      	ldr	r0, [r7, #12]
2400a946:	f004 f93d 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400a94a:	4603      	mov	r3, r0
2400a94c:	2b00      	cmp	r3, #0
2400a94e:	d009      	beq.n	2400a964 <HAL_I2C_Slave_Receive+0x1ea>
    {
      /* Disable Address Acknowledge */
      hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a950:	68fb      	ldr	r3, [r7, #12]
2400a952:	681b      	ldr	r3, [r3, #0]
2400a954:	685a      	ldr	r2, [r3, #4]
2400a956:	68fb      	ldr	r3, [r7, #12]
2400a958:	681b      	ldr	r3, [r3, #0]
2400a95a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a95e:	605a      	str	r2, [r3, #4]
      return HAL_ERROR;
2400a960:	2301      	movs	r3, #1
2400a962:	e016      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
    }

    /* Disable Address Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400a964:	68fb      	ldr	r3, [r7, #12]
2400a966:	681b      	ldr	r3, [r3, #0]
2400a968:	685a      	ldr	r2, [r3, #4]
2400a96a:	68fb      	ldr	r3, [r7, #12]
2400a96c:	681b      	ldr	r3, [r3, #0]
2400a96e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400a972:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400a974:	68fb      	ldr	r3, [r7, #12]
2400a976:	2220      	movs	r2, #32
2400a978:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400a97c:	68fb      	ldr	r3, [r7, #12]
2400a97e:	2200      	movs	r2, #0
2400a980:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400a984:	68fb      	ldr	r3, [r7, #12]
2400a986:	2200      	movs	r2, #0
2400a988:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400a98c:	2300      	movs	r3, #0
2400a98e:	e000      	b.n	2400a992 <HAL_I2C_Slave_Receive+0x218>
  }
  else
  {
    return HAL_BUSY;
2400a990:	2302      	movs	r3, #2
  }
}
2400a992:	4618      	mov	r0, r3
2400a994:	3718      	adds	r7, #24
2400a996:	46bd      	mov	sp, r7
2400a998:	bd80      	pop	{r7, pc}
	...

2400a99c <HAL_I2C_Master_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                             uint16_t Size)
{
2400a99c:	b580      	push	{r7, lr}
2400a99e:	b088      	sub	sp, #32
2400a9a0:	af02      	add	r7, sp, #8
2400a9a2:	60f8      	str	r0, [r7, #12]
2400a9a4:	607a      	str	r2, [r7, #4]
2400a9a6:	461a      	mov	r2, r3
2400a9a8:	460b      	mov	r3, r1
2400a9aa:	817b      	strh	r3, [r7, #10]
2400a9ac:	4613      	mov	r3, r2
2400a9ae:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400a9b0:	68fb      	ldr	r3, [r7, #12]
2400a9b2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400a9b6:	b2db      	uxtb	r3, r3
2400a9b8:	2b20      	cmp	r3, #32
2400a9ba:	d153      	bne.n	2400aa64 <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400a9bc:	68fb      	ldr	r3, [r7, #12]
2400a9be:	681b      	ldr	r3, [r3, #0]
2400a9c0:	699b      	ldr	r3, [r3, #24]
2400a9c2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400a9c6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400a9ca:	d101      	bne.n	2400a9d0 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
2400a9cc:	2302      	movs	r3, #2
2400a9ce:	e04a      	b.n	2400aa66 <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400a9d0:	68fb      	ldr	r3, [r7, #12]
2400a9d2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400a9d6:	2b01      	cmp	r3, #1
2400a9d8:	d101      	bne.n	2400a9de <HAL_I2C_Master_Transmit_IT+0x42>
2400a9da:	2302      	movs	r3, #2
2400a9dc:	e043      	b.n	2400aa66 <HAL_I2C_Master_Transmit_IT+0xca>
2400a9de:	68fb      	ldr	r3, [r7, #12]
2400a9e0:	2201      	movs	r2, #1
2400a9e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400a9e6:	68fb      	ldr	r3, [r7, #12]
2400a9e8:	2221      	movs	r2, #33	; 0x21
2400a9ea:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400a9ee:	68fb      	ldr	r3, [r7, #12]
2400a9f0:	2210      	movs	r2, #16
2400a9f2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400a9f6:	68fb      	ldr	r3, [r7, #12]
2400a9f8:	2200      	movs	r2, #0
2400a9fa:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400a9fc:	68fb      	ldr	r3, [r7, #12]
2400a9fe:	687a      	ldr	r2, [r7, #4]
2400aa00:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400aa02:	68fb      	ldr	r3, [r7, #12]
2400aa04:	893a      	ldrh	r2, [r7, #8]
2400aa06:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400aa08:	68fb      	ldr	r3, [r7, #12]
2400aa0a:	4a19      	ldr	r2, [pc, #100]	; (2400aa70 <HAL_I2C_Master_Transmit_IT+0xd4>)
2400aa0c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400aa0e:	68fb      	ldr	r3, [r7, #12]
2400aa10:	4a18      	ldr	r2, [pc, #96]	; (2400aa74 <HAL_I2C_Master_Transmit_IT+0xd8>)
2400aa12:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400aa14:	68fb      	ldr	r3, [r7, #12]
2400aa16:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa18:	b29b      	uxth	r3, r3
2400aa1a:	2bff      	cmp	r3, #255	; 0xff
2400aa1c:	d906      	bls.n	2400aa2c <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400aa1e:	68fb      	ldr	r3, [r7, #12]
2400aa20:	22ff      	movs	r2, #255	; 0xff
2400aa22:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400aa24:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400aa28:	617b      	str	r3, [r7, #20]
2400aa2a:	e007      	b.n	2400aa3c <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400aa2c:	68fb      	ldr	r3, [r7, #12]
2400aa2e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aa30:	b29a      	uxth	r2, r3
2400aa32:	68fb      	ldr	r3, [r7, #12]
2400aa34:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400aa36:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400aa3a:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
2400aa3c:	68fb      	ldr	r3, [r7, #12]
2400aa3e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400aa40:	b2da      	uxtb	r2, r3
2400aa42:	8979      	ldrh	r1, [r7, #10]
2400aa44:	4b0c      	ldr	r3, [pc, #48]	; (2400aa78 <HAL_I2C_Master_Transmit_IT+0xdc>)
2400aa46:	9300      	str	r3, [sp, #0]
2400aa48:	697b      	ldr	r3, [r7, #20]
2400aa4a:	68f8      	ldr	r0, [r7, #12]
2400aa4c:	f004 fadc 	bl	2400f008 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400aa50:	68fb      	ldr	r3, [r7, #12]
2400aa52:	2200      	movs	r2, #0
2400aa54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400aa58:	2101      	movs	r1, #1
2400aa5a:	68f8      	ldr	r0, [r7, #12]
2400aa5c:	f004 fb06 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400aa60:	2300      	movs	r3, #0
2400aa62:	e000      	b.n	2400aa66 <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2400aa64:	2302      	movs	r3, #2
  }
}
2400aa66:	4618      	mov	r0, r3
2400aa68:	3718      	adds	r7, #24
2400aa6a:	46bd      	mov	sp, r7
2400aa6c:	bd80      	pop	{r7, pc}
2400aa6e:	bf00      	nop
2400aa70:	ffff0000 	.word	0xffff0000
2400aa74:	2400d0af 	.word	0x2400d0af
2400aa78:	80002000 	.word	0x80002000

2400aa7c <HAL_I2C_Master_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                            uint16_t Size)
{
2400aa7c:	b580      	push	{r7, lr}
2400aa7e:	b088      	sub	sp, #32
2400aa80:	af02      	add	r7, sp, #8
2400aa82:	60f8      	str	r0, [r7, #12]
2400aa84:	607a      	str	r2, [r7, #4]
2400aa86:	461a      	mov	r2, r3
2400aa88:	460b      	mov	r3, r1
2400aa8a:	817b      	strh	r3, [r7, #10]
2400aa8c:	4613      	mov	r3, r2
2400aa8e:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400aa90:	68fb      	ldr	r3, [r7, #12]
2400aa92:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400aa96:	b2db      	uxtb	r3, r3
2400aa98:	2b20      	cmp	r3, #32
2400aa9a:	d153      	bne.n	2400ab44 <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400aa9c:	68fb      	ldr	r3, [r7, #12]
2400aa9e:	681b      	ldr	r3, [r3, #0]
2400aaa0:	699b      	ldr	r3, [r3, #24]
2400aaa2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400aaa6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400aaaa:	d101      	bne.n	2400aab0 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
2400aaac:	2302      	movs	r3, #2
2400aaae:	e04a      	b.n	2400ab46 <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400aab0:	68fb      	ldr	r3, [r7, #12]
2400aab2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400aab6:	2b01      	cmp	r3, #1
2400aab8:	d101      	bne.n	2400aabe <HAL_I2C_Master_Receive_IT+0x42>
2400aaba:	2302      	movs	r3, #2
2400aabc:	e043      	b.n	2400ab46 <HAL_I2C_Master_Receive_IT+0xca>
2400aabe:	68fb      	ldr	r3, [r7, #12]
2400aac0:	2201      	movs	r2, #1
2400aac2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400aac6:	68fb      	ldr	r3, [r7, #12]
2400aac8:	2222      	movs	r2, #34	; 0x22
2400aaca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400aace:	68fb      	ldr	r3, [r7, #12]
2400aad0:	2210      	movs	r2, #16
2400aad2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400aad6:	68fb      	ldr	r3, [r7, #12]
2400aad8:	2200      	movs	r2, #0
2400aada:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400aadc:	68fb      	ldr	r3, [r7, #12]
2400aade:	687a      	ldr	r2, [r7, #4]
2400aae0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400aae2:	68fb      	ldr	r3, [r7, #12]
2400aae4:	893a      	ldrh	r2, [r7, #8]
2400aae6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400aae8:	68fb      	ldr	r3, [r7, #12]
2400aaea:	4a19      	ldr	r2, [pc, #100]	; (2400ab50 <HAL_I2C_Master_Receive_IT+0xd4>)
2400aaec:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400aaee:	68fb      	ldr	r3, [r7, #12]
2400aaf0:	4a18      	ldr	r2, [pc, #96]	; (2400ab54 <HAL_I2C_Master_Receive_IT+0xd8>)
2400aaf2:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400aaf4:	68fb      	ldr	r3, [r7, #12]
2400aaf6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aaf8:	b29b      	uxth	r3, r3
2400aafa:	2bff      	cmp	r3, #255	; 0xff
2400aafc:	d906      	bls.n	2400ab0c <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400aafe:	68fb      	ldr	r3, [r7, #12]
2400ab00:	22ff      	movs	r2, #255	; 0xff
2400ab02:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400ab04:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400ab08:	617b      	str	r3, [r7, #20]
2400ab0a:	e007      	b.n	2400ab1c <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400ab0c:	68fb      	ldr	r3, [r7, #12]
2400ab0e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ab10:	b29a      	uxth	r2, r3
2400ab12:	68fb      	ldr	r3, [r7, #12]
2400ab14:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400ab16:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400ab1a:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400ab1c:	68fb      	ldr	r3, [r7, #12]
2400ab1e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ab20:	b2da      	uxtb	r2, r3
2400ab22:	8979      	ldrh	r1, [r7, #10]
2400ab24:	4b0c      	ldr	r3, [pc, #48]	; (2400ab58 <HAL_I2C_Master_Receive_IT+0xdc>)
2400ab26:	9300      	str	r3, [sp, #0]
2400ab28:	697b      	ldr	r3, [r7, #20]
2400ab2a:	68f8      	ldr	r0, [r7, #12]
2400ab2c:	f004 fa6c 	bl	2400f008 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400ab30:	68fb      	ldr	r3, [r7, #12]
2400ab32:	2200      	movs	r2, #0
2400ab34:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400ab38:	2102      	movs	r1, #2
2400ab3a:	68f8      	ldr	r0, [r7, #12]
2400ab3c:	f004 fa96 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400ab40:	2300      	movs	r3, #0
2400ab42:	e000      	b.n	2400ab46 <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
2400ab44:	2302      	movs	r3, #2
  }
}
2400ab46:	4618      	mov	r0, r3
2400ab48:	3718      	adds	r7, #24
2400ab4a:	46bd      	mov	sp, r7
2400ab4c:	bd80      	pop	{r7, pc}
2400ab4e:	bf00      	nop
2400ab50:	ffff0000 	.word	0xffff0000
2400ab54:	2400d0af 	.word	0x2400d0af
2400ab58:	80002400 	.word	0x80002400

2400ab5c <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400ab5c:	b580      	push	{r7, lr}
2400ab5e:	b084      	sub	sp, #16
2400ab60:	af00      	add	r7, sp, #0
2400ab62:	60f8      	str	r0, [r7, #12]
2400ab64:	60b9      	str	r1, [r7, #8]
2400ab66:	4613      	mov	r3, r2
2400ab68:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400ab6a:	68fb      	ldr	r3, [r7, #12]
2400ab6c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ab70:	b2db      	uxtb	r3, r3
2400ab72:	2b20      	cmp	r3, #32
2400ab74:	d139      	bne.n	2400abea <HAL_I2C_Slave_Transmit_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400ab76:	68fb      	ldr	r3, [r7, #12]
2400ab78:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400ab7c:	2b01      	cmp	r3, #1
2400ab7e:	d101      	bne.n	2400ab84 <HAL_I2C_Slave_Transmit_IT+0x28>
2400ab80:	2302      	movs	r3, #2
2400ab82:	e033      	b.n	2400abec <HAL_I2C_Slave_Transmit_IT+0x90>
2400ab84:	68fb      	ldr	r3, [r7, #12]
2400ab86:	2201      	movs	r2, #1
2400ab88:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400ab8c:	68fb      	ldr	r3, [r7, #12]
2400ab8e:	2221      	movs	r2, #33	; 0x21
2400ab90:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400ab94:	68fb      	ldr	r3, [r7, #12]
2400ab96:	2220      	movs	r2, #32
2400ab98:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400ab9c:	68fb      	ldr	r3, [r7, #12]
2400ab9e:	2200      	movs	r2, #0
2400aba0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400aba2:	68fb      	ldr	r3, [r7, #12]
2400aba4:	681b      	ldr	r3, [r3, #0]
2400aba6:	685a      	ldr	r2, [r3, #4]
2400aba8:	68fb      	ldr	r3, [r7, #12]
2400abaa:	681b      	ldr	r3, [r3, #0]
2400abac:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400abb0:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400abb2:	68fb      	ldr	r3, [r7, #12]
2400abb4:	68ba      	ldr	r2, [r7, #8]
2400abb6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400abb8:	68fb      	ldr	r3, [r7, #12]
2400abba:	88fa      	ldrh	r2, [r7, #6]
2400abbc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400abbe:	68fb      	ldr	r3, [r7, #12]
2400abc0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400abc2:	b29a      	uxth	r2, r3
2400abc4:	68fb      	ldr	r3, [r7, #12]
2400abc6:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400abc8:	68fb      	ldr	r3, [r7, #12]
2400abca:	4a0a      	ldr	r2, [pc, #40]	; (2400abf4 <HAL_I2C_Slave_Transmit_IT+0x98>)
2400abcc:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400abce:	68fb      	ldr	r3, [r7, #12]
2400abd0:	4a09      	ldr	r2, [pc, #36]	; (2400abf8 <HAL_I2C_Slave_Transmit_IT+0x9c>)
2400abd2:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400abd4:	68fb      	ldr	r3, [r7, #12]
2400abd6:	2200      	movs	r2, #0
2400abd8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400abdc:	f248 0101 	movw	r1, #32769	; 0x8001
2400abe0:	68f8      	ldr	r0, [r7, #12]
2400abe2:	f004 fa43 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400abe6:	2300      	movs	r3, #0
2400abe8:	e000      	b.n	2400abec <HAL_I2C_Slave_Transmit_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
2400abea:	2302      	movs	r3, #2
  }
}
2400abec:	4618      	mov	r0, r3
2400abee:	3710      	adds	r7, #16
2400abf0:	46bd      	mov	sp, r7
2400abf2:	bd80      	pop	{r7, pc}
2400abf4:	ffff0000 	.word	0xffff0000
2400abf8:	2400d2e7 	.word	0x2400d2e7

2400abfc <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400abfc:	b580      	push	{r7, lr}
2400abfe:	b084      	sub	sp, #16
2400ac00:	af00      	add	r7, sp, #0
2400ac02:	60f8      	str	r0, [r7, #12]
2400ac04:	60b9      	str	r1, [r7, #8]
2400ac06:	4613      	mov	r3, r2
2400ac08:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400ac0a:	68fb      	ldr	r3, [r7, #12]
2400ac0c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ac10:	b2db      	uxtb	r3, r3
2400ac12:	2b20      	cmp	r3, #32
2400ac14:	d139      	bne.n	2400ac8a <HAL_I2C_Slave_Receive_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400ac16:	68fb      	ldr	r3, [r7, #12]
2400ac18:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400ac1c:	2b01      	cmp	r3, #1
2400ac1e:	d101      	bne.n	2400ac24 <HAL_I2C_Slave_Receive_IT+0x28>
2400ac20:	2302      	movs	r3, #2
2400ac22:	e033      	b.n	2400ac8c <HAL_I2C_Slave_Receive_IT+0x90>
2400ac24:	68fb      	ldr	r3, [r7, #12]
2400ac26:	2201      	movs	r2, #1
2400ac28:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400ac2c:	68fb      	ldr	r3, [r7, #12]
2400ac2e:	2222      	movs	r2, #34	; 0x22
2400ac30:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400ac34:	68fb      	ldr	r3, [r7, #12]
2400ac36:	2220      	movs	r2, #32
2400ac38:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400ac3c:	68fb      	ldr	r3, [r7, #12]
2400ac3e:	2200      	movs	r2, #0
2400ac40:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400ac42:	68fb      	ldr	r3, [r7, #12]
2400ac44:	681b      	ldr	r3, [r3, #0]
2400ac46:	685a      	ldr	r2, [r3, #4]
2400ac48:	68fb      	ldr	r3, [r7, #12]
2400ac4a:	681b      	ldr	r3, [r3, #0]
2400ac4c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400ac50:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ac52:	68fb      	ldr	r3, [r7, #12]
2400ac54:	68ba      	ldr	r2, [r7, #8]
2400ac56:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ac58:	68fb      	ldr	r3, [r7, #12]
2400ac5a:	88fa      	ldrh	r2, [r7, #6]
2400ac5c:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400ac5e:	68fb      	ldr	r3, [r7, #12]
2400ac60:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ac62:	b29a      	uxth	r2, r3
2400ac64:	68fb      	ldr	r3, [r7, #12]
2400ac66:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400ac68:	68fb      	ldr	r3, [r7, #12]
2400ac6a:	4a0a      	ldr	r2, [pc, #40]	; (2400ac94 <HAL_I2C_Slave_Receive_IT+0x98>)
2400ac6c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400ac6e:	68fb      	ldr	r3, [r7, #12]
2400ac70:	4a09      	ldr	r2, [pc, #36]	; (2400ac98 <HAL_I2C_Slave_Receive_IT+0x9c>)
2400ac72:	635a      	str	r2, [r3, #52]	; 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400ac74:	68fb      	ldr	r3, [r7, #12]
2400ac76:	2200      	movs	r2, #0
2400ac78:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400ac7c:	f248 0102 	movw	r1, #32770	; 0x8002
2400ac80:	68f8      	ldr	r0, [r7, #12]
2400ac82:	f004 f9f3 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400ac86:	2300      	movs	r3, #0
2400ac88:	e000      	b.n	2400ac8c <HAL_I2C_Slave_Receive_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
2400ac8a:	2302      	movs	r3, #2
  }
}
2400ac8c:	4618      	mov	r0, r3
2400ac8e:	3710      	adds	r7, #16
2400ac90:	46bd      	mov	sp, r7
2400ac92:	bd80      	pop	{r7, pc}
2400ac94:	ffff0000 	.word	0xffff0000
2400ac98:	2400d2e7 	.word	0x2400d2e7

2400ac9c <HAL_I2C_Master_Transmit_DMA>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                              uint16_t Size)
{
2400ac9c:	b580      	push	{r7, lr}
2400ac9e:	b088      	sub	sp, #32
2400aca0:	af02      	add	r7, sp, #8
2400aca2:	60f8      	str	r0, [r7, #12]
2400aca4:	607a      	str	r2, [r7, #4]
2400aca6:	461a      	mov	r2, r3
2400aca8:	460b      	mov	r3, r1
2400acaa:	817b      	strh	r3, [r7, #10]
2400acac:	4613      	mov	r3, r2
2400acae:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400acb0:	68fb      	ldr	r3, [r7, #12]
2400acb2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400acb6:	b2db      	uxtb	r3, r3
2400acb8:	2b20      	cmp	r3, #32
2400acba:	f040 80cd 	bne.w	2400ae58 <HAL_I2C_Master_Transmit_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400acbe:	68fb      	ldr	r3, [r7, #12]
2400acc0:	681b      	ldr	r3, [r3, #0]
2400acc2:	699b      	ldr	r3, [r3, #24]
2400acc4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400acc8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400accc:	d101      	bne.n	2400acd2 <HAL_I2C_Master_Transmit_DMA+0x36>
    {
      return HAL_BUSY;
2400acce:	2302      	movs	r3, #2
2400acd0:	e0c3      	b.n	2400ae5a <HAL_I2C_Master_Transmit_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400acd2:	68fb      	ldr	r3, [r7, #12]
2400acd4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400acd8:	2b01      	cmp	r3, #1
2400acda:	d101      	bne.n	2400ace0 <HAL_I2C_Master_Transmit_DMA+0x44>
2400acdc:	2302      	movs	r3, #2
2400acde:	e0bc      	b.n	2400ae5a <HAL_I2C_Master_Transmit_DMA+0x1be>
2400ace0:	68fb      	ldr	r3, [r7, #12]
2400ace2:	2201      	movs	r2, #1
2400ace4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400ace8:	68fb      	ldr	r3, [r7, #12]
2400acea:	2221      	movs	r2, #33	; 0x21
2400acec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400acf0:	68fb      	ldr	r3, [r7, #12]
2400acf2:	2210      	movs	r2, #16
2400acf4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400acf8:	68fb      	ldr	r3, [r7, #12]
2400acfa:	2200      	movs	r2, #0
2400acfc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400acfe:	68fb      	ldr	r3, [r7, #12]
2400ad00:	687a      	ldr	r2, [r7, #4]
2400ad02:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ad04:	68fb      	ldr	r3, [r7, #12]
2400ad06:	893a      	ldrh	r2, [r7, #8]
2400ad08:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400ad0a:	68fb      	ldr	r3, [r7, #12]
2400ad0c:	4a55      	ldr	r2, [pc, #340]	; (2400ae64 <HAL_I2C_Master_Transmit_DMA+0x1c8>)
2400ad0e:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400ad10:	68fb      	ldr	r3, [r7, #12]
2400ad12:	4a55      	ldr	r2, [pc, #340]	; (2400ae68 <HAL_I2C_Master_Transmit_DMA+0x1cc>)
2400ad14:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400ad16:	68fb      	ldr	r3, [r7, #12]
2400ad18:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ad1a:	b29b      	uxth	r3, r3
2400ad1c:	2bff      	cmp	r3, #255	; 0xff
2400ad1e:	d906      	bls.n	2400ad2e <HAL_I2C_Master_Transmit_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400ad20:	68fb      	ldr	r3, [r7, #12]
2400ad22:	22ff      	movs	r2, #255	; 0xff
2400ad24:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400ad26:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400ad2a:	617b      	str	r3, [r7, #20]
2400ad2c:	e007      	b.n	2400ad3e <HAL_I2C_Master_Transmit_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400ad2e:	68fb      	ldr	r3, [r7, #12]
2400ad30:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ad32:	b29a      	uxth	r2, r3
2400ad34:	68fb      	ldr	r3, [r7, #12]
2400ad36:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400ad38:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400ad3c:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
2400ad3e:	68fb      	ldr	r3, [r7, #12]
2400ad40:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ad42:	2b00      	cmp	r3, #0
2400ad44:	d070      	beq.n	2400ae28 <HAL_I2C_Master_Transmit_DMA+0x18c>
    {
      if (hi2c->hdmatx != NULL)
2400ad46:	68fb      	ldr	r3, [r7, #12]
2400ad48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ad4a:	2b00      	cmp	r3, #0
2400ad4c:	d020      	beq.n	2400ad90 <HAL_I2C_Master_Transmit_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400ad4e:	68fb      	ldr	r3, [r7, #12]
2400ad50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ad52:	4a46      	ldr	r2, [pc, #280]	; (2400ae6c <HAL_I2C_Master_Transmit_DMA+0x1d0>)
2400ad54:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400ad56:	68fb      	ldr	r3, [r7, #12]
2400ad58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ad5a:	4a45      	ldr	r2, [pc, #276]	; (2400ae70 <HAL_I2C_Master_Transmit_DMA+0x1d4>)
2400ad5c:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400ad5e:	68fb      	ldr	r3, [r7, #12]
2400ad60:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ad62:	2200      	movs	r2, #0
2400ad64:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2400ad66:	68fb      	ldr	r3, [r7, #12]
2400ad68:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ad6a:	2200      	movs	r2, #0
2400ad6c:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400ad6e:	68fb      	ldr	r3, [r7, #12]
2400ad70:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400ad72:	6879      	ldr	r1, [r7, #4]
2400ad74:	68fb      	ldr	r3, [r7, #12]
2400ad76:	681b      	ldr	r3, [r3, #0]
2400ad78:	3328      	adds	r3, #40	; 0x28
2400ad7a:	461a      	mov	r2, r3
                                         hi2c->XferSize);
2400ad7c:	68fb      	ldr	r3, [r7, #12]
2400ad7e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400ad80:	f7f9 f87a 	bl	24003e78 <HAL_DMA_Start_IT>
2400ad84:	4603      	mov	r3, r0
2400ad86:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400ad88:	7cfb      	ldrb	r3, [r7, #19]
2400ad8a:	2b00      	cmp	r3, #0
2400ad8c:	d138      	bne.n	2400ae00 <HAL_I2C_Master_Transmit_DMA+0x164>
2400ad8e:	e013      	b.n	2400adb8 <HAL_I2C_Master_Transmit_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
2400ad90:	68fb      	ldr	r3, [r7, #12]
2400ad92:	2220      	movs	r2, #32
2400ad94:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ad98:	68fb      	ldr	r3, [r7, #12]
2400ad9a:	2200      	movs	r2, #0
2400ad9c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400ada0:	68fb      	ldr	r3, [r7, #12]
2400ada2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ada4:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400ada8:	68fb      	ldr	r3, [r7, #12]
2400adaa:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400adac:	68fb      	ldr	r3, [r7, #12]
2400adae:	2200      	movs	r2, #0
2400adb0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400adb4:	2301      	movs	r3, #1
2400adb6:	e050      	b.n	2400ae5a <HAL_I2C_Master_Transmit_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
2400adb8:	68fb      	ldr	r3, [r7, #12]
2400adba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400adbc:	b2da      	uxtb	r2, r3
2400adbe:	8979      	ldrh	r1, [r7, #10]
2400adc0:	4b2c      	ldr	r3, [pc, #176]	; (2400ae74 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
2400adc2:	9300      	str	r3, [sp, #0]
2400adc4:	697b      	ldr	r3, [r7, #20]
2400adc6:	68f8      	ldr	r0, [r7, #12]
2400adc8:	f004 f91e 	bl	2400f008 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400adcc:	68fb      	ldr	r3, [r7, #12]
2400adce:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400add0:	b29a      	uxth	r2, r3
2400add2:	68fb      	ldr	r3, [r7, #12]
2400add4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400add6:	1ad3      	subs	r3, r2, r3
2400add8:	b29a      	uxth	r2, r3
2400adda:	68fb      	ldr	r3, [r7, #12]
2400addc:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400adde:	68fb      	ldr	r3, [r7, #12]
2400ade0:	2200      	movs	r2, #0
2400ade2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400ade6:	2110      	movs	r1, #16
2400ade8:	68f8      	ldr	r0, [r7, #12]
2400adea:	f004 f93f 	bl	2400f06c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400adee:	68fb      	ldr	r3, [r7, #12]
2400adf0:	681b      	ldr	r3, [r3, #0]
2400adf2:	681a      	ldr	r2, [r3, #0]
2400adf4:	68fb      	ldr	r3, [r7, #12]
2400adf6:	681b      	ldr	r3, [r3, #0]
2400adf8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400adfc:	601a      	str	r2, [r3, #0]
2400adfe:	e029      	b.n	2400ae54 <HAL_I2C_Master_Transmit_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400ae00:	68fb      	ldr	r3, [r7, #12]
2400ae02:	2220      	movs	r2, #32
2400ae04:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ae08:	68fb      	ldr	r3, [r7, #12]
2400ae0a:	2200      	movs	r2, #0
2400ae0c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400ae10:	68fb      	ldr	r3, [r7, #12]
2400ae12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ae14:	f043 0210 	orr.w	r2, r3, #16
2400ae18:	68fb      	ldr	r3, [r7, #12]
2400ae1a:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ae1c:	68fb      	ldr	r3, [r7, #12]
2400ae1e:	2200      	movs	r2, #0
2400ae20:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400ae24:	2301      	movs	r3, #1
2400ae26:	e018      	b.n	2400ae5a <HAL_I2C_Master_Transmit_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400ae28:	68fb      	ldr	r3, [r7, #12]
2400ae2a:	4a13      	ldr	r2, [pc, #76]	; (2400ae78 <HAL_I2C_Master_Transmit_DMA+0x1dc>)
2400ae2c:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400ae2e:	68fb      	ldr	r3, [r7, #12]
2400ae30:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ae32:	b2da      	uxtb	r2, r3
2400ae34:	8979      	ldrh	r1, [r7, #10]
2400ae36:	4b0f      	ldr	r3, [pc, #60]	; (2400ae74 <HAL_I2C_Master_Transmit_DMA+0x1d8>)
2400ae38:	9300      	str	r3, [sp, #0]
2400ae3a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400ae3e:	68f8      	ldr	r0, [r7, #12]
2400ae40:	f004 f8e2 	bl	2400f008 <I2C_TransferConfig>
                         I2C_GENERATE_START_WRITE);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ae44:	68fb      	ldr	r3, [r7, #12]
2400ae46:	2200      	movs	r2, #0
2400ae48:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400ae4c:	2101      	movs	r1, #1
2400ae4e:	68f8      	ldr	r0, [r7, #12]
2400ae50:	f004 f90c 	bl	2400f06c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400ae54:	2300      	movs	r3, #0
2400ae56:	e000      	b.n	2400ae5a <HAL_I2C_Master_Transmit_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
2400ae58:	2302      	movs	r3, #2
  }
}
2400ae5a:	4618      	mov	r0, r3
2400ae5c:	3718      	adds	r7, #24
2400ae5e:	46bd      	mov	sp, r7
2400ae60:	bd80      	pop	{r7, pc}
2400ae62:	bf00      	nop
2400ae64:	ffff0000 	.word	0xffff0000
2400ae68:	2400d4d7 	.word	0x2400d4d7
2400ae6c:	2400e643 	.word	0x2400e643
2400ae70:	2400e915 	.word	0x2400e915
2400ae74:	80002000 	.word	0x80002000
2400ae78:	2400d0af 	.word	0x2400d0af

2400ae7c <HAL_I2C_Master_Receive_DMA>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                             uint16_t Size)
{
2400ae7c:	b580      	push	{r7, lr}
2400ae7e:	b088      	sub	sp, #32
2400ae80:	af02      	add	r7, sp, #8
2400ae82:	60f8      	str	r0, [r7, #12]
2400ae84:	607a      	str	r2, [r7, #4]
2400ae86:	461a      	mov	r2, r3
2400ae88:	460b      	mov	r3, r1
2400ae8a:	817b      	strh	r3, [r7, #10]
2400ae8c:	4613      	mov	r3, r2
2400ae8e:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400ae90:	68fb      	ldr	r3, [r7, #12]
2400ae92:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ae96:	b2db      	uxtb	r3, r3
2400ae98:	2b20      	cmp	r3, #32
2400ae9a:	f040 80cd 	bne.w	2400b038 <HAL_I2C_Master_Receive_DMA+0x1bc>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400ae9e:	68fb      	ldr	r3, [r7, #12]
2400aea0:	681b      	ldr	r3, [r3, #0]
2400aea2:	699b      	ldr	r3, [r3, #24]
2400aea4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400aea8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400aeac:	d101      	bne.n	2400aeb2 <HAL_I2C_Master_Receive_DMA+0x36>
    {
      return HAL_BUSY;
2400aeae:	2302      	movs	r3, #2
2400aeb0:	e0c3      	b.n	2400b03a <HAL_I2C_Master_Receive_DMA+0x1be>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400aeb2:	68fb      	ldr	r3, [r7, #12]
2400aeb4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400aeb8:	2b01      	cmp	r3, #1
2400aeba:	d101      	bne.n	2400aec0 <HAL_I2C_Master_Receive_DMA+0x44>
2400aebc:	2302      	movs	r3, #2
2400aebe:	e0bc      	b.n	2400b03a <HAL_I2C_Master_Receive_DMA+0x1be>
2400aec0:	68fb      	ldr	r3, [r7, #12]
2400aec2:	2201      	movs	r2, #1
2400aec4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400aec8:	68fb      	ldr	r3, [r7, #12]
2400aeca:	2222      	movs	r2, #34	; 0x22
2400aecc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
2400aed0:	68fb      	ldr	r3, [r7, #12]
2400aed2:	2210      	movs	r2, #16
2400aed4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400aed8:	68fb      	ldr	r3, [r7, #12]
2400aeda:	2200      	movs	r2, #0
2400aedc:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400aede:	68fb      	ldr	r3, [r7, #12]
2400aee0:	687a      	ldr	r2, [r7, #4]
2400aee2:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400aee4:	68fb      	ldr	r3, [r7, #12]
2400aee6:	893a      	ldrh	r2, [r7, #8]
2400aee8:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400aeea:	68fb      	ldr	r3, [r7, #12]
2400aeec:	4a55      	ldr	r2, [pc, #340]	; (2400b044 <HAL_I2C_Master_Receive_DMA+0x1c8>)
2400aeee:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400aef0:	68fb      	ldr	r3, [r7, #12]
2400aef2:	4a55      	ldr	r2, [pc, #340]	; (2400b048 <HAL_I2C_Master_Receive_DMA+0x1cc>)
2400aef4:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400aef6:	68fb      	ldr	r3, [r7, #12]
2400aef8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400aefa:	b29b      	uxth	r3, r3
2400aefc:	2bff      	cmp	r3, #255	; 0xff
2400aefe:	d906      	bls.n	2400af0e <HAL_I2C_Master_Receive_DMA+0x92>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400af00:	68fb      	ldr	r3, [r7, #12]
2400af02:	22ff      	movs	r2, #255	; 0xff
2400af04:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400af06:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400af0a:	617b      	str	r3, [r7, #20]
2400af0c:	e007      	b.n	2400af1e <HAL_I2C_Master_Receive_DMA+0xa2>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400af0e:	68fb      	ldr	r3, [r7, #12]
2400af10:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400af12:	b29a      	uxth	r2, r3
2400af14:	68fb      	ldr	r3, [r7, #12]
2400af16:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400af18:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400af1c:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferSize > 0U)
2400af1e:	68fb      	ldr	r3, [r7, #12]
2400af20:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400af22:	2b00      	cmp	r3, #0
2400af24:	d070      	beq.n	2400b008 <HAL_I2C_Master_Receive_DMA+0x18c>
    {
      if (hi2c->hdmarx != NULL)
2400af26:	68fb      	ldr	r3, [r7, #12]
2400af28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400af2a:	2b00      	cmp	r3, #0
2400af2c:	d020      	beq.n	2400af70 <HAL_I2C_Master_Receive_DMA+0xf4>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400af2e:	68fb      	ldr	r3, [r7, #12]
2400af30:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400af32:	4a46      	ldr	r2, [pc, #280]	; (2400b04c <HAL_I2C_Master_Receive_DMA+0x1d0>)
2400af34:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400af36:	68fb      	ldr	r3, [r7, #12]
2400af38:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400af3a:	4a45      	ldr	r2, [pc, #276]	; (2400b050 <HAL_I2C_Master_Receive_DMA+0x1d4>)
2400af3c:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400af3e:	68fb      	ldr	r3, [r7, #12]
2400af40:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400af42:	2200      	movs	r2, #0
2400af44:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2400af46:	68fb      	ldr	r3, [r7, #12]
2400af48:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400af4a:	2200      	movs	r2, #0
2400af4c:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400af4e:	68fb      	ldr	r3, [r7, #12]
2400af50:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400af52:	68fb      	ldr	r3, [r7, #12]
2400af54:	681b      	ldr	r3, [r3, #0]
2400af56:	3324      	adds	r3, #36	; 0x24
2400af58:	4619      	mov	r1, r3
2400af5a:	687a      	ldr	r2, [r7, #4]
                                         hi2c->XferSize);
2400af5c:	68fb      	ldr	r3, [r7, #12]
2400af5e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400af60:	f7f8 ff8a 	bl	24003e78 <HAL_DMA_Start_IT>
2400af64:	4603      	mov	r3, r0
2400af66:	74fb      	strb	r3, [r7, #19]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400af68:	7cfb      	ldrb	r3, [r7, #19]
2400af6a:	2b00      	cmp	r3, #0
2400af6c:	d138      	bne.n	2400afe0 <HAL_I2C_Master_Receive_DMA+0x164>
2400af6e:	e013      	b.n	2400af98 <HAL_I2C_Master_Receive_DMA+0x11c>
        hi2c->State     = HAL_I2C_STATE_READY;
2400af70:	68fb      	ldr	r3, [r7, #12]
2400af72:	2220      	movs	r2, #32
2400af74:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400af78:	68fb      	ldr	r3, [r7, #12]
2400af7a:	2200      	movs	r2, #0
2400af7c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400af80:	68fb      	ldr	r3, [r7, #12]
2400af82:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400af84:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400af88:	68fb      	ldr	r3, [r7, #12]
2400af8a:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400af8c:	68fb      	ldr	r3, [r7, #12]
2400af8e:	2200      	movs	r2, #0
2400af90:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400af94:	2301      	movs	r3, #1
2400af96:	e050      	b.n	2400b03a <HAL_I2C_Master_Receive_DMA+0x1be>
      {
        /* Send Slave Address */
        /* Set NBYTES to read and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400af98:	68fb      	ldr	r3, [r7, #12]
2400af9a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400af9c:	b2da      	uxtb	r2, r3
2400af9e:	8979      	ldrh	r1, [r7, #10]
2400afa0:	4b2c      	ldr	r3, [pc, #176]	; (2400b054 <HAL_I2C_Master_Receive_DMA+0x1d8>)
2400afa2:	9300      	str	r3, [sp, #0]
2400afa4:	697b      	ldr	r3, [r7, #20]
2400afa6:	68f8      	ldr	r0, [r7, #12]
2400afa8:	f004 f82e 	bl	2400f008 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400afac:	68fb      	ldr	r3, [r7, #12]
2400afae:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400afb0:	b29a      	uxth	r2, r3
2400afb2:	68fb      	ldr	r3, [r7, #12]
2400afb4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400afb6:	1ad3      	subs	r3, r2, r3
2400afb8:	b29a      	uxth	r2, r3
2400afba:	68fb      	ldr	r3, [r7, #12]
2400afbc:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400afbe:	68fb      	ldr	r3, [r7, #12]
2400afc0:	2200      	movs	r2, #0
2400afc2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400afc6:	2110      	movs	r1, #16
2400afc8:	68f8      	ldr	r0, [r7, #12]
2400afca:	f004 f84f 	bl	2400f06c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400afce:	68fb      	ldr	r3, [r7, #12]
2400afd0:	681b      	ldr	r3, [r3, #0]
2400afd2:	681a      	ldr	r2, [r3, #0]
2400afd4:	68fb      	ldr	r3, [r7, #12]
2400afd6:	681b      	ldr	r3, [r3, #0]
2400afd8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400afdc:	601a      	str	r2, [r3, #0]
2400afde:	e029      	b.n	2400b034 <HAL_I2C_Master_Receive_DMA+0x1b8>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400afe0:	68fb      	ldr	r3, [r7, #12]
2400afe2:	2220      	movs	r2, #32
2400afe4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400afe8:	68fb      	ldr	r3, [r7, #12]
2400afea:	2200      	movs	r2, #0
2400afec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400aff0:	68fb      	ldr	r3, [r7, #12]
2400aff2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400aff4:	f043 0210 	orr.w	r2, r3, #16
2400aff8:	68fb      	ldr	r3, [r7, #12]
2400affa:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400affc:	68fb      	ldr	r3, [r7, #12]
2400affe:	2200      	movs	r2, #0
2400b000:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400b004:	2301      	movs	r3, #1
2400b006:	e018      	b.n	2400b03a <HAL_I2C_Master_Receive_DMA+0x1be>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400b008:	68fb      	ldr	r3, [r7, #12]
2400b00a:	4a13      	ldr	r2, [pc, #76]	; (2400b058 <HAL_I2C_Master_Receive_DMA+0x1dc>)
2400b00c:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400b00e:	68fb      	ldr	r3, [r7, #12]
2400b010:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b012:	b2da      	uxtb	r2, r3
2400b014:	8979      	ldrh	r1, [r7, #10]
2400b016:	4b0f      	ldr	r3, [pc, #60]	; (2400b054 <HAL_I2C_Master_Receive_DMA+0x1d8>)
2400b018:	9300      	str	r3, [sp, #0]
2400b01a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b01e:	68f8      	ldr	r0, [r7, #12]
2400b020:	f003 fff2 	bl	2400f008 <I2C_TransferConfig>
                         I2C_GENERATE_START_READ);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b024:	68fb      	ldr	r3, [r7, #12]
2400b026:	2200      	movs	r2, #0
2400b028:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b02c:	2101      	movs	r1, #1
2400b02e:	68f8      	ldr	r0, [r7, #12]
2400b030:	f004 f81c 	bl	2400f06c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400b034:	2300      	movs	r3, #0
2400b036:	e000      	b.n	2400b03a <HAL_I2C_Master_Receive_DMA+0x1be>
  }
  else
  {
    return HAL_BUSY;
2400b038:	2302      	movs	r3, #2
  }
}
2400b03a:	4618      	mov	r0, r3
2400b03c:	3718      	adds	r7, #24
2400b03e:	46bd      	mov	sp, r7
2400b040:	bd80      	pop	{r7, pc}
2400b042:	bf00      	nop
2400b044:	ffff0000 	.word	0xffff0000
2400b048:	2400d4d7 	.word	0x2400d4d7
2400b04c:	2400e719 	.word	0x2400e719
2400b050:	2400e915 	.word	0x2400e915
2400b054:	80002400 	.word	0x80002400
2400b058:	2400d0af 	.word	0x2400d0af

2400b05c <HAL_I2C_Slave_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400b05c:	b580      	push	{r7, lr}
2400b05e:	b086      	sub	sp, #24
2400b060:	af00      	add	r7, sp, #0
2400b062:	60f8      	str	r0, [r7, #12]
2400b064:	60b9      	str	r1, [r7, #8]
2400b066:	4613      	mov	r3, r2
2400b068:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b06a:	68fb      	ldr	r3, [r7, #12]
2400b06c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b070:	b2db      	uxtb	r3, r3
2400b072:	2b20      	cmp	r3, #32
2400b074:	f040 809b 	bne.w	2400b1ae <HAL_I2C_Slave_Transmit_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
2400b078:	68bb      	ldr	r3, [r7, #8]
2400b07a:	2b00      	cmp	r3, #0
2400b07c:	d002      	beq.n	2400b084 <HAL_I2C_Slave_Transmit_DMA+0x28>
2400b07e:	88fb      	ldrh	r3, [r7, #6]
2400b080:	2b00      	cmp	r3, #0
2400b082:	d105      	bne.n	2400b090 <HAL_I2C_Slave_Transmit_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b084:	68fb      	ldr	r3, [r7, #12]
2400b086:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b08a:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b08c:	2301      	movs	r3, #1
2400b08e:	e08f      	b.n	2400b1b0 <HAL_I2C_Slave_Transmit_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b090:	68fb      	ldr	r3, [r7, #12]
2400b092:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b096:	2b01      	cmp	r3, #1
2400b098:	d101      	bne.n	2400b09e <HAL_I2C_Slave_Transmit_DMA+0x42>
2400b09a:	2302      	movs	r3, #2
2400b09c:	e088      	b.n	2400b1b0 <HAL_I2C_Slave_Transmit_DMA+0x154>
2400b09e:	68fb      	ldr	r3, [r7, #12]
2400b0a0:	2201      	movs	r2, #1
2400b0a2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400b0a6:	68fb      	ldr	r3, [r7, #12]
2400b0a8:	2221      	movs	r2, #33	; 0x21
2400b0aa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400b0ae:	68fb      	ldr	r3, [r7, #12]
2400b0b0:	2220      	movs	r2, #32
2400b0b2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b0b6:	68fb      	ldr	r3, [r7, #12]
2400b0b8:	2200      	movs	r2, #0
2400b0ba:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b0bc:	68fb      	ldr	r3, [r7, #12]
2400b0be:	68ba      	ldr	r2, [r7, #8]
2400b0c0:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b0c2:	68fb      	ldr	r3, [r7, #12]
2400b0c4:	88fa      	ldrh	r2, [r7, #6]
2400b0c6:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b0c8:	68fb      	ldr	r3, [r7, #12]
2400b0ca:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b0cc:	b29a      	uxth	r2, r3
2400b0ce:	68fb      	ldr	r3, [r7, #12]
2400b0d0:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b0d2:	68fb      	ldr	r3, [r7, #12]
2400b0d4:	4a38      	ldr	r2, [pc, #224]	; (2400b1b8 <HAL_I2C_Slave_Transmit_DMA+0x15c>)
2400b0d6:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400b0d8:	68fb      	ldr	r3, [r7, #12]
2400b0da:	4a38      	ldr	r2, [pc, #224]	; (2400b1bc <HAL_I2C_Slave_Transmit_DMA+0x160>)
2400b0dc:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
2400b0de:	68fb      	ldr	r3, [r7, #12]
2400b0e0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b0e2:	2b00      	cmp	r3, #0
2400b0e4:	d020      	beq.n	2400b128 <HAL_I2C_Slave_Transmit_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400b0e6:	68fb      	ldr	r3, [r7, #12]
2400b0e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b0ea:	4a35      	ldr	r2, [pc, #212]	; (2400b1c0 <HAL_I2C_Slave_Transmit_DMA+0x164>)
2400b0ec:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400b0ee:	68fb      	ldr	r3, [r7, #12]
2400b0f0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b0f2:	4a34      	ldr	r2, [pc, #208]	; (2400b1c4 <HAL_I2C_Slave_Transmit_DMA+0x168>)
2400b0f4:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400b0f6:	68fb      	ldr	r3, [r7, #12]
2400b0f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b0fa:	2200      	movs	r2, #0
2400b0fc:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400b0fe:	68fb      	ldr	r3, [r7, #12]
2400b100:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400b102:	2200      	movs	r2, #0
2400b104:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400b106:	68fb      	ldr	r3, [r7, #12]
2400b108:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400b10a:	68b9      	ldr	r1, [r7, #8]
2400b10c:	68fb      	ldr	r3, [r7, #12]
2400b10e:	681b      	ldr	r3, [r3, #0]
2400b110:	3328      	adds	r3, #40	; 0x28
2400b112:	461a      	mov	r2, r3
                                       hi2c->XferSize);
2400b114:	68fb      	ldr	r3, [r7, #12]
2400b116:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400b118:	f7f8 feae 	bl	24003e78 <HAL_DMA_Start_IT>
2400b11c:	4603      	mov	r3, r0
2400b11e:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400b120:	7dfb      	ldrb	r3, [r7, #23]
2400b122:	2b00      	cmp	r3, #0
2400b124:	d12f      	bne.n	2400b186 <HAL_I2C_Slave_Transmit_DMA+0x12a>
2400b126:	e013      	b.n	2400b150 <HAL_I2C_Slave_Transmit_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b128:	68fb      	ldr	r3, [r7, #12]
2400b12a:	2228      	movs	r2, #40	; 0x28
2400b12c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b130:	68fb      	ldr	r3, [r7, #12]
2400b132:	2200      	movs	r2, #0
2400b134:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b138:	68fb      	ldr	r3, [r7, #12]
2400b13a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b13c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b140:	68fb      	ldr	r3, [r7, #12]
2400b142:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b144:	68fb      	ldr	r3, [r7, #12]
2400b146:	2200      	movs	r2, #0
2400b148:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b14c:	2301      	movs	r3, #1
2400b14e:	e02f      	b.n	2400b1b0 <HAL_I2C_Slave_Transmit_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b150:	68fb      	ldr	r3, [r7, #12]
2400b152:	681b      	ldr	r3, [r3, #0]
2400b154:	685a      	ldr	r2, [r3, #4]
2400b156:	68fb      	ldr	r3, [r7, #12]
2400b158:	681b      	ldr	r3, [r3, #0]
2400b15a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b15e:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b160:	68fb      	ldr	r3, [r7, #12]
2400b162:	2200      	movs	r2, #0
2400b164:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400b168:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b16c:	68f8      	ldr	r0, [r7, #12]
2400b16e:	f003 ff7d 	bl	2400f06c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400b172:	68fb      	ldr	r3, [r7, #12]
2400b174:	681b      	ldr	r3, [r3, #0]
2400b176:	681a      	ldr	r2, [r3, #0]
2400b178:	68fb      	ldr	r3, [r7, #12]
2400b17a:	681b      	ldr	r3, [r3, #0]
2400b17c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400b180:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400b182:	2300      	movs	r3, #0
2400b184:	e014      	b.n	2400b1b0 <HAL_I2C_Slave_Transmit_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b186:	68fb      	ldr	r3, [r7, #12]
2400b188:	2228      	movs	r2, #40	; 0x28
2400b18a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b18e:	68fb      	ldr	r3, [r7, #12]
2400b190:	2200      	movs	r2, #0
2400b192:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b196:	68fb      	ldr	r3, [r7, #12]
2400b198:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b19a:	f043 0210 	orr.w	r2, r3, #16
2400b19e:	68fb      	ldr	r3, [r7, #12]
2400b1a0:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b1a2:	68fb      	ldr	r3, [r7, #12]
2400b1a4:	2200      	movs	r2, #0
2400b1a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b1aa:	2301      	movs	r3, #1
2400b1ac:	e000      	b.n	2400b1b0 <HAL_I2C_Slave_Transmit_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
2400b1ae:	2302      	movs	r3, #2
  }
}
2400b1b0:	4618      	mov	r0, r3
2400b1b2:	3718      	adds	r7, #24
2400b1b4:	46bd      	mov	sp, r7
2400b1b6:	bd80      	pop	{r7, pc}
2400b1b8:	ffff0000 	.word	0xffff0000
2400b1bc:	2400d6ad 	.word	0x2400d6ad
2400b1c0:	2400e6d9 	.word	0x2400e6d9
2400b1c4:	2400e915 	.word	0x2400e915

2400b1c8 <HAL_I2C_Slave_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
2400b1c8:	b580      	push	{r7, lr}
2400b1ca:	b086      	sub	sp, #24
2400b1cc:	af00      	add	r7, sp, #0
2400b1ce:	60f8      	str	r0, [r7, #12]
2400b1d0:	60b9      	str	r1, [r7, #8]
2400b1d2:	4613      	mov	r3, r2
2400b1d4:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b1d6:	68fb      	ldr	r3, [r7, #12]
2400b1d8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b1dc:	b2db      	uxtb	r3, r3
2400b1de:	2b20      	cmp	r3, #32
2400b1e0:	f040 809b 	bne.w	2400b31a <HAL_I2C_Slave_Receive_DMA+0x152>
  {
    if ((pData == NULL) || (Size == 0U))
2400b1e4:	68bb      	ldr	r3, [r7, #8]
2400b1e6:	2b00      	cmp	r3, #0
2400b1e8:	d002      	beq.n	2400b1f0 <HAL_I2C_Slave_Receive_DMA+0x28>
2400b1ea:	88fb      	ldrh	r3, [r7, #6]
2400b1ec:	2b00      	cmp	r3, #0
2400b1ee:	d105      	bne.n	2400b1fc <HAL_I2C_Slave_Receive_DMA+0x34>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b1f0:	68fb      	ldr	r3, [r7, #12]
2400b1f2:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b1f6:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b1f8:	2301      	movs	r3, #1
2400b1fa:	e08f      	b.n	2400b31c <HAL_I2C_Slave_Receive_DMA+0x154>
    }
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b1fc:	68fb      	ldr	r3, [r7, #12]
2400b1fe:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b202:	2b01      	cmp	r3, #1
2400b204:	d101      	bne.n	2400b20a <HAL_I2C_Slave_Receive_DMA+0x42>
2400b206:	2302      	movs	r3, #2
2400b208:	e088      	b.n	2400b31c <HAL_I2C_Slave_Receive_DMA+0x154>
2400b20a:	68fb      	ldr	r3, [r7, #12]
2400b20c:	2201      	movs	r2, #1
2400b20e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400b212:	68fb      	ldr	r3, [r7, #12]
2400b214:	2222      	movs	r2, #34	; 0x22
2400b216:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
2400b21a:	68fb      	ldr	r3, [r7, #12]
2400b21c:	2220      	movs	r2, #32
2400b21e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b222:	68fb      	ldr	r3, [r7, #12]
2400b224:	2200      	movs	r2, #0
2400b226:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b228:	68fb      	ldr	r3, [r7, #12]
2400b22a:	68ba      	ldr	r2, [r7, #8]
2400b22c:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b22e:	68fb      	ldr	r3, [r7, #12]
2400b230:	88fa      	ldrh	r2, [r7, #6]
2400b232:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400b234:	68fb      	ldr	r3, [r7, #12]
2400b236:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b238:	b29a      	uxth	r2, r3
2400b23a:	68fb      	ldr	r3, [r7, #12]
2400b23c:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b23e:	68fb      	ldr	r3, [r7, #12]
2400b240:	4a38      	ldr	r2, [pc, #224]	; (2400b324 <HAL_I2C_Slave_Receive_DMA+0x15c>)
2400b242:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400b244:	68fb      	ldr	r3, [r7, #12]
2400b246:	4a38      	ldr	r2, [pc, #224]	; (2400b328 <HAL_I2C_Slave_Receive_DMA+0x160>)
2400b248:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400b24a:	68fb      	ldr	r3, [r7, #12]
2400b24c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b24e:	2b00      	cmp	r3, #0
2400b250:	d020      	beq.n	2400b294 <HAL_I2C_Slave_Receive_DMA+0xcc>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400b252:	68fb      	ldr	r3, [r7, #12]
2400b254:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b256:	4a35      	ldr	r2, [pc, #212]	; (2400b32c <HAL_I2C_Slave_Receive_DMA+0x164>)
2400b258:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400b25a:	68fb      	ldr	r3, [r7, #12]
2400b25c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b25e:	4a34      	ldr	r2, [pc, #208]	; (2400b330 <HAL_I2C_Slave_Receive_DMA+0x168>)
2400b260:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400b262:	68fb      	ldr	r3, [r7, #12]
2400b264:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b266:	2200      	movs	r2, #0
2400b268:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400b26a:	68fb      	ldr	r3, [r7, #12]
2400b26c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400b26e:	2200      	movs	r2, #0
2400b270:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400b272:	68fb      	ldr	r3, [r7, #12]
2400b274:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400b276:	68fb      	ldr	r3, [r7, #12]
2400b278:	681b      	ldr	r3, [r3, #0]
2400b27a:	3324      	adds	r3, #36	; 0x24
2400b27c:	4619      	mov	r1, r3
2400b27e:	68ba      	ldr	r2, [r7, #8]
                                       hi2c->XferSize);
2400b280:	68fb      	ldr	r3, [r7, #12]
2400b282:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400b284:	f7f8 fdf8 	bl	24003e78 <HAL_DMA_Start_IT>
2400b288:	4603      	mov	r3, r0
2400b28a:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400b28c:	7dfb      	ldrb	r3, [r7, #23]
2400b28e:	2b00      	cmp	r3, #0
2400b290:	d12f      	bne.n	2400b2f2 <HAL_I2C_Slave_Receive_DMA+0x12a>
2400b292:	e013      	b.n	2400b2bc <HAL_I2C_Slave_Receive_DMA+0xf4>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b294:	68fb      	ldr	r3, [r7, #12]
2400b296:	2228      	movs	r2, #40	; 0x28
2400b298:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b29c:	68fb      	ldr	r3, [r7, #12]
2400b29e:	2200      	movs	r2, #0
2400b2a0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400b2a4:	68fb      	ldr	r3, [r7, #12]
2400b2a6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b2a8:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400b2ac:	68fb      	ldr	r3, [r7, #12]
2400b2ae:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b2b0:	68fb      	ldr	r3, [r7, #12]
2400b2b2:	2200      	movs	r2, #0
2400b2b4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b2b8:	2301      	movs	r3, #1
2400b2ba:	e02f      	b.n	2400b31c <HAL_I2C_Slave_Receive_DMA+0x154>
    {
      /* Enable Address Acknowledge */
      hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400b2bc:	68fb      	ldr	r3, [r7, #12]
2400b2be:	681b      	ldr	r3, [r3, #0]
2400b2c0:	685a      	ldr	r2, [r3, #4]
2400b2c2:	68fb      	ldr	r3, [r7, #12]
2400b2c4:	681b      	ldr	r3, [r3, #0]
2400b2c6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400b2ca:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b2cc:	68fb      	ldr	r3, [r7, #12]
2400b2ce:	2200      	movs	r2, #0
2400b2d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR, STOP, NACK, ADDR interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400b2d4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b2d8:	68f8      	ldr	r0, [r7, #12]
2400b2da:	f003 fec7 	bl	2400f06c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400b2de:	68fb      	ldr	r3, [r7, #12]
2400b2e0:	681b      	ldr	r3, [r3, #0]
2400b2e2:	681a      	ldr	r2, [r3, #0]
2400b2e4:	68fb      	ldr	r3, [r7, #12]
2400b2e6:	681b      	ldr	r3, [r3, #0]
2400b2e8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400b2ec:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400b2ee:	2300      	movs	r3, #0
2400b2f0:	e014      	b.n	2400b31c <HAL_I2C_Slave_Receive_DMA+0x154>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400b2f2:	68fb      	ldr	r3, [r7, #12]
2400b2f4:	2228      	movs	r2, #40	; 0x28
2400b2f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400b2fa:	68fb      	ldr	r3, [r7, #12]
2400b2fc:	2200      	movs	r2, #0
2400b2fe:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400b302:	68fb      	ldr	r3, [r7, #12]
2400b304:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400b306:	f043 0210 	orr.w	r2, r3, #16
2400b30a:	68fb      	ldr	r3, [r7, #12]
2400b30c:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400b30e:	68fb      	ldr	r3, [r7, #12]
2400b310:	2200      	movs	r2, #0
2400b312:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b316:	2301      	movs	r3, #1
2400b318:	e000      	b.n	2400b31c <HAL_I2C_Slave_Receive_DMA+0x154>
  }
  else
  {
    return HAL_BUSY;
2400b31a:	2302      	movs	r3, #2
  }
}
2400b31c:	4618      	mov	r0, r3
2400b31e:	3718      	adds	r7, #24
2400b320:	46bd      	mov	sp, r7
2400b322:	bd80      	pop	{r7, pc}
2400b324:	ffff0000 	.word	0xffff0000
2400b328:	2400d6ad 	.word	0x2400d6ad
2400b32c:	2400e7b1 	.word	0x2400e7b1
2400b330:	2400e915 	.word	0x2400e915

2400b334 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400b334:	b580      	push	{r7, lr}
2400b336:	b088      	sub	sp, #32
2400b338:	af02      	add	r7, sp, #8
2400b33a:	60f8      	str	r0, [r7, #12]
2400b33c:	4608      	mov	r0, r1
2400b33e:	4611      	mov	r1, r2
2400b340:	461a      	mov	r2, r3
2400b342:	4603      	mov	r3, r0
2400b344:	817b      	strh	r3, [r7, #10]
2400b346:	460b      	mov	r3, r1
2400b348:	813b      	strh	r3, [r7, #8]
2400b34a:	4613      	mov	r3, r2
2400b34c:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b34e:	68fb      	ldr	r3, [r7, #12]
2400b350:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b354:	b2db      	uxtb	r3, r3
2400b356:	2b20      	cmp	r3, #32
2400b358:	f040 80f9 	bne.w	2400b54e <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
2400b35c:	6a3b      	ldr	r3, [r7, #32]
2400b35e:	2b00      	cmp	r3, #0
2400b360:	d002      	beq.n	2400b368 <HAL_I2C_Mem_Write+0x34>
2400b362:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b364:	2b00      	cmp	r3, #0
2400b366:	d105      	bne.n	2400b374 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b368:	68fb      	ldr	r3, [r7, #12]
2400b36a:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b36e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b370:	2301      	movs	r3, #1
2400b372:	e0ed      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b374:	68fb      	ldr	r3, [r7, #12]
2400b376:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b37a:	2b01      	cmp	r3, #1
2400b37c:	d101      	bne.n	2400b382 <HAL_I2C_Mem_Write+0x4e>
2400b37e:	2302      	movs	r3, #2
2400b380:	e0e6      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
2400b382:	68fb      	ldr	r3, [r7, #12]
2400b384:	2201      	movs	r2, #1
2400b386:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400b38a:	f7f6 ffdb 	bl	24002344 <HAL_GetTick>
2400b38e:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400b390:	697b      	ldr	r3, [r7, #20]
2400b392:	9300      	str	r3, [sp, #0]
2400b394:	2319      	movs	r3, #25
2400b396:	2201      	movs	r2, #1
2400b398:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b39c:	68f8      	ldr	r0, [r7, #12]
2400b39e:	f003 fc11 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400b3a2:	4603      	mov	r3, r0
2400b3a4:	2b00      	cmp	r3, #0
2400b3a6:	d001      	beq.n	2400b3ac <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
2400b3a8:	2301      	movs	r3, #1
2400b3aa:	e0d1      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400b3ac:	68fb      	ldr	r3, [r7, #12]
2400b3ae:	2221      	movs	r2, #33	; 0x21
2400b3b0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400b3b4:	68fb      	ldr	r3, [r7, #12]
2400b3b6:	2240      	movs	r2, #64	; 0x40
2400b3b8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b3bc:	68fb      	ldr	r3, [r7, #12]
2400b3be:	2200      	movs	r2, #0
2400b3c0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400b3c2:	68fb      	ldr	r3, [r7, #12]
2400b3c4:	6a3a      	ldr	r2, [r7, #32]
2400b3c6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400b3c8:	68fb      	ldr	r3, [r7, #12]
2400b3ca:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b3cc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400b3ce:	68fb      	ldr	r3, [r7, #12]
2400b3d0:	2200      	movs	r2, #0
2400b3d2:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400b3d4:	88f8      	ldrh	r0, [r7, #6]
2400b3d6:	893a      	ldrh	r2, [r7, #8]
2400b3d8:	8979      	ldrh	r1, [r7, #10]
2400b3da:	697b      	ldr	r3, [r7, #20]
2400b3dc:	9301      	str	r3, [sp, #4]
2400b3de:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b3e0:	9300      	str	r3, [sp, #0]
2400b3e2:	4603      	mov	r3, r0
2400b3e4:	68f8      	ldr	r0, [r7, #12]
2400b3e6:	f002 fb39 	bl	2400da5c <I2C_RequestMemoryWrite>
2400b3ea:	4603      	mov	r3, r0
2400b3ec:	2b00      	cmp	r3, #0
2400b3ee:	d005      	beq.n	2400b3fc <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b3f0:	68fb      	ldr	r3, [r7, #12]
2400b3f2:	2200      	movs	r2, #0
2400b3f4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b3f8:	2301      	movs	r3, #1
2400b3fa:	e0a9      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b3fc:	68fb      	ldr	r3, [r7, #12]
2400b3fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b400:	b29b      	uxth	r3, r3
2400b402:	2bff      	cmp	r3, #255	; 0xff
2400b404:	d90e      	bls.n	2400b424 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b406:	68fb      	ldr	r3, [r7, #12]
2400b408:	22ff      	movs	r2, #255	; 0xff
2400b40a:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400b40c:	68fb      	ldr	r3, [r7, #12]
2400b40e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b410:	b2da      	uxtb	r2, r3
2400b412:	8979      	ldrh	r1, [r7, #10]
2400b414:	2300      	movs	r3, #0
2400b416:	9300      	str	r3, [sp, #0]
2400b418:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b41c:	68f8      	ldr	r0, [r7, #12]
2400b41e:	f003 fdf3 	bl	2400f008 <I2C_TransferConfig>
2400b422:	e00f      	b.n	2400b444 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b424:	68fb      	ldr	r3, [r7, #12]
2400b426:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b428:	b29a      	uxth	r2, r3
2400b42a:	68fb      	ldr	r3, [r7, #12]
2400b42c:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
2400b42e:	68fb      	ldr	r3, [r7, #12]
2400b430:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b432:	b2da      	uxtb	r2, r3
2400b434:	8979      	ldrh	r1, [r7, #10]
2400b436:	2300      	movs	r3, #0
2400b438:	9300      	str	r3, [sp, #0]
2400b43a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b43e:	68f8      	ldr	r0, [r7, #12]
2400b440:	f003 fde2 	bl	2400f008 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400b444:	697a      	ldr	r2, [r7, #20]
2400b446:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400b448:	68f8      	ldr	r0, [r7, #12]
2400b44a:	f003 fbfb 	bl	2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>
2400b44e:	4603      	mov	r3, r0
2400b450:	2b00      	cmp	r3, #0
2400b452:	d001      	beq.n	2400b458 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
2400b454:	2301      	movs	r3, #1
2400b456:	e07b      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400b458:	68fb      	ldr	r3, [r7, #12]
2400b45a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b45c:	781a      	ldrb	r2, [r3, #0]
2400b45e:	68fb      	ldr	r3, [r7, #12]
2400b460:	681b      	ldr	r3, [r3, #0]
2400b462:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400b464:	68fb      	ldr	r3, [r7, #12]
2400b466:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b468:	1c5a      	adds	r2, r3, #1
2400b46a:	68fb      	ldr	r3, [r7, #12]
2400b46c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400b46e:	68fb      	ldr	r3, [r7, #12]
2400b470:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b472:	b29b      	uxth	r3, r3
2400b474:	3b01      	subs	r3, #1
2400b476:	b29a      	uxth	r2, r3
2400b478:	68fb      	ldr	r3, [r7, #12]
2400b47a:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400b47c:	68fb      	ldr	r3, [r7, #12]
2400b47e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b480:	3b01      	subs	r3, #1
2400b482:	b29a      	uxth	r2, r3
2400b484:	68fb      	ldr	r3, [r7, #12]
2400b486:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400b488:	68fb      	ldr	r3, [r7, #12]
2400b48a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b48c:	b29b      	uxth	r3, r3
2400b48e:	2b00      	cmp	r3, #0
2400b490:	d034      	beq.n	2400b4fc <HAL_I2C_Mem_Write+0x1c8>
2400b492:	68fb      	ldr	r3, [r7, #12]
2400b494:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b496:	2b00      	cmp	r3, #0
2400b498:	d130      	bne.n	2400b4fc <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400b49a:	697b      	ldr	r3, [r7, #20]
2400b49c:	9300      	str	r3, [sp, #0]
2400b49e:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b4a0:	2200      	movs	r2, #0
2400b4a2:	2180      	movs	r1, #128	; 0x80
2400b4a4:	68f8      	ldr	r0, [r7, #12]
2400b4a6:	f003 fb8d 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400b4aa:	4603      	mov	r3, r0
2400b4ac:	2b00      	cmp	r3, #0
2400b4ae:	d001      	beq.n	2400b4b4 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
2400b4b0:	2301      	movs	r3, #1
2400b4b2:	e04d      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b4b4:	68fb      	ldr	r3, [r7, #12]
2400b4b6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b4b8:	b29b      	uxth	r3, r3
2400b4ba:	2bff      	cmp	r3, #255	; 0xff
2400b4bc:	d90e      	bls.n	2400b4dc <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400b4be:	68fb      	ldr	r3, [r7, #12]
2400b4c0:	22ff      	movs	r2, #255	; 0xff
2400b4c2:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400b4c4:	68fb      	ldr	r3, [r7, #12]
2400b4c6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b4c8:	b2da      	uxtb	r2, r3
2400b4ca:	8979      	ldrh	r1, [r7, #10]
2400b4cc:	2300      	movs	r3, #0
2400b4ce:	9300      	str	r3, [sp, #0]
2400b4d0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b4d4:	68f8      	ldr	r0, [r7, #12]
2400b4d6:	f003 fd97 	bl	2400f008 <I2C_TransferConfig>
2400b4da:	e00f      	b.n	2400b4fc <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400b4dc:	68fb      	ldr	r3, [r7, #12]
2400b4de:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b4e0:	b29a      	uxth	r2, r3
2400b4e2:	68fb      	ldr	r3, [r7, #12]
2400b4e4:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400b4e6:	68fb      	ldr	r3, [r7, #12]
2400b4e8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b4ea:	b2da      	uxtb	r2, r3
2400b4ec:	8979      	ldrh	r1, [r7, #10]
2400b4ee:	2300      	movs	r3, #0
2400b4f0:	9300      	str	r3, [sp, #0]
2400b4f2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b4f6:	68f8      	ldr	r0, [r7, #12]
2400b4f8:	f003 fd86 	bl	2400f008 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
2400b4fc:	68fb      	ldr	r3, [r7, #12]
2400b4fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b500:	b29b      	uxth	r3, r3
2400b502:	2b00      	cmp	r3, #0
2400b504:	d19e      	bne.n	2400b444 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400b506:	697a      	ldr	r2, [r7, #20]
2400b508:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400b50a:	68f8      	ldr	r0, [r7, #12]
2400b50c:	f003 fbda 	bl	2400ecc4 <I2C_WaitOnSTOPFlagUntilTimeout>
2400b510:	4603      	mov	r3, r0
2400b512:	2b00      	cmp	r3, #0
2400b514:	d001      	beq.n	2400b51a <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
2400b516:	2301      	movs	r3, #1
2400b518:	e01a      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400b51a:	68fb      	ldr	r3, [r7, #12]
2400b51c:	681b      	ldr	r3, [r3, #0]
2400b51e:	2220      	movs	r2, #32
2400b520:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400b522:	68fb      	ldr	r3, [r7, #12]
2400b524:	681b      	ldr	r3, [r3, #0]
2400b526:	6859      	ldr	r1, [r3, #4]
2400b528:	68fb      	ldr	r3, [r7, #12]
2400b52a:	681a      	ldr	r2, [r3, #0]
2400b52c:	4b0a      	ldr	r3, [pc, #40]	; (2400b558 <HAL_I2C_Mem_Write+0x224>)
2400b52e:	400b      	ands	r3, r1
2400b530:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400b532:	68fb      	ldr	r3, [r7, #12]
2400b534:	2220      	movs	r2, #32
2400b536:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400b53a:	68fb      	ldr	r3, [r7, #12]
2400b53c:	2200      	movs	r2, #0
2400b53e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b542:	68fb      	ldr	r3, [r7, #12]
2400b544:	2200      	movs	r2, #0
2400b546:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400b54a:	2300      	movs	r3, #0
2400b54c:	e000      	b.n	2400b550 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
2400b54e:	2302      	movs	r3, #2
  }
}
2400b550:	4618      	mov	r0, r3
2400b552:	3718      	adds	r7, #24
2400b554:	46bd      	mov	sp, r7
2400b556:	bd80      	pop	{r7, pc}
2400b558:	fe00e800 	.word	0xfe00e800

2400b55c <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
2400b55c:	b580      	push	{r7, lr}
2400b55e:	b088      	sub	sp, #32
2400b560:	af02      	add	r7, sp, #8
2400b562:	60f8      	str	r0, [r7, #12]
2400b564:	4608      	mov	r0, r1
2400b566:	4611      	mov	r1, r2
2400b568:	461a      	mov	r2, r3
2400b56a:	4603      	mov	r3, r0
2400b56c:	817b      	strh	r3, [r7, #10]
2400b56e:	460b      	mov	r3, r1
2400b570:	813b      	strh	r3, [r7, #8]
2400b572:	4613      	mov	r3, r2
2400b574:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b576:	68fb      	ldr	r3, [r7, #12]
2400b578:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b57c:	b2db      	uxtb	r3, r3
2400b57e:	2b20      	cmp	r3, #32
2400b580:	f040 80fd 	bne.w	2400b77e <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
2400b584:	6a3b      	ldr	r3, [r7, #32]
2400b586:	2b00      	cmp	r3, #0
2400b588:	d002      	beq.n	2400b590 <HAL_I2C_Mem_Read+0x34>
2400b58a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b58c:	2b00      	cmp	r3, #0
2400b58e:	d105      	bne.n	2400b59c <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b590:	68fb      	ldr	r3, [r7, #12]
2400b592:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b596:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b598:	2301      	movs	r3, #1
2400b59a:	e0f1      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b59c:	68fb      	ldr	r3, [r7, #12]
2400b59e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b5a2:	2b01      	cmp	r3, #1
2400b5a4:	d101      	bne.n	2400b5aa <HAL_I2C_Mem_Read+0x4e>
2400b5a6:	2302      	movs	r3, #2
2400b5a8:	e0ea      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
2400b5aa:	68fb      	ldr	r3, [r7, #12]
2400b5ac:	2201      	movs	r2, #1
2400b5ae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400b5b2:	f7f6 fec7 	bl	24002344 <HAL_GetTick>
2400b5b6:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
2400b5b8:	697b      	ldr	r3, [r7, #20]
2400b5ba:	9300      	str	r3, [sp, #0]
2400b5bc:	2319      	movs	r3, #25
2400b5be:	2201      	movs	r2, #1
2400b5c0:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400b5c4:	68f8      	ldr	r0, [r7, #12]
2400b5c6:	f003 fafd 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400b5ca:	4603      	mov	r3, r0
2400b5cc:	2b00      	cmp	r3, #0
2400b5ce:	d001      	beq.n	2400b5d4 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
2400b5d0:	2301      	movs	r3, #1
2400b5d2:	e0d5      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400b5d4:	68fb      	ldr	r3, [r7, #12]
2400b5d6:	2222      	movs	r2, #34	; 0x22
2400b5d8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
2400b5dc:	68fb      	ldr	r3, [r7, #12]
2400b5de:	2240      	movs	r2, #64	; 0x40
2400b5e0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400b5e4:	68fb      	ldr	r3, [r7, #12]
2400b5e6:	2200      	movs	r2, #0
2400b5e8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
2400b5ea:	68fb      	ldr	r3, [r7, #12]
2400b5ec:	6a3a      	ldr	r2, [r7, #32]
2400b5ee:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
2400b5f0:	68fb      	ldr	r3, [r7, #12]
2400b5f2:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b5f4:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
2400b5f6:	68fb      	ldr	r3, [r7, #12]
2400b5f8:	2200      	movs	r2, #0
2400b5fa:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
2400b5fc:	88f8      	ldrh	r0, [r7, #6]
2400b5fe:	893a      	ldrh	r2, [r7, #8]
2400b600:	8979      	ldrh	r1, [r7, #10]
2400b602:	697b      	ldr	r3, [r7, #20]
2400b604:	9301      	str	r3, [sp, #4]
2400b606:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b608:	9300      	str	r3, [sp, #0]
2400b60a:	4603      	mov	r3, r0
2400b60c:	68f8      	ldr	r0, [r7, #12]
2400b60e:	f002 fa79 	bl	2400db04 <I2C_RequestMemoryRead>
2400b612:	4603      	mov	r3, r0
2400b614:	2b00      	cmp	r3, #0
2400b616:	d005      	beq.n	2400b624 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b618:	68fb      	ldr	r3, [r7, #12]
2400b61a:	2200      	movs	r2, #0
2400b61c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b620:	2301      	movs	r3, #1
2400b622:	e0ad      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b624:	68fb      	ldr	r3, [r7, #12]
2400b626:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b628:	b29b      	uxth	r3, r3
2400b62a:	2bff      	cmp	r3, #255	; 0xff
2400b62c:	d90e      	bls.n	2400b64c <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b62e:	68fb      	ldr	r3, [r7, #12]
2400b630:	22ff      	movs	r2, #255	; 0xff
2400b632:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
2400b634:	68fb      	ldr	r3, [r7, #12]
2400b636:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b638:	b2da      	uxtb	r2, r3
2400b63a:	8979      	ldrh	r1, [r7, #10]
2400b63c:	4b52      	ldr	r3, [pc, #328]	; (2400b788 <HAL_I2C_Mem_Read+0x22c>)
2400b63e:	9300      	str	r3, [sp, #0]
2400b640:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b644:	68f8      	ldr	r0, [r7, #12]
2400b646:	f003 fcdf 	bl	2400f008 <I2C_TransferConfig>
2400b64a:	e00f      	b.n	2400b66c <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b64c:	68fb      	ldr	r3, [r7, #12]
2400b64e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b650:	b29a      	uxth	r2, r3
2400b652:	68fb      	ldr	r3, [r7, #12]
2400b654:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400b656:	68fb      	ldr	r3, [r7, #12]
2400b658:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b65a:	b2da      	uxtb	r2, r3
2400b65c:	8979      	ldrh	r1, [r7, #10]
2400b65e:	4b4a      	ldr	r3, [pc, #296]	; (2400b788 <HAL_I2C_Mem_Read+0x22c>)
2400b660:	9300      	str	r3, [sp, #0]
2400b662:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b666:	68f8      	ldr	r0, [r7, #12]
2400b668:	f003 fcce 	bl	2400f008 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
2400b66c:	697b      	ldr	r3, [r7, #20]
2400b66e:	9300      	str	r3, [sp, #0]
2400b670:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b672:	2200      	movs	r2, #0
2400b674:	2104      	movs	r1, #4
2400b676:	68f8      	ldr	r0, [r7, #12]
2400b678:	f003 faa4 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400b67c:	4603      	mov	r3, r0
2400b67e:	2b00      	cmp	r3, #0
2400b680:	d001      	beq.n	2400b686 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
2400b682:	2301      	movs	r3, #1
2400b684:	e07c      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400b686:	68fb      	ldr	r3, [r7, #12]
2400b688:	681b      	ldr	r3, [r3, #0]
2400b68a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400b68c:	68fb      	ldr	r3, [r7, #12]
2400b68e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b690:	b2d2      	uxtb	r2, r2
2400b692:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400b694:	68fb      	ldr	r3, [r7, #12]
2400b696:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400b698:	1c5a      	adds	r2, r3, #1
2400b69a:	68fb      	ldr	r3, [r7, #12]
2400b69c:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400b69e:	68fb      	ldr	r3, [r7, #12]
2400b6a0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b6a2:	3b01      	subs	r3, #1
2400b6a4:	b29a      	uxth	r2, r3
2400b6a6:	68fb      	ldr	r3, [r7, #12]
2400b6a8:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400b6aa:	68fb      	ldr	r3, [r7, #12]
2400b6ac:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b6ae:	b29b      	uxth	r3, r3
2400b6b0:	3b01      	subs	r3, #1
2400b6b2:	b29a      	uxth	r2, r3
2400b6b4:	68fb      	ldr	r3, [r7, #12]
2400b6b6:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400b6b8:	68fb      	ldr	r3, [r7, #12]
2400b6ba:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b6bc:	b29b      	uxth	r3, r3
2400b6be:	2b00      	cmp	r3, #0
2400b6c0:	d034      	beq.n	2400b72c <HAL_I2C_Mem_Read+0x1d0>
2400b6c2:	68fb      	ldr	r3, [r7, #12]
2400b6c4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b6c6:	2b00      	cmp	r3, #0
2400b6c8:	d130      	bne.n	2400b72c <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
2400b6ca:	697b      	ldr	r3, [r7, #20]
2400b6cc:	9300      	str	r3, [sp, #0]
2400b6ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400b6d0:	2200      	movs	r2, #0
2400b6d2:	2180      	movs	r1, #128	; 0x80
2400b6d4:	68f8      	ldr	r0, [r7, #12]
2400b6d6:	f003 fa75 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400b6da:	4603      	mov	r3, r0
2400b6dc:	2b00      	cmp	r3, #0
2400b6de:	d001      	beq.n	2400b6e4 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
2400b6e0:	2301      	movs	r3, #1
2400b6e2:	e04d      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b6e4:	68fb      	ldr	r3, [r7, #12]
2400b6e6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b6e8:	b29b      	uxth	r3, r3
2400b6ea:	2bff      	cmp	r3, #255	; 0xff
2400b6ec:	d90e      	bls.n	2400b70c <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
2400b6ee:	68fb      	ldr	r3, [r7, #12]
2400b6f0:	22ff      	movs	r2, #255	; 0xff
2400b6f2:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
2400b6f4:	68fb      	ldr	r3, [r7, #12]
2400b6f6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b6f8:	b2da      	uxtb	r2, r3
2400b6fa:	8979      	ldrh	r1, [r7, #10]
2400b6fc:	2300      	movs	r3, #0
2400b6fe:	9300      	str	r3, [sp, #0]
2400b700:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b704:	68f8      	ldr	r0, [r7, #12]
2400b706:	f003 fc7f 	bl	2400f008 <I2C_TransferConfig>
2400b70a:	e00f      	b.n	2400b72c <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
2400b70c:	68fb      	ldr	r3, [r7, #12]
2400b70e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b710:	b29a      	uxth	r2, r3
2400b712:	68fb      	ldr	r3, [r7, #12]
2400b714:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400b716:	68fb      	ldr	r3, [r7, #12]
2400b718:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b71a:	b2da      	uxtb	r2, r3
2400b71c:	8979      	ldrh	r1, [r7, #10]
2400b71e:	2300      	movs	r3, #0
2400b720:	9300      	str	r3, [sp, #0]
2400b722:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b726:	68f8      	ldr	r0, [r7, #12]
2400b728:	f003 fc6e 	bl	2400f008 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
2400b72c:	68fb      	ldr	r3, [r7, #12]
2400b72e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b730:	b29b      	uxth	r3, r3
2400b732:	2b00      	cmp	r3, #0
2400b734:	d19a      	bne.n	2400b66c <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
2400b736:	697a      	ldr	r2, [r7, #20]
2400b738:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400b73a:	68f8      	ldr	r0, [r7, #12]
2400b73c:	f003 fac2 	bl	2400ecc4 <I2C_WaitOnSTOPFlagUntilTimeout>
2400b740:	4603      	mov	r3, r0
2400b742:	2b00      	cmp	r3, #0
2400b744:	d001      	beq.n	2400b74a <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
2400b746:	2301      	movs	r3, #1
2400b748:	e01a      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400b74a:	68fb      	ldr	r3, [r7, #12]
2400b74c:	681b      	ldr	r3, [r3, #0]
2400b74e:	2220      	movs	r2, #32
2400b750:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400b752:	68fb      	ldr	r3, [r7, #12]
2400b754:	681b      	ldr	r3, [r3, #0]
2400b756:	6859      	ldr	r1, [r3, #4]
2400b758:	68fb      	ldr	r3, [r7, #12]
2400b75a:	681a      	ldr	r2, [r3, #0]
2400b75c:	4b0b      	ldr	r3, [pc, #44]	; (2400b78c <HAL_I2C_Mem_Read+0x230>)
2400b75e:	400b      	ands	r3, r1
2400b760:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
2400b762:	68fb      	ldr	r3, [r7, #12]
2400b764:	2220      	movs	r2, #32
2400b766:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
2400b76a:	68fb      	ldr	r3, [r7, #12]
2400b76c:	2200      	movs	r2, #0
2400b76e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b772:	68fb      	ldr	r3, [r7, #12]
2400b774:	2200      	movs	r2, #0
2400b776:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400b77a:	2300      	movs	r3, #0
2400b77c:	e000      	b.n	2400b780 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
2400b77e:	2302      	movs	r3, #2
  }
}
2400b780:	4618      	mov	r0, r3
2400b782:	3718      	adds	r7, #24
2400b784:	46bd      	mov	sp, r7
2400b786:	bd80      	pop	{r7, pc}
2400b788:	80002400 	.word	0x80002400
2400b78c:	fe00e800 	.word	0xfe00e800

2400b790 <HAL_I2C_Mem_Write_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400b790:	b580      	push	{r7, lr}
2400b792:	b088      	sub	sp, #32
2400b794:	af02      	add	r7, sp, #8
2400b796:	60f8      	str	r0, [r7, #12]
2400b798:	4608      	mov	r0, r1
2400b79a:	4611      	mov	r1, r2
2400b79c:	461a      	mov	r2, r3
2400b79e:	4603      	mov	r3, r0
2400b7a0:	817b      	strh	r3, [r7, #10]
2400b7a2:	460b      	mov	r3, r1
2400b7a4:	813b      	strh	r3, [r7, #8]
2400b7a6:	4613      	mov	r3, r2
2400b7a8:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b7aa:	68fb      	ldr	r3, [r7, #12]
2400b7ac:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b7b0:	b2db      	uxtb	r3, r3
2400b7b2:	2b20      	cmp	r3, #32
2400b7b4:	d176      	bne.n	2400b8a4 <HAL_I2C_Mem_Write_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
2400b7b6:	6a3b      	ldr	r3, [r7, #32]
2400b7b8:	2b00      	cmp	r3, #0
2400b7ba:	d002      	beq.n	2400b7c2 <HAL_I2C_Mem_Write_IT+0x32>
2400b7bc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b7be:	2b00      	cmp	r3, #0
2400b7c0:	d105      	bne.n	2400b7ce <HAL_I2C_Mem_Write_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b7c2:	68fb      	ldr	r3, [r7, #12]
2400b7c4:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b7c8:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b7ca:	2301      	movs	r3, #1
2400b7cc:	e06b      	b.n	2400b8a6 <HAL_I2C_Mem_Write_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400b7ce:	68fb      	ldr	r3, [r7, #12]
2400b7d0:	681b      	ldr	r3, [r3, #0]
2400b7d2:	699b      	ldr	r3, [r3, #24]
2400b7d4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b7d8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b7dc:	d101      	bne.n	2400b7e2 <HAL_I2C_Mem_Write_IT+0x52>
    {
      return HAL_BUSY;
2400b7de:	2302      	movs	r3, #2
2400b7e0:	e061      	b.n	2400b8a6 <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b7e2:	68fb      	ldr	r3, [r7, #12]
2400b7e4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b7e8:	2b01      	cmp	r3, #1
2400b7ea:	d101      	bne.n	2400b7f0 <HAL_I2C_Mem_Write_IT+0x60>
2400b7ec:	2302      	movs	r3, #2
2400b7ee:	e05a      	b.n	2400b8a6 <HAL_I2C_Mem_Write_IT+0x116>
2400b7f0:	68fb      	ldr	r3, [r7, #12]
2400b7f2:	2201      	movs	r2, #1
2400b7f4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400b7f8:	f7f6 fda4 	bl	24002344 <HAL_GetTick>
2400b7fc:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400b7fe:	68fb      	ldr	r3, [r7, #12]
2400b800:	2221      	movs	r2, #33	; 0x21
2400b802:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400b806:	68fb      	ldr	r3, [r7, #12]
2400b808:	2240      	movs	r2, #64	; 0x40
2400b80a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b80e:	68fb      	ldr	r3, [r7, #12]
2400b810:	2200      	movs	r2, #0
2400b812:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b814:	68fb      	ldr	r3, [r7, #12]
2400b816:	6a3a      	ldr	r2, [r7, #32]
2400b818:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b81a:	68fb      	ldr	r3, [r7, #12]
2400b81c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b81e:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b820:	68fb      	ldr	r3, [r7, #12]
2400b822:	4a23      	ldr	r2, [pc, #140]	; (2400b8b0 <HAL_I2C_Mem_Write_IT+0x120>)
2400b824:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400b826:	68fb      	ldr	r3, [r7, #12]
2400b828:	4a22      	ldr	r2, [pc, #136]	; (2400b8b4 <HAL_I2C_Mem_Write_IT+0x124>)
2400b82a:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b82c:	68fb      	ldr	r3, [r7, #12]
2400b82e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b830:	b29b      	uxth	r3, r3
2400b832:	2bff      	cmp	r3, #255	; 0xff
2400b834:	d906      	bls.n	2400b844 <HAL_I2C_Mem_Write_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b836:	68fb      	ldr	r3, [r7, #12]
2400b838:	22ff      	movs	r2, #255	; 0xff
2400b83a:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400b83c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b840:	617b      	str	r3, [r7, #20]
2400b842:	e007      	b.n	2400b854 <HAL_I2C_Mem_Write_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b844:	68fb      	ldr	r3, [r7, #12]
2400b846:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b848:	b29a      	uxth	r2, r3
2400b84a:	68fb      	ldr	r3, [r7, #12]
2400b84c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400b84e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b852:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart)
2400b854:	88f8      	ldrh	r0, [r7, #6]
2400b856:	893a      	ldrh	r2, [r7, #8]
2400b858:	8979      	ldrh	r1, [r7, #10]
2400b85a:	693b      	ldr	r3, [r7, #16]
2400b85c:	9301      	str	r3, [sp, #4]
2400b85e:	2319      	movs	r3, #25
2400b860:	9300      	str	r3, [sp, #0]
2400b862:	4603      	mov	r3, r0
2400b864:	68f8      	ldr	r0, [r7, #12]
2400b866:	f002 f8f9 	bl	2400da5c <I2C_RequestMemoryWrite>
2400b86a:	4603      	mov	r3, r0
2400b86c:	2b00      	cmp	r3, #0
2400b86e:	d005      	beq.n	2400b87c <HAL_I2C_Mem_Write_IT+0xec>
        != HAL_OK)
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b870:	68fb      	ldr	r3, [r7, #12]
2400b872:	2200      	movs	r2, #0
2400b874:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b878:	2301      	movs	r3, #1
2400b87a:	e014      	b.n	2400b8a6 <HAL_I2C_Mem_Write_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400b87c:	68fb      	ldr	r3, [r7, #12]
2400b87e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b880:	b2da      	uxtb	r2, r3
2400b882:	8979      	ldrh	r1, [r7, #10]
2400b884:	2300      	movs	r3, #0
2400b886:	9300      	str	r3, [sp, #0]
2400b888:	697b      	ldr	r3, [r7, #20]
2400b88a:	68f8      	ldr	r0, [r7, #12]
2400b88c:	f003 fbbc 	bl	2400f008 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b890:	68fb      	ldr	r3, [r7, #12]
2400b892:	2200      	movs	r2, #0
2400b894:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400b898:	2101      	movs	r1, #1
2400b89a:	68f8      	ldr	r0, [r7, #12]
2400b89c:	f003 fbe6 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400b8a0:	2300      	movs	r3, #0
2400b8a2:	e000      	b.n	2400b8a6 <HAL_I2C_Mem_Write_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
2400b8a4:	2302      	movs	r3, #2
  }
}
2400b8a6:	4618      	mov	r0, r3
2400b8a8:	3718      	adds	r7, #24
2400b8aa:	46bd      	mov	sp, r7
2400b8ac:	bd80      	pop	{r7, pc}
2400b8ae:	bf00      	nop
2400b8b0:	ffff0000 	.word	0xffff0000
2400b8b4:	2400d0af 	.word	0x2400d0af

2400b8b8 <HAL_I2C_Mem_Read_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                      uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400b8b8:	b580      	push	{r7, lr}
2400b8ba:	b088      	sub	sp, #32
2400b8bc:	af02      	add	r7, sp, #8
2400b8be:	60f8      	str	r0, [r7, #12]
2400b8c0:	4608      	mov	r0, r1
2400b8c2:	4611      	mov	r1, r2
2400b8c4:	461a      	mov	r2, r3
2400b8c6:	4603      	mov	r3, r0
2400b8c8:	817b      	strh	r3, [r7, #10]
2400b8ca:	460b      	mov	r3, r1
2400b8cc:	813b      	strh	r3, [r7, #8]
2400b8ce:	4613      	mov	r3, r2
2400b8d0:	80fb      	strh	r3, [r7, #6]
  uint32_t xfermode;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b8d2:	68fb      	ldr	r3, [r7, #12]
2400b8d4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400b8d8:	b2db      	uxtb	r3, r3
2400b8da:	2b20      	cmp	r3, #32
2400b8dc:	d176      	bne.n	2400b9cc <HAL_I2C_Mem_Read_IT+0x114>
  {
    if ((pData == NULL) || (Size == 0U))
2400b8de:	6a3b      	ldr	r3, [r7, #32]
2400b8e0:	2b00      	cmp	r3, #0
2400b8e2:	d002      	beq.n	2400b8ea <HAL_I2C_Mem_Read_IT+0x32>
2400b8e4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
2400b8e6:	2b00      	cmp	r3, #0
2400b8e8:	d105      	bne.n	2400b8f6 <HAL_I2C_Mem_Read_IT+0x3e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400b8ea:	68fb      	ldr	r3, [r7, #12]
2400b8ec:	f44f 7200 	mov.w	r2, #512	; 0x200
2400b8f0:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400b8f2:	2301      	movs	r3, #1
2400b8f4:	e06b      	b.n	2400b9ce <HAL_I2C_Mem_Read_IT+0x116>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400b8f6:	68fb      	ldr	r3, [r7, #12]
2400b8f8:	681b      	ldr	r3, [r3, #0]
2400b8fa:	699b      	ldr	r3, [r3, #24]
2400b8fc:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400b900:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400b904:	d101      	bne.n	2400b90a <HAL_I2C_Mem_Read_IT+0x52>
    {
      return HAL_BUSY;
2400b906:	2302      	movs	r3, #2
2400b908:	e061      	b.n	2400b9ce <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400b90a:	68fb      	ldr	r3, [r7, #12]
2400b90c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400b910:	2b01      	cmp	r3, #1
2400b912:	d101      	bne.n	2400b918 <HAL_I2C_Mem_Read_IT+0x60>
2400b914:	2302      	movs	r3, #2
2400b916:	e05a      	b.n	2400b9ce <HAL_I2C_Mem_Read_IT+0x116>
2400b918:	68fb      	ldr	r3, [r7, #12]
2400b91a:	2201      	movs	r2, #1
2400b91c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400b920:	f7f6 fd10 	bl	24002344 <HAL_GetTick>
2400b924:	6138      	str	r0, [r7, #16]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400b926:	68fb      	ldr	r3, [r7, #12]
2400b928:	2222      	movs	r2, #34	; 0x22
2400b92a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400b92e:	68fb      	ldr	r3, [r7, #12]
2400b930:	2240      	movs	r2, #64	; 0x40
2400b932:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400b936:	68fb      	ldr	r3, [r7, #12]
2400b938:	2200      	movs	r2, #0
2400b93a:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400b93c:	68fb      	ldr	r3, [r7, #12]
2400b93e:	6a3a      	ldr	r2, [r7, #32]
2400b940:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400b942:	68fb      	ldr	r3, [r7, #12]
2400b944:	8cba      	ldrh	r2, [r7, #36]	; 0x24
2400b946:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400b948:	68fb      	ldr	r3, [r7, #12]
2400b94a:	4a23      	ldr	r2, [pc, #140]	; (2400b9d8 <HAL_I2C_Mem_Read_IT+0x120>)
2400b94c:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400b94e:	68fb      	ldr	r3, [r7, #12]
2400b950:	4a22      	ldr	r2, [pc, #136]	; (2400b9dc <HAL_I2C_Mem_Read_IT+0x124>)
2400b952:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400b954:	68fb      	ldr	r3, [r7, #12]
2400b956:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b958:	b29b      	uxth	r3, r3
2400b95a:	2bff      	cmp	r3, #255	; 0xff
2400b95c:	d906      	bls.n	2400b96c <HAL_I2C_Mem_Read_IT+0xb4>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400b95e:	68fb      	ldr	r3, [r7, #12]
2400b960:	22ff      	movs	r2, #255	; 0xff
2400b962:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400b964:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400b968:	617b      	str	r3, [r7, #20]
2400b96a:	e007      	b.n	2400b97c <HAL_I2C_Mem_Read_IT+0xc4>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400b96c:	68fb      	ldr	r3, [r7, #12]
2400b96e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400b970:	b29a      	uxth	r2, r3
2400b972:	68fb      	ldr	r3, [r7, #12]
2400b974:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400b976:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400b97a:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400b97c:	88f8      	ldrh	r0, [r7, #6]
2400b97e:	893a      	ldrh	r2, [r7, #8]
2400b980:	8979      	ldrh	r1, [r7, #10]
2400b982:	693b      	ldr	r3, [r7, #16]
2400b984:	9301      	str	r3, [sp, #4]
2400b986:	2319      	movs	r3, #25
2400b988:	9300      	str	r3, [sp, #0]
2400b98a:	4603      	mov	r3, r0
2400b98c:	68f8      	ldr	r0, [r7, #12]
2400b98e:	f002 f8b9 	bl	2400db04 <I2C_RequestMemoryRead>
2400b992:	4603      	mov	r3, r0
2400b994:	2b00      	cmp	r3, #0
2400b996:	d005      	beq.n	2400b9a4 <HAL_I2C_Mem_Read_IT+0xec>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400b998:	68fb      	ldr	r3, [r7, #12]
2400b99a:	2200      	movs	r2, #0
2400b99c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400b9a0:	2301      	movs	r3, #1
2400b9a2:	e014      	b.n	2400b9ce <HAL_I2C_Mem_Read_IT+0x116>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400b9a4:	68fb      	ldr	r3, [r7, #12]
2400b9a6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400b9a8:	b2da      	uxtb	r2, r3
2400b9aa:	8979      	ldrh	r1, [r7, #10]
2400b9ac:	4b0c      	ldr	r3, [pc, #48]	; (2400b9e0 <HAL_I2C_Mem_Read_IT+0x128>)
2400b9ae:	9300      	str	r3, [sp, #0]
2400b9b0:	697b      	ldr	r3, [r7, #20]
2400b9b2:	68f8      	ldr	r0, [r7, #12]
2400b9b4:	f003 fb28 	bl	2400f008 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400b9b8:	68fb      	ldr	r3, [r7, #12]
2400b9ba:	2200      	movs	r2, #0
2400b9bc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400b9c0:	2102      	movs	r1, #2
2400b9c2:	68f8      	ldr	r0, [r7, #12]
2400b9c4:	f003 fb52 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400b9c8:	2300      	movs	r3, #0
2400b9ca:	e000      	b.n	2400b9ce <HAL_I2C_Mem_Read_IT+0x116>
  }
  else
  {
    return HAL_BUSY;
2400b9cc:	2302      	movs	r3, #2
  }
}
2400b9ce:	4618      	mov	r0, r3
2400b9d0:	3718      	adds	r7, #24
2400b9d2:	46bd      	mov	sp, r7
2400b9d4:	bd80      	pop	{r7, pc}
2400b9d6:	bf00      	nop
2400b9d8:	ffff0000 	.word	0xffff0000
2400b9dc:	2400d0af 	.word	0x2400d0af
2400b9e0:	80002400 	.word	0x80002400

2400b9e4 <HAL_I2C_Mem_Write_DMA>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                        uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400b9e4:	b580      	push	{r7, lr}
2400b9e6:	b08a      	sub	sp, #40	; 0x28
2400b9e8:	af02      	add	r7, sp, #8
2400b9ea:	60f8      	str	r0, [r7, #12]
2400b9ec:	4608      	mov	r0, r1
2400b9ee:	4611      	mov	r1, r2
2400b9f0:	461a      	mov	r2, r3
2400b9f2:	4603      	mov	r3, r0
2400b9f4:	817b      	strh	r3, [r7, #10]
2400b9f6:	460b      	mov	r3, r1
2400b9f8:	813b      	strh	r3, [r7, #8]
2400b9fa:	4613      	mov	r3, r2
2400b9fc:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400b9fe:	68fb      	ldr	r3, [r7, #12]
2400ba00:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ba04:	b2db      	uxtb	r3, r3
2400ba06:	2b20      	cmp	r3, #32
2400ba08:	f040 80d5 	bne.w	2400bbb6 <HAL_I2C_Mem_Write_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
2400ba0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400ba0e:	2b00      	cmp	r3, #0
2400ba10:	d002      	beq.n	2400ba18 <HAL_I2C_Mem_Write_DMA+0x34>
2400ba12:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2400ba14:	2b00      	cmp	r3, #0
2400ba16:	d105      	bne.n	2400ba24 <HAL_I2C_Mem_Write_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400ba18:	68fb      	ldr	r3, [r7, #12]
2400ba1a:	f44f 7200 	mov.w	r2, #512	; 0x200
2400ba1e:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400ba20:	2301      	movs	r3, #1
2400ba22:	e0c9      	b.n	2400bbb8 <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400ba24:	68fb      	ldr	r3, [r7, #12]
2400ba26:	681b      	ldr	r3, [r3, #0]
2400ba28:	699b      	ldr	r3, [r3, #24]
2400ba2a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400ba2e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400ba32:	d101      	bne.n	2400ba38 <HAL_I2C_Mem_Write_DMA+0x54>
    {
      return HAL_BUSY;
2400ba34:	2302      	movs	r3, #2
2400ba36:	e0bf      	b.n	2400bbb8 <HAL_I2C_Mem_Write_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400ba38:	68fb      	ldr	r3, [r7, #12]
2400ba3a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400ba3e:	2b01      	cmp	r3, #1
2400ba40:	d101      	bne.n	2400ba46 <HAL_I2C_Mem_Write_DMA+0x62>
2400ba42:	2302      	movs	r3, #2
2400ba44:	e0b8      	b.n	2400bbb8 <HAL_I2C_Mem_Write_DMA+0x1d4>
2400ba46:	68fb      	ldr	r3, [r7, #12]
2400ba48:	2201      	movs	r2, #1
2400ba4a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400ba4e:	f7f6 fc79 	bl	24002344 <HAL_GetTick>
2400ba52:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
2400ba54:	68fb      	ldr	r3, [r7, #12]
2400ba56:	2221      	movs	r2, #33	; 0x21
2400ba58:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400ba5c:	68fb      	ldr	r3, [r7, #12]
2400ba5e:	2240      	movs	r2, #64	; 0x40
2400ba60:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400ba64:	68fb      	ldr	r3, [r7, #12]
2400ba66:	2200      	movs	r2, #0
2400ba68:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ba6a:	68fb      	ldr	r3, [r7, #12]
2400ba6c:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400ba6e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ba70:	68fb      	ldr	r3, [r7, #12]
2400ba72:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2400ba74:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400ba76:	68fb      	ldr	r3, [r7, #12]
2400ba78:	4a51      	ldr	r2, [pc, #324]	; (2400bbc0 <HAL_I2C_Mem_Write_DMA+0x1dc>)
2400ba7a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400ba7c:	68fb      	ldr	r3, [r7, #12]
2400ba7e:	4a51      	ldr	r2, [pc, #324]	; (2400bbc4 <HAL_I2C_Mem_Write_DMA+0x1e0>)
2400ba80:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400ba82:	68fb      	ldr	r3, [r7, #12]
2400ba84:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ba86:	b29b      	uxth	r3, r3
2400ba88:	2bff      	cmp	r3, #255	; 0xff
2400ba8a:	d906      	bls.n	2400ba9a <HAL_I2C_Mem_Write_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400ba8c:	68fb      	ldr	r3, [r7, #12]
2400ba8e:	22ff      	movs	r2, #255	; 0xff
2400ba90:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400ba92:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400ba96:	61fb      	str	r3, [r7, #28]
2400ba98:	e007      	b.n	2400baaa <HAL_I2C_Mem_Write_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400ba9a:	68fb      	ldr	r3, [r7, #12]
2400ba9c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ba9e:	b29a      	uxth	r2, r3
2400baa0:	68fb      	ldr	r3, [r7, #12]
2400baa2:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400baa4:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400baa8:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart)
2400baaa:	88f8      	ldrh	r0, [r7, #6]
2400baac:	893a      	ldrh	r2, [r7, #8]
2400baae:	8979      	ldrh	r1, [r7, #10]
2400bab0:	69bb      	ldr	r3, [r7, #24]
2400bab2:	9301      	str	r3, [sp, #4]
2400bab4:	2319      	movs	r3, #25
2400bab6:	9300      	str	r3, [sp, #0]
2400bab8:	4603      	mov	r3, r0
2400baba:	68f8      	ldr	r0, [r7, #12]
2400babc:	f001 ffce 	bl	2400da5c <I2C_RequestMemoryWrite>
2400bac0:	4603      	mov	r3, r0
2400bac2:	2b00      	cmp	r3, #0
2400bac4:	d005      	beq.n	2400bad2 <HAL_I2C_Mem_Write_DMA+0xee>
        != HAL_OK)
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400bac6:	68fb      	ldr	r3, [r7, #12]
2400bac8:	2200      	movs	r2, #0
2400baca:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bace:	2301      	movs	r3, #1
2400bad0:	e072      	b.n	2400bbb8 <HAL_I2C_Mem_Write_DMA+0x1d4>
    }


    if (hi2c->hdmatx != NULL)
2400bad2:	68fb      	ldr	r3, [r7, #12]
2400bad4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400bad6:	2b00      	cmp	r3, #0
2400bad8:	d020      	beq.n	2400bb1c <HAL_I2C_Mem_Write_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400bada:	68fb      	ldr	r3, [r7, #12]
2400badc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400bade:	4a3a      	ldr	r2, [pc, #232]	; (2400bbc8 <HAL_I2C_Mem_Write_DMA+0x1e4>)
2400bae0:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400bae2:	68fb      	ldr	r3, [r7, #12]
2400bae4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400bae6:	4a39      	ldr	r2, [pc, #228]	; (2400bbcc <HAL_I2C_Mem_Write_DMA+0x1e8>)
2400bae8:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400baea:	68fb      	ldr	r3, [r7, #12]
2400baec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400baee:	2200      	movs	r2, #0
2400baf0:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400baf2:	68fb      	ldr	r3, [r7, #12]
2400baf4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400baf6:	2200      	movs	r2, #0
2400baf8:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400bafa:	68fb      	ldr	r3, [r7, #12]
2400bafc:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400bafe:	6ab9      	ldr	r1, [r7, #40]	; 0x28
2400bb00:	68fb      	ldr	r3, [r7, #12]
2400bb02:	681b      	ldr	r3, [r3, #0]
2400bb04:	3328      	adds	r3, #40	; 0x28
2400bb06:	461a      	mov	r2, r3
                                       hi2c->XferSize);
2400bb08:	68fb      	ldr	r3, [r7, #12]
2400bb0a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400bb0c:	f7f8 f9b4 	bl	24003e78 <HAL_DMA_Start_IT>
2400bb10:	4603      	mov	r3, r0
2400bb12:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400bb14:	7dfb      	ldrb	r3, [r7, #23]
2400bb16:	2b00      	cmp	r3, #0
2400bb18:	d139      	bne.n	2400bb8e <HAL_I2C_Mem_Write_DMA+0x1aa>
2400bb1a:	e013      	b.n	2400bb44 <HAL_I2C_Mem_Write_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
2400bb1c:	68fb      	ldr	r3, [r7, #12]
2400bb1e:	2220      	movs	r2, #32
2400bb20:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400bb24:	68fb      	ldr	r3, [r7, #12]
2400bb26:	2200      	movs	r2, #0
2400bb28:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400bb2c:	68fb      	ldr	r3, [r7, #12]
2400bb2e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bb30:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400bb34:	68fb      	ldr	r3, [r7, #12]
2400bb36:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400bb38:	68fb      	ldr	r3, [r7, #12]
2400bb3a:	2200      	movs	r2, #0
2400bb3c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bb40:	2301      	movs	r3, #1
2400bb42:	e039      	b.n	2400bbb8 <HAL_I2C_Mem_Write_DMA+0x1d4>
    {
      /* Send Slave Address */
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400bb44:	68fb      	ldr	r3, [r7, #12]
2400bb46:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bb48:	b2da      	uxtb	r2, r3
2400bb4a:	8979      	ldrh	r1, [r7, #10]
2400bb4c:	2300      	movs	r3, #0
2400bb4e:	9300      	str	r3, [sp, #0]
2400bb50:	69fb      	ldr	r3, [r7, #28]
2400bb52:	68f8      	ldr	r0, [r7, #12]
2400bb54:	f003 fa58 	bl	2400f008 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400bb58:	68fb      	ldr	r3, [r7, #12]
2400bb5a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bb5c:	b29a      	uxth	r2, r3
2400bb5e:	68fb      	ldr	r3, [r7, #12]
2400bb60:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bb62:	1ad3      	subs	r3, r2, r3
2400bb64:	b29a      	uxth	r2, r3
2400bb66:	68fb      	ldr	r3, [r7, #12]
2400bb68:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400bb6a:	68fb      	ldr	r3, [r7, #12]
2400bb6c:	2200      	movs	r2, #0
2400bb6e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400bb72:	2110      	movs	r1, #16
2400bb74:	68f8      	ldr	r0, [r7, #12]
2400bb76:	f003 fa79 	bl	2400f06c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400bb7a:	68fb      	ldr	r3, [r7, #12]
2400bb7c:	681b      	ldr	r3, [r3, #0]
2400bb7e:	681a      	ldr	r2, [r3, #0]
2400bb80:	68fb      	ldr	r3, [r7, #12]
2400bb82:	681b      	ldr	r3, [r3, #0]
2400bb84:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400bb88:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400bb8a:	2300      	movs	r3, #0
2400bb8c:	e014      	b.n	2400bbb8 <HAL_I2C_Mem_Write_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
2400bb8e:	68fb      	ldr	r3, [r7, #12]
2400bb90:	2220      	movs	r2, #32
2400bb92:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400bb96:	68fb      	ldr	r3, [r7, #12]
2400bb98:	2200      	movs	r2, #0
2400bb9a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400bb9e:	68fb      	ldr	r3, [r7, #12]
2400bba0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bba2:	f043 0210 	orr.w	r2, r3, #16
2400bba6:	68fb      	ldr	r3, [r7, #12]
2400bba8:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400bbaa:	68fb      	ldr	r3, [r7, #12]
2400bbac:	2200      	movs	r2, #0
2400bbae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bbb2:	2301      	movs	r3, #1
2400bbb4:	e000      	b.n	2400bbb8 <HAL_I2C_Mem_Write_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
2400bbb6:	2302      	movs	r3, #2
  }
}
2400bbb8:	4618      	mov	r0, r3
2400bbba:	3720      	adds	r7, #32
2400bbbc:	46bd      	mov	sp, r7
2400bbbe:	bd80      	pop	{r7, pc}
2400bbc0:	ffff0000 	.word	0xffff0000
2400bbc4:	2400d4d7 	.word	0x2400d4d7
2400bbc8:	2400e643 	.word	0x2400e643
2400bbcc:	2400e915 	.word	0x2400e915

2400bbd0 <HAL_I2C_Mem_Read_DMA>:
  * @param  Size Amount of data to be read
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                       uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
{
2400bbd0:	b580      	push	{r7, lr}
2400bbd2:	b08a      	sub	sp, #40	; 0x28
2400bbd4:	af02      	add	r7, sp, #8
2400bbd6:	60f8      	str	r0, [r7, #12]
2400bbd8:	4608      	mov	r0, r1
2400bbda:	4611      	mov	r1, r2
2400bbdc:	461a      	mov	r2, r3
2400bbde:	4603      	mov	r3, r0
2400bbe0:	817b      	strh	r3, [r7, #10]
2400bbe2:	460b      	mov	r3, r1
2400bbe4:	813b      	strh	r3, [r7, #8]
2400bbe6:	4613      	mov	r3, r2
2400bbe8:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400bbea:	68fb      	ldr	r3, [r7, #12]
2400bbec:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bbf0:	b2db      	uxtb	r3, r3
2400bbf2:	2b20      	cmp	r3, #32
2400bbf4:	f040 80d5 	bne.w	2400bda2 <HAL_I2C_Mem_Read_DMA+0x1d2>
  {
    if ((pData == NULL) || (Size == 0U))
2400bbf8:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400bbfa:	2b00      	cmp	r3, #0
2400bbfc:	d002      	beq.n	2400bc04 <HAL_I2C_Mem_Read_DMA+0x34>
2400bbfe:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
2400bc00:	2b00      	cmp	r3, #0
2400bc02:	d105      	bne.n	2400bc10 <HAL_I2C_Mem_Read_DMA+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400bc04:	68fb      	ldr	r3, [r7, #12]
2400bc06:	f44f 7200 	mov.w	r2, #512	; 0x200
2400bc0a:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400bc0c:	2301      	movs	r3, #1
2400bc0e:	e0c9      	b.n	2400bda4 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400bc10:	68fb      	ldr	r3, [r7, #12]
2400bc12:	681b      	ldr	r3, [r3, #0]
2400bc14:	699b      	ldr	r3, [r3, #24]
2400bc16:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400bc1a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400bc1e:	d101      	bne.n	2400bc24 <HAL_I2C_Mem_Read_DMA+0x54>
    {
      return HAL_BUSY;
2400bc20:	2302      	movs	r3, #2
2400bc22:	e0bf      	b.n	2400bda4 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400bc24:	68fb      	ldr	r3, [r7, #12]
2400bc26:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bc2a:	2b01      	cmp	r3, #1
2400bc2c:	d101      	bne.n	2400bc32 <HAL_I2C_Mem_Read_DMA+0x62>
2400bc2e:	2302      	movs	r3, #2
2400bc30:	e0b8      	b.n	2400bda4 <HAL_I2C_Mem_Read_DMA+0x1d4>
2400bc32:	68fb      	ldr	r3, [r7, #12]
2400bc34:	2201      	movs	r2, #1
2400bc36:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
2400bc3a:	f7f6 fb83 	bl	24002344 <HAL_GetTick>
2400bc3e:	61b8      	str	r0, [r7, #24]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
2400bc40:	68fb      	ldr	r3, [r7, #12]
2400bc42:	2222      	movs	r2, #34	; 0x22
2400bc44:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MEM;
2400bc48:	68fb      	ldr	r3, [r7, #12]
2400bc4a:	2240      	movs	r2, #64	; 0x40
2400bc4c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
2400bc50:	68fb      	ldr	r3, [r7, #12]
2400bc52:	2200      	movs	r2, #0
2400bc54:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400bc56:	68fb      	ldr	r3, [r7, #12]
2400bc58:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400bc5a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400bc5c:	68fb      	ldr	r3, [r7, #12]
2400bc5e:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
2400bc60:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400bc62:	68fb      	ldr	r3, [r7, #12]
2400bc64:	4a51      	ldr	r2, [pc, #324]	; (2400bdac <HAL_I2C_Mem_Read_DMA+0x1dc>)
2400bc66:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400bc68:	68fb      	ldr	r3, [r7, #12]
2400bc6a:	4a51      	ldr	r2, [pc, #324]	; (2400bdb0 <HAL_I2C_Mem_Read_DMA+0x1e0>)
2400bc6c:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400bc6e:	68fb      	ldr	r3, [r7, #12]
2400bc70:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bc72:	b29b      	uxth	r3, r3
2400bc74:	2bff      	cmp	r3, #255	; 0xff
2400bc76:	d906      	bls.n	2400bc86 <HAL_I2C_Mem_Read_DMA+0xb6>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400bc78:	68fb      	ldr	r3, [r7, #12]
2400bc7a:	22ff      	movs	r2, #255	; 0xff
2400bc7c:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400bc7e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400bc82:	61fb      	str	r3, [r7, #28]
2400bc84:	e007      	b.n	2400bc96 <HAL_I2C_Mem_Read_DMA+0xc6>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400bc86:	68fb      	ldr	r3, [r7, #12]
2400bc88:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bc8a:	b29a      	uxth	r2, r3
2400bc8c:	68fb      	ldr	r3, [r7, #12]
2400bc8e:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_AUTOEND_MODE;
2400bc90:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400bc94:	61fb      	str	r3, [r7, #28]
    }

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
2400bc96:	88f8      	ldrh	r0, [r7, #6]
2400bc98:	893a      	ldrh	r2, [r7, #8]
2400bc9a:	8979      	ldrh	r1, [r7, #10]
2400bc9c:	69bb      	ldr	r3, [r7, #24]
2400bc9e:	9301      	str	r3, [sp, #4]
2400bca0:	2319      	movs	r3, #25
2400bca2:	9300      	str	r3, [sp, #0]
2400bca4:	4603      	mov	r3, r0
2400bca6:	68f8      	ldr	r0, [r7, #12]
2400bca8:	f001 ff2c 	bl	2400db04 <I2C_RequestMemoryRead>
2400bcac:	4603      	mov	r3, r0
2400bcae:	2b00      	cmp	r3, #0
2400bcb0:	d005      	beq.n	2400bcbe <HAL_I2C_Mem_Read_DMA+0xee>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400bcb2:	68fb      	ldr	r3, [r7, #12]
2400bcb4:	2200      	movs	r2, #0
2400bcb6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bcba:	2301      	movs	r3, #1
2400bcbc:	e072      	b.n	2400bda4 <HAL_I2C_Mem_Read_DMA+0x1d4>
    }

    if (hi2c->hdmarx != NULL)
2400bcbe:	68fb      	ldr	r3, [r7, #12]
2400bcc0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400bcc2:	2b00      	cmp	r3, #0
2400bcc4:	d020      	beq.n	2400bd08 <HAL_I2C_Mem_Read_DMA+0x138>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400bcc6:	68fb      	ldr	r3, [r7, #12]
2400bcc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400bcca:	4a3a      	ldr	r2, [pc, #232]	; (2400bdb4 <HAL_I2C_Mem_Read_DMA+0x1e4>)
2400bccc:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400bcce:	68fb      	ldr	r3, [r7, #12]
2400bcd0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400bcd2:	4a39      	ldr	r2, [pc, #228]	; (2400bdb8 <HAL_I2C_Mem_Read_DMA+0x1e8>)
2400bcd4:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400bcd6:	68fb      	ldr	r3, [r7, #12]
2400bcd8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400bcda:	2200      	movs	r2, #0
2400bcdc:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400bcde:	68fb      	ldr	r3, [r7, #12]
2400bce0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400bce2:	2200      	movs	r2, #0
2400bce4:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400bce6:	68fb      	ldr	r3, [r7, #12]
2400bce8:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400bcea:	68fb      	ldr	r3, [r7, #12]
2400bcec:	681b      	ldr	r3, [r3, #0]
2400bcee:	3324      	adds	r3, #36	; 0x24
2400bcf0:	4619      	mov	r1, r3
2400bcf2:	6aba      	ldr	r2, [r7, #40]	; 0x28
                                       hi2c->XferSize);
2400bcf4:	68fb      	ldr	r3, [r7, #12]
2400bcf6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400bcf8:	f7f8 f8be 	bl	24003e78 <HAL_DMA_Start_IT>
2400bcfc:	4603      	mov	r3, r0
2400bcfe:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400bd00:	7dfb      	ldrb	r3, [r7, #23]
2400bd02:	2b00      	cmp	r3, #0
2400bd04:	d139      	bne.n	2400bd7a <HAL_I2C_Mem_Read_DMA+0x1aa>
2400bd06:	e013      	b.n	2400bd30 <HAL_I2C_Mem_Read_DMA+0x160>
      hi2c->State     = HAL_I2C_STATE_READY;
2400bd08:	68fb      	ldr	r3, [r7, #12]
2400bd0a:	2220      	movs	r2, #32
2400bd0c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400bd10:	68fb      	ldr	r3, [r7, #12]
2400bd12:	2200      	movs	r2, #0
2400bd14:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400bd18:	68fb      	ldr	r3, [r7, #12]
2400bd1a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd1c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400bd20:	68fb      	ldr	r3, [r7, #12]
2400bd22:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400bd24:	68fb      	ldr	r3, [r7, #12]
2400bd26:	2200      	movs	r2, #0
2400bd28:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bd2c:	2301      	movs	r3, #1
2400bd2e:	e039      	b.n	2400bda4 <HAL_I2C_Mem_Read_DMA+0x1d4>
    {
      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
2400bd30:	68fb      	ldr	r3, [r7, #12]
2400bd32:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bd34:	b2da      	uxtb	r2, r3
2400bd36:	8979      	ldrh	r1, [r7, #10]
2400bd38:	4b20      	ldr	r3, [pc, #128]	; (2400bdbc <HAL_I2C_Mem_Read_DMA+0x1ec>)
2400bd3a:	9300      	str	r3, [sp, #0]
2400bd3c:	69fb      	ldr	r3, [r7, #28]
2400bd3e:	68f8      	ldr	r0, [r7, #12]
2400bd40:	f003 f962 	bl	2400f008 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400bd44:	68fb      	ldr	r3, [r7, #12]
2400bd46:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400bd48:	b29a      	uxth	r2, r3
2400bd4a:	68fb      	ldr	r3, [r7, #12]
2400bd4c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400bd4e:	1ad3      	subs	r3, r2, r3
2400bd50:	b29a      	uxth	r2, r3
2400bd52:	68fb      	ldr	r3, [r7, #12]
2400bd54:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400bd56:	68fb      	ldr	r3, [r7, #12]
2400bd58:	2200      	movs	r2, #0
2400bd5a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Note : The I2C interrupts must be enabled after unlocking current process
                to avoid the risk of I2C interrupt handle execution before current
                process unlock */
      /* Enable ERR and NACK interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400bd5e:	2110      	movs	r1, #16
2400bd60:	68f8      	ldr	r0, [r7, #12]
2400bd62:	f003 f983 	bl	2400f06c <I2C_Enable_IRQ>

      /* Enable DMA Request */
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400bd66:	68fb      	ldr	r3, [r7, #12]
2400bd68:	681b      	ldr	r3, [r3, #0]
2400bd6a:	681a      	ldr	r2, [r3, #0]
2400bd6c:	68fb      	ldr	r3, [r7, #12]
2400bd6e:	681b      	ldr	r3, [r3, #0]
2400bd70:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400bd74:	601a      	str	r2, [r3, #0]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    return HAL_OK;
2400bd76:	2300      	movs	r3, #0
2400bd78:	e014      	b.n	2400bda4 <HAL_I2C_Mem_Read_DMA+0x1d4>
      hi2c->State     = HAL_I2C_STATE_READY;
2400bd7a:	68fb      	ldr	r3, [r7, #12]
2400bd7c:	2220      	movs	r2, #32
2400bd7e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400bd82:	68fb      	ldr	r3, [r7, #12]
2400bd84:	2200      	movs	r2, #0
2400bd86:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400bd8a:	68fb      	ldr	r3, [r7, #12]
2400bd8c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bd8e:	f043 0210 	orr.w	r2, r3, #16
2400bd92:	68fb      	ldr	r3, [r7, #12]
2400bd94:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400bd96:	68fb      	ldr	r3, [r7, #12]
2400bd98:	2200      	movs	r2, #0
2400bd9a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400bd9e:	2301      	movs	r3, #1
2400bda0:	e000      	b.n	2400bda4 <HAL_I2C_Mem_Read_DMA+0x1d4>
  }
  else
  {
    return HAL_BUSY;
2400bda2:	2302      	movs	r3, #2
  }
}
2400bda4:	4618      	mov	r0, r3
2400bda6:	3720      	adds	r7, #32
2400bda8:	46bd      	mov	sp, r7
2400bdaa:	bd80      	pop	{r7, pc}
2400bdac:	ffff0000 	.word	0xffff0000
2400bdb0:	2400d4d7 	.word	0x2400d4d7
2400bdb4:	2400e719 	.word	0x2400e719
2400bdb8:	2400e915 	.word	0x2400e915
2400bdbc:	80002400 	.word	0x80002400

2400bdc0 <HAL_I2C_IsDeviceReady>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials,
                                        uint32_t Timeout)
{
2400bdc0:	b580      	push	{r7, lr}
2400bdc2:	b08a      	sub	sp, #40	; 0x28
2400bdc4:	af02      	add	r7, sp, #8
2400bdc6:	60f8      	str	r0, [r7, #12]
2400bdc8:	607a      	str	r2, [r7, #4]
2400bdca:	603b      	str	r3, [r7, #0]
2400bdcc:	460b      	mov	r3, r1
2400bdce:	817b      	strh	r3, [r7, #10]
  uint32_t tickstart;

  __IO uint32_t I2C_Trials = 0UL;
2400bdd0:	2300      	movs	r3, #0
2400bdd2:	617b      	str	r3, [r7, #20]

  FlagStatus tmp1;
  FlagStatus tmp2;

  if (hi2c->State == HAL_I2C_STATE_READY)
2400bdd4:	68fb      	ldr	r3, [r7, #12]
2400bdd6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bdda:	b2db      	uxtb	r3, r3
2400bddc:	2b20      	cmp	r3, #32
2400bdde:	f040 80ef 	bne.w	2400bfc0 <HAL_I2C_IsDeviceReady+0x200>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
2400bde2:	68fb      	ldr	r3, [r7, #12]
2400bde4:	681b      	ldr	r3, [r3, #0]
2400bde6:	699b      	ldr	r3, [r3, #24]
2400bde8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400bdec:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400bdf0:	d101      	bne.n	2400bdf6 <HAL_I2C_IsDeviceReady+0x36>
    {
      return HAL_BUSY;
2400bdf2:	2302      	movs	r3, #2
2400bdf4:	e0e5      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400bdf6:	68fb      	ldr	r3, [r7, #12]
2400bdf8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bdfc:	2b01      	cmp	r3, #1
2400bdfe:	d101      	bne.n	2400be04 <HAL_I2C_IsDeviceReady+0x44>
2400be00:	2302      	movs	r3, #2
2400be02:	e0de      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
2400be04:	68fb      	ldr	r3, [r7, #12]
2400be06:	2201      	movs	r2, #1
2400be08:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400be0c:	68fb      	ldr	r3, [r7, #12]
2400be0e:	2224      	movs	r2, #36	; 0x24
2400be10:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400be14:	68fb      	ldr	r3, [r7, #12]
2400be16:	2200      	movs	r2, #0
2400be18:	645a      	str	r2, [r3, #68]	; 0x44

    do
    {
      /* Generate Start */
      hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode, DevAddress);
2400be1a:	68fb      	ldr	r3, [r7, #12]
2400be1c:	68db      	ldr	r3, [r3, #12]
2400be1e:	2b01      	cmp	r3, #1
2400be20:	d105      	bne.n	2400be2e <HAL_I2C_IsDeviceReady+0x6e>
2400be22:	897b      	ldrh	r3, [r7, #10]
2400be24:	f3c3 0209 	ubfx	r2, r3, #0, #10
2400be28:	4b68      	ldr	r3, [pc, #416]	; (2400bfcc <HAL_I2C_IsDeviceReady+0x20c>)
2400be2a:	4313      	orrs	r3, r2
2400be2c:	e004      	b.n	2400be38 <HAL_I2C_IsDeviceReady+0x78>
2400be2e:	897b      	ldrh	r3, [r7, #10]
2400be30:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400be34:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
2400be38:	68fa      	ldr	r2, [r7, #12]
2400be3a:	6812      	ldr	r2, [r2, #0]
2400be3c:	6053      	str	r3, [r2, #4]

      /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
      /* Wait until STOPF flag is set or a NACK flag is set*/
      tickstart = HAL_GetTick();
2400be3e:	f7f6 fa81 	bl	24002344 <HAL_GetTick>
2400be42:	61b8      	str	r0, [r7, #24]

      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400be44:	68fb      	ldr	r3, [r7, #12]
2400be46:	681b      	ldr	r3, [r3, #0]
2400be48:	699b      	ldr	r3, [r3, #24]
2400be4a:	f003 0320 	and.w	r3, r3, #32
2400be4e:	2b20      	cmp	r3, #32
2400be50:	bf0c      	ite	eq
2400be52:	2301      	moveq	r3, #1
2400be54:	2300      	movne	r3, #0
2400be56:	b2db      	uxtb	r3, r3
2400be58:	77fb      	strb	r3, [r7, #31]
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400be5a:	68fb      	ldr	r3, [r7, #12]
2400be5c:	681b      	ldr	r3, [r3, #0]
2400be5e:	699b      	ldr	r3, [r3, #24]
2400be60:	f003 0310 	and.w	r3, r3, #16
2400be64:	2b10      	cmp	r3, #16
2400be66:	bf0c      	ite	eq
2400be68:	2301      	moveq	r3, #1
2400be6a:	2300      	movne	r3, #0
2400be6c:	b2db      	uxtb	r3, r3
2400be6e:	77bb      	strb	r3, [r7, #30]

      while ((tmp1 == RESET) && (tmp2 == RESET))
2400be70:	e034      	b.n	2400bedc <HAL_I2C_IsDeviceReady+0x11c>
      {
        if (Timeout != HAL_MAX_DELAY)
2400be72:	683b      	ldr	r3, [r7, #0]
2400be74:	f1b3 3fff 	cmp.w	r3, #4294967295
2400be78:	d01a      	beq.n	2400beb0 <HAL_I2C_IsDeviceReady+0xf0>
        {
          if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400be7a:	f7f6 fa63 	bl	24002344 <HAL_GetTick>
2400be7e:	4602      	mov	r2, r0
2400be80:	69bb      	ldr	r3, [r7, #24]
2400be82:	1ad3      	subs	r3, r2, r3
2400be84:	683a      	ldr	r2, [r7, #0]
2400be86:	429a      	cmp	r2, r3
2400be88:	d302      	bcc.n	2400be90 <HAL_I2C_IsDeviceReady+0xd0>
2400be8a:	683b      	ldr	r3, [r7, #0]
2400be8c:	2b00      	cmp	r3, #0
2400be8e:	d10f      	bne.n	2400beb0 <HAL_I2C_IsDeviceReady+0xf0>
          {
            /* Update I2C state */
            hi2c->State = HAL_I2C_STATE_READY;
2400be90:	68fb      	ldr	r3, [r7, #12]
2400be92:	2220      	movs	r2, #32
2400be94:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

            /* Update I2C error code */
            hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400be98:	68fb      	ldr	r3, [r7, #12]
2400be9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400be9c:	f043 0220 	orr.w	r2, r3, #32
2400bea0:	68fb      	ldr	r3, [r7, #12]
2400bea2:	645a      	str	r2, [r3, #68]	; 0x44

            /* Process Unlocked */
            __HAL_UNLOCK(hi2c);
2400bea4:	68fb      	ldr	r3, [r7, #12]
2400bea6:	2200      	movs	r2, #0
2400bea8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

            return HAL_ERROR;
2400beac:	2301      	movs	r3, #1
2400beae:	e088      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
          }
        }

        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF);
2400beb0:	68fb      	ldr	r3, [r7, #12]
2400beb2:	681b      	ldr	r3, [r3, #0]
2400beb4:	699b      	ldr	r3, [r3, #24]
2400beb6:	f003 0320 	and.w	r3, r3, #32
2400beba:	2b20      	cmp	r3, #32
2400bebc:	bf0c      	ite	eq
2400bebe:	2301      	moveq	r3, #1
2400bec0:	2300      	movne	r3, #0
2400bec2:	b2db      	uxtb	r3, r3
2400bec4:	77fb      	strb	r3, [r7, #31]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
2400bec6:	68fb      	ldr	r3, [r7, #12]
2400bec8:	681b      	ldr	r3, [r3, #0]
2400beca:	699b      	ldr	r3, [r3, #24]
2400becc:	f003 0310 	and.w	r3, r3, #16
2400bed0:	2b10      	cmp	r3, #16
2400bed2:	bf0c      	ite	eq
2400bed4:	2301      	moveq	r3, #1
2400bed6:	2300      	movne	r3, #0
2400bed8:	b2db      	uxtb	r3, r3
2400beda:	77bb      	strb	r3, [r7, #30]
      while ((tmp1 == RESET) && (tmp2 == RESET))
2400bedc:	7ffb      	ldrb	r3, [r7, #31]
2400bede:	2b00      	cmp	r3, #0
2400bee0:	d102      	bne.n	2400bee8 <HAL_I2C_IsDeviceReady+0x128>
2400bee2:	7fbb      	ldrb	r3, [r7, #30]
2400bee4:	2b00      	cmp	r3, #0
2400bee6:	d0c4      	beq.n	2400be72 <HAL_I2C_IsDeviceReady+0xb2>
      }

      /* Check if the NACKF flag has not been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
2400bee8:	68fb      	ldr	r3, [r7, #12]
2400beea:	681b      	ldr	r3, [r3, #0]
2400beec:	699b      	ldr	r3, [r3, #24]
2400beee:	f003 0310 	and.w	r3, r3, #16
2400bef2:	2b10      	cmp	r3, #16
2400bef4:	d01a      	beq.n	2400bf2c <HAL_I2C_IsDeviceReady+0x16c>
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400bef6:	69bb      	ldr	r3, [r7, #24]
2400bef8:	9300      	str	r3, [sp, #0]
2400befa:	683b      	ldr	r3, [r7, #0]
2400befc:	2200      	movs	r2, #0
2400befe:	2120      	movs	r1, #32
2400bf00:	68f8      	ldr	r0, [r7, #12]
2400bf02:	f002 fe5f 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400bf06:	4603      	mov	r3, r0
2400bf08:	2b00      	cmp	r3, #0
2400bf0a:	d001      	beq.n	2400bf10 <HAL_I2C_IsDeviceReady+0x150>
        {
          return HAL_ERROR;
2400bf0c:	2301      	movs	r3, #1
2400bf0e:	e058      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400bf10:	68fb      	ldr	r3, [r7, #12]
2400bf12:	681b      	ldr	r3, [r3, #0]
2400bf14:	2220      	movs	r2, #32
2400bf16:	61da      	str	r2, [r3, #28]

        /* Device is ready */
        hi2c->State = HAL_I2C_STATE_READY;
2400bf18:	68fb      	ldr	r3, [r7, #12]
2400bf1a:	2220      	movs	r2, #32
2400bf1c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400bf20:	68fb      	ldr	r3, [r7, #12]
2400bf22:	2200      	movs	r2, #0
2400bf24:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_OK;
2400bf28:	2300      	movs	r3, #0
2400bf2a:	e04a      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
      }
      else
      {
        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400bf2c:	69bb      	ldr	r3, [r7, #24]
2400bf2e:	9300      	str	r3, [sp, #0]
2400bf30:	683b      	ldr	r3, [r7, #0]
2400bf32:	2200      	movs	r2, #0
2400bf34:	2120      	movs	r1, #32
2400bf36:	68f8      	ldr	r0, [r7, #12]
2400bf38:	f002 fe44 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400bf3c:	4603      	mov	r3, r0
2400bf3e:	2b00      	cmp	r3, #0
2400bf40:	d001      	beq.n	2400bf46 <HAL_I2C_IsDeviceReady+0x186>
        {
          return HAL_ERROR;
2400bf42:	2301      	movs	r3, #1
2400bf44:	e03d      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400bf46:	68fb      	ldr	r3, [r7, #12]
2400bf48:	681b      	ldr	r3, [r3, #0]
2400bf4a:	2210      	movs	r2, #16
2400bf4c:	61da      	str	r2, [r3, #28]

        /* Clear STOP Flag, auto generated with autoend*/
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400bf4e:	68fb      	ldr	r3, [r7, #12]
2400bf50:	681b      	ldr	r3, [r3, #0]
2400bf52:	2220      	movs	r2, #32
2400bf54:	61da      	str	r2, [r3, #28]
      }

      /* Check if the maximum allowed number of trials has been reached */
      if (I2C_Trials == Trials)
2400bf56:	697b      	ldr	r3, [r7, #20]
2400bf58:	687a      	ldr	r2, [r7, #4]
2400bf5a:	429a      	cmp	r2, r3
2400bf5c:	d118      	bne.n	2400bf90 <HAL_I2C_IsDeviceReady+0x1d0>
      {
        /* Generate Stop */
        hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400bf5e:	68fb      	ldr	r3, [r7, #12]
2400bf60:	681b      	ldr	r3, [r3, #0]
2400bf62:	685a      	ldr	r2, [r3, #4]
2400bf64:	68fb      	ldr	r3, [r7, #12]
2400bf66:	681b      	ldr	r3, [r3, #0]
2400bf68:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400bf6c:	605a      	str	r2, [r3, #4]

        /* Wait until STOPF flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout, tickstart) != HAL_OK)
2400bf6e:	69bb      	ldr	r3, [r7, #24]
2400bf70:	9300      	str	r3, [sp, #0]
2400bf72:	683b      	ldr	r3, [r7, #0]
2400bf74:	2200      	movs	r2, #0
2400bf76:	2120      	movs	r1, #32
2400bf78:	68f8      	ldr	r0, [r7, #12]
2400bf7a:	f002 fe23 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400bf7e:	4603      	mov	r3, r0
2400bf80:	2b00      	cmp	r3, #0
2400bf82:	d001      	beq.n	2400bf88 <HAL_I2C_IsDeviceReady+0x1c8>
        {
          return HAL_ERROR;
2400bf84:	2301      	movs	r3, #1
2400bf86:	e01c      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400bf88:	68fb      	ldr	r3, [r7, #12]
2400bf8a:	681b      	ldr	r3, [r3, #0]
2400bf8c:	2220      	movs	r2, #32
2400bf8e:	61da      	str	r2, [r3, #28]
      }

      /* Increment Trials */
      I2C_Trials++;
2400bf90:	697b      	ldr	r3, [r7, #20]
2400bf92:	3301      	adds	r3, #1
2400bf94:	617b      	str	r3, [r7, #20]
    } while (I2C_Trials < Trials);
2400bf96:	697b      	ldr	r3, [r7, #20]
2400bf98:	687a      	ldr	r2, [r7, #4]
2400bf9a:	429a      	cmp	r2, r3
2400bf9c:	f63f af3d 	bhi.w	2400be1a <HAL_I2C_IsDeviceReady+0x5a>

    /* Update I2C state */
    hi2c->State = HAL_I2C_STATE_READY;
2400bfa0:	68fb      	ldr	r3, [r7, #12]
2400bfa2:	2220      	movs	r2, #32
2400bfa4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Update I2C error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400bfa8:	68fb      	ldr	r3, [r7, #12]
2400bfaa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400bfac:	f043 0220 	orr.w	r2, r3, #32
2400bfb0:	68fb      	ldr	r3, [r7, #12]
2400bfb2:	645a      	str	r2, [r3, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400bfb4:	68fb      	ldr	r3, [r7, #12]
2400bfb6:	2200      	movs	r2, #0
2400bfb8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
2400bfbc:	2301      	movs	r3, #1
2400bfbe:	e000      	b.n	2400bfc2 <HAL_I2C_IsDeviceReady+0x202>
  }
  else
  {
    return HAL_BUSY;
2400bfc0:	2302      	movs	r3, #2
  }
}
2400bfc2:	4618      	mov	r0, r3
2400bfc4:	3720      	adds	r7, #32
2400bfc6:	46bd      	mov	sp, r7
2400bfc8:	bd80      	pop	{r7, pc}
2400bfca:	bf00      	nop
2400bfcc:	02002000 	.word	0x02002000

2400bfd0 <HAL_I2C_Master_Seq_Transmit_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                 uint16_t Size, uint32_t XferOptions)
{
2400bfd0:	b580      	push	{r7, lr}
2400bfd2:	b088      	sub	sp, #32
2400bfd4:	af02      	add	r7, sp, #8
2400bfd6:	60f8      	str	r0, [r7, #12]
2400bfd8:	607a      	str	r2, [r7, #4]
2400bfda:	461a      	mov	r2, r3
2400bfdc:	460b      	mov	r3, r1
2400bfde:	817b      	strh	r3, [r7, #10]
2400bfe0:	4613      	mov	r3, r2
2400bfe2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400bfe4:	4b3a      	ldr	r3, [pc, #232]	; (2400c0d0 <HAL_I2C_Master_Seq_Transmit_IT+0x100>)
2400bfe6:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400bfe8:	68fb      	ldr	r3, [r7, #12]
2400bfea:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400bfee:	b2db      	uxtb	r3, r3
2400bff0:	2b20      	cmp	r3, #32
2400bff2:	d167      	bne.n	2400c0c4 <HAL_I2C_Master_Seq_Transmit_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400bff4:	68fb      	ldr	r3, [r7, #12]
2400bff6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400bffa:	2b01      	cmp	r3, #1
2400bffc:	d101      	bne.n	2400c002 <HAL_I2C_Master_Seq_Transmit_IT+0x32>
2400bffe:	2302      	movs	r3, #2
2400c000:	e061      	b.n	2400c0c6 <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
2400c002:	68fb      	ldr	r3, [r7, #12]
2400c004:	2201      	movs	r2, #1
2400c006:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400c00a:	68fb      	ldr	r3, [r7, #12]
2400c00c:	2221      	movs	r2, #33	; 0x21
2400c00e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400c012:	68fb      	ldr	r3, [r7, #12]
2400c014:	2210      	movs	r2, #16
2400c016:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c01a:	68fb      	ldr	r3, [r7, #12]
2400c01c:	2200      	movs	r2, #0
2400c01e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c020:	68fb      	ldr	r3, [r7, #12]
2400c022:	687a      	ldr	r2, [r7, #4]
2400c024:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c026:	68fb      	ldr	r3, [r7, #12]
2400c028:	893a      	ldrh	r2, [r7, #8]
2400c02a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400c02c:	68fb      	ldr	r3, [r7, #12]
2400c02e:	6a3a      	ldr	r2, [r7, #32]
2400c030:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400c032:	68fb      	ldr	r3, [r7, #12]
2400c034:	4a27      	ldr	r2, [pc, #156]	; (2400c0d4 <HAL_I2C_Master_Seq_Transmit_IT+0x104>)
2400c036:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c038:	68fb      	ldr	r3, [r7, #12]
2400c03a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c03c:	b29b      	uxth	r3, r3
2400c03e:	2bff      	cmp	r3, #255	; 0xff
2400c040:	d906      	bls.n	2400c050 <HAL_I2C_Master_Seq_Transmit_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400c042:	68fb      	ldr	r3, [r7, #12]
2400c044:	22ff      	movs	r2, #255	; 0xff
2400c046:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400c048:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c04c:	617b      	str	r3, [r7, #20]
2400c04e:	e007      	b.n	2400c060 <HAL_I2C_Master_Seq_Transmit_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400c050:	68fb      	ldr	r3, [r7, #12]
2400c052:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c054:	b29a      	uxth	r2, r3
2400c056:	68fb      	ldr	r3, [r7, #12]
2400c058:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400c05a:	68fb      	ldr	r3, [r7, #12]
2400c05c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c05e:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400c060:	68fb      	ldr	r3, [r7, #12]
2400c062:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400c064:	2b11      	cmp	r3, #17
2400c066:	d10e      	bne.n	2400c086 <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400c068:	6a3b      	ldr	r3, [r7, #32]
2400c06a:	2baa      	cmp	r3, #170	; 0xaa
2400c06c:	d003      	beq.n	2400c076 <HAL_I2C_Master_Seq_Transmit_IT+0xa6>
2400c06e:	6a3b      	ldr	r3, [r7, #32]
2400c070:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400c074:	d101      	bne.n	2400c07a <HAL_I2C_Master_Seq_Transmit_IT+0xaa>
2400c076:	2301      	movs	r3, #1
2400c078:	e000      	b.n	2400c07c <HAL_I2C_Master_Seq_Transmit_IT+0xac>
2400c07a:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400c07c:	2b00      	cmp	r3, #0
2400c07e:	d102      	bne.n	2400c086 <HAL_I2C_Master_Seq_Transmit_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400c080:	2300      	movs	r3, #0
2400c082:	613b      	str	r3, [r7, #16]
2400c084:	e00a      	b.n	2400c09c <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400c086:	68f8      	ldr	r0, [r7, #12]
2400c088:	f003 f8b2 	bl	2400f1f0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400c08c:	68fb      	ldr	r3, [r7, #12]
2400c08e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c090:	b29b      	uxth	r3, r3
2400c092:	2bff      	cmp	r3, #255	; 0xff
2400c094:	d802      	bhi.n	2400c09c <HAL_I2C_Master_Seq_Transmit_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400c096:	68fb      	ldr	r3, [r7, #12]
2400c098:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c09a:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to write */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400c09c:	68fb      	ldr	r3, [r7, #12]
2400c09e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c0a0:	b2da      	uxtb	r2, r3
2400c0a2:	8979      	ldrh	r1, [r7, #10]
2400c0a4:	693b      	ldr	r3, [r7, #16]
2400c0a6:	9300      	str	r3, [sp, #0]
2400c0a8:	697b      	ldr	r3, [r7, #20]
2400c0aa:	68f8      	ldr	r0, [r7, #12]
2400c0ac:	f002 ffac 	bl	2400f008 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c0b0:	68fb      	ldr	r3, [r7, #12]
2400c0b2:	2200      	movs	r2, #0
2400c0b4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400c0b8:	2101      	movs	r1, #1
2400c0ba:	68f8      	ldr	r0, [r7, #12]
2400c0bc:	f002 ffd6 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400c0c0:	2300      	movs	r3, #0
2400c0c2:	e000      	b.n	2400c0c6 <HAL_I2C_Master_Seq_Transmit_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400c0c4:	2302      	movs	r3, #2
  }
}
2400c0c6:	4618      	mov	r0, r3
2400c0c8:	3718      	adds	r7, #24
2400c0ca:	46bd      	mov	sp, r7
2400c0cc:	bd80      	pop	{r7, pc}
2400c0ce:	bf00      	nop
2400c0d0:	80002000 	.word	0x80002000
2400c0d4:	2400d0af 	.word	0x2400d0af

2400c0d8 <HAL_I2C_Master_Seq_Transmit_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                  uint16_t Size, uint32_t XferOptions)
{
2400c0d8:	b580      	push	{r7, lr}
2400c0da:	b08a      	sub	sp, #40	; 0x28
2400c0dc:	af02      	add	r7, sp, #8
2400c0de:	60f8      	str	r0, [r7, #12]
2400c0e0:	607a      	str	r2, [r7, #4]
2400c0e2:	461a      	mov	r2, r3
2400c0e4:	460b      	mov	r3, r1
2400c0e6:	817b      	strh	r3, [r7, #10]
2400c0e8:	4613      	mov	r3, r2
2400c0ea:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_WRITE;
2400c0ec:	4b77      	ldr	r3, [pc, #476]	; (2400c2cc <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400c0ee:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400c0f0:	68fb      	ldr	r3, [r7, #12]
2400c0f2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c0f6:	b2db      	uxtb	r3, r3
2400c0f8:	2b20      	cmp	r3, #32
2400c0fa:	f040 80e1 	bne.w	2400c2c0 <HAL_I2C_Master_Seq_Transmit_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c0fe:	68fb      	ldr	r3, [r7, #12]
2400c100:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c104:	2b01      	cmp	r3, #1
2400c106:	d101      	bne.n	2400c10c <HAL_I2C_Master_Seq_Transmit_DMA+0x34>
2400c108:	2302      	movs	r3, #2
2400c10a:	e0da      	b.n	2400c2c2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
2400c10c:	68fb      	ldr	r3, [r7, #12]
2400c10e:	2201      	movs	r2, #1
2400c110:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
2400c114:	68fb      	ldr	r3, [r7, #12]
2400c116:	2221      	movs	r2, #33	; 0x21
2400c118:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400c11c:	68fb      	ldr	r3, [r7, #12]
2400c11e:	2210      	movs	r2, #16
2400c120:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c124:	68fb      	ldr	r3, [r7, #12]
2400c126:	2200      	movs	r2, #0
2400c128:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c12a:	68fb      	ldr	r3, [r7, #12]
2400c12c:	687a      	ldr	r2, [r7, #4]
2400c12e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c130:	68fb      	ldr	r3, [r7, #12]
2400c132:	893a      	ldrh	r2, [r7, #8]
2400c134:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400c136:	68fb      	ldr	r3, [r7, #12]
2400c138:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400c13a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400c13c:	68fb      	ldr	r3, [r7, #12]
2400c13e:	4a64      	ldr	r2, [pc, #400]	; (2400c2d0 <HAL_I2C_Master_Seq_Transmit_DMA+0x1f8>)
2400c140:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c142:	68fb      	ldr	r3, [r7, #12]
2400c144:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c146:	b29b      	uxth	r3, r3
2400c148:	2bff      	cmp	r3, #255	; 0xff
2400c14a:	d906      	bls.n	2400c15a <HAL_I2C_Master_Seq_Transmit_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400c14c:	68fb      	ldr	r3, [r7, #12]
2400c14e:	22ff      	movs	r2, #255	; 0xff
2400c150:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400c152:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c156:	61fb      	str	r3, [r7, #28]
2400c158:	e007      	b.n	2400c16a <HAL_I2C_Master_Seq_Transmit_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400c15a:	68fb      	ldr	r3, [r7, #12]
2400c15c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c15e:	b29a      	uxth	r2, r3
2400c160:	68fb      	ldr	r3, [r7, #12]
2400c162:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400c164:	68fb      	ldr	r3, [r7, #12]
2400c166:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c168:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400c16a:	68fb      	ldr	r3, [r7, #12]
2400c16c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400c16e:	2b11      	cmp	r3, #17
2400c170:	d10e      	bne.n	2400c190 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400c172:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400c174:	2baa      	cmp	r3, #170	; 0xaa
2400c176:	d003      	beq.n	2400c180 <HAL_I2C_Master_Seq_Transmit_DMA+0xa8>
2400c178:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400c17a:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400c17e:	d101      	bne.n	2400c184 <HAL_I2C_Master_Seq_Transmit_DMA+0xac>
2400c180:	2301      	movs	r3, #1
2400c182:	e000      	b.n	2400c186 <HAL_I2C_Master_Seq_Transmit_DMA+0xae>
2400c184:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX) && \
2400c186:	2b00      	cmp	r3, #0
2400c188:	d102      	bne.n	2400c190 <HAL_I2C_Master_Seq_Transmit_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400c18a:	2300      	movs	r3, #0
2400c18c:	61bb      	str	r3, [r7, #24]
2400c18e:	e00a      	b.n	2400c1a6 <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400c190:	68f8      	ldr	r0, [r7, #12]
2400c192:	f003 f82d 	bl	2400f1f0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400c196:	68fb      	ldr	r3, [r7, #12]
2400c198:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c19a:	b29b      	uxth	r3, r3
2400c19c:	2bff      	cmp	r3, #255	; 0xff
2400c19e:	d802      	bhi.n	2400c1a6 <HAL_I2C_Master_Seq_Transmit_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400c1a0:	68fb      	ldr	r3, [r7, #12]
2400c1a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c1a4:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400c1a6:	68fb      	ldr	r3, [r7, #12]
2400c1a8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c1aa:	2b00      	cmp	r3, #0
2400c1ac:	d070      	beq.n	2400c290 <HAL_I2C_Master_Seq_Transmit_DMA+0x1b8>
    {
      if (hi2c->hdmatx != NULL)
2400c1ae:	68fb      	ldr	r3, [r7, #12]
2400c1b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c1b2:	2b00      	cmp	r3, #0
2400c1b4:	d020      	beq.n	2400c1f8 <HAL_I2C_Master_Seq_Transmit_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
2400c1b6:	68fb      	ldr	r3, [r7, #12]
2400c1b8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c1ba:	4a46      	ldr	r2, [pc, #280]	; (2400c2d4 <HAL_I2C_Master_Seq_Transmit_DMA+0x1fc>)
2400c1bc:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400c1be:	68fb      	ldr	r3, [r7, #12]
2400c1c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c1c2:	4a45      	ldr	r2, [pc, #276]	; (2400c2d8 <HAL_I2C_Master_Seq_Transmit_DMA+0x200>)
2400c1c4:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400c1c6:	68fb      	ldr	r3, [r7, #12]
2400c1c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c1ca:	2200      	movs	r2, #0
2400c1cc:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
2400c1ce:	68fb      	ldr	r3, [r7, #12]
2400c1d0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c1d2:	2200      	movs	r2, #0
2400c1d4:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400c1d6:	68fb      	ldr	r3, [r7, #12]
2400c1d8:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400c1da:	6879      	ldr	r1, [r7, #4]
2400c1dc:	68fb      	ldr	r3, [r7, #12]
2400c1de:	681b      	ldr	r3, [r3, #0]
2400c1e0:	3328      	adds	r3, #40	; 0x28
2400c1e2:	461a      	mov	r2, r3
                                         hi2c->XferSize);
2400c1e4:	68fb      	ldr	r3, [r7, #12]
2400c1e6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400c1e8:	f7f7 fe46 	bl	24003e78 <HAL_DMA_Start_IT>
2400c1ec:	4603      	mov	r3, r0
2400c1ee:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400c1f0:	7dfb      	ldrb	r3, [r7, #23]
2400c1f2:	2b00      	cmp	r3, #0
2400c1f4:	d138      	bne.n	2400c268 <HAL_I2C_Master_Seq_Transmit_DMA+0x190>
2400c1f6:	e013      	b.n	2400c220 <HAL_I2C_Master_Seq_Transmit_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400c1f8:	68fb      	ldr	r3, [r7, #12]
2400c1fa:	2220      	movs	r2, #32
2400c1fc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c200:	68fb      	ldr	r3, [r7, #12]
2400c202:	2200      	movs	r2, #0
2400c204:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400c208:	68fb      	ldr	r3, [r7, #12]
2400c20a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c20c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400c210:	68fb      	ldr	r3, [r7, #12]
2400c212:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400c214:	68fb      	ldr	r3, [r7, #12]
2400c216:	2200      	movs	r2, #0
2400c218:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400c21c:	2301      	movs	r3, #1
2400c21e:	e050      	b.n	2400c2c2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to write */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400c220:	68fb      	ldr	r3, [r7, #12]
2400c222:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c224:	b2da      	uxtb	r2, r3
2400c226:	8979      	ldrh	r1, [r7, #10]
2400c228:	69bb      	ldr	r3, [r7, #24]
2400c22a:	9300      	str	r3, [sp, #0]
2400c22c:	69fb      	ldr	r3, [r7, #28]
2400c22e:	68f8      	ldr	r0, [r7, #12]
2400c230:	f002 feea 	bl	2400f008 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400c234:	68fb      	ldr	r3, [r7, #12]
2400c236:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c238:	b29a      	uxth	r2, r3
2400c23a:	68fb      	ldr	r3, [r7, #12]
2400c23c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c23e:	1ad3      	subs	r3, r2, r3
2400c240:	b29a      	uxth	r2, r3
2400c242:	68fb      	ldr	r3, [r7, #12]
2400c244:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400c246:	68fb      	ldr	r3, [r7, #12]
2400c248:	2200      	movs	r2, #0
2400c24a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400c24e:	2110      	movs	r1, #16
2400c250:	68f8      	ldr	r0, [r7, #12]
2400c252:	f002 ff0b 	bl	2400f06c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400c256:	68fb      	ldr	r3, [r7, #12]
2400c258:	681b      	ldr	r3, [r3, #0]
2400c25a:	681a      	ldr	r2, [r3, #0]
2400c25c:	68fb      	ldr	r3, [r7, #12]
2400c25e:	681b      	ldr	r3, [r3, #0]
2400c260:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c264:	601a      	str	r2, [r3, #0]
2400c266:	e029      	b.n	2400c2bc <HAL_I2C_Master_Seq_Transmit_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400c268:	68fb      	ldr	r3, [r7, #12]
2400c26a:	2220      	movs	r2, #32
2400c26c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c270:	68fb      	ldr	r3, [r7, #12]
2400c272:	2200      	movs	r2, #0
2400c274:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400c278:	68fb      	ldr	r3, [r7, #12]
2400c27a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c27c:	f043 0210 	orr.w	r2, r3, #16
2400c280:	68fb      	ldr	r3, [r7, #12]
2400c282:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400c284:	68fb      	ldr	r3, [r7, #12]
2400c286:	2200      	movs	r2, #0
2400c288:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400c28c:	2301      	movs	r3, #1
2400c28e:	e018      	b.n	2400c2c2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400c290:	68fb      	ldr	r3, [r7, #12]
2400c292:	4a12      	ldr	r2, [pc, #72]	; (2400c2dc <HAL_I2C_Master_Seq_Transmit_DMA+0x204>)
2400c294:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to write and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400c296:	68fb      	ldr	r3, [r7, #12]
2400c298:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c29a:	b2da      	uxtb	r2, r3
2400c29c:	8979      	ldrh	r1, [r7, #10]
2400c29e:	4b0b      	ldr	r3, [pc, #44]	; (2400c2cc <HAL_I2C_Master_Seq_Transmit_DMA+0x1f4>)
2400c2a0:	9300      	str	r3, [sp, #0]
2400c2a2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400c2a6:	68f8      	ldr	r0, [r7, #12]
2400c2a8:	f002 feae 	bl	2400f008 <I2C_TransferConfig>
                         I2C_GENERATE_START_WRITE);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400c2ac:	68fb      	ldr	r3, [r7, #12]
2400c2ae:	2200      	movs	r2, #0
2400c2b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400c2b4:	2101      	movs	r1, #1
2400c2b6:	68f8      	ldr	r0, [r7, #12]
2400c2b8:	f002 fed8 	bl	2400f06c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400c2bc:	2300      	movs	r3, #0
2400c2be:	e000      	b.n	2400c2c2 <HAL_I2C_Master_Seq_Transmit_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400c2c0:	2302      	movs	r3, #2
  }
}
2400c2c2:	4618      	mov	r0, r3
2400c2c4:	3720      	adds	r7, #32
2400c2c6:	46bd      	mov	sp, r7
2400c2c8:	bd80      	pop	{r7, pc}
2400c2ca:	bf00      	nop
2400c2cc:	80002000 	.word	0x80002000
2400c2d0:	2400d4d7 	.word	0x2400d4d7
2400c2d4:	2400e643 	.word	0x2400e643
2400c2d8:	2400e915 	.word	0x2400e915
2400c2dc:	2400d0af 	.word	0x2400d0af

2400c2e0 <HAL_I2C_Master_Seq_Receive_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                uint16_t Size, uint32_t XferOptions)
{
2400c2e0:	b580      	push	{r7, lr}
2400c2e2:	b088      	sub	sp, #32
2400c2e4:	af02      	add	r7, sp, #8
2400c2e6:	60f8      	str	r0, [r7, #12]
2400c2e8:	607a      	str	r2, [r7, #4]
2400c2ea:	461a      	mov	r2, r3
2400c2ec:	460b      	mov	r3, r1
2400c2ee:	817b      	strh	r3, [r7, #10]
2400c2f0:	4613      	mov	r3, r2
2400c2f2:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400c2f4:	4b3a      	ldr	r3, [pc, #232]	; (2400c3e0 <HAL_I2C_Master_Seq_Receive_IT+0x100>)
2400c2f6:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400c2f8:	68fb      	ldr	r3, [r7, #12]
2400c2fa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c2fe:	b2db      	uxtb	r3, r3
2400c300:	2b20      	cmp	r3, #32
2400c302:	d167      	bne.n	2400c3d4 <HAL_I2C_Master_Seq_Receive_IT+0xf4>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c304:	68fb      	ldr	r3, [r7, #12]
2400c306:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c30a:	2b01      	cmp	r3, #1
2400c30c:	d101      	bne.n	2400c312 <HAL_I2C_Master_Seq_Receive_IT+0x32>
2400c30e:	2302      	movs	r3, #2
2400c310:	e061      	b.n	2400c3d6 <HAL_I2C_Master_Seq_Receive_IT+0xf6>
2400c312:	68fb      	ldr	r3, [r7, #12]
2400c314:	2201      	movs	r2, #1
2400c316:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400c31a:	68fb      	ldr	r3, [r7, #12]
2400c31c:	2222      	movs	r2, #34	; 0x22
2400c31e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400c322:	68fb      	ldr	r3, [r7, #12]
2400c324:	2210      	movs	r2, #16
2400c326:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c32a:	68fb      	ldr	r3, [r7, #12]
2400c32c:	2200      	movs	r2, #0
2400c32e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c330:	68fb      	ldr	r3, [r7, #12]
2400c332:	687a      	ldr	r2, [r7, #4]
2400c334:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c336:	68fb      	ldr	r3, [r7, #12]
2400c338:	893a      	ldrh	r2, [r7, #8]
2400c33a:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400c33c:	68fb      	ldr	r3, [r7, #12]
2400c33e:	6a3a      	ldr	r2, [r7, #32]
2400c340:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
2400c342:	68fb      	ldr	r3, [r7, #12]
2400c344:	4a27      	ldr	r2, [pc, #156]	; (2400c3e4 <HAL_I2C_Master_Seq_Receive_IT+0x104>)
2400c346:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c348:	68fb      	ldr	r3, [r7, #12]
2400c34a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c34c:	b29b      	uxth	r3, r3
2400c34e:	2bff      	cmp	r3, #255	; 0xff
2400c350:	d906      	bls.n	2400c360 <HAL_I2C_Master_Seq_Receive_IT+0x80>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400c352:	68fb      	ldr	r3, [r7, #12]
2400c354:	22ff      	movs	r2, #255	; 0xff
2400c356:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400c358:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c35c:	617b      	str	r3, [r7, #20]
2400c35e:	e007      	b.n	2400c370 <HAL_I2C_Master_Seq_Receive_IT+0x90>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400c360:	68fb      	ldr	r3, [r7, #12]
2400c362:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c364:	b29a      	uxth	r2, r3
2400c366:	68fb      	ldr	r3, [r7, #12]
2400c368:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400c36a:	68fb      	ldr	r3, [r7, #12]
2400c36c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c36e:	617b      	str	r3, [r7, #20]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c370:	68fb      	ldr	r3, [r7, #12]
2400c372:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400c374:	2b12      	cmp	r3, #18
2400c376:	d10e      	bne.n	2400c396 <HAL_I2C_Master_Seq_Receive_IT+0xb6>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400c378:	6a3b      	ldr	r3, [r7, #32]
2400c37a:	2baa      	cmp	r3, #170	; 0xaa
2400c37c:	d003      	beq.n	2400c386 <HAL_I2C_Master_Seq_Receive_IT+0xa6>
2400c37e:	6a3b      	ldr	r3, [r7, #32]
2400c380:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400c384:	d101      	bne.n	2400c38a <HAL_I2C_Master_Seq_Receive_IT+0xaa>
2400c386:	2301      	movs	r3, #1
2400c388:	e000      	b.n	2400c38c <HAL_I2C_Master_Seq_Receive_IT+0xac>
2400c38a:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c38c:	2b00      	cmp	r3, #0
2400c38e:	d102      	bne.n	2400c396 <HAL_I2C_Master_Seq_Receive_IT+0xb6>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400c390:	2300      	movs	r3, #0
2400c392:	613b      	str	r3, [r7, #16]
2400c394:	e00a      	b.n	2400c3ac <HAL_I2C_Master_Seq_Receive_IT+0xcc>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400c396:	68f8      	ldr	r0, [r7, #12]
2400c398:	f002 ff2a 	bl	2400f1f0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400c39c:	68fb      	ldr	r3, [r7, #12]
2400c39e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c3a0:	b29b      	uxth	r3, r3
2400c3a2:	2bff      	cmp	r3, #255	; 0xff
2400c3a4:	d802      	bhi.n	2400c3ac <HAL_I2C_Master_Seq_Receive_IT+0xcc>
      {
        xfermode = hi2c->XferOptions;
2400c3a6:	68fb      	ldr	r3, [r7, #12]
2400c3a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c3aa:	617b      	str	r3, [r7, #20]
      }
    }

    /* Send Slave Address and set NBYTES to read */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400c3ac:	68fb      	ldr	r3, [r7, #12]
2400c3ae:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c3b0:	b2da      	uxtb	r2, r3
2400c3b2:	8979      	ldrh	r1, [r7, #10]
2400c3b4:	693b      	ldr	r3, [r7, #16]
2400c3b6:	9300      	str	r3, [sp, #0]
2400c3b8:	697b      	ldr	r3, [r7, #20]
2400c3ba:	68f8      	ldr	r0, [r7, #12]
2400c3bc:	f002 fe24 	bl	2400f008 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c3c0:	68fb      	ldr	r3, [r7, #12]
2400c3c2:	2200      	movs	r2, #0
2400c3c4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
2400c3c8:	2102      	movs	r1, #2
2400c3ca:	68f8      	ldr	r0, [r7, #12]
2400c3cc:	f002 fe4e 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400c3d0:	2300      	movs	r3, #0
2400c3d2:	e000      	b.n	2400c3d6 <HAL_I2C_Master_Seq_Receive_IT+0xf6>
  }
  else
  {
    return HAL_BUSY;
2400c3d4:	2302      	movs	r3, #2
  }
}
2400c3d6:	4618      	mov	r0, r3
2400c3d8:	3718      	adds	r7, #24
2400c3da:	46bd      	mov	sp, r7
2400c3dc:	bd80      	pop	{r7, pc}
2400c3de:	bf00      	nop
2400c3e0:	80002400 	.word	0x80002400
2400c3e4:	2400d0af 	.word	0x2400d0af

2400c3e8 <HAL_I2C_Master_Seq_Receive_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                                 uint16_t Size, uint32_t XferOptions)
{
2400c3e8:	b580      	push	{r7, lr}
2400c3ea:	b08a      	sub	sp, #40	; 0x28
2400c3ec:	af02      	add	r7, sp, #8
2400c3ee:	60f8      	str	r0, [r7, #12]
2400c3f0:	607a      	str	r2, [r7, #4]
2400c3f2:	461a      	mov	r2, r3
2400c3f4:	460b      	mov	r3, r1
2400c3f6:	817b      	strh	r3, [r7, #10]
2400c3f8:	4613      	mov	r3, r2
2400c3fa:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;
  uint32_t xferrequest = I2C_GENERATE_START_READ;
2400c3fc:	4b77      	ldr	r3, [pc, #476]	; (2400c5dc <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400c3fe:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400c400:	68fb      	ldr	r3, [r7, #12]
2400c402:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c406:	b2db      	uxtb	r3, r3
2400c408:	2b20      	cmp	r3, #32
2400c40a:	f040 80e1 	bne.w	2400c5d0 <HAL_I2C_Master_Seq_Receive_DMA+0x1e8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c40e:	68fb      	ldr	r3, [r7, #12]
2400c410:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c414:	2b01      	cmp	r3, #1
2400c416:	d101      	bne.n	2400c41c <HAL_I2C_Master_Seq_Receive_DMA+0x34>
2400c418:	2302      	movs	r3, #2
2400c41a:	e0da      	b.n	2400c5d2 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
2400c41c:	68fb      	ldr	r3, [r7, #12]
2400c41e:	2201      	movs	r2, #1
2400c420:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
2400c424:	68fb      	ldr	r3, [r7, #12]
2400c426:	2222      	movs	r2, #34	; 0x22
2400c428:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
2400c42c:	68fb      	ldr	r3, [r7, #12]
2400c42e:	2210      	movs	r2, #16
2400c430:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c434:	68fb      	ldr	r3, [r7, #12]
2400c436:	2200      	movs	r2, #0
2400c438:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c43a:	68fb      	ldr	r3, [r7, #12]
2400c43c:	687a      	ldr	r2, [r7, #4]
2400c43e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c440:	68fb      	ldr	r3, [r7, #12]
2400c442:	893a      	ldrh	r2, [r7, #8]
2400c444:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferOptions = XferOptions;
2400c446:	68fb      	ldr	r3, [r7, #12]
2400c448:	6aba      	ldr	r2, [r7, #40]	; 0x28
2400c44a:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Master_ISR_DMA;
2400c44c:	68fb      	ldr	r3, [r7, #12]
2400c44e:	4a64      	ldr	r2, [pc, #400]	; (2400c5e0 <HAL_I2C_Master_Seq_Receive_DMA+0x1f8>)
2400c450:	635a      	str	r2, [r3, #52]	; 0x34

    /* If hi2c->XferCount > MAX_NBYTE_SIZE, use reload mode */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400c452:	68fb      	ldr	r3, [r7, #12]
2400c454:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c456:	b29b      	uxth	r3, r3
2400c458:	2bff      	cmp	r3, #255	; 0xff
2400c45a:	d906      	bls.n	2400c46a <HAL_I2C_Master_Seq_Receive_DMA+0x82>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400c45c:	68fb      	ldr	r3, [r7, #12]
2400c45e:	22ff      	movs	r2, #255	; 0xff
2400c460:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = I2C_RELOAD_MODE;
2400c462:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400c466:	61fb      	str	r3, [r7, #28]
2400c468:	e007      	b.n	2400c47a <HAL_I2C_Master_Seq_Receive_DMA+0x92>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
2400c46a:	68fb      	ldr	r3, [r7, #12]
2400c46c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c46e:	b29a      	uxth	r2, r3
2400c470:	68fb      	ldr	r3, [r7, #12]
2400c472:	851a      	strh	r2, [r3, #40]	; 0x28
      xfermode = hi2c->XferOptions;
2400c474:	68fb      	ldr	r3, [r7, #12]
2400c476:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c478:	61fb      	str	r3, [r7, #28]
    }

    /* If transfer direction not change and there is no request to start another frame,
       do not generate Restart Condition */
    /* Mean Previous state is same as current state */
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c47a:	68fb      	ldr	r3, [r7, #12]
2400c47c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400c47e:	2b12      	cmp	r3, #18
2400c480:	d10e      	bne.n	2400c4a0 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
        (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 0))
2400c482:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400c484:	2baa      	cmp	r3, #170	; 0xaa
2400c486:	d003      	beq.n	2400c490 <HAL_I2C_Master_Seq_Receive_DMA+0xa8>
2400c488:	6abb      	ldr	r3, [r7, #40]	; 0x28
2400c48a:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400c48e:	d101      	bne.n	2400c494 <HAL_I2C_Master_Seq_Receive_DMA+0xac>
2400c490:	2301      	movs	r3, #1
2400c492:	e000      	b.n	2400c496 <HAL_I2C_Master_Seq_Receive_DMA+0xae>
2400c494:	2300      	movs	r3, #0
    if ((hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX) && \
2400c496:	2b00      	cmp	r3, #0
2400c498:	d102      	bne.n	2400c4a0 <HAL_I2C_Master_Seq_Receive_DMA+0xb8>
    {
      xferrequest = I2C_NO_STARTSTOP;
2400c49a:	2300      	movs	r3, #0
2400c49c:	61bb      	str	r3, [r7, #24]
2400c49e:	e00a      	b.n	2400c4b6 <HAL_I2C_Master_Seq_Receive_DMA+0xce>
    }
    else
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
2400c4a0:	68f8      	ldr	r0, [r7, #12]
2400c4a2:	f002 fea5 	bl	2400f1f0 <I2C_ConvertOtherXferOptions>

      /* Update xfermode accordingly if no reload is necessary */
      if (hi2c->XferCount <= MAX_NBYTE_SIZE)
2400c4a6:	68fb      	ldr	r3, [r7, #12]
2400c4a8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c4aa:	b29b      	uxth	r3, r3
2400c4ac:	2bff      	cmp	r3, #255	; 0xff
2400c4ae:	d802      	bhi.n	2400c4b6 <HAL_I2C_Master_Seq_Receive_DMA+0xce>
      {
        xfermode = hi2c->XferOptions;
2400c4b0:	68fb      	ldr	r3, [r7, #12]
2400c4b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400c4b4:	61fb      	str	r3, [r7, #28]
      }
    }

    if (hi2c->XferSize > 0U)
2400c4b6:	68fb      	ldr	r3, [r7, #12]
2400c4b8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c4ba:	2b00      	cmp	r3, #0
2400c4bc:	d070      	beq.n	2400c5a0 <HAL_I2C_Master_Seq_Receive_DMA+0x1b8>
    {
      if (hi2c->hdmarx != NULL)
2400c4be:	68fb      	ldr	r3, [r7, #12]
2400c4c0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c4c2:	2b00      	cmp	r3, #0
2400c4c4:	d020      	beq.n	2400c508 <HAL_I2C_Master_Seq_Receive_DMA+0x120>
      {
        /* Set the I2C DMA transfer complete callback */
        hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
2400c4c6:	68fb      	ldr	r3, [r7, #12]
2400c4c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c4ca:	4a46      	ldr	r2, [pc, #280]	; (2400c5e4 <HAL_I2C_Master_Seq_Receive_DMA+0x1fc>)
2400c4cc:	63da      	str	r2, [r3, #60]	; 0x3c

        /* Set the DMA error callback */
        hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400c4ce:	68fb      	ldr	r3, [r7, #12]
2400c4d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c4d2:	4a45      	ldr	r2, [pc, #276]	; (2400c5e8 <HAL_I2C_Master_Seq_Receive_DMA+0x200>)
2400c4d4:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Set the unused DMA callbacks to NULL */
        hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400c4d6:	68fb      	ldr	r3, [r7, #12]
2400c4d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c4da:	2200      	movs	r2, #0
2400c4dc:	641a      	str	r2, [r3, #64]	; 0x40
        hi2c->hdmarx->XferAbortCallback = NULL;
2400c4de:	68fb      	ldr	r3, [r7, #12]
2400c4e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c4e2:	2200      	movs	r2, #0
2400c4e4:	651a      	str	r2, [r3, #80]	; 0x50

        /* Enable the DMA stream or channel depends on Instance */
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400c4e6:	68fb      	ldr	r3, [r7, #12]
2400c4e8:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400c4ea:	68fb      	ldr	r3, [r7, #12]
2400c4ec:	681b      	ldr	r3, [r3, #0]
2400c4ee:	3324      	adds	r3, #36	; 0x24
2400c4f0:	4619      	mov	r1, r3
2400c4f2:	687a      	ldr	r2, [r7, #4]
                                         hi2c->XferSize);
2400c4f4:	68fb      	ldr	r3, [r7, #12]
2400c4f6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData,
2400c4f8:	f7f7 fcbe 	bl	24003e78 <HAL_DMA_Start_IT>
2400c4fc:	4603      	mov	r3, r0
2400c4fe:	75fb      	strb	r3, [r7, #23]
        __HAL_UNLOCK(hi2c);

        return HAL_ERROR;
      }

      if (dmaxferstatus == HAL_OK)
2400c500:	7dfb      	ldrb	r3, [r7, #23]
2400c502:	2b00      	cmp	r3, #0
2400c504:	d138      	bne.n	2400c578 <HAL_I2C_Master_Seq_Receive_DMA+0x190>
2400c506:	e013      	b.n	2400c530 <HAL_I2C_Master_Seq_Receive_DMA+0x148>
        hi2c->State     = HAL_I2C_STATE_READY;
2400c508:	68fb      	ldr	r3, [r7, #12]
2400c50a:	2220      	movs	r2, #32
2400c50c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c510:	68fb      	ldr	r3, [r7, #12]
2400c512:	2200      	movs	r2, #0
2400c514:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400c518:	68fb      	ldr	r3, [r7, #12]
2400c51a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c51c:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400c520:	68fb      	ldr	r3, [r7, #12]
2400c522:	645a      	str	r2, [r3, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
2400c524:	68fb      	ldr	r3, [r7, #12]
2400c526:	2200      	movs	r2, #0
2400c528:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400c52c:	2301      	movs	r3, #1
2400c52e:	e050      	b.n	2400c5d2 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      {
        /* Send Slave Address and set NBYTES to read */
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, xferrequest);
2400c530:	68fb      	ldr	r3, [r7, #12]
2400c532:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c534:	b2da      	uxtb	r2, r3
2400c536:	8979      	ldrh	r1, [r7, #10]
2400c538:	69bb      	ldr	r3, [r7, #24]
2400c53a:	9300      	str	r3, [sp, #0]
2400c53c:	69fb      	ldr	r3, [r7, #28]
2400c53e:	68f8      	ldr	r0, [r7, #12]
2400c540:	f002 fd62 	bl	2400f008 <I2C_TransferConfig>

        /* Update XferCount value */
        hi2c->XferCount -= hi2c->XferSize;
2400c544:	68fb      	ldr	r3, [r7, #12]
2400c546:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c548:	b29a      	uxth	r2, r3
2400c54a:	68fb      	ldr	r3, [r7, #12]
2400c54c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c54e:	1ad3      	subs	r3, r2, r3
2400c550:	b29a      	uxth	r2, r3
2400c552:	68fb      	ldr	r3, [r7, #12]
2400c554:	855a      	strh	r2, [r3, #42]	; 0x2a

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400c556:	68fb      	ldr	r3, [r7, #12]
2400c558:	2200      	movs	r2, #0
2400c55a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Note : The I2C interrupts must be enabled after unlocking current process
                  to avoid the risk of I2C interrupt handle execution before current
                  process unlock */
        /* Enable ERR and NACK interrupts */
        I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
2400c55e:	2110      	movs	r1, #16
2400c560:	68f8      	ldr	r0, [r7, #12]
2400c562:	f002 fd83 	bl	2400f06c <I2C_Enable_IRQ>

        /* Enable DMA Request */
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400c566:	68fb      	ldr	r3, [r7, #12]
2400c568:	681b      	ldr	r3, [r3, #0]
2400c56a:	681a      	ldr	r2, [r3, #0]
2400c56c:	68fb      	ldr	r3, [r7, #12]
2400c56e:	681b      	ldr	r3, [r3, #0]
2400c570:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400c574:	601a      	str	r2, [r3, #0]
2400c576:	e029      	b.n	2400c5cc <HAL_I2C_Master_Seq_Receive_DMA+0x1e4>
      }
      else
      {
        /* Update I2C state */
        hi2c->State     = HAL_I2C_STATE_READY;
2400c578:	68fb      	ldr	r3, [r7, #12]
2400c57a:	2220      	movs	r2, #32
2400c57c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c580:	68fb      	ldr	r3, [r7, #12]
2400c582:	2200      	movs	r2, #0
2400c584:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Update I2C error code */
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400c588:	68fb      	ldr	r3, [r7, #12]
2400c58a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c58c:	f043 0210 	orr.w	r2, r3, #16
2400c590:	68fb      	ldr	r3, [r7, #12]
2400c592:	645a      	str	r2, [r3, #68]	; 0x44

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400c594:	68fb      	ldr	r3, [r7, #12]
2400c596:	2200      	movs	r2, #0
2400c598:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400c59c:	2301      	movs	r3, #1
2400c59e:	e018      	b.n	2400c5d2 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
      }
    }
    else
    {
      /* Update Transfer ISR function pointer */
      hi2c->XferISR = I2C_Master_ISR_IT;
2400c5a0:	68fb      	ldr	r3, [r7, #12]
2400c5a2:	4a12      	ldr	r2, [pc, #72]	; (2400c5ec <HAL_I2C_Master_Seq_Receive_DMA+0x204>)
2400c5a4:	635a      	str	r2, [r3, #52]	; 0x34

      /* Send Slave Address */
      /* Set NBYTES to read and generate START condition */
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
2400c5a6:	68fb      	ldr	r3, [r7, #12]
2400c5a8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c5aa:	b2da      	uxtb	r2, r3
2400c5ac:	8979      	ldrh	r1, [r7, #10]
2400c5ae:	4b0b      	ldr	r3, [pc, #44]	; (2400c5dc <HAL_I2C_Master_Seq_Receive_DMA+0x1f4>)
2400c5b0:	9300      	str	r3, [sp, #0]
2400c5b2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400c5b6:	68f8      	ldr	r0, [r7, #12]
2400c5b8:	f002 fd26 	bl	2400f008 <I2C_TransferConfig>
                         I2C_GENERATE_START_READ);

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400c5bc:	68fb      	ldr	r3, [r7, #12]
2400c5be:	2200      	movs	r2, #0
2400c5c0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
                process unlock */
      /* Enable ERR, TC, STOP, NACK, TXI interrupt */
      /* possible to enable all of these */
      /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
        I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
      I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
2400c5c4:	2101      	movs	r1, #1
2400c5c6:	68f8      	ldr	r0, [r7, #12]
2400c5c8:	f002 fd50 	bl	2400f06c <I2C_Enable_IRQ>
    }

    return HAL_OK;
2400c5cc:	2300      	movs	r3, #0
2400c5ce:	e000      	b.n	2400c5d2 <HAL_I2C_Master_Seq_Receive_DMA+0x1ea>
  }
  else
  {
    return HAL_BUSY;
2400c5d0:	2302      	movs	r3, #2
  }
}
2400c5d2:	4618      	mov	r0, r3
2400c5d4:	3720      	adds	r7, #32
2400c5d6:	46bd      	mov	sp, r7
2400c5d8:	bd80      	pop	{r7, pc}
2400c5da:	bf00      	nop
2400c5dc:	80002400 	.word	0x80002400
2400c5e0:	2400d4d7 	.word	0x2400d4d7
2400c5e4:	2400e719 	.word	0x2400e719
2400c5e8:	2400e915 	.word	0x2400e915
2400c5ec:	2400d0af 	.word	0x2400d0af

2400c5f0 <HAL_I2C_Slave_Seq_Transmit_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                                uint32_t XferOptions)
{
2400c5f0:	b580      	push	{r7, lr}
2400c5f2:	b084      	sub	sp, #16
2400c5f4:	af00      	add	r7, sp, #0
2400c5f6:	60f8      	str	r0, [r7, #12]
2400c5f8:	60b9      	str	r1, [r7, #8]
2400c5fa:	603b      	str	r3, [r7, #0]
2400c5fc:	4613      	mov	r3, r2
2400c5fe:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400c600:	68fb      	ldr	r3, [r7, #12]
2400c602:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c606:	b2db      	uxtb	r3, r3
2400c608:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400c60c:	2b28      	cmp	r3, #40	; 0x28
2400c60e:	f040 808a 	bne.w	2400c726 <HAL_I2C_Slave_Seq_Transmit_IT+0x136>
  {
    if ((pData == NULL) || (Size == 0U))
2400c612:	68bb      	ldr	r3, [r7, #8]
2400c614:	2b00      	cmp	r3, #0
2400c616:	d002      	beq.n	2400c61e <HAL_I2C_Slave_Seq_Transmit_IT+0x2e>
2400c618:	88fb      	ldrh	r3, [r7, #6]
2400c61a:	2b00      	cmp	r3, #0
2400c61c:	d105      	bne.n	2400c62a <HAL_I2C_Slave_Seq_Transmit_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400c61e:	68fb      	ldr	r3, [r7, #12]
2400c620:	f44f 7200 	mov.w	r2, #512	; 0x200
2400c624:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400c626:	2301      	movs	r3, #1
2400c628:	e07e      	b.n	2400c728 <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400c62a:	f248 0101 	movw	r1, #32769	; 0x8001
2400c62e:	68f8      	ldr	r0, [r7, #12]
2400c630:	f002 fd80 	bl	2400f134 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c634:	68fb      	ldr	r3, [r7, #12]
2400c636:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c63a:	2b01      	cmp	r3, #1
2400c63c:	d101      	bne.n	2400c642 <HAL_I2C_Slave_Seq_Transmit_IT+0x52>
2400c63e:	2302      	movs	r3, #2
2400c640:	e072      	b.n	2400c728 <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
2400c642:	68fb      	ldr	r3, [r7, #12]
2400c644:	2201      	movs	r2, #1
2400c646:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400c64a:	68fb      	ldr	r3, [r7, #12]
2400c64c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c650:	b2db      	uxtb	r3, r3
2400c652:	2b2a      	cmp	r3, #42	; 0x2a
2400c654:	d12a      	bne.n	2400c6ac <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400c656:	2102      	movs	r1, #2
2400c658:	68f8      	ldr	r0, [r7, #12]
2400c65a:	f002 fd6b 	bl	2400f134 <I2C_Disable_IRQ>

      /* Abort DMA Xfer if any */
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400c65e:	68fb      	ldr	r3, [r7, #12]
2400c660:	681b      	ldr	r3, [r3, #0]
2400c662:	681b      	ldr	r3, [r3, #0]
2400c664:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400c668:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400c66c:	d11e      	bne.n	2400c6ac <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400c66e:	68fb      	ldr	r3, [r7, #12]
2400c670:	681b      	ldr	r3, [r3, #0]
2400c672:	681a      	ldr	r2, [r3, #0]
2400c674:	68fb      	ldr	r3, [r7, #12]
2400c676:	681b      	ldr	r3, [r3, #0]
2400c678:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c67c:	601a      	str	r2, [r3, #0]

        if (hi2c->hdmarx != NULL)
2400c67e:	68fb      	ldr	r3, [r7, #12]
2400c680:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c682:	2b00      	cmp	r3, #0
2400c684:	d012      	beq.n	2400c6ac <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400c686:	68fb      	ldr	r3, [r7, #12]
2400c688:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c68a:	4a29      	ldr	r2, [pc, #164]	; (2400c730 <HAL_I2C_Slave_Seq_Transmit_IT+0x140>)
2400c68c:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400c68e:	68fb      	ldr	r3, [r7, #12]
2400c690:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c692:	4618      	mov	r0, r3
2400c694:	f7f8 f978 	bl	24004988 <HAL_DMA_Abort_IT>
2400c698:	4603      	mov	r3, r0
2400c69a:	2b00      	cmp	r3, #0
2400c69c:	d006      	beq.n	2400c6ac <HAL_I2C_Slave_Seq_Transmit_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400c69e:	68fb      	ldr	r3, [r7, #12]
2400c6a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c6a2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c6a4:	68fa      	ldr	r2, [r7, #12]
2400c6a6:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400c6a8:	4610      	mov	r0, r2
2400c6aa:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400c6ac:	68fb      	ldr	r3, [r7, #12]
2400c6ae:	2229      	movs	r2, #41	; 0x29
2400c6b0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400c6b4:	68fb      	ldr	r3, [r7, #12]
2400c6b6:	2220      	movs	r2, #32
2400c6b8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c6bc:	68fb      	ldr	r3, [r7, #12]
2400c6be:	2200      	movs	r2, #0
2400c6c0:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400c6c2:	68fb      	ldr	r3, [r7, #12]
2400c6c4:	681b      	ldr	r3, [r3, #0]
2400c6c6:	685a      	ldr	r2, [r3, #4]
2400c6c8:	68fb      	ldr	r3, [r7, #12]
2400c6ca:	681b      	ldr	r3, [r3, #0]
2400c6cc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c6d0:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c6d2:	68fb      	ldr	r3, [r7, #12]
2400c6d4:	68ba      	ldr	r2, [r7, #8]
2400c6d6:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c6d8:	68fb      	ldr	r3, [r7, #12]
2400c6da:	88fa      	ldrh	r2, [r7, #6]
2400c6dc:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400c6de:	68fb      	ldr	r3, [r7, #12]
2400c6e0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c6e2:	b29a      	uxth	r2, r3
2400c6e4:	68fb      	ldr	r3, [r7, #12]
2400c6e6:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400c6e8:	68fb      	ldr	r3, [r7, #12]
2400c6ea:	683a      	ldr	r2, [r7, #0]
2400c6ec:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400c6ee:	68fb      	ldr	r3, [r7, #12]
2400c6f0:	4a10      	ldr	r2, [pc, #64]	; (2400c734 <HAL_I2C_Slave_Seq_Transmit_IT+0x144>)
2400c6f2:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2400c6f4:	68fb      	ldr	r3, [r7, #12]
2400c6f6:	681b      	ldr	r3, [r3, #0]
2400c6f8:	699b      	ldr	r3, [r3, #24]
2400c6fa:	0c1b      	lsrs	r3, r3, #16
2400c6fc:	b2db      	uxtb	r3, r3
2400c6fe:	f003 0301 	and.w	r3, r3, #1
2400c702:	b2db      	uxtb	r3, r3
2400c704:	2b01      	cmp	r3, #1
2400c706:	d103      	bne.n	2400c710 <HAL_I2C_Slave_Seq_Transmit_IT+0x120>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400c708:	68fb      	ldr	r3, [r7, #12]
2400c70a:	681b      	ldr	r3, [r3, #0]
2400c70c:	2208      	movs	r2, #8
2400c70e:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c710:	68fb      	ldr	r3, [r7, #12]
2400c712:	2200      	movs	r2, #0
2400c714:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
2400c718:	f248 0101 	movw	r1, #32769	; 0x8001
2400c71c:	68f8      	ldr	r0, [r7, #12]
2400c71e:	f002 fca5 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400c722:	2300      	movs	r3, #0
2400c724:	e000      	b.n	2400c728 <HAL_I2C_Slave_Seq_Transmit_IT+0x138>
  }
  else
  {
    return HAL_ERROR;
2400c726:	2301      	movs	r3, #1
  }
}
2400c728:	4618      	mov	r0, r3
2400c72a:	3710      	adds	r7, #16
2400c72c:	46bd      	mov	sp, r7
2400c72e:	bd80      	pop	{r7, pc}
2400c730:	2400eb89 	.word	0x2400eb89
2400c734:	2400d2e7 	.word	0x2400d2e7

2400c738 <HAL_I2C_Slave_Seq_Transmit_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                                 uint32_t XferOptions)
{
2400c738:	b580      	push	{r7, lr}
2400c73a:	b086      	sub	sp, #24
2400c73c:	af00      	add	r7, sp, #0
2400c73e:	60f8      	str	r0, [r7, #12]
2400c740:	60b9      	str	r1, [r7, #8]
2400c742:	603b      	str	r3, [r7, #0]
2400c744:	4613      	mov	r3, r2
2400c746:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400c748:	68fb      	ldr	r3, [r7, #12]
2400c74a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c74e:	b2db      	uxtb	r3, r3
2400c750:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400c754:	2b28      	cmp	r3, #40	; 0x28
2400c756:	f040 811a 	bne.w	2400c98e <HAL_I2C_Slave_Seq_Transmit_DMA+0x256>
  {
    if ((pData == NULL) || (Size == 0U))
2400c75a:	68bb      	ldr	r3, [r7, #8]
2400c75c:	2b00      	cmp	r3, #0
2400c75e:	d002      	beq.n	2400c766 <HAL_I2C_Slave_Seq_Transmit_DMA+0x2e>
2400c760:	88fb      	ldrh	r3, [r7, #6]
2400c762:	2b00      	cmp	r3, #0
2400c764:	d105      	bne.n	2400c772 <HAL_I2C_Slave_Seq_Transmit_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400c766:	68fb      	ldr	r3, [r7, #12]
2400c768:	f44f 7200 	mov.w	r2, #512	; 0x200
2400c76c:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400c76e:	2301      	movs	r3, #1
2400c770:	e10e      	b.n	2400c990 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c772:	68fb      	ldr	r3, [r7, #12]
2400c774:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c778:	2b01      	cmp	r3, #1
2400c77a:	d101      	bne.n	2400c780 <HAL_I2C_Slave_Seq_Transmit_DMA+0x48>
2400c77c:	2302      	movs	r3, #2
2400c77e:	e107      	b.n	2400c990 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
2400c780:	68fb      	ldr	r3, [r7, #12]
2400c782:	2201      	movs	r2, #1
2400c784:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400c788:	f248 0101 	movw	r1, #32769	; 0x8001
2400c78c:	68f8      	ldr	r0, [r7, #12]
2400c78e:	f002 fcd1 	bl	2400f134 <I2C_Disable_IRQ>

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave RX state to TX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400c792:	68fb      	ldr	r3, [r7, #12]
2400c794:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c798:	b2db      	uxtb	r3, r3
2400c79a:	2b2a      	cmp	r3, #42	; 0x2a
2400c79c:	d12b      	bne.n	2400c7f6 <HAL_I2C_Slave_Seq_Transmit_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400c79e:	2102      	movs	r1, #2
2400c7a0:	68f8      	ldr	r0, [r7, #12]
2400c7a2:	f002 fcc7 	bl	2400f134 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400c7a6:	68fb      	ldr	r3, [r7, #12]
2400c7a8:	681b      	ldr	r3, [r3, #0]
2400c7aa:	681b      	ldr	r3, [r3, #0]
2400c7ac:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400c7b0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400c7b4:	d14c      	bne.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400c7b6:	68fb      	ldr	r3, [r7, #12]
2400c7b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c7ba:	2b00      	cmp	r3, #0
2400c7bc:	d048      	beq.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400c7be:	68fb      	ldr	r3, [r7, #12]
2400c7c0:	681b      	ldr	r3, [r3, #0]
2400c7c2:	681a      	ldr	r2, [r3, #0]
2400c7c4:	68fb      	ldr	r3, [r7, #12]
2400c7c6:	681b      	ldr	r3, [r3, #0]
2400c7c8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c7cc:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400c7ce:	68fb      	ldr	r3, [r7, #12]
2400c7d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c7d2:	4a71      	ldr	r2, [pc, #452]	; (2400c998 <HAL_I2C_Slave_Seq_Transmit_DMA+0x260>)
2400c7d4:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400c7d6:	68fb      	ldr	r3, [r7, #12]
2400c7d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c7da:	4618      	mov	r0, r3
2400c7dc:	f7f8 f8d4 	bl	24004988 <HAL_DMA_Abort_IT>
2400c7e0:	4603      	mov	r3, r0
2400c7e2:	2b00      	cmp	r3, #0
2400c7e4:	d034      	beq.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400c7e6:	68fb      	ldr	r3, [r7, #12]
2400c7e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400c7ea:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c7ec:	68fa      	ldr	r2, [r7, #12]
2400c7ee:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400c7f0:	4610      	mov	r0, r2
2400c7f2:	4798      	blx	r3
2400c7f4:	e02c      	b.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400c7f6:	68fb      	ldr	r3, [r7, #12]
2400c7f8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c7fc:	b2db      	uxtb	r3, r3
2400c7fe:	2b29      	cmp	r3, #41	; 0x29
2400c800:	d126      	bne.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400c802:	68fb      	ldr	r3, [r7, #12]
2400c804:	681b      	ldr	r3, [r3, #0]
2400c806:	681b      	ldr	r3, [r3, #0]
2400c808:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400c80c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400c810:	d11e      	bne.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400c812:	68fb      	ldr	r3, [r7, #12]
2400c814:	681b      	ldr	r3, [r3, #0]
2400c816:	681a      	ldr	r2, [r3, #0]
2400c818:	68fb      	ldr	r3, [r7, #12]
2400c81a:	681b      	ldr	r3, [r3, #0]
2400c81c:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400c820:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400c822:	68fb      	ldr	r3, [r7, #12]
2400c824:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c826:	2b00      	cmp	r3, #0
2400c828:	d012      	beq.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400c82a:	68fb      	ldr	r3, [r7, #12]
2400c82c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c82e:	4a5a      	ldr	r2, [pc, #360]	; (2400c998 <HAL_I2C_Slave_Seq_Transmit_DMA+0x260>)
2400c830:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400c832:	68fb      	ldr	r3, [r7, #12]
2400c834:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c836:	4618      	mov	r0, r3
2400c838:	f7f8 f8a6 	bl	24004988 <HAL_DMA_Abort_IT>
2400c83c:	4603      	mov	r3, r0
2400c83e:	2b00      	cmp	r3, #0
2400c840:	d006      	beq.n	2400c850 <HAL_I2C_Slave_Seq_Transmit_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400c842:	68fb      	ldr	r3, [r7, #12]
2400c844:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c846:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400c848:	68fa      	ldr	r2, [r7, #12]
2400c84a:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400c84c:	4610      	mov	r0, r2
2400c84e:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
2400c850:	68fb      	ldr	r3, [r7, #12]
2400c852:	2229      	movs	r2, #41	; 0x29
2400c854:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400c858:	68fb      	ldr	r3, [r7, #12]
2400c85a:	2220      	movs	r2, #32
2400c85c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400c860:	68fb      	ldr	r3, [r7, #12]
2400c862:	2200      	movs	r2, #0
2400c864:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400c866:	68fb      	ldr	r3, [r7, #12]
2400c868:	681b      	ldr	r3, [r3, #0]
2400c86a:	685a      	ldr	r2, [r3, #4]
2400c86c:	68fb      	ldr	r3, [r7, #12]
2400c86e:	681b      	ldr	r3, [r3, #0]
2400c870:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400c874:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400c876:	68fb      	ldr	r3, [r7, #12]
2400c878:	68ba      	ldr	r2, [r7, #8]
2400c87a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400c87c:	68fb      	ldr	r3, [r7, #12]
2400c87e:	88fa      	ldrh	r2, [r7, #6]
2400c880:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400c882:	68fb      	ldr	r3, [r7, #12]
2400c884:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c886:	b29a      	uxth	r2, r3
2400c888:	68fb      	ldr	r3, [r7, #12]
2400c88a:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400c88c:	68fb      	ldr	r3, [r7, #12]
2400c88e:	683a      	ldr	r2, [r7, #0]
2400c890:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400c892:	68fb      	ldr	r3, [r7, #12]
2400c894:	4a41      	ldr	r2, [pc, #260]	; (2400c99c <HAL_I2C_Slave_Seq_Transmit_DMA+0x264>)
2400c896:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmatx != NULL)
2400c898:	68fb      	ldr	r3, [r7, #12]
2400c89a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c89c:	2b00      	cmp	r3, #0
2400c89e:	d020      	beq.n	2400c8e2 <HAL_I2C_Slave_Seq_Transmit_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
2400c8a0:	68fb      	ldr	r3, [r7, #12]
2400c8a2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c8a4:	4a3e      	ldr	r2, [pc, #248]	; (2400c9a0 <HAL_I2C_Slave_Seq_Transmit_DMA+0x268>)
2400c8a6:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
2400c8a8:	68fb      	ldr	r3, [r7, #12]
2400c8aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c8ac:	4a3d      	ldr	r2, [pc, #244]	; (2400c9a4 <HAL_I2C_Slave_Seq_Transmit_DMA+0x26c>)
2400c8ae:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmatx->XferHalfCpltCallback = NULL;
2400c8b0:	68fb      	ldr	r3, [r7, #12]
2400c8b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c8b4:	2200      	movs	r2, #0
2400c8b6:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmatx->XferAbortCallback = NULL;
2400c8b8:	68fb      	ldr	r3, [r7, #12]
2400c8ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400c8bc:	2200      	movs	r2, #0
2400c8be:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400c8c0:	68fb      	ldr	r3, [r7, #12]
2400c8c2:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400c8c4:	68b9      	ldr	r1, [r7, #8]
2400c8c6:	68fb      	ldr	r3, [r7, #12]
2400c8c8:	681b      	ldr	r3, [r3, #0]
2400c8ca:	3328      	adds	r3, #40	; 0x28
2400c8cc:	461a      	mov	r2, r3
                                       hi2c->XferSize);
2400c8ce:	68fb      	ldr	r3, [r7, #12]
2400c8d0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR,
2400c8d2:	f7f7 fad1 	bl	24003e78 <HAL_DMA_Start_IT>
2400c8d6:	4603      	mov	r3, r0
2400c8d8:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400c8da:	7dfb      	ldrb	r3, [r7, #23]
2400c8dc:	2b00      	cmp	r3, #0
2400c8de:	d12b      	bne.n	2400c938 <HAL_I2C_Slave_Seq_Transmit_DMA+0x200>
2400c8e0:	e013      	b.n	2400c90a <HAL_I2C_Slave_Seq_Transmit_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400c8e2:	68fb      	ldr	r3, [r7, #12]
2400c8e4:	2228      	movs	r2, #40	; 0x28
2400c8e6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c8ea:	68fb      	ldr	r3, [r7, #12]
2400c8ec:	2200      	movs	r2, #0
2400c8ee:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400c8f2:	68fb      	ldr	r3, [r7, #12]
2400c8f4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c8f6:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400c8fa:	68fb      	ldr	r3, [r7, #12]
2400c8fc:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400c8fe:	68fb      	ldr	r3, [r7, #12]
2400c900:	2200      	movs	r2, #0
2400c902:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400c906:	2301      	movs	r3, #1
2400c908:	e042      	b.n	2400c990 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400c90a:	68fb      	ldr	r3, [r7, #12]
2400c90c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400c90e:	b29a      	uxth	r2, r3
2400c910:	68fb      	ldr	r3, [r7, #12]
2400c912:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400c914:	1ad3      	subs	r3, r2, r3
2400c916:	b29a      	uxth	r2, r3
2400c918:	68fb      	ldr	r3, [r7, #12]
2400c91a:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400c91c:	68fb      	ldr	r3, [r7, #12]
2400c91e:	2200      	movs	r2, #0
2400c920:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_RECEIVE)
2400c922:	68fb      	ldr	r3, [r7, #12]
2400c924:	681b      	ldr	r3, [r3, #0]
2400c926:	699b      	ldr	r3, [r3, #24]
2400c928:	0c1b      	lsrs	r3, r3, #16
2400c92a:	b2db      	uxtb	r3, r3
2400c92c:	f003 0301 	and.w	r3, r3, #1
2400c930:	b2db      	uxtb	r3, r3
2400c932:	2b01      	cmp	r3, #1
2400c934:	d118      	bne.n	2400c968 <HAL_I2C_Slave_Seq_Transmit_DMA+0x230>
2400c936:	e013      	b.n	2400c960 <HAL_I2C_Slave_Seq_Transmit_DMA+0x228>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400c938:	68fb      	ldr	r3, [r7, #12]
2400c93a:	2228      	movs	r2, #40	; 0x28
2400c93c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400c940:	68fb      	ldr	r3, [r7, #12]
2400c942:	2200      	movs	r2, #0
2400c944:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400c948:	68fb      	ldr	r3, [r7, #12]
2400c94a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400c94c:	f043 0210 	orr.w	r2, r3, #16
2400c950:	68fb      	ldr	r3, [r7, #12]
2400c952:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400c954:	68fb      	ldr	r3, [r7, #12]
2400c956:	2200      	movs	r2, #0
2400c958:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400c95c:	2301      	movs	r3, #1
2400c95e:	e017      	b.n	2400c990 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400c960:	68fb      	ldr	r3, [r7, #12]
2400c962:	681b      	ldr	r3, [r3, #0]
2400c964:	2208      	movs	r2, #8
2400c966:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400c968:	68fb      	ldr	r3, [r7, #12]
2400c96a:	2200      	movs	r2, #0
2400c96c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400c970:	68fb      	ldr	r3, [r7, #12]
2400c972:	681b      	ldr	r3, [r3, #0]
2400c974:	681a      	ldr	r2, [r3, #0]
2400c976:	68fb      	ldr	r3, [r7, #12]
2400c978:	681b      	ldr	r3, [r3, #0]
2400c97a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400c97e:	601a      	str	r2, [r3, #0]

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* Enable ERR, STOP, NACK, ADDR interrupts */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400c980:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400c984:	68f8      	ldr	r0, [r7, #12]
2400c986:	f002 fb71 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400c98a:	2300      	movs	r3, #0
2400c98c:	e000      	b.n	2400c990 <HAL_I2C_Slave_Seq_Transmit_DMA+0x258>
  }
  else
  {
    return HAL_ERROR;
2400c98e:	2301      	movs	r3, #1
  }
}
2400c990:	4618      	mov	r0, r3
2400c992:	3718      	adds	r7, #24
2400c994:	46bd      	mov	sp, r7
2400c996:	bd80      	pop	{r7, pc}
2400c998:	2400eb89 	.word	0x2400eb89
2400c99c:	2400d6ad 	.word	0x2400d6ad
2400c9a0:	2400e6d9 	.word	0x2400e6d9
2400c9a4:	2400e915 	.word	0x2400e915

2400c9a8 <HAL_I2C_Slave_Seq_Receive_IT>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                               uint32_t XferOptions)
{
2400c9a8:	b580      	push	{r7, lr}
2400c9aa:	b084      	sub	sp, #16
2400c9ac:	af00      	add	r7, sp, #0
2400c9ae:	60f8      	str	r0, [r7, #12]
2400c9b0:	60b9      	str	r1, [r7, #8]
2400c9b2:	603b      	str	r3, [r7, #0]
2400c9b4:	4613      	mov	r3, r2
2400c9b6:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400c9b8:	68fb      	ldr	r3, [r7, #12]
2400c9ba:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400c9be:	b2db      	uxtb	r3, r3
2400c9c0:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400c9c4:	2b28      	cmp	r3, #40	; 0x28
2400c9c6:	f040 808a 	bne.w	2400cade <HAL_I2C_Slave_Seq_Receive_IT+0x136>
  {
    if ((pData == NULL) || (Size == 0U))
2400c9ca:	68bb      	ldr	r3, [r7, #8]
2400c9cc:	2b00      	cmp	r3, #0
2400c9ce:	d002      	beq.n	2400c9d6 <HAL_I2C_Slave_Seq_Receive_IT+0x2e>
2400c9d0:	88fb      	ldrh	r3, [r7, #6]
2400c9d2:	2b00      	cmp	r3, #0
2400c9d4:	d105      	bne.n	2400c9e2 <HAL_I2C_Slave_Seq_Receive_IT+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400c9d6:	68fb      	ldr	r3, [r7, #12]
2400c9d8:	f44f 7200 	mov.w	r2, #512	; 0x200
2400c9dc:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400c9de:	2301      	movs	r3, #1
2400c9e0:	e07e      	b.n	2400cae0 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400c9e2:	f248 0102 	movw	r1, #32770	; 0x8002
2400c9e6:	68f8      	ldr	r0, [r7, #12]
2400c9e8:	f002 fba4 	bl	2400f134 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400c9ec:	68fb      	ldr	r3, [r7, #12]
2400c9ee:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400c9f2:	2b01      	cmp	r3, #1
2400c9f4:	d101      	bne.n	2400c9fa <HAL_I2C_Slave_Seq_Receive_IT+0x52>
2400c9f6:	2302      	movs	r3, #2
2400c9f8:	e072      	b.n	2400cae0 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
2400c9fa:	68fb      	ldr	r3, [r7, #12]
2400c9fc:	2201      	movs	r2, #1
2400c9fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400ca02:	68fb      	ldr	r3, [r7, #12]
2400ca04:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ca08:	b2db      	uxtb	r3, r3
2400ca0a:	2b29      	cmp	r3, #41	; 0x29
2400ca0c:	d12a      	bne.n	2400ca64 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400ca0e:	2101      	movs	r1, #1
2400ca10:	68f8      	ldr	r0, [r7, #12]
2400ca12:	f002 fb8f 	bl	2400f134 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400ca16:	68fb      	ldr	r3, [r7, #12]
2400ca18:	681b      	ldr	r3, [r3, #0]
2400ca1a:	681b      	ldr	r3, [r3, #0]
2400ca1c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400ca20:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400ca24:	d11e      	bne.n	2400ca64 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400ca26:	68fb      	ldr	r3, [r7, #12]
2400ca28:	681b      	ldr	r3, [r3, #0]
2400ca2a:	681a      	ldr	r2, [r3, #0]
2400ca2c:	68fb      	ldr	r3, [r7, #12]
2400ca2e:	681b      	ldr	r3, [r3, #0]
2400ca30:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400ca34:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400ca36:	68fb      	ldr	r3, [r7, #12]
2400ca38:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ca3a:	2b00      	cmp	r3, #0
2400ca3c:	d012      	beq.n	2400ca64 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400ca3e:	68fb      	ldr	r3, [r7, #12]
2400ca40:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ca42:	4a29      	ldr	r2, [pc, #164]	; (2400cae8 <HAL_I2C_Slave_Seq_Receive_IT+0x140>)
2400ca44:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400ca46:	68fb      	ldr	r3, [r7, #12]
2400ca48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ca4a:	4618      	mov	r0, r3
2400ca4c:	f7f7 ff9c 	bl	24004988 <HAL_DMA_Abort_IT>
2400ca50:	4603      	mov	r3, r0
2400ca52:	2b00      	cmp	r3, #0
2400ca54:	d006      	beq.n	2400ca64 <HAL_I2C_Slave_Seq_Receive_IT+0xbc>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400ca56:	68fb      	ldr	r3, [r7, #12]
2400ca58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ca5a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400ca5c:	68fa      	ldr	r2, [r7, #12]
2400ca5e:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400ca60:	4610      	mov	r0, r2
2400ca62:	4798      	blx	r3
          }
        }
      }
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400ca64:	68fb      	ldr	r3, [r7, #12]
2400ca66:	222a      	movs	r2, #42	; 0x2a
2400ca68:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400ca6c:	68fb      	ldr	r3, [r7, #12]
2400ca6e:	2220      	movs	r2, #32
2400ca70:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400ca74:	68fb      	ldr	r3, [r7, #12]
2400ca76:	2200      	movs	r2, #0
2400ca78:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400ca7a:	68fb      	ldr	r3, [r7, #12]
2400ca7c:	681b      	ldr	r3, [r3, #0]
2400ca7e:	685a      	ldr	r2, [r3, #4]
2400ca80:	68fb      	ldr	r3, [r7, #12]
2400ca82:	681b      	ldr	r3, [r3, #0]
2400ca84:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400ca88:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400ca8a:	68fb      	ldr	r3, [r7, #12]
2400ca8c:	68ba      	ldr	r2, [r7, #8]
2400ca8e:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400ca90:	68fb      	ldr	r3, [r7, #12]
2400ca92:	88fa      	ldrh	r2, [r7, #6]
2400ca94:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400ca96:	68fb      	ldr	r3, [r7, #12]
2400ca98:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ca9a:	b29a      	uxth	r2, r3
2400ca9c:	68fb      	ldr	r3, [r7, #12]
2400ca9e:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400caa0:	68fb      	ldr	r3, [r7, #12]
2400caa2:	683a      	ldr	r2, [r7, #0]
2400caa4:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
2400caa6:	68fb      	ldr	r3, [r7, #12]
2400caa8:	4a10      	ldr	r2, [pc, #64]	; (2400caec <HAL_I2C_Slave_Seq_Receive_IT+0x144>)
2400caaa:	635a      	str	r2, [r3, #52]	; 0x34

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2400caac:	68fb      	ldr	r3, [r7, #12]
2400caae:	681b      	ldr	r3, [r3, #0]
2400cab0:	699b      	ldr	r3, [r3, #24]
2400cab2:	0c1b      	lsrs	r3, r3, #16
2400cab4:	b2db      	uxtb	r3, r3
2400cab6:	f003 0301 	and.w	r3, r3, #1
2400caba:	b2db      	uxtb	r3, r3
2400cabc:	2b00      	cmp	r3, #0
2400cabe:	d103      	bne.n	2400cac8 <HAL_I2C_Slave_Seq_Receive_IT+0x120>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400cac0:	68fb      	ldr	r3, [r7, #12]
2400cac2:	681b      	ldr	r3, [r3, #0]
2400cac4:	2208      	movs	r2, #8
2400cac6:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cac8:	68fb      	ldr	r3, [r7, #12]
2400caca:	2200      	movs	r2, #0
2400cacc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400cad0:	f248 0102 	movw	r1, #32770	; 0x8002
2400cad4:	68f8      	ldr	r0, [r7, #12]
2400cad6:	f002 fac9 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400cada:	2300      	movs	r3, #0
2400cadc:	e000      	b.n	2400cae0 <HAL_I2C_Slave_Seq_Receive_IT+0x138>
  }
  else
  {
    return HAL_ERROR;
2400cade:	2301      	movs	r3, #1
  }
}
2400cae0:	4618      	mov	r0, r3
2400cae2:	3710      	adds	r7, #16
2400cae4:	46bd      	mov	sp, r7
2400cae6:	bd80      	pop	{r7, pc}
2400cae8:	2400eb89 	.word	0x2400eb89
2400caec:	2400d2e7 	.word	0x2400d2e7

2400caf0 <HAL_I2C_Slave_Seq_Receive_DMA>:
  * @param  XferOptions Options of Transfer, value of @ref I2C_XFEROPTIONS
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size,
                                                uint32_t XferOptions)
{
2400caf0:	b580      	push	{r7, lr}
2400caf2:	b086      	sub	sp, #24
2400caf4:	af00      	add	r7, sp, #0
2400caf6:	60f8      	str	r0, [r7, #12]
2400caf8:	60b9      	str	r1, [r7, #8]
2400cafa:	603b      	str	r3, [r7, #0]
2400cafc:	4613      	mov	r3, r2
2400cafe:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef dmaxferstatus;

  /* Check the parameters */
  assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400cb00:	68fb      	ldr	r3, [r7, #12]
2400cb02:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cb06:	b2db      	uxtb	r3, r3
2400cb08:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400cb0c:	2b28      	cmp	r3, #40	; 0x28
2400cb0e:	f040 811a 	bne.w	2400cd46 <HAL_I2C_Slave_Seq_Receive_DMA+0x256>
  {
    if ((pData == NULL) || (Size == 0U))
2400cb12:	68bb      	ldr	r3, [r7, #8]
2400cb14:	2b00      	cmp	r3, #0
2400cb16:	d002      	beq.n	2400cb1e <HAL_I2C_Slave_Seq_Receive_DMA+0x2e>
2400cb18:	88fb      	ldrh	r3, [r7, #6]
2400cb1a:	2b00      	cmp	r3, #0
2400cb1c:	d105      	bne.n	2400cb2a <HAL_I2C_Slave_Seq_Receive_DMA+0x3a>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
2400cb1e:	68fb      	ldr	r3, [r7, #12]
2400cb20:	f44f 7200 	mov.w	r2, #512	; 0x200
2400cb24:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
2400cb26:	2301      	movs	r3, #1
2400cb28:	e10e      	b.n	2400cd48 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    }

    /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400cb2a:	f248 0102 	movw	r1, #32770	; 0x8002
2400cb2e:	68f8      	ldr	r0, [r7, #12]
2400cb30:	f002 fb00 	bl	2400f134 <I2C_Disable_IRQ>

    /* Process Locked */
    __HAL_LOCK(hi2c);
2400cb34:	68fb      	ldr	r3, [r7, #12]
2400cb36:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400cb3a:	2b01      	cmp	r3, #1
2400cb3c:	d101      	bne.n	2400cb42 <HAL_I2C_Slave_Seq_Receive_DMA+0x52>
2400cb3e:	2302      	movs	r3, #2
2400cb40:	e102      	b.n	2400cd48 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
2400cb42:	68fb      	ldr	r3, [r7, #12]
2400cb44:	2201      	movs	r2, #1
2400cb46:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
    /* and then toggle the HAL slave TX state to RX state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400cb4a:	68fb      	ldr	r3, [r7, #12]
2400cb4c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cb50:	b2db      	uxtb	r3, r3
2400cb52:	2b29      	cmp	r3, #41	; 0x29
2400cb54:	d12b      	bne.n	2400cbae <HAL_I2C_Slave_Seq_Receive_DMA+0xbe>
    {
      /* Disable associated Interrupts */
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400cb56:	2101      	movs	r1, #1
2400cb58:	68f8      	ldr	r0, [r7, #12]
2400cb5a:	f002 faeb 	bl	2400f134 <I2C_Disable_IRQ>

      if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400cb5e:	68fb      	ldr	r3, [r7, #12]
2400cb60:	681b      	ldr	r3, [r3, #0]
2400cb62:	681b      	ldr	r3, [r3, #0]
2400cb64:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400cb68:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400cb6c:	d14c      	bne.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        /* Abort DMA Xfer if any */
        if (hi2c->hdmatx != NULL)
2400cb6e:	68fb      	ldr	r3, [r7, #12]
2400cb70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cb72:	2b00      	cmp	r3, #0
2400cb74:	d048      	beq.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400cb76:	68fb      	ldr	r3, [r7, #12]
2400cb78:	681b      	ldr	r3, [r3, #0]
2400cb7a:	681a      	ldr	r2, [r3, #0]
2400cb7c:	68fb      	ldr	r3, [r7, #12]
2400cb7e:	681b      	ldr	r3, [r3, #0]
2400cb80:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400cb84:	601a      	str	r2, [r3, #0]

          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400cb86:	68fb      	ldr	r3, [r7, #12]
2400cb88:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cb8a:	4a71      	ldr	r2, [pc, #452]	; (2400cd50 <HAL_I2C_Slave_Seq_Receive_DMA+0x260>)
2400cb8c:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA TX */
          if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400cb8e:	68fb      	ldr	r3, [r7, #12]
2400cb90:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cb92:	4618      	mov	r0, r3
2400cb94:	f7f7 fef8 	bl	24004988 <HAL_DMA_Abort_IT>
2400cb98:	4603      	mov	r3, r0
2400cb9a:	2b00      	cmp	r3, #0
2400cb9c:	d034      	beq.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400cb9e:	68fb      	ldr	r3, [r7, #12]
2400cba0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400cba2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400cba4:	68fa      	ldr	r2, [r7, #12]
2400cba6:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400cba8:	4610      	mov	r0, r2
2400cbaa:	4798      	blx	r3
2400cbac:	e02c      	b.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          }
        }
      }
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400cbae:	68fb      	ldr	r3, [r7, #12]
2400cbb0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cbb4:	b2db      	uxtb	r3, r3
2400cbb6:	2b2a      	cmp	r3, #42	; 0x2a
2400cbb8:	d126      	bne.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
    {
      if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400cbba:	68fb      	ldr	r3, [r7, #12]
2400cbbc:	681b      	ldr	r3, [r3, #0]
2400cbbe:	681b      	ldr	r3, [r3, #0]
2400cbc0:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400cbc4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400cbc8:	d11e      	bne.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
      {
        hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400cbca:	68fb      	ldr	r3, [r7, #12]
2400cbcc:	681b      	ldr	r3, [r3, #0]
2400cbce:	681a      	ldr	r2, [r3, #0]
2400cbd0:	68fb      	ldr	r3, [r7, #12]
2400cbd2:	681b      	ldr	r3, [r3, #0]
2400cbd4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400cbd8:	601a      	str	r2, [r3, #0]

        /* Abort DMA Xfer if any */
        if (hi2c->hdmarx != NULL)
2400cbda:	68fb      	ldr	r3, [r7, #12]
2400cbdc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cbde:	2b00      	cmp	r3, #0
2400cbe0:	d012      	beq.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
        {
          /* Set the I2C DMA Abort callback :
           will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
          hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400cbe2:	68fb      	ldr	r3, [r7, #12]
2400cbe4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cbe6:	4a5a      	ldr	r2, [pc, #360]	; (2400cd50 <HAL_I2C_Slave_Seq_Receive_DMA+0x260>)
2400cbe8:	651a      	str	r2, [r3, #80]	; 0x50

          /* Abort DMA RX */
          if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400cbea:	68fb      	ldr	r3, [r7, #12]
2400cbec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cbee:	4618      	mov	r0, r3
2400cbf0:	f7f7 feca 	bl	24004988 <HAL_DMA_Abort_IT>
2400cbf4:	4603      	mov	r3, r0
2400cbf6:	2b00      	cmp	r3, #0
2400cbf8:	d006      	beq.n	2400cc08 <HAL_I2C_Slave_Seq_Receive_DMA+0x118>
          {
            /* Call Directly XferAbortCallback function in case of error */
            hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400cbfa:	68fb      	ldr	r3, [r7, #12]
2400cbfc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cbfe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400cc00:	68fa      	ldr	r2, [r7, #12]
2400cc02:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400cc04:	4610      	mov	r0, r2
2400cc06:	4798      	blx	r3
    else
    {
      /* Nothing to do */
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
2400cc08:	68fb      	ldr	r3, [r7, #12]
2400cc0a:	222a      	movs	r2, #42	; 0x2a
2400cc0c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_SLAVE;
2400cc10:	68fb      	ldr	r3, [r7, #12]
2400cc12:	2220      	movs	r2, #32
2400cc14:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400cc18:	68fb      	ldr	r3, [r7, #12]
2400cc1a:	2200      	movs	r2, #0
2400cc1c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
2400cc1e:	68fb      	ldr	r3, [r7, #12]
2400cc20:	681b      	ldr	r3, [r3, #0]
2400cc22:	685a      	ldr	r2, [r3, #4]
2400cc24:	68fb      	ldr	r3, [r7, #12]
2400cc26:	681b      	ldr	r3, [r3, #0]
2400cc28:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400cc2c:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
2400cc2e:	68fb      	ldr	r3, [r7, #12]
2400cc30:	68ba      	ldr	r2, [r7, #8]
2400cc32:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount   = Size;
2400cc34:	68fb      	ldr	r3, [r7, #12]
2400cc36:	88fa      	ldrh	r2, [r7, #6]
2400cc38:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferSize    = hi2c->XferCount;
2400cc3a:	68fb      	ldr	r3, [r7, #12]
2400cc3c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400cc3e:	b29a      	uxth	r2, r3
2400cc40:	68fb      	ldr	r3, [r7, #12]
2400cc42:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferOptions = XferOptions;
2400cc44:	68fb      	ldr	r3, [r7, #12]
2400cc46:	683a      	ldr	r2, [r7, #0]
2400cc48:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_DMA;
2400cc4a:	68fb      	ldr	r3, [r7, #12]
2400cc4c:	4a41      	ldr	r2, [pc, #260]	; (2400cd54 <HAL_I2C_Slave_Seq_Receive_DMA+0x264>)
2400cc4e:	635a      	str	r2, [r3, #52]	; 0x34

    if (hi2c->hdmarx != NULL)
2400cc50:	68fb      	ldr	r3, [r7, #12]
2400cc52:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cc54:	2b00      	cmp	r3, #0
2400cc56:	d020      	beq.n	2400cc9a <HAL_I2C_Slave_Seq_Receive_DMA+0x1aa>
    {
      /* Set the I2C DMA transfer complete callback */
      hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
2400cc58:	68fb      	ldr	r3, [r7, #12]
2400cc5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cc5c:	4a3e      	ldr	r2, [pc, #248]	; (2400cd58 <HAL_I2C_Slave_Seq_Receive_DMA+0x268>)
2400cc5e:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the DMA error callback */
      hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
2400cc60:	68fb      	ldr	r3, [r7, #12]
2400cc62:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cc64:	4a3d      	ldr	r2, [pc, #244]	; (2400cd5c <HAL_I2C_Slave_Seq_Receive_DMA+0x26c>)
2400cc66:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the unused DMA callbacks to NULL */
      hi2c->hdmarx->XferHalfCpltCallback = NULL;
2400cc68:	68fb      	ldr	r3, [r7, #12]
2400cc6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cc6c:	2200      	movs	r2, #0
2400cc6e:	641a      	str	r2, [r3, #64]	; 0x40
      hi2c->hdmarx->XferAbortCallback = NULL;
2400cc70:	68fb      	ldr	r3, [r7, #12]
2400cc72:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400cc74:	2200      	movs	r2, #0
2400cc76:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the DMA stream or channel depends on Instance */
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR,
2400cc78:	68fb      	ldr	r3, [r7, #12]
2400cc7a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400cc7c:	68fb      	ldr	r3, [r7, #12]
2400cc7e:	681b      	ldr	r3, [r3, #0]
2400cc80:	3324      	adds	r3, #36	; 0x24
2400cc82:	4619      	mov	r1, r3
2400cc84:	68ba      	ldr	r2, [r7, #8]
                                       (uint32_t)pData, hi2c->XferSize);
2400cc86:	68fb      	ldr	r3, [r7, #12]
2400cc88:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
      dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR,
2400cc8a:	f7f7 f8f5 	bl	24003e78 <HAL_DMA_Start_IT>
2400cc8e:	4603      	mov	r3, r0
2400cc90:	75fb      	strb	r3, [r7, #23]
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (dmaxferstatus == HAL_OK)
2400cc92:	7dfb      	ldrb	r3, [r7, #23]
2400cc94:	2b00      	cmp	r3, #0
2400cc96:	d12b      	bne.n	2400ccf0 <HAL_I2C_Slave_Seq_Receive_DMA+0x200>
2400cc98:	e013      	b.n	2400ccc2 <HAL_I2C_Slave_Seq_Receive_DMA+0x1d2>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400cc9a:	68fb      	ldr	r3, [r7, #12]
2400cc9c:	2228      	movs	r2, #40	; 0x28
2400cc9e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400cca2:	68fb      	ldr	r3, [r7, #12]
2400cca4:	2200      	movs	r2, #0
2400cca6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
2400ccaa:	68fb      	ldr	r3, [r7, #12]
2400ccac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ccae:	f043 0280 	orr.w	r2, r3, #128	; 0x80
2400ccb2:	68fb      	ldr	r3, [r7, #12]
2400ccb4:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400ccb6:	68fb      	ldr	r3, [r7, #12]
2400ccb8:	2200      	movs	r2, #0
2400ccba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400ccbe:	2301      	movs	r3, #1
2400ccc0:	e042      	b.n	2400cd48 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    {
      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400ccc2:	68fb      	ldr	r3, [r7, #12]
2400ccc4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400ccc6:	b29a      	uxth	r2, r3
2400ccc8:	68fb      	ldr	r3, [r7, #12]
2400ccca:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400cccc:	1ad3      	subs	r3, r2, r3
2400ccce:	b29a      	uxth	r2, r3
2400ccd0:	68fb      	ldr	r3, [r7, #12]
2400ccd2:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Reset XferSize */
      hi2c->XferSize = 0;
2400ccd4:	68fb      	ldr	r3, [r7, #12]
2400ccd6:	2200      	movs	r2, #0
2400ccd8:	851a      	strh	r2, [r3, #40]	; 0x28
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
    }

    if (I2C_GET_DIR(hi2c) == I2C_DIRECTION_TRANSMIT)
2400ccda:	68fb      	ldr	r3, [r7, #12]
2400ccdc:	681b      	ldr	r3, [r3, #0]
2400ccde:	699b      	ldr	r3, [r3, #24]
2400cce0:	0c1b      	lsrs	r3, r3, #16
2400cce2:	b2db      	uxtb	r3, r3
2400cce4:	f003 0301 	and.w	r3, r3, #1
2400cce8:	b2db      	uxtb	r3, r3
2400ccea:	2b00      	cmp	r3, #0
2400ccec:	d118      	bne.n	2400cd20 <HAL_I2C_Slave_Seq_Receive_DMA+0x230>
2400ccee:	e013      	b.n	2400cd18 <HAL_I2C_Slave_Seq_Receive_DMA+0x228>
      hi2c->State     = HAL_I2C_STATE_LISTEN;
2400ccf0:	68fb      	ldr	r3, [r7, #12]
2400ccf2:	2228      	movs	r2, #40	; 0x28
2400ccf4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode      = HAL_I2C_MODE_NONE;
2400ccf8:	68fb      	ldr	r3, [r7, #12]
2400ccfa:	2200      	movs	r2, #0
2400ccfc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
2400cd00:	68fb      	ldr	r3, [r7, #12]
2400cd02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cd04:	f043 0210 	orr.w	r2, r3, #16
2400cd08:	68fb      	ldr	r3, [r7, #12]
2400cd0a:	645a      	str	r2, [r3, #68]	; 0x44
      __HAL_UNLOCK(hi2c);
2400cd0c:	68fb      	ldr	r3, [r7, #12]
2400cd0e:	2200      	movs	r2, #0
2400cd10:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
2400cd14:	2301      	movs	r3, #1
2400cd16:	e017      	b.n	2400cd48 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
    {
      /* Clear ADDR flag after prepare the transfer parameters */
      /* This action will generate an acknowledge to the Master */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400cd18:	68fb      	ldr	r3, [r7, #12]
2400cd1a:	681b      	ldr	r3, [r3, #0]
2400cd1c:	2208      	movs	r2, #8
2400cd1e:	61da      	str	r2, [r3, #28]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400cd20:	68fb      	ldr	r3, [r7, #12]
2400cd22:	2200      	movs	r2, #0
2400cd24:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Enable DMA Request */
    hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400cd28:	68fb      	ldr	r3, [r7, #12]
2400cd2a:	681b      	ldr	r3, [r3, #0]
2400cd2c:	681a      	ldr	r2, [r3, #0]
2400cd2e:	68fb      	ldr	r3, [r7, #12]
2400cd30:	681b      	ldr	r3, [r3, #0]
2400cd32:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400cd36:	601a      	str	r2, [r3, #0]

    /* Note : The I2C interrupts must be enabled after unlocking current process
    to avoid the risk of I2C interrupt handle execution before current
    process unlock */
    /* REnable ADDR interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
2400cd38:	f248 0102 	movw	r1, #32770	; 0x8002
2400cd3c:	68f8      	ldr	r0, [r7, #12]
2400cd3e:	f002 f995 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400cd42:	2300      	movs	r3, #0
2400cd44:	e000      	b.n	2400cd48 <HAL_I2C_Slave_Seq_Receive_DMA+0x258>
  }
  else
  {
    return HAL_ERROR;
2400cd46:	2301      	movs	r3, #1
  }
}
2400cd48:	4618      	mov	r0, r3
2400cd4a:	3718      	adds	r7, #24
2400cd4c:	46bd      	mov	sp, r7
2400cd4e:	bd80      	pop	{r7, pc}
2400cd50:	2400eb89 	.word	0x2400eb89
2400cd54:	2400d6ad 	.word	0x2400d6ad
2400cd58:	2400e7b1 	.word	0x2400e7b1
2400cd5c:	2400e915 	.word	0x2400e915

2400cd60 <HAL_I2C_EnableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400cd60:	b580      	push	{r7, lr}
2400cd62:	b082      	sub	sp, #8
2400cd64:	af00      	add	r7, sp, #0
2400cd66:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_READY)
2400cd68:	687b      	ldr	r3, [r7, #4]
2400cd6a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cd6e:	b2db      	uxtb	r3, r3
2400cd70:	2b20      	cmp	r3, #32
2400cd72:	d10d      	bne.n	2400cd90 <HAL_I2C_EnableListen_IT+0x30>
  {
    hi2c->State = HAL_I2C_STATE_LISTEN;
2400cd74:	687b      	ldr	r3, [r7, #4]
2400cd76:	2228      	movs	r2, #40	; 0x28
2400cd78:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR = I2C_Slave_ISR_IT;
2400cd7c:	687b      	ldr	r3, [r7, #4]
2400cd7e:	4a07      	ldr	r2, [pc, #28]	; (2400cd9c <HAL_I2C_EnableListen_IT+0x3c>)
2400cd80:	635a      	str	r2, [r3, #52]	; 0x34

    /* Enable the Address Match interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400cd82:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cd86:	6878      	ldr	r0, [r7, #4]
2400cd88:	f002 f970 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400cd8c:	2300      	movs	r3, #0
2400cd8e:	e000      	b.n	2400cd92 <HAL_I2C_EnableListen_IT+0x32>
  }
  else
  {
    return HAL_BUSY;
2400cd90:	2302      	movs	r3, #2
  }
}
2400cd92:	4618      	mov	r0, r3
2400cd94:	3708      	adds	r7, #8
2400cd96:	46bd      	mov	sp, r7
2400cd98:	bd80      	pop	{r7, pc}
2400cd9a:	bf00      	nop
2400cd9c:	2400d2e7 	.word	0x2400d2e7

2400cda0 <HAL_I2C_DisableListen_IT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
{
2400cda0:	b580      	push	{r7, lr}
2400cda2:	b084      	sub	sp, #16
2400cda4:	af00      	add	r7, sp, #0
2400cda6:	6078      	str	r0, [r7, #4]
  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp;

  /* Disable Address listen mode only if a transfer is not ongoing */
  if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400cda8:	687b      	ldr	r3, [r7, #4]
2400cdaa:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cdae:	b2db      	uxtb	r3, r3
2400cdb0:	2b28      	cmp	r3, #40	; 0x28
2400cdb2:	d121      	bne.n	2400cdf8 <HAL_I2C_DisableListen_IT+0x58>
  {
    tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
2400cdb4:	687b      	ldr	r3, [r7, #4]
2400cdb6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400cdba:	b2db      	uxtb	r3, r3
2400cdbc:	f003 0303 	and.w	r3, r3, #3
2400cdc0:	60fb      	str	r3, [r7, #12]
    hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
2400cdc2:	687b      	ldr	r3, [r7, #4]
2400cdc4:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400cdc8:	b2db      	uxtb	r3, r3
2400cdca:	461a      	mov	r2, r3
2400cdcc:	68fb      	ldr	r3, [r7, #12]
2400cdce:	431a      	orrs	r2, r3
2400cdd0:	687b      	ldr	r3, [r7, #4]
2400cdd2:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_READY;
2400cdd4:	687b      	ldr	r3, [r7, #4]
2400cdd6:	2220      	movs	r2, #32
2400cdd8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400cddc:	687b      	ldr	r3, [r7, #4]
2400cdde:	2200      	movs	r2, #0
2400cde0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->XferISR = NULL;
2400cde4:	687b      	ldr	r3, [r7, #4]
2400cde6:	2200      	movs	r2, #0
2400cde8:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable the Address Match interrupt */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400cdea:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400cdee:	6878      	ldr	r0, [r7, #4]
2400cdf0:	f002 f9a0 	bl	2400f134 <I2C_Disable_IRQ>

    return HAL_OK;
2400cdf4:	2300      	movs	r3, #0
2400cdf6:	e000      	b.n	2400cdfa <HAL_I2C_DisableListen_IT+0x5a>
  }
  else
  {
    return HAL_BUSY;
2400cdf8:	2302      	movs	r3, #2
  }
}
2400cdfa:	4618      	mov	r0, r3
2400cdfc:	3710      	adds	r7, #16
2400cdfe:	46bd      	mov	sp, r7
2400ce00:	bd80      	pop	{r7, pc}
	...

2400ce04 <HAL_I2C_Master_Abort_IT>:
  * @param  DevAddress Target device address: The device 7 bits address value
  *         in datasheet must be shifted to the left before calling the interface
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
{
2400ce04:	b580      	push	{r7, lr}
2400ce06:	b084      	sub	sp, #16
2400ce08:	af02      	add	r7, sp, #8
2400ce0a:	6078      	str	r0, [r7, #4]
2400ce0c:	460b      	mov	r3, r1
2400ce0e:	807b      	strh	r3, [r7, #2]
  if (hi2c->Mode == HAL_I2C_MODE_MASTER)
2400ce10:	687b      	ldr	r3, [r7, #4]
2400ce12:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400ce16:	b2db      	uxtb	r3, r3
2400ce18:	2b10      	cmp	r3, #16
2400ce1a:	d13c      	bne.n	2400ce96 <HAL_I2C_Master_Abort_IT+0x92>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400ce1c:	687b      	ldr	r3, [r7, #4]
2400ce1e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400ce22:	2b01      	cmp	r3, #1
2400ce24:	d101      	bne.n	2400ce2a <HAL_I2C_Master_Abort_IT+0x26>
2400ce26:	2302      	movs	r3, #2
2400ce28:	e036      	b.n	2400ce98 <HAL_I2C_Master_Abort_IT+0x94>
2400ce2a:	687b      	ldr	r3, [r7, #4]
2400ce2c:	2201      	movs	r2, #1
2400ce2e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Disable Interrupts and Store Previous state */
    if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400ce32:	687b      	ldr	r3, [r7, #4]
2400ce34:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ce38:	b2db      	uxtb	r3, r3
2400ce3a:	2b21      	cmp	r3, #33	; 0x21
2400ce3c:	d107      	bne.n	2400ce4e <HAL_I2C_Master_Abort_IT+0x4a>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400ce3e:	2101      	movs	r1, #1
2400ce40:	6878      	ldr	r0, [r7, #4]
2400ce42:	f002 f977 	bl	2400f134 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400ce46:	687b      	ldr	r3, [r7, #4]
2400ce48:	2211      	movs	r2, #17
2400ce4a:	631a      	str	r2, [r3, #48]	; 0x30
2400ce4c:	e00c      	b.n	2400ce68 <HAL_I2C_Master_Abort_IT+0x64>
    }
    else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400ce4e:	687b      	ldr	r3, [r7, #4]
2400ce50:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ce54:	b2db      	uxtb	r3, r3
2400ce56:	2b22      	cmp	r3, #34	; 0x22
2400ce58:	d106      	bne.n	2400ce68 <HAL_I2C_Master_Abort_IT+0x64>
    {
      I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400ce5a:	2102      	movs	r1, #2
2400ce5c:	6878      	ldr	r0, [r7, #4]
2400ce5e:	f002 f969 	bl	2400f134 <I2C_Disable_IRQ>
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400ce62:	687b      	ldr	r3, [r7, #4]
2400ce64:	2212      	movs	r2, #18
2400ce66:	631a      	str	r2, [r3, #48]	; 0x30
    {
      /* Do nothing */
    }

    /* Set State at HAL_I2C_STATE_ABORT */
    hi2c->State = HAL_I2C_STATE_ABORT;
2400ce68:	687b      	ldr	r3, [r7, #4]
2400ce6a:	2260      	movs	r2, #96	; 0x60
2400ce6c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Set NBYTES to 1 to generate a dummy read on I2C peripheral */
    /* Set AUTOEND mode, this will generate a NACK then STOP condition to abort the current transfer */
    I2C_TransferConfig(hi2c, DevAddress, 1, I2C_AUTOEND_MODE, I2C_GENERATE_STOP);
2400ce70:	8879      	ldrh	r1, [r7, #2]
2400ce72:	4b0b      	ldr	r3, [pc, #44]	; (2400cea0 <HAL_I2C_Master_Abort_IT+0x9c>)
2400ce74:	9300      	str	r3, [sp, #0]
2400ce76:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400ce7a:	2201      	movs	r2, #1
2400ce7c:	6878      	ldr	r0, [r7, #4]
2400ce7e:	f002 f8c3 	bl	2400f008 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400ce82:	687b      	ldr	r3, [r7, #4]
2400ce84:	2200      	movs	r2, #0
2400ce86:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Note : The I2C interrupts must be enabled after unlocking current process
              to avoid the risk of I2C interrupt handle execution before current
              process unlock */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400ce8a:	2120      	movs	r1, #32
2400ce8c:	6878      	ldr	r0, [r7, #4]
2400ce8e:	f002 f8ed 	bl	2400f06c <I2C_Enable_IRQ>

    return HAL_OK;
2400ce92:	2300      	movs	r3, #0
2400ce94:	e000      	b.n	2400ce98 <HAL_I2C_Master_Abort_IT+0x94>
  }
  else
  {
    /* Wrong usage of abort function */
    /* This function should be used only in case of abort monitored by master device */
    return HAL_ERROR;
2400ce96:	2301      	movs	r3, #1
  }
}
2400ce98:	4618      	mov	r0, r3
2400ce9a:	3708      	adds	r7, #8
2400ce9c:	46bd      	mov	sp, r7
2400ce9e:	bd80      	pop	{r7, pc}
2400cea0:	80004000 	.word	0x80004000

2400cea4 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400cea4:	b580      	push	{r7, lr}
2400cea6:	b084      	sub	sp, #16
2400cea8:	af00      	add	r7, sp, #0
2400ceaa:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400ceac:	687b      	ldr	r3, [r7, #4]
2400ceae:	681b      	ldr	r3, [r3, #0]
2400ceb0:	699b      	ldr	r3, [r3, #24]
2400ceb2:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400ceb4:	687b      	ldr	r3, [r7, #4]
2400ceb6:	681b      	ldr	r3, [r3, #0]
2400ceb8:	681b      	ldr	r3, [r3, #0]
2400ceba:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
2400cebc:	687b      	ldr	r3, [r7, #4]
2400cebe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400cec0:	2b00      	cmp	r3, #0
2400cec2:	d005      	beq.n	2400ced0 <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
2400cec4:	687b      	ldr	r3, [r7, #4]
2400cec6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400cec8:	68ba      	ldr	r2, [r7, #8]
2400ceca:	68f9      	ldr	r1, [r7, #12]
2400cecc:	6878      	ldr	r0, [r7, #4]
2400cece:	4798      	blx	r3
  }
}
2400ced0:	bf00      	nop
2400ced2:	3710      	adds	r7, #16
2400ced4:	46bd      	mov	sp, r7
2400ced6:	bd80      	pop	{r7, pc}

2400ced8 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
2400ced8:	b580      	push	{r7, lr}
2400ceda:	b086      	sub	sp, #24
2400cedc:	af00      	add	r7, sp, #0
2400cede:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
2400cee0:	687b      	ldr	r3, [r7, #4]
2400cee2:	681b      	ldr	r3, [r3, #0]
2400cee4:	699b      	ldr	r3, [r3, #24]
2400cee6:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
2400cee8:	687b      	ldr	r3, [r7, #4]
2400ceea:	681b      	ldr	r3, [r3, #0]
2400ceec:	681b      	ldr	r3, [r3, #0]
2400ceee:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
2400cef0:	697b      	ldr	r3, [r7, #20]
2400cef2:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400cef6:	2b00      	cmp	r3, #0
2400cef8:	d00f      	beq.n	2400cf1a <HAL_I2C_ER_IRQHandler+0x42>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400cefa:	693b      	ldr	r3, [r7, #16]
2400cefc:	f003 0380 	and.w	r3, r3, #128	; 0x80
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
2400cf00:	2b00      	cmp	r3, #0
2400cf02:	d00a      	beq.n	2400cf1a <HAL_I2C_ER_IRQHandler+0x42>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
2400cf04:	687b      	ldr	r3, [r7, #4]
2400cf06:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cf08:	f043 0201 	orr.w	r2, r3, #1
2400cf0c:	687b      	ldr	r3, [r7, #4]
2400cf0e:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2400cf10:	687b      	ldr	r3, [r7, #4]
2400cf12:	681b      	ldr	r3, [r3, #0]
2400cf14:	f44f 7280 	mov.w	r2, #256	; 0x100
2400cf18:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
2400cf1a:	697b      	ldr	r3, [r7, #20]
2400cf1c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2400cf20:	2b00      	cmp	r3, #0
2400cf22:	d00f      	beq.n	2400cf44 <HAL_I2C_ER_IRQHandler+0x6c>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400cf24:	693b      	ldr	r3, [r7, #16]
2400cf26:	f003 0380 	and.w	r3, r3, #128	; 0x80
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
2400cf2a:	2b00      	cmp	r3, #0
2400cf2c:	d00a      	beq.n	2400cf44 <HAL_I2C_ER_IRQHandler+0x6c>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
2400cf2e:	687b      	ldr	r3, [r7, #4]
2400cf30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cf32:	f043 0208 	orr.w	r2, r3, #8
2400cf36:	687b      	ldr	r3, [r7, #4]
2400cf38:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2400cf3a:	687b      	ldr	r3, [r7, #4]
2400cf3c:	681b      	ldr	r3, [r3, #0]
2400cf3e:	f44f 6280 	mov.w	r2, #1024	; 0x400
2400cf42:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
2400cf44:	697b      	ldr	r3, [r7, #20]
2400cf46:	f403 7300 	and.w	r3, r3, #512	; 0x200
2400cf4a:	2b00      	cmp	r3, #0
2400cf4c:	d00f      	beq.n	2400cf6e <HAL_I2C_ER_IRQHandler+0x96>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
2400cf4e:	693b      	ldr	r3, [r7, #16]
2400cf50:	f003 0380 	and.w	r3, r3, #128	; 0x80
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
2400cf54:	2b00      	cmp	r3, #0
2400cf56:	d00a      	beq.n	2400cf6e <HAL_I2C_ER_IRQHandler+0x96>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
2400cf58:	687b      	ldr	r3, [r7, #4]
2400cf5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cf5c:	f043 0202 	orr.w	r2, r3, #2
2400cf60:	687b      	ldr	r3, [r7, #4]
2400cf62:	645a      	str	r2, [r3, #68]	; 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2400cf64:	687b      	ldr	r3, [r7, #4]
2400cf66:	681b      	ldr	r3, [r3, #0]
2400cf68:	f44f 7200 	mov.w	r2, #512	; 0x200
2400cf6c:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400cf6e:	687b      	ldr	r3, [r7, #4]
2400cf70:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400cf72:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
2400cf74:	68fb      	ldr	r3, [r7, #12]
2400cf76:	f003 030b 	and.w	r3, r3, #11
2400cf7a:	2b00      	cmp	r3, #0
2400cf7c:	d003      	beq.n	2400cf86 <HAL_I2C_ER_IRQHandler+0xae>
  {
    I2C_ITError(hi2c, tmperror);
2400cf7e:	68f9      	ldr	r1, [r7, #12]
2400cf80:	6878      	ldr	r0, [r7, #4]
2400cf82:	f001 fa43 	bl	2400e40c <I2C_ITError>
  }
}
2400cf86:	bf00      	nop
2400cf88:	3718      	adds	r7, #24
2400cf8a:	46bd      	mov	sp, r7
2400cf8c:	bd80      	pop	{r7, pc}

2400cf8e <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cf8e:	b480      	push	{r7}
2400cf90:	b083      	sub	sp, #12
2400cf92:	af00      	add	r7, sp, #0
2400cf94:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
2400cf96:	bf00      	nop
2400cf98:	370c      	adds	r7, #12
2400cf9a:	46bd      	mov	sp, r7
2400cf9c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cfa0:	4770      	bx	lr

2400cfa2 <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cfa2:	b480      	push	{r7}
2400cfa4:	b083      	sub	sp, #12
2400cfa6:	af00      	add	r7, sp, #0
2400cfa8:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
2400cfaa:	bf00      	nop
2400cfac:	370c      	adds	r7, #12
2400cfae:	46bd      	mov	sp, r7
2400cfb0:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cfb4:	4770      	bx	lr

2400cfb6 <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cfb6:	b480      	push	{r7}
2400cfb8:	b083      	sub	sp, #12
2400cfba:	af00      	add	r7, sp, #0
2400cfbc:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
2400cfbe:	bf00      	nop
2400cfc0:	370c      	adds	r7, #12
2400cfc2:	46bd      	mov	sp, r7
2400cfc4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cfc8:	4770      	bx	lr

2400cfca <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cfca:	b480      	push	{r7}
2400cfcc:	b083      	sub	sp, #12
2400cfce:	af00      	add	r7, sp, #0
2400cfd0:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
2400cfd2:	bf00      	nop
2400cfd4:	370c      	adds	r7, #12
2400cfd6:	46bd      	mov	sp, r7
2400cfd8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cfdc:	4770      	bx	lr

2400cfde <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
2400cfde:	b480      	push	{r7}
2400cfe0:	b083      	sub	sp, #12
2400cfe2:	af00      	add	r7, sp, #0
2400cfe4:	6078      	str	r0, [r7, #4]
2400cfe6:	460b      	mov	r3, r1
2400cfe8:	70fb      	strb	r3, [r7, #3]
2400cfea:	4613      	mov	r3, r2
2400cfec:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
2400cfee:	bf00      	nop
2400cff0:	370c      	adds	r7, #12
2400cff2:	46bd      	mov	sp, r7
2400cff4:	f85d 7b04 	ldr.w	r7, [sp], #4
2400cff8:	4770      	bx	lr

2400cffa <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400cffa:	b480      	push	{r7}
2400cffc:	b083      	sub	sp, #12
2400cffe:	af00      	add	r7, sp, #0
2400d000:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
2400d002:	bf00      	nop
2400d004:	370c      	adds	r7, #12
2400d006:	46bd      	mov	sp, r7
2400d008:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d00c:	4770      	bx	lr

2400d00e <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400d00e:	b480      	push	{r7}
2400d010:	b083      	sub	sp, #12
2400d012:	af00      	add	r7, sp, #0
2400d014:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
2400d016:	bf00      	nop
2400d018:	370c      	adds	r7, #12
2400d01a:	46bd      	mov	sp, r7
2400d01c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d020:	4770      	bx	lr

2400d022 <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400d022:	b480      	push	{r7}
2400d024:	b083      	sub	sp, #12
2400d026:	af00      	add	r7, sp, #0
2400d028:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
2400d02a:	bf00      	nop
2400d02c:	370c      	adds	r7, #12
2400d02e:	46bd      	mov	sp, r7
2400d030:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d034:	4770      	bx	lr

2400d036 <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400d036:	b480      	push	{r7}
2400d038:	b083      	sub	sp, #12
2400d03a:	af00      	add	r7, sp, #0
2400d03c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
2400d03e:	bf00      	nop
2400d040:	370c      	adds	r7, #12
2400d042:	46bd      	mov	sp, r7
2400d044:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d048:	4770      	bx	lr

2400d04a <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
2400d04a:	b480      	push	{r7}
2400d04c:	b083      	sub	sp, #12
2400d04e:	af00      	add	r7, sp, #0
2400d050:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
2400d052:	bf00      	nop
2400d054:	370c      	adds	r7, #12
2400d056:	46bd      	mov	sp, r7
2400d058:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d05c:	4770      	bx	lr

2400d05e <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
2400d05e:	b480      	push	{r7}
2400d060:	b083      	sub	sp, #12
2400d062:	af00      	add	r7, sp, #0
2400d064:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
2400d066:	687b      	ldr	r3, [r7, #4]
2400d068:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d06c:	b2db      	uxtb	r3, r3
}
2400d06e:	4618      	mov	r0, r3
2400d070:	370c      	adds	r7, #12
2400d072:	46bd      	mov	sp, r7
2400d074:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d078:	4770      	bx	lr

2400d07a <HAL_I2C_GetMode>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL mode
  */
HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
{
2400d07a:	b480      	push	{r7}
2400d07c:	b083      	sub	sp, #12
2400d07e:	af00      	add	r7, sp, #0
2400d080:	6078      	str	r0, [r7, #4]
  return hi2c->Mode;
2400d082:	687b      	ldr	r3, [r7, #4]
2400d084:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400d088:	b2db      	uxtb	r3, r3
}
2400d08a:	4618      	mov	r0, r3
2400d08c:	370c      	adds	r7, #12
2400d08e:	46bd      	mov	sp, r7
2400d090:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d094:	4770      	bx	lr

2400d096 <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
2400d096:	b480      	push	{r7}
2400d098:	b083      	sub	sp, #12
2400d09a:	af00      	add	r7, sp, #0
2400d09c:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
2400d09e:	687b      	ldr	r3, [r7, #4]
2400d0a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2400d0a2:	4618      	mov	r0, r3
2400d0a4:	370c      	adds	r7, #12
2400d0a6:	46bd      	mov	sp, r7
2400d0a8:	f85d 7b04 	ldr.w	r7, [sp], #4
2400d0ac:	4770      	bx	lr

2400d0ae <I2C_Master_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
2400d0ae:	b580      	push	{r7, lr}
2400d0b0:	b088      	sub	sp, #32
2400d0b2:	af02      	add	r7, sp, #8
2400d0b4:	60f8      	str	r0, [r7, #12]
2400d0b6:	60b9      	str	r1, [r7, #8]
2400d0b8:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
2400d0ba:	68bb      	ldr	r3, [r7, #8]
2400d0bc:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400d0be:	68fb      	ldr	r3, [r7, #12]
2400d0c0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d0c4:	2b01      	cmp	r3, #1
2400d0c6:	d101      	bne.n	2400d0cc <I2C_Master_ISR_IT+0x1e>
2400d0c8:	2302      	movs	r3, #2
2400d0ca:	e108      	b.n	2400d2de <I2C_Master_ISR_IT+0x230>
2400d0cc:	68fb      	ldr	r3, [r7, #12]
2400d0ce:	2201      	movs	r2, #1
2400d0d0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d0d4:	697b      	ldr	r3, [r7, #20]
2400d0d6:	f003 0310 	and.w	r3, r3, #16
2400d0da:	2b00      	cmp	r3, #0
2400d0dc:	d012      	beq.n	2400d104 <I2C_Master_ISR_IT+0x56>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d0de:	687b      	ldr	r3, [r7, #4]
2400d0e0:	f003 0310 	and.w	r3, r3, #16
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d0e4:	2b00      	cmp	r3, #0
2400d0e6:	d00d      	beq.n	2400d104 <I2C_Master_ISR_IT+0x56>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d0e8:	68fb      	ldr	r3, [r7, #12]
2400d0ea:	681b      	ldr	r3, [r3, #0]
2400d0ec:	2210      	movs	r2, #16
2400d0ee:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d0f0:	68fb      	ldr	r3, [r7, #12]
2400d0f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d0f4:	f043 0204 	orr.w	r2, r3, #4
2400d0f8:	68fb      	ldr	r3, [r7, #12]
2400d0fa:	645a      	str	r2, [r3, #68]	; 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400d0fc:	68f8      	ldr	r0, [r7, #12]
2400d0fe:	f001 fa7c 	bl	2400e5fa <I2C_Flush_TXDR>
2400d102:	e0d9      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d104:	697b      	ldr	r3, [r7, #20]
2400d106:	f003 0304 	and.w	r3, r3, #4
2400d10a:	2b00      	cmp	r3, #0
2400d10c:	d022      	beq.n	2400d154 <I2C_Master_ISR_IT+0xa6>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400d10e:	687b      	ldr	r3, [r7, #4]
2400d110:	f003 0304 	and.w	r3, r3, #4
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d114:	2b00      	cmp	r3, #0
2400d116:	d01d      	beq.n	2400d154 <I2C_Master_ISR_IT+0xa6>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400d118:	697b      	ldr	r3, [r7, #20]
2400d11a:	f023 0304 	bic.w	r3, r3, #4
2400d11e:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d120:	68fb      	ldr	r3, [r7, #12]
2400d122:	681b      	ldr	r3, [r3, #0]
2400d124:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d126:	68fb      	ldr	r3, [r7, #12]
2400d128:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d12a:	b2d2      	uxtb	r2, r2
2400d12c:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400d12e:	68fb      	ldr	r3, [r7, #12]
2400d130:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d132:	1c5a      	adds	r2, r3, #1
2400d134:	68fb      	ldr	r3, [r7, #12]
2400d136:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400d138:	68fb      	ldr	r3, [r7, #12]
2400d13a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d13c:	3b01      	subs	r3, #1
2400d13e:	b29a      	uxth	r2, r3
2400d140:	68fb      	ldr	r3, [r7, #12]
2400d142:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400d144:	68fb      	ldr	r3, [r7, #12]
2400d146:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d148:	b29b      	uxth	r3, r3
2400d14a:	3b01      	subs	r3, #1
2400d14c:	b29a      	uxth	r2, r3
2400d14e:	68fb      	ldr	r3, [r7, #12]
2400d150:	855a      	strh	r2, [r3, #42]	; 0x2a
2400d152:	e0b1      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d154:	697b      	ldr	r3, [r7, #20]
2400d156:	f003 0302 	and.w	r3, r3, #2
2400d15a:	2b00      	cmp	r3, #0
2400d15c:	d01d      	beq.n	2400d19a <I2C_Master_ISR_IT+0xec>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400d15e:	687b      	ldr	r3, [r7, #4]
2400d160:	f003 0302 	and.w	r3, r3, #2
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d164:	2b00      	cmp	r3, #0
2400d166:	d018      	beq.n	2400d19a <I2C_Master_ISR_IT+0xec>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400d168:	68fb      	ldr	r3, [r7, #12]
2400d16a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d16c:	781a      	ldrb	r2, [r3, #0]
2400d16e:	68fb      	ldr	r3, [r7, #12]
2400d170:	681b      	ldr	r3, [r3, #0]
2400d172:	629a      	str	r2, [r3, #40]	; 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400d174:	68fb      	ldr	r3, [r7, #12]
2400d176:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d178:	1c5a      	adds	r2, r3, #1
2400d17a:	68fb      	ldr	r3, [r7, #12]
2400d17c:	625a      	str	r2, [r3, #36]	; 0x24

    hi2c->XferSize--;
2400d17e:	68fb      	ldr	r3, [r7, #12]
2400d180:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d182:	3b01      	subs	r3, #1
2400d184:	b29a      	uxth	r2, r3
2400d186:	68fb      	ldr	r3, [r7, #12]
2400d188:	851a      	strh	r2, [r3, #40]	; 0x28
    hi2c->XferCount--;
2400d18a:	68fb      	ldr	r3, [r7, #12]
2400d18c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d18e:	b29b      	uxth	r3, r3
2400d190:	3b01      	subs	r3, #1
2400d192:	b29a      	uxth	r2, r3
2400d194:	68fb      	ldr	r3, [r7, #12]
2400d196:	855a      	strh	r2, [r3, #42]	; 0x2a
2400d198:	e08e      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
2400d19a:	697b      	ldr	r3, [r7, #20]
2400d19c:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400d1a0:	2b00      	cmp	r3, #0
2400d1a2:	d05c      	beq.n	2400d25e <I2C_Master_ISR_IT+0x1b0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d1a4:	687b      	ldr	r3, [r7, #4]
2400d1a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
2400d1aa:	2b00      	cmp	r3, #0
2400d1ac:	d057      	beq.n	2400d25e <I2C_Master_ISR_IT+0x1b0>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400d1ae:	68fb      	ldr	r3, [r7, #12]
2400d1b0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d1b2:	b29b      	uxth	r3, r3
2400d1b4:	2b00      	cmp	r3, #0
2400d1b6:	d040      	beq.n	2400d23a <I2C_Master_ISR_IT+0x18c>
2400d1b8:	68fb      	ldr	r3, [r7, #12]
2400d1ba:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d1bc:	2b00      	cmp	r3, #0
2400d1be:	d13c      	bne.n	2400d23a <I2C_Master_ISR_IT+0x18c>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400d1c0:	68fb      	ldr	r3, [r7, #12]
2400d1c2:	681b      	ldr	r3, [r3, #0]
2400d1c4:	685b      	ldr	r3, [r3, #4]
2400d1c6:	b29b      	uxth	r3, r3
2400d1c8:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400d1cc:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d1ce:	68fb      	ldr	r3, [r7, #12]
2400d1d0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d1d2:	b29b      	uxth	r3, r3
2400d1d4:	2bff      	cmp	r3, #255	; 0xff
2400d1d6:	d90e      	bls.n	2400d1f6 <I2C_Master_ISR_IT+0x148>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400d1d8:	68fb      	ldr	r3, [r7, #12]
2400d1da:	22ff      	movs	r2, #255	; 0xff
2400d1dc:	851a      	strh	r2, [r3, #40]	; 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
2400d1de:	68fb      	ldr	r3, [r7, #12]
2400d1e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d1e2:	b2da      	uxtb	r2, r3
2400d1e4:	8a79      	ldrh	r1, [r7, #18]
2400d1e6:	2300      	movs	r3, #0
2400d1e8:	9300      	str	r3, [sp, #0]
2400d1ea:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400d1ee:	68f8      	ldr	r0, [r7, #12]
2400d1f0:	f001 ff0a 	bl	2400f008 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d1f4:	e032      	b.n	2400d25c <I2C_Master_ISR_IT+0x1ae>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400d1f6:	68fb      	ldr	r3, [r7, #12]
2400d1f8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d1fa:	b29a      	uxth	r2, r3
2400d1fc:	68fb      	ldr	r3, [r7, #12]
2400d1fe:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400d200:	68fb      	ldr	r3, [r7, #12]
2400d202:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d204:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d208:	d00b      	beq.n	2400d222 <I2C_Master_ISR_IT+0x174>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
2400d20a:	68fb      	ldr	r3, [r7, #12]
2400d20c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d20e:	b2da      	uxtb	r2, r3
                             hi2c->XferOptions, I2C_NO_STARTSTOP);
2400d210:	68fb      	ldr	r3, [r7, #12]
2400d212:	6adb      	ldr	r3, [r3, #44]	; 0x2c
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
2400d214:	8a79      	ldrh	r1, [r7, #18]
2400d216:	2000      	movs	r0, #0
2400d218:	9000      	str	r0, [sp, #0]
2400d21a:	68f8      	ldr	r0, [r7, #12]
2400d21c:	f001 fef4 	bl	2400f008 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d220:	e01c      	b.n	2400d25c <I2C_Master_ISR_IT+0x1ae>
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
2400d222:	68fb      	ldr	r3, [r7, #12]
2400d224:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d226:	b2da      	uxtb	r2, r3
2400d228:	8a79      	ldrh	r1, [r7, #18]
2400d22a:	2300      	movs	r3, #0
2400d22c:	9300      	str	r3, [sp, #0]
2400d22e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400d232:	68f8      	ldr	r0, [r7, #12]
2400d234:	f001 fee8 	bl	2400f008 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d238:	e010      	b.n	2400d25c <I2C_Master_ISR_IT+0x1ae>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400d23a:	68fb      	ldr	r3, [r7, #12]
2400d23c:	681b      	ldr	r3, [r3, #0]
2400d23e:	685b      	ldr	r3, [r3, #4]
2400d240:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d244:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d248:	d003      	beq.n	2400d252 <I2C_Master_ISR_IT+0x1a4>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400d24a:	68f8      	ldr	r0, [r7, #12]
2400d24c:	f000 fd32 	bl	2400dcb4 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400d250:	e032      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d252:	2140      	movs	r1, #64	; 0x40
2400d254:	68f8      	ldr	r0, [r7, #12]
2400d256:	f001 f8d9 	bl	2400e40c <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
2400d25a:	e02d      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
2400d25c:	e02c      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
2400d25e:	697b      	ldr	r3, [r7, #20]
2400d260:	f003 0340 	and.w	r3, r3, #64	; 0x40
2400d264:	2b00      	cmp	r3, #0
2400d266:	d027      	beq.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d268:	687b      	ldr	r3, [r7, #4]
2400d26a:	f003 0340 	and.w	r3, r3, #64	; 0x40
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
2400d26e:	2b00      	cmp	r3, #0
2400d270:	d022      	beq.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
  {
    if (hi2c->XferCount == 0U)
2400d272:	68fb      	ldr	r3, [r7, #12]
2400d274:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d276:	b29b      	uxth	r3, r3
2400d278:	2b00      	cmp	r3, #0
2400d27a:	d119      	bne.n	2400d2b0 <I2C_Master_ISR_IT+0x202>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400d27c:	68fb      	ldr	r3, [r7, #12]
2400d27e:	681b      	ldr	r3, [r3, #0]
2400d280:	685b      	ldr	r3, [r3, #4]
2400d282:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d286:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d28a:	d015      	beq.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400d28c:	68fb      	ldr	r3, [r7, #12]
2400d28e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d290:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d294:	d108      	bne.n	2400d2a8 <I2C_Master_ISR_IT+0x1fa>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400d296:	68fb      	ldr	r3, [r7, #12]
2400d298:	681b      	ldr	r3, [r3, #0]
2400d29a:	685a      	ldr	r2, [r3, #4]
2400d29c:	68fb      	ldr	r3, [r7, #12]
2400d29e:	681b      	ldr	r3, [r3, #0]
2400d2a0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d2a4:	605a      	str	r2, [r3, #4]
2400d2a6:	e007      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400d2a8:	68f8      	ldr	r0, [r7, #12]
2400d2aa:	f000 fd03 	bl	2400dcb4 <I2C_ITMasterSeqCplt>
2400d2ae:	e003      	b.n	2400d2b8 <I2C_Master_ISR_IT+0x20a>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d2b0:	2140      	movs	r1, #64	; 0x40
2400d2b2:	68f8      	ldr	r0, [r7, #12]
2400d2b4:	f001 f8aa 	bl	2400e40c <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d2b8:	697b      	ldr	r3, [r7, #20]
2400d2ba:	f003 0320 	and.w	r3, r3, #32
2400d2be:	2b00      	cmp	r3, #0
2400d2c0:	d008      	beq.n	2400d2d4 <I2C_Master_ISR_IT+0x226>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d2c2:	687b      	ldr	r3, [r7, #4]
2400d2c4:	f003 0320 	and.w	r3, r3, #32
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d2c8:	2b00      	cmp	r3, #0
2400d2ca:	d003      	beq.n	2400d2d4 <I2C_Master_ISR_IT+0x226>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
2400d2cc:	6979      	ldr	r1, [r7, #20]
2400d2ce:	68f8      	ldr	r0, [r7, #12]
2400d2d0:	f000 fd8a 	bl	2400dde8 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d2d4:	68fb      	ldr	r3, [r7, #12]
2400d2d6:	2200      	movs	r2, #0
2400d2d8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d2dc:	2300      	movs	r3, #0
}
2400d2de:	4618      	mov	r0, r3
2400d2e0:	3718      	adds	r7, #24
2400d2e2:	46bd      	mov	sp, r7
2400d2e4:	bd80      	pop	{r7, pc}

2400d2e6 <I2C_Slave_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                          uint32_t ITSources)
{
2400d2e6:	b580      	push	{r7, lr}
2400d2e8:	b086      	sub	sp, #24
2400d2ea:	af00      	add	r7, sp, #0
2400d2ec:	60f8      	str	r0, [r7, #12]
2400d2ee:	60b9      	str	r1, [r7, #8]
2400d2f0:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d2f2:	68fb      	ldr	r3, [r7, #12]
2400d2f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d2f6:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
2400d2f8:	68bb      	ldr	r3, [r7, #8]
2400d2fa:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
2400d2fc:	68fb      	ldr	r3, [r7, #12]
2400d2fe:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d302:	2b01      	cmp	r3, #1
2400d304:	d101      	bne.n	2400d30a <I2C_Slave_ISR_IT+0x24>
2400d306:	2302      	movs	r3, #2
2400d308:	e0e1      	b.n	2400d4ce <I2C_Slave_ISR_IT+0x1e8>
2400d30a:	68fb      	ldr	r3, [r7, #12]
2400d30c:	2201      	movs	r2, #1
2400d30e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d312:	693b      	ldr	r3, [r7, #16]
2400d314:	f003 0320 	and.w	r3, r3, #32
2400d318:	2b00      	cmp	r3, #0
2400d31a:	d008      	beq.n	2400d32e <I2C_Slave_ISR_IT+0x48>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d31c:	687b      	ldr	r3, [r7, #4]
2400d31e:	f003 0320 	and.w	r3, r3, #32
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d322:	2b00      	cmp	r3, #0
2400d324:	d003      	beq.n	2400d32e <I2C_Slave_ISR_IT+0x48>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
2400d326:	6939      	ldr	r1, [r7, #16]
2400d328:	68f8      	ldr	r0, [r7, #12]
2400d32a:	f000 fe25 	bl	2400df78 <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d32e:	693b      	ldr	r3, [r7, #16]
2400d330:	f003 0310 	and.w	r3, r3, #16
2400d334:	2b00      	cmp	r3, #0
2400d336:	d04b      	beq.n	2400d3d0 <I2C_Slave_ISR_IT+0xea>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d338:	687b      	ldr	r3, [r7, #4]
2400d33a:	f003 0310 	and.w	r3, r3, #16
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
2400d33e:	2b00      	cmp	r3, #0
2400d340:	d046      	beq.n	2400d3d0 <I2C_Slave_ISR_IT+0xea>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
2400d342:	68fb      	ldr	r3, [r7, #12]
2400d344:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d346:	b29b      	uxth	r3, r3
2400d348:	2b00      	cmp	r3, #0
2400d34a:	d128      	bne.n	2400d39e <I2C_Slave_ISR_IT+0xb8>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
2400d34c:	68fb      	ldr	r3, [r7, #12]
2400d34e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d352:	b2db      	uxtb	r3, r3
2400d354:	2b28      	cmp	r3, #40	; 0x28
2400d356:	d108      	bne.n	2400d36a <I2C_Slave_ISR_IT+0x84>
2400d358:	697b      	ldr	r3, [r7, #20]
2400d35a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d35e:	d104      	bne.n	2400d36a <I2C_Slave_ISR_IT+0x84>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
2400d360:	6939      	ldr	r1, [r7, #16]
2400d362:	68f8      	ldr	r0, [r7, #12]
2400d364:	f000 fffe 	bl	2400e364 <I2C_ITListenCplt>
2400d368:	e031      	b.n	2400d3ce <I2C_Slave_ISR_IT+0xe8>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400d36a:	68fb      	ldr	r3, [r7, #12]
2400d36c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d370:	b2db      	uxtb	r3, r3
2400d372:	2b29      	cmp	r3, #41	; 0x29
2400d374:	d10e      	bne.n	2400d394 <I2C_Slave_ISR_IT+0xae>
2400d376:	697b      	ldr	r3, [r7, #20]
2400d378:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d37c:	d00a      	beq.n	2400d394 <I2C_Slave_ISR_IT+0xae>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d37e:	68fb      	ldr	r3, [r7, #12]
2400d380:	681b      	ldr	r3, [r3, #0]
2400d382:	2210      	movs	r2, #16
2400d384:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
2400d386:	68f8      	ldr	r0, [r7, #12]
2400d388:	f001 f937 	bl	2400e5fa <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400d38c:	68f8      	ldr	r0, [r7, #12]
2400d38e:	f000 fcce 	bl	2400dd2e <I2C_ITSlaveSeqCplt>
2400d392:	e01c      	b.n	2400d3ce <I2C_Slave_ISR_IT+0xe8>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d394:	68fb      	ldr	r3, [r7, #12]
2400d396:	681b      	ldr	r3, [r3, #0]
2400d398:	2210      	movs	r2, #16
2400d39a:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
2400d39c:	e08f      	b.n	2400d4be <I2C_Slave_ISR_IT+0x1d8>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d39e:	68fb      	ldr	r3, [r7, #12]
2400d3a0:	681b      	ldr	r3, [r3, #0]
2400d3a2:	2210      	movs	r2, #16
2400d3a4:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d3a6:	68fb      	ldr	r3, [r7, #12]
2400d3a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d3aa:	f043 0204 	orr.w	r2, r3, #4
2400d3ae:	68fb      	ldr	r3, [r7, #12]
2400d3b0:	645a      	str	r2, [r3, #68]	; 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400d3b2:	697b      	ldr	r3, [r7, #20]
2400d3b4:	2b00      	cmp	r3, #0
2400d3b6:	d003      	beq.n	2400d3c0 <I2C_Slave_ISR_IT+0xda>
2400d3b8:	697b      	ldr	r3, [r7, #20]
2400d3ba:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400d3be:	d17e      	bne.n	2400d4be <I2C_Slave_ISR_IT+0x1d8>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
2400d3c0:	68fb      	ldr	r3, [r7, #12]
2400d3c2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d3c4:	4619      	mov	r1, r3
2400d3c6:	68f8      	ldr	r0, [r7, #12]
2400d3c8:	f001 f820 	bl	2400e40c <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400d3cc:	e077      	b.n	2400d4be <I2C_Slave_ISR_IT+0x1d8>
2400d3ce:	e076      	b.n	2400d4be <I2C_Slave_ISR_IT+0x1d8>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d3d0:	693b      	ldr	r3, [r7, #16]
2400d3d2:	f003 0304 	and.w	r3, r3, #4
2400d3d6:	2b00      	cmp	r3, #0
2400d3d8:	d02f      	beq.n	2400d43a <I2C_Slave_ISR_IT+0x154>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
2400d3da:	687b      	ldr	r3, [r7, #4]
2400d3dc:	f003 0304 	and.w	r3, r3, #4
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
2400d3e0:	2b00      	cmp	r3, #0
2400d3e2:	d02a      	beq.n	2400d43a <I2C_Slave_ISR_IT+0x154>
  {
    if (hi2c->XferCount > 0U)
2400d3e4:	68fb      	ldr	r3, [r7, #12]
2400d3e6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d3e8:	b29b      	uxth	r3, r3
2400d3ea:	2b00      	cmp	r3, #0
2400d3ec:	d018      	beq.n	2400d420 <I2C_Slave_ISR_IT+0x13a>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400d3ee:	68fb      	ldr	r3, [r7, #12]
2400d3f0:	681b      	ldr	r3, [r3, #0]
2400d3f2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400d3f4:	68fb      	ldr	r3, [r7, #12]
2400d3f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d3f8:	b2d2      	uxtb	r2, r2
2400d3fa:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400d3fc:	68fb      	ldr	r3, [r7, #12]
2400d3fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d400:	1c5a      	adds	r2, r3, #1
2400d402:	68fb      	ldr	r3, [r7, #12]
2400d404:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
2400d406:	68fb      	ldr	r3, [r7, #12]
2400d408:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d40a:	3b01      	subs	r3, #1
2400d40c:	b29a      	uxth	r2, r3
2400d40e:	68fb      	ldr	r3, [r7, #12]
2400d410:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400d412:	68fb      	ldr	r3, [r7, #12]
2400d414:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d416:	b29b      	uxth	r3, r3
2400d418:	3b01      	subs	r3, #1
2400d41a:	b29a      	uxth	r2, r3
2400d41c:	68fb      	ldr	r3, [r7, #12]
2400d41e:	855a      	strh	r2, [r3, #42]	; 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
2400d420:	68fb      	ldr	r3, [r7, #12]
2400d422:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d424:	b29b      	uxth	r3, r3
2400d426:	2b00      	cmp	r3, #0
2400d428:	d14b      	bne.n	2400d4c2 <I2C_Slave_ISR_IT+0x1dc>
2400d42a:	697b      	ldr	r3, [r7, #20]
2400d42c:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d430:	d047      	beq.n	2400d4c2 <I2C_Slave_ISR_IT+0x1dc>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
2400d432:	68f8      	ldr	r0, [r7, #12]
2400d434:	f000 fc7b 	bl	2400dd2e <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
2400d438:	e043      	b.n	2400d4c2 <I2C_Slave_ISR_IT+0x1dc>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
2400d43a:	693b      	ldr	r3, [r7, #16]
2400d43c:	f003 0308 	and.w	r3, r3, #8
2400d440:	2b00      	cmp	r3, #0
2400d442:	d009      	beq.n	2400d458 <I2C_Slave_ISR_IT+0x172>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400d444:	687b      	ldr	r3, [r7, #4]
2400d446:	f003 0308 	and.w	r3, r3, #8
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
2400d44a:	2b00      	cmp	r3, #0
2400d44c:	d004      	beq.n	2400d458 <I2C_Slave_ISR_IT+0x172>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
2400d44e:	6939      	ldr	r1, [r7, #16]
2400d450:	68f8      	ldr	r0, [r7, #12]
2400d452:	f000 fbab 	bl	2400dbac <I2C_ITAddrCplt>
2400d456:	e035      	b.n	2400d4c4 <I2C_Slave_ISR_IT+0x1de>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d458:	693b      	ldr	r3, [r7, #16]
2400d45a:	f003 0302 	and.w	r3, r3, #2
2400d45e:	2b00      	cmp	r3, #0
2400d460:	d030      	beq.n	2400d4c4 <I2C_Slave_ISR_IT+0x1de>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
2400d462:	687b      	ldr	r3, [r7, #4]
2400d464:	f003 0302 	and.w	r3, r3, #2
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
2400d468:	2b00      	cmp	r3, #0
2400d46a:	d02b      	beq.n	2400d4c4 <I2C_Slave_ISR_IT+0x1de>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Data have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
2400d46c:	68fb      	ldr	r3, [r7, #12]
2400d46e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d470:	b29b      	uxth	r3, r3
2400d472:	2b00      	cmp	r3, #0
2400d474:	d018      	beq.n	2400d4a8 <I2C_Slave_ISR_IT+0x1c2>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
2400d476:	68fb      	ldr	r3, [r7, #12]
2400d478:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d47a:	781a      	ldrb	r2, [r3, #0]
2400d47c:	68fb      	ldr	r3, [r7, #12]
2400d47e:	681b      	ldr	r3, [r3, #0]
2400d480:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
2400d482:	68fb      	ldr	r3, [r7, #12]
2400d484:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400d486:	1c5a      	adds	r2, r3, #1
2400d488:	68fb      	ldr	r3, [r7, #12]
2400d48a:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
2400d48c:	68fb      	ldr	r3, [r7, #12]
2400d48e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d490:	b29b      	uxth	r3, r3
2400d492:	3b01      	subs	r3, #1
2400d494:	b29a      	uxth	r2, r3
2400d496:	68fb      	ldr	r3, [r7, #12]
2400d498:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
2400d49a:	68fb      	ldr	r3, [r7, #12]
2400d49c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d49e:	3b01      	subs	r3, #1
2400d4a0:	b29a      	uxth	r2, r3
2400d4a2:	68fb      	ldr	r3, [r7, #12]
2400d4a4:	851a      	strh	r2, [r3, #40]	; 0x28
2400d4a6:	e00d      	b.n	2400d4c4 <I2C_Slave_ISR_IT+0x1de>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400d4a8:	697b      	ldr	r3, [r7, #20]
2400d4aa:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400d4ae:	d002      	beq.n	2400d4b6 <I2C_Slave_ISR_IT+0x1d0>
2400d4b0:	697b      	ldr	r3, [r7, #20]
2400d4b2:	2b00      	cmp	r3, #0
2400d4b4:	d106      	bne.n	2400d4c4 <I2C_Slave_ISR_IT+0x1de>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
2400d4b6:	68f8      	ldr	r0, [r7, #12]
2400d4b8:	f000 fc39 	bl	2400dd2e <I2C_ITSlaveSeqCplt>
2400d4bc:	e002      	b.n	2400d4c4 <I2C_Slave_ISR_IT+0x1de>
    if (hi2c->XferCount == 0U)
2400d4be:	bf00      	nop
2400d4c0:	e000      	b.n	2400d4c4 <I2C_Slave_ISR_IT+0x1de>
    if ((hi2c->XferCount == 0U) && \
2400d4c2:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d4c4:	68fb      	ldr	r3, [r7, #12]
2400d4c6:	2200      	movs	r2, #0
2400d4c8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d4cc:	2300      	movs	r3, #0
}
2400d4ce:	4618      	mov	r0, r3
2400d4d0:	3718      	adds	r7, #24
2400d4d2:	46bd      	mov	sp, r7
2400d4d4:	bd80      	pop	{r7, pc}

2400d4d6 <I2C_Master_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                            uint32_t ITSources)
{
2400d4d6:	b580      	push	{r7, lr}
2400d4d8:	b088      	sub	sp, #32
2400d4da:	af02      	add	r7, sp, #8
2400d4dc:	60f8      	str	r0, [r7, #12]
2400d4de:	60b9      	str	r1, [r7, #8]
2400d4e0:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
2400d4e2:	68fb      	ldr	r3, [r7, #12]
2400d4e4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d4e8:	2b01      	cmp	r3, #1
2400d4ea:	d101      	bne.n	2400d4f0 <I2C_Master_ISR_DMA+0x1a>
2400d4ec:	2302      	movs	r3, #2
2400d4ee:	e0d9      	b.n	2400d6a4 <I2C_Master_ISR_DMA+0x1ce>
2400d4f0:	68fb      	ldr	r3, [r7, #12]
2400d4f2:	2201      	movs	r2, #1
2400d4f4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d4f8:	68bb      	ldr	r3, [r7, #8]
2400d4fa:	f003 0310 	and.w	r3, r3, #16
2400d4fe:	2b00      	cmp	r3, #0
2400d500:	d016      	beq.n	2400d530 <I2C_Master_ISR_DMA+0x5a>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d502:	687b      	ldr	r3, [r7, #4]
2400d504:	f003 0310 	and.w	r3, r3, #16
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d508:	2b00      	cmp	r3, #0
2400d50a:	d011      	beq.n	2400d530 <I2C_Master_ISR_DMA+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d50c:	68fb      	ldr	r3, [r7, #12]
2400d50e:	681b      	ldr	r3, [r3, #0]
2400d510:	2210      	movs	r2, #16
2400d512:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d514:	68fb      	ldr	r3, [r7, #12]
2400d516:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d518:	f043 0204 	orr.w	r2, r3, #4
2400d51c:	68fb      	ldr	r3, [r7, #12]
2400d51e:	645a      	str	r2, [r3, #68]	; 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400d520:	2120      	movs	r1, #32
2400d522:	68f8      	ldr	r0, [r7, #12]
2400d524:	f001 fda2 	bl	2400f06c <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400d528:	68f8      	ldr	r0, [r7, #12]
2400d52a:	f001 f866 	bl	2400e5fa <I2C_Flush_TXDR>
2400d52e:	e0b4      	b.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
2400d530:	68bb      	ldr	r3, [r7, #8]
2400d532:	f003 0380 	and.w	r3, r3, #128	; 0x80
2400d536:	2b00      	cmp	r3, #0
2400d538:	d071      	beq.n	2400d61e <I2C_Master_ISR_DMA+0x148>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d53a:	687b      	ldr	r3, [r7, #4]
2400d53c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
2400d540:	2b00      	cmp	r3, #0
2400d542:	d06c      	beq.n	2400d61e <I2C_Master_ISR_DMA+0x148>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
2400d544:	68fb      	ldr	r3, [r7, #12]
2400d546:	681b      	ldr	r3, [r3, #0]
2400d548:	681a      	ldr	r2, [r3, #0]
2400d54a:	68fb      	ldr	r3, [r7, #12]
2400d54c:	681b      	ldr	r3, [r3, #0]
2400d54e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
2400d552:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
2400d554:	68fb      	ldr	r3, [r7, #12]
2400d556:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d558:	b29b      	uxth	r3, r3
2400d55a:	2b00      	cmp	r3, #0
2400d55c:	d04e      	beq.n	2400d5fc <I2C_Master_ISR_DMA+0x126>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
2400d55e:	68fb      	ldr	r3, [r7, #12]
2400d560:	681b      	ldr	r3, [r3, #0]
2400d562:	685b      	ldr	r3, [r3, #4]
2400d564:	b29b      	uxth	r3, r3
2400d566:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400d56a:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400d56c:	68fb      	ldr	r3, [r7, #12]
2400d56e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d570:	b29b      	uxth	r3, r3
2400d572:	2bff      	cmp	r3, #255	; 0xff
2400d574:	d906      	bls.n	2400d584 <I2C_Master_ISR_DMA+0xae>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
2400d576:	68fb      	ldr	r3, [r7, #12]
2400d578:	22ff      	movs	r2, #255	; 0xff
2400d57a:	851a      	strh	r2, [r3, #40]	; 0x28
        xfermode = I2C_RELOAD_MODE;
2400d57c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400d580:	617b      	str	r3, [r7, #20]
2400d582:	e010      	b.n	2400d5a6 <I2C_Master_ISR_DMA+0xd0>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
2400d584:	68fb      	ldr	r3, [r7, #12]
2400d586:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d588:	b29a      	uxth	r2, r3
2400d58a:	68fb      	ldr	r3, [r7, #12]
2400d58c:	851a      	strh	r2, [r3, #40]	; 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400d58e:	68fb      	ldr	r3, [r7, #12]
2400d590:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d592:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d596:	d003      	beq.n	2400d5a0 <I2C_Master_ISR_DMA+0xca>
        {
          xfermode = hi2c->XferOptions;
2400d598:	68fb      	ldr	r3, [r7, #12]
2400d59a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d59c:	617b      	str	r3, [r7, #20]
2400d59e:	e002      	b.n	2400d5a6 <I2C_Master_ISR_DMA+0xd0>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
2400d5a0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
2400d5a4:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
2400d5a6:	68fb      	ldr	r3, [r7, #12]
2400d5a8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d5aa:	b2da      	uxtb	r2, r3
2400d5ac:	8a79      	ldrh	r1, [r7, #18]
2400d5ae:	2300      	movs	r3, #0
2400d5b0:	9300      	str	r3, [sp, #0]
2400d5b2:	697b      	ldr	r3, [r7, #20]
2400d5b4:	68f8      	ldr	r0, [r7, #12]
2400d5b6:	f001 fd27 	bl	2400f008 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
2400d5ba:	68fb      	ldr	r3, [r7, #12]
2400d5bc:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d5be:	b29a      	uxth	r2, r3
2400d5c0:	68fb      	ldr	r3, [r7, #12]
2400d5c2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400d5c4:	1ad3      	subs	r3, r2, r3
2400d5c6:	b29a      	uxth	r2, r3
2400d5c8:	68fb      	ldr	r3, [r7, #12]
2400d5ca:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400d5cc:	68fb      	ldr	r3, [r7, #12]
2400d5ce:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d5d2:	b2db      	uxtb	r3, r3
2400d5d4:	2b22      	cmp	r3, #34	; 0x22
2400d5d6:	d108      	bne.n	2400d5ea <I2C_Master_ISR_DMA+0x114>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
2400d5d8:	68fb      	ldr	r3, [r7, #12]
2400d5da:	681b      	ldr	r3, [r3, #0]
2400d5dc:	681a      	ldr	r2, [r3, #0]
2400d5de:	68fb      	ldr	r3, [r7, #12]
2400d5e0:	681b      	ldr	r3, [r3, #0]
2400d5e2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400d5e6:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400d5e8:	e057      	b.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
2400d5ea:	68fb      	ldr	r3, [r7, #12]
2400d5ec:	681b      	ldr	r3, [r3, #0]
2400d5ee:	681a      	ldr	r2, [r3, #0]
2400d5f0:	68fb      	ldr	r3, [r7, #12]
2400d5f2:	681b      	ldr	r3, [r3, #0]
2400d5f4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d5f8:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
2400d5fa:	e04e      	b.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400d5fc:	68fb      	ldr	r3, [r7, #12]
2400d5fe:	681b      	ldr	r3, [r3, #0]
2400d600:	685b      	ldr	r3, [r3, #4]
2400d602:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d606:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d60a:	d003      	beq.n	2400d614 <I2C_Master_ISR_DMA+0x13e>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
2400d60c:	68f8      	ldr	r0, [r7, #12]
2400d60e:	f000 fb51 	bl	2400dcb4 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
2400d612:	e042      	b.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d614:	2140      	movs	r1, #64	; 0x40
2400d616:	68f8      	ldr	r0, [r7, #12]
2400d618:	f000 fef8 	bl	2400e40c <I2C_ITError>
    if (hi2c->XferCount != 0U)
2400d61c:	e03d      	b.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
2400d61e:	68bb      	ldr	r3, [r7, #8]
2400d620:	f003 0340 	and.w	r3, r3, #64	; 0x40
2400d624:	2b00      	cmp	r3, #0
2400d626:	d028      	beq.n	2400d67a <I2C_Master_ISR_DMA+0x1a4>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
2400d628:	687b      	ldr	r3, [r7, #4]
2400d62a:	f003 0340 	and.w	r3, r3, #64	; 0x40
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
2400d62e:	2b00      	cmp	r3, #0
2400d630:	d023      	beq.n	2400d67a <I2C_Master_ISR_DMA+0x1a4>
  {
    if (hi2c->XferCount == 0U)
2400d632:	68fb      	ldr	r3, [r7, #12]
2400d634:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400d636:	b29b      	uxth	r3, r3
2400d638:	2b00      	cmp	r3, #0
2400d63a:	d119      	bne.n	2400d670 <I2C_Master_ISR_DMA+0x19a>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
2400d63c:	68fb      	ldr	r3, [r7, #12]
2400d63e:	681b      	ldr	r3, [r3, #0]
2400d640:	685b      	ldr	r3, [r3, #4]
2400d642:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2400d646:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d64a:	d025      	beq.n	2400d698 <I2C_Master_ISR_DMA+0x1c2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
2400d64c:	68fb      	ldr	r3, [r7, #12]
2400d64e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d650:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d654:	d108      	bne.n	2400d668 <I2C_Master_ISR_DMA+0x192>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400d656:	68fb      	ldr	r3, [r7, #12]
2400d658:	681b      	ldr	r3, [r3, #0]
2400d65a:	685a      	ldr	r2, [r3, #4]
2400d65c:	68fb      	ldr	r3, [r7, #12]
2400d65e:	681b      	ldr	r3, [r3, #0]
2400d660:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400d664:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
2400d666:	e017      	b.n	2400d698 <I2C_Master_ISR_DMA+0x1c2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
2400d668:	68f8      	ldr	r0, [r7, #12]
2400d66a:	f000 fb23 	bl	2400dcb4 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
2400d66e:	e013      	b.n	2400d698 <I2C_Master_ISR_DMA+0x1c2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
2400d670:	2140      	movs	r1, #64	; 0x40
2400d672:	68f8      	ldr	r0, [r7, #12]
2400d674:	f000 feca 	bl	2400e40c <I2C_ITError>
    if (hi2c->XferCount == 0U)
2400d678:	e00e      	b.n	2400d698 <I2C_Master_ISR_DMA+0x1c2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d67a:	68bb      	ldr	r3, [r7, #8]
2400d67c:	f003 0320 	and.w	r3, r3, #32
2400d680:	2b00      	cmp	r3, #0
2400d682:	d00a      	beq.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d684:	687b      	ldr	r3, [r7, #4]
2400d686:	f003 0320 	and.w	r3, r3, #32
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d68a:	2b00      	cmp	r3, #0
2400d68c:	d005      	beq.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
2400d68e:	68b9      	ldr	r1, [r7, #8]
2400d690:	68f8      	ldr	r0, [r7, #12]
2400d692:	f000 fba9 	bl	2400dde8 <I2C_ITMasterCplt>
2400d696:	e000      	b.n	2400d69a <I2C_Master_ISR_DMA+0x1c4>
    if (hi2c->XferCount == 0U)
2400d698:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400d69a:	68fb      	ldr	r3, [r7, #12]
2400d69c:	2200      	movs	r2, #0
2400d69e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400d6a2:	2300      	movs	r3, #0
}
2400d6a4:	4618      	mov	r0, r3
2400d6a6:	3718      	adds	r7, #24
2400d6a8:	46bd      	mov	sp, r7
2400d6aa:	bd80      	pop	{r7, pc}

2400d6ac <I2C_Slave_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
2400d6ac:	b580      	push	{r7, lr}
2400d6ae:	b088      	sub	sp, #32
2400d6b0:	af00      	add	r7, sp, #0
2400d6b2:	60f8      	str	r0, [r7, #12]
2400d6b4:	60b9      	str	r1, [r7, #8]
2400d6b6:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
2400d6b8:	68fb      	ldr	r3, [r7, #12]
2400d6ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400d6bc:	61bb      	str	r3, [r7, #24]
  uint32_t treatdmanack = 0U;
2400d6be:	2300      	movs	r3, #0
2400d6c0:	61fb      	str	r3, [r7, #28]
  HAL_I2C_StateTypeDef tmpstate;

  /* Process locked */
  __HAL_LOCK(hi2c);
2400d6c2:	68fb      	ldr	r3, [r7, #12]
2400d6c4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400d6c8:	2b01      	cmp	r3, #1
2400d6ca:	d101      	bne.n	2400d6d0 <I2C_Slave_ISR_DMA+0x24>
2400d6cc:	2302      	movs	r3, #2
2400d6ce:	e1c0      	b.n	2400da52 <I2C_Slave_ISR_DMA+0x3a6>
2400d6d0:	68fb      	ldr	r3, [r7, #12]
2400d6d2:	2201      	movs	r2, #1
2400d6d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d6d8:	68bb      	ldr	r3, [r7, #8]
2400d6da:	f003 0320 	and.w	r3, r3, #32
2400d6de:	2b00      	cmp	r3, #0
2400d6e0:	d008      	beq.n	2400d6f4 <I2C_Slave_ISR_DMA+0x48>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
2400d6e2:	687b      	ldr	r3, [r7, #4]
2400d6e4:	f003 0320 	and.w	r3, r3, #32
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
2400d6e8:	2b00      	cmp	r3, #0
2400d6ea:	d003      	beq.n	2400d6f4 <I2C_Slave_ISR_DMA+0x48>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
2400d6ec:	68b9      	ldr	r1, [r7, #8]
2400d6ee:	68f8      	ldr	r0, [r7, #12]
2400d6f0:	f000 fc42 	bl	2400df78 <I2C_ITSlaveCplt>
  }

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d6f4:	68bb      	ldr	r3, [r7, #8]
2400d6f6:	f003 0310 	and.w	r3, r3, #16
2400d6fa:	2b00      	cmp	r3, #0
2400d6fc:	f000 8196 	beq.w	2400da2c <I2C_Slave_ISR_DMA+0x380>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
2400d700:	687b      	ldr	r3, [r7, #4]
2400d702:	f003 0310 	and.w	r3, r3, #16
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
2400d706:	2b00      	cmp	r3, #0
2400d708:	f000 8190 	beq.w	2400da2c <I2C_Slave_ISR_DMA+0x380>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400d70c:	687b      	ldr	r3, [r7, #4]
2400d70e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400d712:	2b00      	cmp	r3, #0
2400d714:	d105      	bne.n	2400d722 <I2C_Slave_ISR_DMA+0x76>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
2400d716:	687b      	ldr	r3, [r7, #4]
2400d718:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400d71c:	2b00      	cmp	r3, #0
2400d71e:	f000 817e 	beq.w	2400da1e <I2C_Slave_ISR_DMA+0x372>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
2400d722:	68fb      	ldr	r3, [r7, #12]
2400d724:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d726:	2b00      	cmp	r3, #0
2400d728:	d07b      	beq.n	2400d822 <I2C_Slave_ISR_DMA+0x176>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
2400d72a:	687b      	ldr	r3, [r7, #4]
2400d72c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400d730:	2b00      	cmp	r3, #0
2400d732:	d076      	beq.n	2400d822 <I2C_Slave_ISR_DMA+0x176>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)
2400d734:	68fb      	ldr	r3, [r7, #12]
2400d736:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d738:	681b      	ldr	r3, [r3, #0]
2400d73a:	4a74      	ldr	r2, [pc, #464]	; (2400d90c <I2C_Slave_ISR_DMA+0x260>)
2400d73c:	4293      	cmp	r3, r2
2400d73e:	d059      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d740:	68fb      	ldr	r3, [r7, #12]
2400d742:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d744:	681b      	ldr	r3, [r3, #0]
2400d746:	4a72      	ldr	r2, [pc, #456]	; (2400d910 <I2C_Slave_ISR_DMA+0x264>)
2400d748:	4293      	cmp	r3, r2
2400d74a:	d053      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d74c:	68fb      	ldr	r3, [r7, #12]
2400d74e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d750:	681b      	ldr	r3, [r3, #0]
2400d752:	4a70      	ldr	r2, [pc, #448]	; (2400d914 <I2C_Slave_ISR_DMA+0x268>)
2400d754:	4293      	cmp	r3, r2
2400d756:	d04d      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d758:	68fb      	ldr	r3, [r7, #12]
2400d75a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d75c:	681b      	ldr	r3, [r3, #0]
2400d75e:	4a6e      	ldr	r2, [pc, #440]	; (2400d918 <I2C_Slave_ISR_DMA+0x26c>)
2400d760:	4293      	cmp	r3, r2
2400d762:	d047      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d764:	68fb      	ldr	r3, [r7, #12]
2400d766:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d768:	681b      	ldr	r3, [r3, #0]
2400d76a:	4a6c      	ldr	r2, [pc, #432]	; (2400d91c <I2C_Slave_ISR_DMA+0x270>)
2400d76c:	4293      	cmp	r3, r2
2400d76e:	d041      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d770:	68fb      	ldr	r3, [r7, #12]
2400d772:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d774:	681b      	ldr	r3, [r3, #0]
2400d776:	4a6a      	ldr	r2, [pc, #424]	; (2400d920 <I2C_Slave_ISR_DMA+0x274>)
2400d778:	4293      	cmp	r3, r2
2400d77a:	d03b      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d77c:	68fb      	ldr	r3, [r7, #12]
2400d77e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d780:	681b      	ldr	r3, [r3, #0]
2400d782:	4a68      	ldr	r2, [pc, #416]	; (2400d924 <I2C_Slave_ISR_DMA+0x278>)
2400d784:	4293      	cmp	r3, r2
2400d786:	d035      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d788:	68fb      	ldr	r3, [r7, #12]
2400d78a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d78c:	681b      	ldr	r3, [r3, #0]
2400d78e:	4a66      	ldr	r2, [pc, #408]	; (2400d928 <I2C_Slave_ISR_DMA+0x27c>)
2400d790:	4293      	cmp	r3, r2
2400d792:	d02f      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d794:	68fb      	ldr	r3, [r7, #12]
2400d796:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d798:	681b      	ldr	r3, [r3, #0]
2400d79a:	4a64      	ldr	r2, [pc, #400]	; (2400d92c <I2C_Slave_ISR_DMA+0x280>)
2400d79c:	4293      	cmp	r3, r2
2400d79e:	d029      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d7a0:	68fb      	ldr	r3, [r7, #12]
2400d7a2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7a4:	681b      	ldr	r3, [r3, #0]
2400d7a6:	4a62      	ldr	r2, [pc, #392]	; (2400d930 <I2C_Slave_ISR_DMA+0x284>)
2400d7a8:	4293      	cmp	r3, r2
2400d7aa:	d023      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d7ac:	68fb      	ldr	r3, [r7, #12]
2400d7ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7b0:	681b      	ldr	r3, [r3, #0]
2400d7b2:	4a60      	ldr	r2, [pc, #384]	; (2400d934 <I2C_Slave_ISR_DMA+0x288>)
2400d7b4:	4293      	cmp	r3, r2
2400d7b6:	d01d      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d7b8:	68fb      	ldr	r3, [r7, #12]
2400d7ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7bc:	681b      	ldr	r3, [r3, #0]
2400d7be:	4a5e      	ldr	r2, [pc, #376]	; (2400d938 <I2C_Slave_ISR_DMA+0x28c>)
2400d7c0:	4293      	cmp	r3, r2
2400d7c2:	d017      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d7c4:	68fb      	ldr	r3, [r7, #12]
2400d7c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7c8:	681b      	ldr	r3, [r3, #0]
2400d7ca:	4a5c      	ldr	r2, [pc, #368]	; (2400d93c <I2C_Slave_ISR_DMA+0x290>)
2400d7cc:	4293      	cmp	r3, r2
2400d7ce:	d011      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d7d0:	68fb      	ldr	r3, [r7, #12]
2400d7d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7d4:	681b      	ldr	r3, [r3, #0]
2400d7d6:	4a5a      	ldr	r2, [pc, #360]	; (2400d940 <I2C_Slave_ISR_DMA+0x294>)
2400d7d8:	4293      	cmp	r3, r2
2400d7da:	d00b      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d7dc:	68fb      	ldr	r3, [r7, #12]
2400d7de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7e0:	681b      	ldr	r3, [r3, #0]
2400d7e2:	4a58      	ldr	r2, [pc, #352]	; (2400d944 <I2C_Slave_ISR_DMA+0x298>)
2400d7e4:	4293      	cmp	r3, r2
2400d7e6:	d005      	beq.n	2400d7f4 <I2C_Slave_ISR_DMA+0x148>
2400d7e8:	68fb      	ldr	r3, [r7, #12]
2400d7ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7ec:	681b      	ldr	r3, [r3, #0]
2400d7ee:	4a56      	ldr	r2, [pc, #344]	; (2400d948 <I2C_Slave_ISR_DMA+0x29c>)
2400d7f0:	4293      	cmp	r3, r2
2400d7f2:	d109      	bne.n	2400d808 <I2C_Slave_ISR_DMA+0x15c>
2400d7f4:	68fb      	ldr	r3, [r7, #12]
2400d7f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d7f8:	681b      	ldr	r3, [r3, #0]
2400d7fa:	685b      	ldr	r3, [r3, #4]
2400d7fc:	2b00      	cmp	r3, #0
2400d7fe:	bf0c      	ite	eq
2400d800:	2301      	moveq	r3, #1
2400d802:	2300      	movne	r3, #0
2400d804:	b2db      	uxtb	r3, r3
2400d806:	e008      	b.n	2400d81a <I2C_Slave_ISR_DMA+0x16e>
2400d808:	68fb      	ldr	r3, [r7, #12]
2400d80a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400d80c:	681b      	ldr	r3, [r3, #0]
2400d80e:	685b      	ldr	r3, [r3, #4]
2400d810:	2b00      	cmp	r3, #0
2400d812:	bf0c      	ite	eq
2400d814:	2301      	moveq	r3, #1
2400d816:	2300      	movne	r3, #0
2400d818:	b2db      	uxtb	r3, r3
2400d81a:	2b00      	cmp	r3, #0
2400d81c:	d001      	beq.n	2400d822 <I2C_Slave_ISR_DMA+0x176>
          {
            treatdmanack = 1U;
2400d81e:	2301      	movs	r3, #1
2400d820:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
2400d822:	68fb      	ldr	r3, [r7, #12]
2400d824:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d826:	2b00      	cmp	r3, #0
2400d828:	f000 809d 	beq.w	2400d966 <I2C_Slave_ISR_DMA+0x2ba>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
2400d82c:	687b      	ldr	r3, [r7, #4]
2400d82e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400d832:	2b00      	cmp	r3, #0
2400d834:	f000 8097 	beq.w	2400d966 <I2C_Slave_ISR_DMA+0x2ba>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)
2400d838:	68fb      	ldr	r3, [r7, #12]
2400d83a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d83c:	681b      	ldr	r3, [r3, #0]
2400d83e:	4a33      	ldr	r2, [pc, #204]	; (2400d90c <I2C_Slave_ISR_DMA+0x260>)
2400d840:	4293      	cmp	r3, r2
2400d842:	d059      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d844:	68fb      	ldr	r3, [r7, #12]
2400d846:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d848:	681b      	ldr	r3, [r3, #0]
2400d84a:	4a31      	ldr	r2, [pc, #196]	; (2400d910 <I2C_Slave_ISR_DMA+0x264>)
2400d84c:	4293      	cmp	r3, r2
2400d84e:	d053      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d850:	68fb      	ldr	r3, [r7, #12]
2400d852:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d854:	681b      	ldr	r3, [r3, #0]
2400d856:	4a2f      	ldr	r2, [pc, #188]	; (2400d914 <I2C_Slave_ISR_DMA+0x268>)
2400d858:	4293      	cmp	r3, r2
2400d85a:	d04d      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d85c:	68fb      	ldr	r3, [r7, #12]
2400d85e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d860:	681b      	ldr	r3, [r3, #0]
2400d862:	4a2d      	ldr	r2, [pc, #180]	; (2400d918 <I2C_Slave_ISR_DMA+0x26c>)
2400d864:	4293      	cmp	r3, r2
2400d866:	d047      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d868:	68fb      	ldr	r3, [r7, #12]
2400d86a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d86c:	681b      	ldr	r3, [r3, #0]
2400d86e:	4a2b      	ldr	r2, [pc, #172]	; (2400d91c <I2C_Slave_ISR_DMA+0x270>)
2400d870:	4293      	cmp	r3, r2
2400d872:	d041      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d874:	68fb      	ldr	r3, [r7, #12]
2400d876:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d878:	681b      	ldr	r3, [r3, #0]
2400d87a:	4a29      	ldr	r2, [pc, #164]	; (2400d920 <I2C_Slave_ISR_DMA+0x274>)
2400d87c:	4293      	cmp	r3, r2
2400d87e:	d03b      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d880:	68fb      	ldr	r3, [r7, #12]
2400d882:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d884:	681b      	ldr	r3, [r3, #0]
2400d886:	4a27      	ldr	r2, [pc, #156]	; (2400d924 <I2C_Slave_ISR_DMA+0x278>)
2400d888:	4293      	cmp	r3, r2
2400d88a:	d035      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d88c:	68fb      	ldr	r3, [r7, #12]
2400d88e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d890:	681b      	ldr	r3, [r3, #0]
2400d892:	4a25      	ldr	r2, [pc, #148]	; (2400d928 <I2C_Slave_ISR_DMA+0x27c>)
2400d894:	4293      	cmp	r3, r2
2400d896:	d02f      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d898:	68fb      	ldr	r3, [r7, #12]
2400d89a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d89c:	681b      	ldr	r3, [r3, #0]
2400d89e:	4a23      	ldr	r2, [pc, #140]	; (2400d92c <I2C_Slave_ISR_DMA+0x280>)
2400d8a0:	4293      	cmp	r3, r2
2400d8a2:	d029      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d8a4:	68fb      	ldr	r3, [r7, #12]
2400d8a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8a8:	681b      	ldr	r3, [r3, #0]
2400d8aa:	4a21      	ldr	r2, [pc, #132]	; (2400d930 <I2C_Slave_ISR_DMA+0x284>)
2400d8ac:	4293      	cmp	r3, r2
2400d8ae:	d023      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d8b0:	68fb      	ldr	r3, [r7, #12]
2400d8b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8b4:	681b      	ldr	r3, [r3, #0]
2400d8b6:	4a1f      	ldr	r2, [pc, #124]	; (2400d934 <I2C_Slave_ISR_DMA+0x288>)
2400d8b8:	4293      	cmp	r3, r2
2400d8ba:	d01d      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d8bc:	68fb      	ldr	r3, [r7, #12]
2400d8be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8c0:	681b      	ldr	r3, [r3, #0]
2400d8c2:	4a1d      	ldr	r2, [pc, #116]	; (2400d938 <I2C_Slave_ISR_DMA+0x28c>)
2400d8c4:	4293      	cmp	r3, r2
2400d8c6:	d017      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d8c8:	68fb      	ldr	r3, [r7, #12]
2400d8ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8cc:	681b      	ldr	r3, [r3, #0]
2400d8ce:	4a1b      	ldr	r2, [pc, #108]	; (2400d93c <I2C_Slave_ISR_DMA+0x290>)
2400d8d0:	4293      	cmp	r3, r2
2400d8d2:	d011      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d8d4:	68fb      	ldr	r3, [r7, #12]
2400d8d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8d8:	681b      	ldr	r3, [r3, #0]
2400d8da:	4a19      	ldr	r2, [pc, #100]	; (2400d940 <I2C_Slave_ISR_DMA+0x294>)
2400d8dc:	4293      	cmp	r3, r2
2400d8de:	d00b      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d8e0:	68fb      	ldr	r3, [r7, #12]
2400d8e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8e4:	681b      	ldr	r3, [r3, #0]
2400d8e6:	4a17      	ldr	r2, [pc, #92]	; (2400d944 <I2C_Slave_ISR_DMA+0x298>)
2400d8e8:	4293      	cmp	r3, r2
2400d8ea:	d005      	beq.n	2400d8f8 <I2C_Slave_ISR_DMA+0x24c>
2400d8ec:	68fb      	ldr	r3, [r7, #12]
2400d8ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8f0:	681b      	ldr	r3, [r3, #0]
2400d8f2:	4a15      	ldr	r2, [pc, #84]	; (2400d948 <I2C_Slave_ISR_DMA+0x29c>)
2400d8f4:	4293      	cmp	r3, r2
2400d8f6:	d129      	bne.n	2400d94c <I2C_Slave_ISR_DMA+0x2a0>
2400d8f8:	68fb      	ldr	r3, [r7, #12]
2400d8fa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d8fc:	681b      	ldr	r3, [r3, #0]
2400d8fe:	685b      	ldr	r3, [r3, #4]
2400d900:	2b00      	cmp	r3, #0
2400d902:	bf0c      	ite	eq
2400d904:	2301      	moveq	r3, #1
2400d906:	2300      	movne	r3, #0
2400d908:	b2db      	uxtb	r3, r3
2400d90a:	e028      	b.n	2400d95e <I2C_Slave_ISR_DMA+0x2b2>
2400d90c:	40020010 	.word	0x40020010
2400d910:	40020028 	.word	0x40020028
2400d914:	40020040 	.word	0x40020040
2400d918:	40020058 	.word	0x40020058
2400d91c:	40020070 	.word	0x40020070
2400d920:	40020088 	.word	0x40020088
2400d924:	400200a0 	.word	0x400200a0
2400d928:	400200b8 	.word	0x400200b8
2400d92c:	40020410 	.word	0x40020410
2400d930:	40020428 	.word	0x40020428
2400d934:	40020440 	.word	0x40020440
2400d938:	40020458 	.word	0x40020458
2400d93c:	40020470 	.word	0x40020470
2400d940:	40020488 	.word	0x40020488
2400d944:	400204a0 	.word	0x400204a0
2400d948:	400204b8 	.word	0x400204b8
2400d94c:	68fb      	ldr	r3, [r7, #12]
2400d94e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400d950:	681b      	ldr	r3, [r3, #0]
2400d952:	685b      	ldr	r3, [r3, #4]
2400d954:	2b00      	cmp	r3, #0
2400d956:	bf0c      	ite	eq
2400d958:	2301      	moveq	r3, #1
2400d95a:	2300      	movne	r3, #0
2400d95c:	b2db      	uxtb	r3, r3
2400d95e:	2b00      	cmp	r3, #0
2400d960:	d001      	beq.n	2400d966 <I2C_Slave_ISR_DMA+0x2ba>
          {
            treatdmanack = 1U;
2400d962:	2301      	movs	r3, #1
2400d964:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      if (treatdmanack == 1U)
2400d966:	69fb      	ldr	r3, [r7, #28]
2400d968:	2b01      	cmp	r3, #1
2400d96a:	d128      	bne.n	2400d9be <I2C_Slave_ISR_DMA+0x312>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
2400d96c:	68fb      	ldr	r3, [r7, #12]
2400d96e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d972:	b2db      	uxtb	r3, r3
2400d974:	2b28      	cmp	r3, #40	; 0x28
2400d976:	d108      	bne.n	2400d98a <I2C_Slave_ISR_DMA+0x2de>
2400d978:	69bb      	ldr	r3, [r7, #24]
2400d97a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2400d97e:	d104      	bne.n	2400d98a <I2C_Slave_ISR_DMA+0x2de>
          /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
             Warning[Pa134]: left and right operands are identical */
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
2400d980:	68b9      	ldr	r1, [r7, #8]
2400d982:	68f8      	ldr	r0, [r7, #12]
2400d984:	f000 fcee 	bl	2400e364 <I2C_ITListenCplt>
2400d988:	e048      	b.n	2400da1c <I2C_Slave_ISR_DMA+0x370>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
2400d98a:	68fb      	ldr	r3, [r7, #12]
2400d98c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d990:	b2db      	uxtb	r3, r3
2400d992:	2b29      	cmp	r3, #41	; 0x29
2400d994:	d10e      	bne.n	2400d9b4 <I2C_Slave_ISR_DMA+0x308>
2400d996:	69bb      	ldr	r3, [r7, #24]
2400d998:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400d99c:	d00a      	beq.n	2400d9b4 <I2C_Slave_ISR_DMA+0x308>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d99e:	68fb      	ldr	r3, [r7, #12]
2400d9a0:	681b      	ldr	r3, [r3, #0]
2400d9a2:	2210      	movs	r2, #16
2400d9a4:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
2400d9a6:	68f8      	ldr	r0, [r7, #12]
2400d9a8:	f000 fe27 	bl	2400e5fa <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
2400d9ac:	68f8      	ldr	r0, [r7, #12]
2400d9ae:	f000 f9be 	bl	2400dd2e <I2C_ITSlaveSeqCplt>
2400d9b2:	e033      	b.n	2400da1c <I2C_Slave_ISR_DMA+0x370>
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d9b4:	68fb      	ldr	r3, [r7, #12]
2400d9b6:	681b      	ldr	r3, [r3, #0]
2400d9b8:	2210      	movs	r2, #16
2400d9ba:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
2400d9bc:	e034      	b.n	2400da28 <I2C_Slave_ISR_DMA+0x37c>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400d9be:	68fb      	ldr	r3, [r7, #12]
2400d9c0:	681b      	ldr	r3, [r3, #0]
2400d9c2:	2210      	movs	r2, #16
2400d9c4:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400d9c6:	68fb      	ldr	r3, [r7, #12]
2400d9c8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400d9ca:	f043 0204 	orr.w	r2, r3, #4
2400d9ce:	68fb      	ldr	r3, [r7, #12]
2400d9d0:	645a      	str	r2, [r3, #68]	; 0x44

        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
        tmpstate = hi2c->State;
2400d9d2:	68fb      	ldr	r3, [r7, #12]
2400d9d4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400d9d8:	75fb      	strb	r3, [r7, #23]

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
2400d9da:	69bb      	ldr	r3, [r7, #24]
2400d9dc:	2b00      	cmp	r3, #0
2400d9de:	d003      	beq.n	2400d9e8 <I2C_Slave_ISR_DMA+0x33c>
2400d9e0:	69bb      	ldr	r3, [r7, #24]
2400d9e2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400d9e6:	d11f      	bne.n	2400da28 <I2C_Slave_ISR_DMA+0x37c>
        {
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400d9e8:	7dfb      	ldrb	r3, [r7, #23]
2400d9ea:	2b21      	cmp	r3, #33	; 0x21
2400d9ec:	d002      	beq.n	2400d9f4 <I2C_Slave_ISR_DMA+0x348>
2400d9ee:	7dfb      	ldrb	r3, [r7, #23]
2400d9f0:	2b29      	cmp	r3, #41	; 0x29
2400d9f2:	d103      	bne.n	2400d9fc <I2C_Slave_ISR_DMA+0x350>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400d9f4:	68fb      	ldr	r3, [r7, #12]
2400d9f6:	2221      	movs	r2, #33	; 0x21
2400d9f8:	631a      	str	r2, [r3, #48]	; 0x30
2400d9fa:	e008      	b.n	2400da0e <I2C_Slave_ISR_DMA+0x362>
          }
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400d9fc:	7dfb      	ldrb	r3, [r7, #23]
2400d9fe:	2b22      	cmp	r3, #34	; 0x22
2400da00:	d002      	beq.n	2400da08 <I2C_Slave_ISR_DMA+0x35c>
2400da02:	7dfb      	ldrb	r3, [r7, #23]
2400da04:	2b2a      	cmp	r3, #42	; 0x2a
2400da06:	d102      	bne.n	2400da0e <I2C_Slave_ISR_DMA+0x362>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400da08:	68fb      	ldr	r3, [r7, #12]
2400da0a:	2222      	movs	r2, #34	; 0x22
2400da0c:	631a      	str	r2, [r3, #48]	; 0x30
          {
            /* Do nothing */
          }

          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
2400da0e:	68fb      	ldr	r3, [r7, #12]
2400da10:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400da12:	4619      	mov	r1, r3
2400da14:	68f8      	ldr	r0, [r7, #12]
2400da16:	f000 fcf9 	bl	2400e40c <I2C_ITError>
      if (treatdmanack == 1U)
2400da1a:	e005      	b.n	2400da28 <I2C_Slave_ISR_DMA+0x37c>
2400da1c:	e004      	b.n	2400da28 <I2C_Slave_ISR_DMA+0x37c>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400da1e:	68fb      	ldr	r3, [r7, #12]
2400da20:	681b      	ldr	r3, [r3, #0]
2400da22:	2210      	movs	r2, #16
2400da24:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400da26:	e00f      	b.n	2400da48 <I2C_Slave_ISR_DMA+0x39c>
      if (treatdmanack == 1U)
2400da28:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
2400da2a:	e00d      	b.n	2400da48 <I2C_Slave_ISR_DMA+0x39c>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
2400da2c:	68bb      	ldr	r3, [r7, #8]
2400da2e:	f003 0308 	and.w	r3, r3, #8
2400da32:	2b00      	cmp	r3, #0
2400da34:	d008      	beq.n	2400da48 <I2C_Slave_ISR_DMA+0x39c>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
2400da36:	687b      	ldr	r3, [r7, #4]
2400da38:	f003 0308 	and.w	r3, r3, #8
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
2400da3c:	2b00      	cmp	r3, #0
2400da3e:	d003      	beq.n	2400da48 <I2C_Slave_ISR_DMA+0x39c>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
2400da40:	68b9      	ldr	r1, [r7, #8]
2400da42:	68f8      	ldr	r0, [r7, #12]
2400da44:	f000 f8b2 	bl	2400dbac <I2C_ITAddrCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400da48:	68fb      	ldr	r3, [r7, #12]
2400da4a:	2200      	movs	r2, #0
2400da4c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
2400da50:	2300      	movs	r3, #0
}
2400da52:	4618      	mov	r0, r3
2400da54:	3720      	adds	r7, #32
2400da56:	46bd      	mov	sp, r7
2400da58:	bd80      	pop	{r7, pc}
2400da5a:	bf00      	nop

2400da5c <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
2400da5c:	b580      	push	{r7, lr}
2400da5e:	b086      	sub	sp, #24
2400da60:	af02      	add	r7, sp, #8
2400da62:	60f8      	str	r0, [r7, #12]
2400da64:	4608      	mov	r0, r1
2400da66:	4611      	mov	r1, r2
2400da68:	461a      	mov	r2, r3
2400da6a:	4603      	mov	r3, r0
2400da6c:	817b      	strh	r3, [r7, #10]
2400da6e:	460b      	mov	r3, r1
2400da70:	813b      	strh	r3, [r7, #8]
2400da72:	4613      	mov	r3, r2
2400da74:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
2400da76:	88fb      	ldrh	r3, [r7, #6]
2400da78:	b2da      	uxtb	r2, r3
2400da7a:	8979      	ldrh	r1, [r7, #10]
2400da7c:	4b20      	ldr	r3, [pc, #128]	; (2400db00 <I2C_RequestMemoryWrite+0xa4>)
2400da7e:	9300      	str	r3, [sp, #0]
2400da80:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
2400da84:	68f8      	ldr	r0, [r7, #12]
2400da86:	f001 fabf 	bl	2400f008 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400da8a:	69fa      	ldr	r2, [r7, #28]
2400da8c:	69b9      	ldr	r1, [r7, #24]
2400da8e:	68f8      	ldr	r0, [r7, #12]
2400da90:	f001 f8d8 	bl	2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>
2400da94:	4603      	mov	r3, r0
2400da96:	2b00      	cmp	r3, #0
2400da98:	d001      	beq.n	2400da9e <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
2400da9a:	2301      	movs	r3, #1
2400da9c:	e02c      	b.n	2400daf8 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400da9e:	88fb      	ldrh	r3, [r7, #6]
2400daa0:	2b01      	cmp	r3, #1
2400daa2:	d105      	bne.n	2400dab0 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400daa4:	893b      	ldrh	r3, [r7, #8]
2400daa6:	b2da      	uxtb	r2, r3
2400daa8:	68fb      	ldr	r3, [r7, #12]
2400daaa:	681b      	ldr	r3, [r3, #0]
2400daac:	629a      	str	r2, [r3, #40]	; 0x28
2400daae:	e015      	b.n	2400dadc <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400dab0:	893b      	ldrh	r3, [r7, #8]
2400dab2:	0a1b      	lsrs	r3, r3, #8
2400dab4:	b29b      	uxth	r3, r3
2400dab6:	b2da      	uxtb	r2, r3
2400dab8:	68fb      	ldr	r3, [r7, #12]
2400daba:	681b      	ldr	r3, [r3, #0]
2400dabc:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400dabe:	69fa      	ldr	r2, [r7, #28]
2400dac0:	69b9      	ldr	r1, [r7, #24]
2400dac2:	68f8      	ldr	r0, [r7, #12]
2400dac4:	f001 f8be 	bl	2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>
2400dac8:	4603      	mov	r3, r0
2400daca:	2b00      	cmp	r3, #0
2400dacc:	d001      	beq.n	2400dad2 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
2400dace:	2301      	movs	r3, #1
2400dad0:	e012      	b.n	2400daf8 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400dad2:	893b      	ldrh	r3, [r7, #8]
2400dad4:	b2da      	uxtb	r2, r3
2400dad6:	68fb      	ldr	r3, [r7, #12]
2400dad8:	681b      	ldr	r3, [r3, #0]
2400dada:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
2400dadc:	69fb      	ldr	r3, [r7, #28]
2400dade:	9300      	str	r3, [sp, #0]
2400dae0:	69bb      	ldr	r3, [r7, #24]
2400dae2:	2200      	movs	r2, #0
2400dae4:	2180      	movs	r1, #128	; 0x80
2400dae6:	68f8      	ldr	r0, [r7, #12]
2400dae8:	f001 f86c 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400daec:	4603      	mov	r3, r0
2400daee:	2b00      	cmp	r3, #0
2400daf0:	d001      	beq.n	2400daf6 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
2400daf2:	2301      	movs	r3, #1
2400daf4:	e000      	b.n	2400daf8 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
2400daf6:	2300      	movs	r3, #0
}
2400daf8:	4618      	mov	r0, r3
2400dafa:	3710      	adds	r7, #16
2400dafc:	46bd      	mov	sp, r7
2400dafe:	bd80      	pop	{r7, pc}
2400db00:	80002000 	.word	0x80002000

2400db04 <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
2400db04:	b580      	push	{r7, lr}
2400db06:	b086      	sub	sp, #24
2400db08:	af02      	add	r7, sp, #8
2400db0a:	60f8      	str	r0, [r7, #12]
2400db0c:	4608      	mov	r0, r1
2400db0e:	4611      	mov	r1, r2
2400db10:	461a      	mov	r2, r3
2400db12:	4603      	mov	r3, r0
2400db14:	817b      	strh	r3, [r7, #10]
2400db16:	460b      	mov	r3, r1
2400db18:	813b      	strh	r3, [r7, #8]
2400db1a:	4613      	mov	r3, r2
2400db1c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
2400db1e:	88fb      	ldrh	r3, [r7, #6]
2400db20:	b2da      	uxtb	r2, r3
2400db22:	8979      	ldrh	r1, [r7, #10]
2400db24:	4b20      	ldr	r3, [pc, #128]	; (2400dba8 <I2C_RequestMemoryRead+0xa4>)
2400db26:	9300      	str	r3, [sp, #0]
2400db28:	2300      	movs	r3, #0
2400db2a:	68f8      	ldr	r0, [r7, #12]
2400db2c:	f001 fa6c 	bl	2400f008 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400db30:	69fa      	ldr	r2, [r7, #28]
2400db32:	69b9      	ldr	r1, [r7, #24]
2400db34:	68f8      	ldr	r0, [r7, #12]
2400db36:	f001 f885 	bl	2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>
2400db3a:	4603      	mov	r3, r0
2400db3c:	2b00      	cmp	r3, #0
2400db3e:	d001      	beq.n	2400db44 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
2400db40:	2301      	movs	r3, #1
2400db42:	e02c      	b.n	2400db9e <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
2400db44:	88fb      	ldrh	r3, [r7, #6]
2400db46:	2b01      	cmp	r3, #1
2400db48:	d105      	bne.n	2400db56 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400db4a:	893b      	ldrh	r3, [r7, #8]
2400db4c:	b2da      	uxtb	r2, r3
2400db4e:	68fb      	ldr	r3, [r7, #12]
2400db50:	681b      	ldr	r3, [r3, #0]
2400db52:	629a      	str	r2, [r3, #40]	; 0x28
2400db54:	e015      	b.n	2400db82 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
2400db56:	893b      	ldrh	r3, [r7, #8]
2400db58:	0a1b      	lsrs	r3, r3, #8
2400db5a:	b29b      	uxth	r3, r3
2400db5c:	b2da      	uxtb	r2, r3
2400db5e:	68fb      	ldr	r3, [r7, #12]
2400db60:	681b      	ldr	r3, [r3, #0]
2400db62:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
2400db64:	69fa      	ldr	r2, [r7, #28]
2400db66:	69b9      	ldr	r1, [r7, #24]
2400db68:	68f8      	ldr	r0, [r7, #12]
2400db6a:	f001 f86b 	bl	2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>
2400db6e:	4603      	mov	r3, r0
2400db70:	2b00      	cmp	r3, #0
2400db72:	d001      	beq.n	2400db78 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
2400db74:	2301      	movs	r3, #1
2400db76:	e012      	b.n	2400db9e <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
2400db78:	893b      	ldrh	r3, [r7, #8]
2400db7a:	b2da      	uxtb	r2, r3
2400db7c:	68fb      	ldr	r3, [r7, #12]
2400db7e:	681b      	ldr	r3, [r3, #0]
2400db80:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
2400db82:	69fb      	ldr	r3, [r7, #28]
2400db84:	9300      	str	r3, [sp, #0]
2400db86:	69bb      	ldr	r3, [r7, #24]
2400db88:	2200      	movs	r2, #0
2400db8a:	2140      	movs	r1, #64	; 0x40
2400db8c:	68f8      	ldr	r0, [r7, #12]
2400db8e:	f001 f819 	bl	2400ebc4 <I2C_WaitOnFlagUntilTimeout>
2400db92:	4603      	mov	r3, r0
2400db94:	2b00      	cmp	r3, #0
2400db96:	d001      	beq.n	2400db9c <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
2400db98:	2301      	movs	r3, #1
2400db9a:	e000      	b.n	2400db9e <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
2400db9c:	2300      	movs	r3, #0
}
2400db9e:	4618      	mov	r0, r3
2400dba0:	3710      	adds	r7, #16
2400dba2:	46bd      	mov	sp, r7
2400dba4:	bd80      	pop	{r7, pc}
2400dba6:	bf00      	nop
2400dba8:	80002000 	.word	0x80002000

2400dbac <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400dbac:	b580      	push	{r7, lr}
2400dbae:	b084      	sub	sp, #16
2400dbb0:	af00      	add	r7, sp, #0
2400dbb2:	6078      	str	r0, [r7, #4]
2400dbb4:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
2400dbb6:	687b      	ldr	r3, [r7, #4]
2400dbb8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dbbc:	b2db      	uxtb	r3, r3
2400dbbe:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400dbc2:	2b28      	cmp	r3, #40	; 0x28
2400dbc4:	d16a      	bne.n	2400dc9c <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
2400dbc6:	687b      	ldr	r3, [r7, #4]
2400dbc8:	681b      	ldr	r3, [r3, #0]
2400dbca:	699b      	ldr	r3, [r3, #24]
2400dbcc:	0c1b      	lsrs	r3, r3, #16
2400dbce:	b2db      	uxtb	r3, r3
2400dbd0:	f003 0301 	and.w	r3, r3, #1
2400dbd4:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
2400dbd6:	687b      	ldr	r3, [r7, #4]
2400dbd8:	681b      	ldr	r3, [r3, #0]
2400dbda:	699b      	ldr	r3, [r3, #24]
2400dbdc:	0c1b      	lsrs	r3, r3, #16
2400dbde:	b29b      	uxth	r3, r3
2400dbe0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400dbe4:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
2400dbe6:	687b      	ldr	r3, [r7, #4]
2400dbe8:	681b      	ldr	r3, [r3, #0]
2400dbea:	689b      	ldr	r3, [r3, #8]
2400dbec:	b29b      	uxth	r3, r3
2400dbee:	f3c3 0309 	ubfx	r3, r3, #0, #10
2400dbf2:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
2400dbf4:	687b      	ldr	r3, [r7, #4]
2400dbf6:	681b      	ldr	r3, [r3, #0]
2400dbf8:	68db      	ldr	r3, [r3, #12]
2400dbfa:	b29b      	uxth	r3, r3
2400dbfc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
2400dc00:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
2400dc02:	687b      	ldr	r3, [r7, #4]
2400dc04:	68db      	ldr	r3, [r3, #12]
2400dc06:	2b02      	cmp	r3, #2
2400dc08:	d138      	bne.n	2400dc7c <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))
2400dc0a:	897b      	ldrh	r3, [r7, #10]
2400dc0c:	09db      	lsrs	r3, r3, #7
2400dc0e:	b29a      	uxth	r2, r3
2400dc10:	89bb      	ldrh	r3, [r7, #12]
2400dc12:	4053      	eors	r3, r2
2400dc14:	b29b      	uxth	r3, r3
2400dc16:	f003 0306 	and.w	r3, r3, #6
2400dc1a:	2b00      	cmp	r3, #0
2400dc1c:	d11c      	bne.n	2400dc58 <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
2400dc1e:	897b      	ldrh	r3, [r7, #10]
2400dc20:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
2400dc22:	687b      	ldr	r3, [r7, #4]
2400dc24:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400dc26:	1c5a      	adds	r2, r3, #1
2400dc28:	687b      	ldr	r3, [r7, #4]
2400dc2a:	649a      	str	r2, [r3, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
2400dc2c:	687b      	ldr	r3, [r7, #4]
2400dc2e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400dc30:	2b02      	cmp	r3, #2
2400dc32:	d13b      	bne.n	2400dcac <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
2400dc34:	687b      	ldr	r3, [r7, #4]
2400dc36:	2200      	movs	r2, #0
2400dc38:	649a      	str	r2, [r3, #72]	; 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400dc3a:	687b      	ldr	r3, [r7, #4]
2400dc3c:	681b      	ldr	r3, [r3, #0]
2400dc3e:	2208      	movs	r2, #8
2400dc40:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
2400dc42:	687b      	ldr	r3, [r7, #4]
2400dc44:	2200      	movs	r2, #0
2400dc46:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400dc4a:	89ba      	ldrh	r2, [r7, #12]
2400dc4c:	7bfb      	ldrb	r3, [r7, #15]
2400dc4e:	4619      	mov	r1, r3
2400dc50:	6878      	ldr	r0, [r7, #4]
2400dc52:	f7ff f9c4 	bl	2400cfde <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
2400dc56:	e029      	b.n	2400dcac <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
2400dc58:	893b      	ldrh	r3, [r7, #8]
2400dc5a:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400dc5c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400dc60:	6878      	ldr	r0, [r7, #4]
2400dc62:	f001 fa67 	bl	2400f134 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
2400dc66:	687b      	ldr	r3, [r7, #4]
2400dc68:	2200      	movs	r2, #0
2400dc6a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400dc6e:	89ba      	ldrh	r2, [r7, #12]
2400dc70:	7bfb      	ldrb	r3, [r7, #15]
2400dc72:	4619      	mov	r1, r3
2400dc74:	6878      	ldr	r0, [r7, #4]
2400dc76:	f7ff f9b2 	bl	2400cfde <HAL_I2C_AddrCallback>
}
2400dc7a:	e017      	b.n	2400dcac <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
2400dc7c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
2400dc80:	6878      	ldr	r0, [r7, #4]
2400dc82:	f001 fa57 	bl	2400f134 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
2400dc86:	687b      	ldr	r3, [r7, #4]
2400dc88:	2200      	movs	r2, #0
2400dc8a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
2400dc8e:	89ba      	ldrh	r2, [r7, #12]
2400dc90:	7bfb      	ldrb	r3, [r7, #15]
2400dc92:	4619      	mov	r1, r3
2400dc94:	6878      	ldr	r0, [r7, #4]
2400dc96:	f7ff f9a2 	bl	2400cfde <HAL_I2C_AddrCallback>
}
2400dc9a:	e007      	b.n	2400dcac <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
2400dc9c:	687b      	ldr	r3, [r7, #4]
2400dc9e:	681b      	ldr	r3, [r3, #0]
2400dca0:	2208      	movs	r2, #8
2400dca2:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
2400dca4:	687b      	ldr	r3, [r7, #4]
2400dca6:	2200      	movs	r2, #0
2400dca8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
2400dcac:	bf00      	nop
2400dcae:	3710      	adds	r7, #16
2400dcb0:	46bd      	mov	sp, r7
2400dcb2:	bd80      	pop	{r7, pc}

2400dcb4 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400dcb4:	b580      	push	{r7, lr}
2400dcb6:	b082      	sub	sp, #8
2400dcb8:	af00      	add	r7, sp, #0
2400dcba:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400dcbc:	687b      	ldr	r3, [r7, #4]
2400dcbe:	2200      	movs	r2, #0
2400dcc0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400dcc4:	687b      	ldr	r3, [r7, #4]
2400dcc6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dcca:	b2db      	uxtb	r3, r3
2400dccc:	2b21      	cmp	r3, #33	; 0x21
2400dcce:	d115      	bne.n	2400dcfc <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
2400dcd0:	687b      	ldr	r3, [r7, #4]
2400dcd2:	2220      	movs	r2, #32
2400dcd4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400dcd8:	687b      	ldr	r3, [r7, #4]
2400dcda:	2211      	movs	r2, #17
2400dcdc:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400dcde:	687b      	ldr	r3, [r7, #4]
2400dce0:	2200      	movs	r2, #0
2400dce2:	635a      	str	r2, [r3, #52]	; 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400dce4:	2101      	movs	r1, #1
2400dce6:	6878      	ldr	r0, [r7, #4]
2400dce8:	f001 fa24 	bl	2400f134 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400dcec:	687b      	ldr	r3, [r7, #4]
2400dcee:	2200      	movs	r2, #0
2400dcf0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
2400dcf4:	6878      	ldr	r0, [r7, #4]
2400dcf6:	f7ff f94a 	bl	2400cf8e <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400dcfa:	e014      	b.n	2400dd26 <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
2400dcfc:	687b      	ldr	r3, [r7, #4]
2400dcfe:	2220      	movs	r2, #32
2400dd00:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400dd04:	687b      	ldr	r3, [r7, #4]
2400dd06:	2212      	movs	r2, #18
2400dd08:	631a      	str	r2, [r3, #48]	; 0x30
    hi2c->XferISR       = NULL;
2400dd0a:	687b      	ldr	r3, [r7, #4]
2400dd0c:	2200      	movs	r2, #0
2400dd0e:	635a      	str	r2, [r3, #52]	; 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400dd10:	2102      	movs	r1, #2
2400dd12:	6878      	ldr	r0, [r7, #4]
2400dd14:	f001 fa0e 	bl	2400f134 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400dd18:	687b      	ldr	r3, [r7, #4]
2400dd1a:	2200      	movs	r2, #0
2400dd1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
2400dd20:	6878      	ldr	r0, [r7, #4]
2400dd22:	f7ff f93e 	bl	2400cfa2 <HAL_I2C_MasterRxCpltCallback>
}
2400dd26:	bf00      	nop
2400dd28:	3708      	adds	r7, #8
2400dd2a:	46bd      	mov	sp, r7
2400dd2c:	bd80      	pop	{r7, pc}

2400dd2e <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
2400dd2e:	b580      	push	{r7, lr}
2400dd30:	b084      	sub	sp, #16
2400dd32:	af00      	add	r7, sp, #0
2400dd34:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400dd36:	687b      	ldr	r3, [r7, #4]
2400dd38:	681b      	ldr	r3, [r3, #0]
2400dd3a:	681b      	ldr	r3, [r3, #0]
2400dd3c:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400dd3e:	687b      	ldr	r3, [r7, #4]
2400dd40:	2200      	movs	r2, #0
2400dd42:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400dd46:	68fb      	ldr	r3, [r7, #12]
2400dd48:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400dd4c:	2b00      	cmp	r3, #0
2400dd4e:	d008      	beq.n	2400dd62 <I2C_ITSlaveSeqCplt+0x34>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400dd50:	687b      	ldr	r3, [r7, #4]
2400dd52:	681b      	ldr	r3, [r3, #0]
2400dd54:	681a      	ldr	r2, [r3, #0]
2400dd56:	687b      	ldr	r3, [r7, #4]
2400dd58:	681b      	ldr	r3, [r3, #0]
2400dd5a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400dd5e:	601a      	str	r2, [r3, #0]
2400dd60:	e00c      	b.n	2400dd7c <I2C_ITSlaveSeqCplt+0x4e>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400dd62:	68fb      	ldr	r3, [r7, #12]
2400dd64:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400dd68:	2b00      	cmp	r3, #0
2400dd6a:	d007      	beq.n	2400dd7c <I2C_ITSlaveSeqCplt+0x4e>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400dd6c:	687b      	ldr	r3, [r7, #4]
2400dd6e:	681b      	ldr	r3, [r3, #0]
2400dd70:	681a      	ldr	r2, [r3, #0]
2400dd72:	687b      	ldr	r3, [r7, #4]
2400dd74:	681b      	ldr	r3, [r3, #0]
2400dd76:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400dd7a:	601a      	str	r2, [r3, #0]
  else
  {
    /* Do nothing */
  }

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
2400dd7c:	687b      	ldr	r3, [r7, #4]
2400dd7e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dd82:	b2db      	uxtb	r3, r3
2400dd84:	2b29      	cmp	r3, #41	; 0x29
2400dd86:	d112      	bne.n	2400ddae <I2C_ITSlaveSeqCplt+0x80>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400dd88:	687b      	ldr	r3, [r7, #4]
2400dd8a:	2228      	movs	r2, #40	; 0x28
2400dd8c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400dd90:	687b      	ldr	r3, [r7, #4]
2400dd92:	2221      	movs	r2, #33	; 0x21
2400dd94:	631a      	str	r2, [r3, #48]	; 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400dd96:	2101      	movs	r1, #1
2400dd98:	6878      	ldr	r0, [r7, #4]
2400dd9a:	f001 f9cb 	bl	2400f134 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400dd9e:	687b      	ldr	r3, [r7, #4]
2400dda0:	2200      	movs	r2, #0
2400dda2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400dda6:	6878      	ldr	r0, [r7, #4]
2400dda8:	f7ff f905 	bl	2400cfb6 <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
2400ddac:	e017      	b.n	2400ddde <I2C_ITSlaveSeqCplt+0xb0>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
2400ddae:	687b      	ldr	r3, [r7, #4]
2400ddb0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400ddb4:	b2db      	uxtb	r3, r3
2400ddb6:	2b2a      	cmp	r3, #42	; 0x2a
2400ddb8:	d111      	bne.n	2400ddde <I2C_ITSlaveSeqCplt+0xb0>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400ddba:	687b      	ldr	r3, [r7, #4]
2400ddbc:	2228      	movs	r2, #40	; 0x28
2400ddbe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400ddc2:	687b      	ldr	r3, [r7, #4]
2400ddc4:	2222      	movs	r2, #34	; 0x22
2400ddc6:	631a      	str	r2, [r3, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400ddc8:	2102      	movs	r1, #2
2400ddca:	6878      	ldr	r0, [r7, #4]
2400ddcc:	f001 f9b2 	bl	2400f134 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
2400ddd0:	687b      	ldr	r3, [r7, #4]
2400ddd2:	2200      	movs	r2, #0
2400ddd4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400ddd8:	6878      	ldr	r0, [r7, #4]
2400ddda:	f7ff f8f6 	bl	2400cfca <HAL_I2C_SlaveRxCpltCallback>
}
2400ddde:	bf00      	nop
2400dde0:	3710      	adds	r7, #16
2400dde2:	46bd      	mov	sp, r7
2400dde4:	bd80      	pop	{r7, pc}
	...

2400dde8 <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400dde8:	b580      	push	{r7, lr}
2400ddea:	b086      	sub	sp, #24
2400ddec:	af00      	add	r7, sp, #0
2400ddee:	6078      	str	r0, [r7, #4]
2400ddf0:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;
  uint32_t tmpITFlags = ITFlags;
2400ddf2:	683b      	ldr	r3, [r7, #0]
2400ddf4:	617b      	str	r3, [r7, #20]
  __IO uint32_t tmpreg;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ddf6:	687b      	ldr	r3, [r7, #4]
2400ddf8:	681b      	ldr	r3, [r3, #0]
2400ddfa:	2220      	movs	r2, #32
2400ddfc:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400ddfe:	687b      	ldr	r3, [r7, #4]
2400de00:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400de04:	b2db      	uxtb	r3, r3
2400de06:	2b21      	cmp	r3, #33	; 0x21
2400de08:	d107      	bne.n	2400de1a <I2C_ITMasterCplt+0x32>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
2400de0a:	2101      	movs	r1, #1
2400de0c:	6878      	ldr	r0, [r7, #4]
2400de0e:	f001 f991 	bl	2400f134 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
2400de12:	687b      	ldr	r3, [r7, #4]
2400de14:	2211      	movs	r2, #17
2400de16:	631a      	str	r2, [r3, #48]	; 0x30
2400de18:	e00c      	b.n	2400de34 <I2C_ITMasterCplt+0x4c>
  }
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400de1a:	687b      	ldr	r3, [r7, #4]
2400de1c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400de20:	b2db      	uxtb	r3, r3
2400de22:	2b22      	cmp	r3, #34	; 0x22
2400de24:	d106      	bne.n	2400de34 <I2C_ITMasterCplt+0x4c>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
2400de26:	2102      	movs	r1, #2
2400de28:	6878      	ldr	r0, [r7, #4]
2400de2a:	f001 f983 	bl	2400f134 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
2400de2e:	687b      	ldr	r3, [r7, #4]
2400de30:	2212      	movs	r2, #18
2400de32:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400de34:	687b      	ldr	r3, [r7, #4]
2400de36:	681b      	ldr	r3, [r3, #0]
2400de38:	6859      	ldr	r1, [r3, #4]
2400de3a:	687b      	ldr	r3, [r7, #4]
2400de3c:	681a      	ldr	r2, [r3, #0]
2400de3e:	4b4c      	ldr	r3, [pc, #304]	; (2400df70 <I2C_ITMasterCplt+0x188>)
2400de40:	400b      	ands	r3, r1
2400de42:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->XferISR       = NULL;
2400de44:	687b      	ldr	r3, [r7, #4]
2400de46:	2200      	movs	r2, #0
2400de48:	635a      	str	r2, [r3, #52]	; 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400de4a:	687b      	ldr	r3, [r7, #4]
2400de4c:	4a49      	ldr	r2, [pc, #292]	; (2400df74 <I2C_ITMasterCplt+0x18c>)
2400de4e:	62da      	str	r2, [r3, #44]	; 0x2c

  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
2400de50:	697b      	ldr	r3, [r7, #20]
2400de52:	f003 0310 	and.w	r3, r3, #16
2400de56:	2b00      	cmp	r3, #0
2400de58:	d009      	beq.n	2400de6e <I2C_ITMasterCplt+0x86>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400de5a:	687b      	ldr	r3, [r7, #4]
2400de5c:	681b      	ldr	r3, [r3, #0]
2400de5e:	2210      	movs	r2, #16
2400de60:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400de62:	687b      	ldr	r3, [r7, #4]
2400de64:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400de66:	f043 0204 	orr.w	r2, r3, #4
2400de6a:	687b      	ldr	r3, [r7, #4]
2400de6c:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Fetch Last receive data if any */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
2400de6e:	687b      	ldr	r3, [r7, #4]
2400de70:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400de74:	b2db      	uxtb	r3, r3
2400de76:	2b60      	cmp	r3, #96	; 0x60
2400de78:	d10a      	bne.n	2400de90 <I2C_ITMasterCplt+0xa8>
2400de7a:	697b      	ldr	r3, [r7, #20]
2400de7c:	f003 0304 	and.w	r3, r3, #4
2400de80:	2b00      	cmp	r3, #0
2400de82:	d005      	beq.n	2400de90 <I2C_ITMasterCplt+0xa8>
  {
    /* Read data from RXDR */
    tmpreg = (uint8_t)hi2c->Instance->RXDR;
2400de84:	687b      	ldr	r3, [r7, #4]
2400de86:	681b      	ldr	r3, [r3, #0]
2400de88:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400de8a:	b2db      	uxtb	r3, r3
2400de8c:	60fb      	str	r3, [r7, #12]
    UNUSED(tmpreg);
2400de8e:	68fb      	ldr	r3, [r7, #12]
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400de90:	6878      	ldr	r0, [r7, #4]
2400de92:	f000 fbb2 	bl	2400e5fa <I2C_Flush_TXDR>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
2400de96:	687b      	ldr	r3, [r7, #4]
2400de98:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400de9a:	613b      	str	r3, [r7, #16]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
2400de9c:	687b      	ldr	r3, [r7, #4]
2400de9e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dea2:	b2db      	uxtb	r3, r3
2400dea4:	2b60      	cmp	r3, #96	; 0x60
2400dea6:	d002      	beq.n	2400deae <I2C_ITMasterCplt+0xc6>
2400dea8:	693b      	ldr	r3, [r7, #16]
2400deaa:	2b00      	cmp	r3, #0
2400deac:	d006      	beq.n	2400debc <I2C_ITMasterCplt+0xd4>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400deae:	687b      	ldr	r3, [r7, #4]
2400deb0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400deb2:	4619      	mov	r1, r3
2400deb4:	6878      	ldr	r0, [r7, #4]
2400deb6:	f000 faa9 	bl	2400e40c <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
2400deba:	e054      	b.n	2400df66 <I2C_ITMasterCplt+0x17e>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
2400debc:	687b      	ldr	r3, [r7, #4]
2400debe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400dec2:	b2db      	uxtb	r3, r3
2400dec4:	2b21      	cmp	r3, #33	; 0x21
2400dec6:	d124      	bne.n	2400df12 <I2C_ITMasterCplt+0x12a>
    hi2c->State = HAL_I2C_STATE_READY;
2400dec8:	687b      	ldr	r3, [r7, #4]
2400deca:	2220      	movs	r2, #32
2400decc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400ded0:	687b      	ldr	r3, [r7, #4]
2400ded2:	2200      	movs	r2, #0
2400ded4:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400ded6:	687b      	ldr	r3, [r7, #4]
2400ded8:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400dedc:	b2db      	uxtb	r3, r3
2400dede:	2b40      	cmp	r3, #64	; 0x40
2400dee0:	d10b      	bne.n	2400defa <I2C_ITMasterCplt+0x112>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400dee2:	687b      	ldr	r3, [r7, #4]
2400dee4:	2200      	movs	r2, #0
2400dee6:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400deea:	687b      	ldr	r3, [r7, #4]
2400deec:	2200      	movs	r2, #0
2400deee:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
2400def2:	6878      	ldr	r0, [r7, #4]
2400def4:	f7ff f88b 	bl	2400d00e <HAL_I2C_MemTxCpltCallback>
}
2400def8:	e035      	b.n	2400df66 <I2C_ITMasterCplt+0x17e>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400defa:	687b      	ldr	r3, [r7, #4]
2400defc:	2200      	movs	r2, #0
2400defe:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400df02:	687b      	ldr	r3, [r7, #4]
2400df04:	2200      	movs	r2, #0
2400df06:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
2400df0a:	6878      	ldr	r0, [r7, #4]
2400df0c:	f7ff f83f 	bl	2400cf8e <HAL_I2C_MasterTxCpltCallback>
}
2400df10:	e029      	b.n	2400df66 <I2C_ITMasterCplt+0x17e>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400df12:	687b      	ldr	r3, [r7, #4]
2400df14:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400df18:	b2db      	uxtb	r3, r3
2400df1a:	2b22      	cmp	r3, #34	; 0x22
2400df1c:	d123      	bne.n	2400df66 <I2C_ITMasterCplt+0x17e>
    hi2c->State = HAL_I2C_STATE_READY;
2400df1e:	687b      	ldr	r3, [r7, #4]
2400df20:	2220      	movs	r2, #32
2400df22:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400df26:	687b      	ldr	r3, [r7, #4]
2400df28:	2200      	movs	r2, #0
2400df2a:	631a      	str	r2, [r3, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
2400df2c:	687b      	ldr	r3, [r7, #4]
2400df2e:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400df32:	b2db      	uxtb	r3, r3
2400df34:	2b40      	cmp	r3, #64	; 0x40
2400df36:	d10b      	bne.n	2400df50 <I2C_ITMasterCplt+0x168>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400df38:	687b      	ldr	r3, [r7, #4]
2400df3a:	2200      	movs	r2, #0
2400df3c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400df40:	687b      	ldr	r3, [r7, #4]
2400df42:	2200      	movs	r2, #0
2400df44:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
2400df48:	6878      	ldr	r0, [r7, #4]
2400df4a:	f7ff f86a 	bl	2400d022 <HAL_I2C_MemRxCpltCallback>
}
2400df4e:	e00a      	b.n	2400df66 <I2C_ITMasterCplt+0x17e>
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400df50:	687b      	ldr	r3, [r7, #4]
2400df52:	2200      	movs	r2, #0
2400df54:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
2400df58:	687b      	ldr	r3, [r7, #4]
2400df5a:	2200      	movs	r2, #0
2400df5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
2400df60:	6878      	ldr	r0, [r7, #4]
2400df62:	f7ff f81e 	bl	2400cfa2 <HAL_I2C_MasterRxCpltCallback>
}
2400df66:	bf00      	nop
2400df68:	3718      	adds	r7, #24
2400df6a:	46bd      	mov	sp, r7
2400df6c:	bd80      	pop	{r7, pc}
2400df6e:	bf00      	nop
2400df70:	fe00e800 	.word	0xfe00e800
2400df74:	ffff0000 	.word	0xffff0000

2400df78 <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400df78:	b580      	push	{r7, lr}
2400df7a:	b086      	sub	sp, #24
2400df7c:	af00      	add	r7, sp, #0
2400df7e:	6078      	str	r0, [r7, #4]
2400df80:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
2400df82:	687b      	ldr	r3, [r7, #4]
2400df84:	681b      	ldr	r3, [r3, #0]
2400df86:	681b      	ldr	r3, [r3, #0]
2400df88:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
2400df8a:	683b      	ldr	r3, [r7, #0]
2400df8c:	617b      	str	r3, [r7, #20]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400df8e:	687b      	ldr	r3, [r7, #4]
2400df90:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400df94:	73fb      	strb	r3, [r7, #15]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400df96:	687b      	ldr	r3, [r7, #4]
2400df98:	681b      	ldr	r3, [r3, #0]
2400df9a:	2220      	movs	r2, #32
2400df9c:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
2400df9e:	7bfb      	ldrb	r3, [r7, #15]
2400dfa0:	2b21      	cmp	r3, #33	; 0x21
2400dfa2:	d002      	beq.n	2400dfaa <I2C_ITSlaveCplt+0x32>
2400dfa4:	7bfb      	ldrb	r3, [r7, #15]
2400dfa6:	2b29      	cmp	r3, #41	; 0x29
2400dfa8:	d108      	bne.n	2400dfbc <I2C_ITSlaveCplt+0x44>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
2400dfaa:	f248 0101 	movw	r1, #32769	; 0x8001
2400dfae:	6878      	ldr	r0, [r7, #4]
2400dfb0:	f001 f8c0 	bl	2400f134 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
2400dfb4:	687b      	ldr	r3, [r7, #4]
2400dfb6:	2221      	movs	r2, #33	; 0x21
2400dfb8:	631a      	str	r2, [r3, #48]	; 0x30
2400dfba:	e00d      	b.n	2400dfd8 <I2C_ITSlaveCplt+0x60>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
2400dfbc:	7bfb      	ldrb	r3, [r7, #15]
2400dfbe:	2b22      	cmp	r3, #34	; 0x22
2400dfc0:	d002      	beq.n	2400dfc8 <I2C_ITSlaveCplt+0x50>
2400dfc2:	7bfb      	ldrb	r3, [r7, #15]
2400dfc4:	2b2a      	cmp	r3, #42	; 0x2a
2400dfc6:	d107      	bne.n	2400dfd8 <I2C_ITSlaveCplt+0x60>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
2400dfc8:	f248 0102 	movw	r1, #32770	; 0x8002
2400dfcc:	6878      	ldr	r0, [r7, #4]
2400dfce:	f001 f8b1 	bl	2400f134 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
2400dfd2:	687b      	ldr	r3, [r7, #4]
2400dfd4:	2222      	movs	r2, #34	; 0x22
2400dfd6:	631a      	str	r2, [r3, #48]	; 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400dfd8:	687b      	ldr	r3, [r7, #4]
2400dfda:	681b      	ldr	r3, [r3, #0]
2400dfdc:	685a      	ldr	r2, [r3, #4]
2400dfde:	687b      	ldr	r3, [r7, #4]
2400dfe0:	681b      	ldr	r3, [r3, #0]
2400dfe2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400dfe6:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
2400dfe8:	687b      	ldr	r3, [r7, #4]
2400dfea:	681b      	ldr	r3, [r3, #0]
2400dfec:	6859      	ldr	r1, [r3, #4]
2400dfee:	687b      	ldr	r3, [r7, #4]
2400dff0:	681a      	ldr	r2, [r3, #0]
2400dff2:	4b7f      	ldr	r3, [pc, #508]	; (2400e1f0 <I2C_ITSlaveCplt+0x278>)
2400dff4:	400b      	ands	r3, r1
2400dff6:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
2400dff8:	6878      	ldr	r0, [r7, #4]
2400dffa:	f000 fafe 	bl	2400e5fa <I2C_Flush_TXDR>

  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
2400dffe:	693b      	ldr	r3, [r7, #16]
2400e000:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400e004:	2b00      	cmp	r3, #0
2400e006:	d07a      	beq.n	2400e0fe <I2C_ITSlaveCplt+0x186>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e008:	687b      	ldr	r3, [r7, #4]
2400e00a:	681b      	ldr	r3, [r3, #0]
2400e00c:	681a      	ldr	r2, [r3, #0]
2400e00e:	687b      	ldr	r3, [r7, #4]
2400e010:	681b      	ldr	r3, [r3, #0]
2400e012:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e016:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
2400e018:	687b      	ldr	r3, [r7, #4]
2400e01a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e01c:	2b00      	cmp	r3, #0
2400e01e:	f000 8110 	beq.w	2400e242 <I2C_ITSlaveCplt+0x2ca>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);
2400e022:	687b      	ldr	r3, [r7, #4]
2400e024:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e026:	681b      	ldr	r3, [r3, #0]
2400e028:	4a72      	ldr	r2, [pc, #456]	; (2400e1f4 <I2C_ITSlaveCplt+0x27c>)
2400e02a:	4293      	cmp	r3, r2
2400e02c:	d059      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e02e:	687b      	ldr	r3, [r7, #4]
2400e030:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e032:	681b      	ldr	r3, [r3, #0]
2400e034:	4a70      	ldr	r2, [pc, #448]	; (2400e1f8 <I2C_ITSlaveCplt+0x280>)
2400e036:	4293      	cmp	r3, r2
2400e038:	d053      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e03a:	687b      	ldr	r3, [r7, #4]
2400e03c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e03e:	681b      	ldr	r3, [r3, #0]
2400e040:	4a6e      	ldr	r2, [pc, #440]	; (2400e1fc <I2C_ITSlaveCplt+0x284>)
2400e042:	4293      	cmp	r3, r2
2400e044:	d04d      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e046:	687b      	ldr	r3, [r7, #4]
2400e048:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e04a:	681b      	ldr	r3, [r3, #0]
2400e04c:	4a6c      	ldr	r2, [pc, #432]	; (2400e200 <I2C_ITSlaveCplt+0x288>)
2400e04e:	4293      	cmp	r3, r2
2400e050:	d047      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e052:	687b      	ldr	r3, [r7, #4]
2400e054:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e056:	681b      	ldr	r3, [r3, #0]
2400e058:	4a6a      	ldr	r2, [pc, #424]	; (2400e204 <I2C_ITSlaveCplt+0x28c>)
2400e05a:	4293      	cmp	r3, r2
2400e05c:	d041      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e05e:	687b      	ldr	r3, [r7, #4]
2400e060:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e062:	681b      	ldr	r3, [r3, #0]
2400e064:	4a68      	ldr	r2, [pc, #416]	; (2400e208 <I2C_ITSlaveCplt+0x290>)
2400e066:	4293      	cmp	r3, r2
2400e068:	d03b      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e06a:	687b      	ldr	r3, [r7, #4]
2400e06c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e06e:	681b      	ldr	r3, [r3, #0]
2400e070:	4a66      	ldr	r2, [pc, #408]	; (2400e20c <I2C_ITSlaveCplt+0x294>)
2400e072:	4293      	cmp	r3, r2
2400e074:	d035      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e076:	687b      	ldr	r3, [r7, #4]
2400e078:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e07a:	681b      	ldr	r3, [r3, #0]
2400e07c:	4a64      	ldr	r2, [pc, #400]	; (2400e210 <I2C_ITSlaveCplt+0x298>)
2400e07e:	4293      	cmp	r3, r2
2400e080:	d02f      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e082:	687b      	ldr	r3, [r7, #4]
2400e084:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e086:	681b      	ldr	r3, [r3, #0]
2400e088:	4a62      	ldr	r2, [pc, #392]	; (2400e214 <I2C_ITSlaveCplt+0x29c>)
2400e08a:	4293      	cmp	r3, r2
2400e08c:	d029      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e08e:	687b      	ldr	r3, [r7, #4]
2400e090:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e092:	681b      	ldr	r3, [r3, #0]
2400e094:	4a60      	ldr	r2, [pc, #384]	; (2400e218 <I2C_ITSlaveCplt+0x2a0>)
2400e096:	4293      	cmp	r3, r2
2400e098:	d023      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e09a:	687b      	ldr	r3, [r7, #4]
2400e09c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e09e:	681b      	ldr	r3, [r3, #0]
2400e0a0:	4a5e      	ldr	r2, [pc, #376]	; (2400e21c <I2C_ITSlaveCplt+0x2a4>)
2400e0a2:	4293      	cmp	r3, r2
2400e0a4:	d01d      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e0a6:	687b      	ldr	r3, [r7, #4]
2400e0a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e0aa:	681b      	ldr	r3, [r3, #0]
2400e0ac:	4a5c      	ldr	r2, [pc, #368]	; (2400e220 <I2C_ITSlaveCplt+0x2a8>)
2400e0ae:	4293      	cmp	r3, r2
2400e0b0:	d017      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e0b2:	687b      	ldr	r3, [r7, #4]
2400e0b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e0b6:	681b      	ldr	r3, [r3, #0]
2400e0b8:	4a5a      	ldr	r2, [pc, #360]	; (2400e224 <I2C_ITSlaveCplt+0x2ac>)
2400e0ba:	4293      	cmp	r3, r2
2400e0bc:	d011      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e0be:	687b      	ldr	r3, [r7, #4]
2400e0c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e0c2:	681b      	ldr	r3, [r3, #0]
2400e0c4:	4a58      	ldr	r2, [pc, #352]	; (2400e228 <I2C_ITSlaveCplt+0x2b0>)
2400e0c6:	4293      	cmp	r3, r2
2400e0c8:	d00b      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e0ca:	687b      	ldr	r3, [r7, #4]
2400e0cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e0ce:	681b      	ldr	r3, [r3, #0]
2400e0d0:	4a56      	ldr	r2, [pc, #344]	; (2400e22c <I2C_ITSlaveCplt+0x2b4>)
2400e0d2:	4293      	cmp	r3, r2
2400e0d4:	d005      	beq.n	2400e0e2 <I2C_ITSlaveCplt+0x16a>
2400e0d6:	687b      	ldr	r3, [r7, #4]
2400e0d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e0da:	681b      	ldr	r3, [r3, #0]
2400e0dc:	4a54      	ldr	r2, [pc, #336]	; (2400e230 <I2C_ITSlaveCplt+0x2b8>)
2400e0de:	4293      	cmp	r3, r2
2400e0e0:	d105      	bne.n	2400e0ee <I2C_ITSlaveCplt+0x176>
2400e0e2:	687b      	ldr	r3, [r7, #4]
2400e0e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e0e6:	681b      	ldr	r3, [r3, #0]
2400e0e8:	685b      	ldr	r3, [r3, #4]
2400e0ea:	b29b      	uxth	r3, r3
2400e0ec:	e004      	b.n	2400e0f8 <I2C_ITSlaveCplt+0x180>
2400e0ee:	687b      	ldr	r3, [r7, #4]
2400e0f0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e0f2:	681b      	ldr	r3, [r3, #0]
2400e0f4:	685b      	ldr	r3, [r3, #4]
2400e0f6:	b29b      	uxth	r3, r3
2400e0f8:	687a      	ldr	r2, [r7, #4]
2400e0fa:	8553      	strh	r3, [r2, #42]	; 0x2a
2400e0fc:	e0a1      	b.n	2400e242 <I2C_ITSlaveCplt+0x2ca>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
2400e0fe:	693b      	ldr	r3, [r7, #16]
2400e100:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400e104:	2b00      	cmp	r3, #0
2400e106:	f000 809c 	beq.w	2400e242 <I2C_ITSlaveCplt+0x2ca>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400e10a:	687b      	ldr	r3, [r7, #4]
2400e10c:	681b      	ldr	r3, [r3, #0]
2400e10e:	681a      	ldr	r2, [r3, #0]
2400e110:	687b      	ldr	r3, [r7, #4]
2400e112:	681b      	ldr	r3, [r3, #0]
2400e114:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400e118:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
2400e11a:	687b      	ldr	r3, [r7, #4]
2400e11c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e11e:	2b00      	cmp	r3, #0
2400e120:	f000 808f 	beq.w	2400e242 <I2C_ITSlaveCplt+0x2ca>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);
2400e124:	687b      	ldr	r3, [r7, #4]
2400e126:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e128:	681b      	ldr	r3, [r3, #0]
2400e12a:	4a32      	ldr	r2, [pc, #200]	; (2400e1f4 <I2C_ITSlaveCplt+0x27c>)
2400e12c:	4293      	cmp	r3, r2
2400e12e:	d059      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e130:	687b      	ldr	r3, [r7, #4]
2400e132:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e134:	681b      	ldr	r3, [r3, #0]
2400e136:	4a30      	ldr	r2, [pc, #192]	; (2400e1f8 <I2C_ITSlaveCplt+0x280>)
2400e138:	4293      	cmp	r3, r2
2400e13a:	d053      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e13c:	687b      	ldr	r3, [r7, #4]
2400e13e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e140:	681b      	ldr	r3, [r3, #0]
2400e142:	4a2e      	ldr	r2, [pc, #184]	; (2400e1fc <I2C_ITSlaveCplt+0x284>)
2400e144:	4293      	cmp	r3, r2
2400e146:	d04d      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e148:	687b      	ldr	r3, [r7, #4]
2400e14a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e14c:	681b      	ldr	r3, [r3, #0]
2400e14e:	4a2c      	ldr	r2, [pc, #176]	; (2400e200 <I2C_ITSlaveCplt+0x288>)
2400e150:	4293      	cmp	r3, r2
2400e152:	d047      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e154:	687b      	ldr	r3, [r7, #4]
2400e156:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e158:	681b      	ldr	r3, [r3, #0]
2400e15a:	4a2a      	ldr	r2, [pc, #168]	; (2400e204 <I2C_ITSlaveCplt+0x28c>)
2400e15c:	4293      	cmp	r3, r2
2400e15e:	d041      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e160:	687b      	ldr	r3, [r7, #4]
2400e162:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e164:	681b      	ldr	r3, [r3, #0]
2400e166:	4a28      	ldr	r2, [pc, #160]	; (2400e208 <I2C_ITSlaveCplt+0x290>)
2400e168:	4293      	cmp	r3, r2
2400e16a:	d03b      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e16c:	687b      	ldr	r3, [r7, #4]
2400e16e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e170:	681b      	ldr	r3, [r3, #0]
2400e172:	4a26      	ldr	r2, [pc, #152]	; (2400e20c <I2C_ITSlaveCplt+0x294>)
2400e174:	4293      	cmp	r3, r2
2400e176:	d035      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e178:	687b      	ldr	r3, [r7, #4]
2400e17a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e17c:	681b      	ldr	r3, [r3, #0]
2400e17e:	4a24      	ldr	r2, [pc, #144]	; (2400e210 <I2C_ITSlaveCplt+0x298>)
2400e180:	4293      	cmp	r3, r2
2400e182:	d02f      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e184:	687b      	ldr	r3, [r7, #4]
2400e186:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e188:	681b      	ldr	r3, [r3, #0]
2400e18a:	4a22      	ldr	r2, [pc, #136]	; (2400e214 <I2C_ITSlaveCplt+0x29c>)
2400e18c:	4293      	cmp	r3, r2
2400e18e:	d029      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e190:	687b      	ldr	r3, [r7, #4]
2400e192:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e194:	681b      	ldr	r3, [r3, #0]
2400e196:	4a20      	ldr	r2, [pc, #128]	; (2400e218 <I2C_ITSlaveCplt+0x2a0>)
2400e198:	4293      	cmp	r3, r2
2400e19a:	d023      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e19c:	687b      	ldr	r3, [r7, #4]
2400e19e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e1a0:	681b      	ldr	r3, [r3, #0]
2400e1a2:	4a1e      	ldr	r2, [pc, #120]	; (2400e21c <I2C_ITSlaveCplt+0x2a4>)
2400e1a4:	4293      	cmp	r3, r2
2400e1a6:	d01d      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e1a8:	687b      	ldr	r3, [r7, #4]
2400e1aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e1ac:	681b      	ldr	r3, [r3, #0]
2400e1ae:	4a1c      	ldr	r2, [pc, #112]	; (2400e220 <I2C_ITSlaveCplt+0x2a8>)
2400e1b0:	4293      	cmp	r3, r2
2400e1b2:	d017      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e1b4:	687b      	ldr	r3, [r7, #4]
2400e1b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e1b8:	681b      	ldr	r3, [r3, #0]
2400e1ba:	4a1a      	ldr	r2, [pc, #104]	; (2400e224 <I2C_ITSlaveCplt+0x2ac>)
2400e1bc:	4293      	cmp	r3, r2
2400e1be:	d011      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e1c0:	687b      	ldr	r3, [r7, #4]
2400e1c2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e1c4:	681b      	ldr	r3, [r3, #0]
2400e1c6:	4a18      	ldr	r2, [pc, #96]	; (2400e228 <I2C_ITSlaveCplt+0x2b0>)
2400e1c8:	4293      	cmp	r3, r2
2400e1ca:	d00b      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e1cc:	687b      	ldr	r3, [r7, #4]
2400e1ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e1d0:	681b      	ldr	r3, [r3, #0]
2400e1d2:	4a16      	ldr	r2, [pc, #88]	; (2400e22c <I2C_ITSlaveCplt+0x2b4>)
2400e1d4:	4293      	cmp	r3, r2
2400e1d6:	d005      	beq.n	2400e1e4 <I2C_ITSlaveCplt+0x26c>
2400e1d8:	687b      	ldr	r3, [r7, #4]
2400e1da:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e1dc:	681b      	ldr	r3, [r3, #0]
2400e1de:	4a14      	ldr	r2, [pc, #80]	; (2400e230 <I2C_ITSlaveCplt+0x2b8>)
2400e1e0:	4293      	cmp	r3, r2
2400e1e2:	d127      	bne.n	2400e234 <I2C_ITSlaveCplt+0x2bc>
2400e1e4:	687b      	ldr	r3, [r7, #4]
2400e1e6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e1e8:	681b      	ldr	r3, [r3, #0]
2400e1ea:	685b      	ldr	r3, [r3, #4]
2400e1ec:	b29b      	uxth	r3, r3
2400e1ee:	e026      	b.n	2400e23e <I2C_ITSlaveCplt+0x2c6>
2400e1f0:	fe00e800 	.word	0xfe00e800
2400e1f4:	40020010 	.word	0x40020010
2400e1f8:	40020028 	.word	0x40020028
2400e1fc:	40020040 	.word	0x40020040
2400e200:	40020058 	.word	0x40020058
2400e204:	40020070 	.word	0x40020070
2400e208:	40020088 	.word	0x40020088
2400e20c:	400200a0 	.word	0x400200a0
2400e210:	400200b8 	.word	0x400200b8
2400e214:	40020410 	.word	0x40020410
2400e218:	40020428 	.word	0x40020428
2400e21c:	40020440 	.word	0x40020440
2400e220:	40020458 	.word	0x40020458
2400e224:	40020470 	.word	0x40020470
2400e228:	40020488 	.word	0x40020488
2400e22c:	400204a0 	.word	0x400204a0
2400e230:	400204b8 	.word	0x400204b8
2400e234:	687b      	ldr	r3, [r7, #4]
2400e236:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e238:	681b      	ldr	r3, [r3, #0]
2400e23a:	685b      	ldr	r3, [r3, #4]
2400e23c:	b29b      	uxth	r3, r3
2400e23e:	687a      	ldr	r2, [r7, #4]
2400e240:	8553      	strh	r3, [r2, #42]	; 0x2a
  {
    /* Do nothing */
  }

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
2400e242:	697b      	ldr	r3, [r7, #20]
2400e244:	f003 0304 	and.w	r3, r3, #4
2400e248:	2b00      	cmp	r3, #0
2400e24a:	d020      	beq.n	2400e28e <I2C_ITSlaveCplt+0x316>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
2400e24c:	697b      	ldr	r3, [r7, #20]
2400e24e:	f023 0304 	bic.w	r3, r3, #4
2400e252:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400e254:	687b      	ldr	r3, [r7, #4]
2400e256:	681b      	ldr	r3, [r3, #0]
2400e258:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400e25a:	687b      	ldr	r3, [r7, #4]
2400e25c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e25e:	b2d2      	uxtb	r2, r2
2400e260:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400e262:	687b      	ldr	r3, [r7, #4]
2400e264:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e266:	1c5a      	adds	r2, r3, #1
2400e268:	687b      	ldr	r3, [r7, #4]
2400e26a:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400e26c:	687b      	ldr	r3, [r7, #4]
2400e26e:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e270:	2b00      	cmp	r3, #0
2400e272:	d00c      	beq.n	2400e28e <I2C_ITSlaveCplt+0x316>
    {
      hi2c->XferSize--;
2400e274:	687b      	ldr	r3, [r7, #4]
2400e276:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e278:	3b01      	subs	r3, #1
2400e27a:	b29a      	uxth	r2, r3
2400e27c:	687b      	ldr	r3, [r7, #4]
2400e27e:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400e280:	687b      	ldr	r3, [r7, #4]
2400e282:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e284:	b29b      	uxth	r3, r3
2400e286:	3b01      	subs	r3, #1
2400e288:	b29a      	uxth	r2, r3
2400e28a:	687b      	ldr	r3, [r7, #4]
2400e28c:	855a      	strh	r2, [r3, #42]	; 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
2400e28e:	687b      	ldr	r3, [r7, #4]
2400e290:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e292:	b29b      	uxth	r3, r3
2400e294:	2b00      	cmp	r3, #0
2400e296:	d005      	beq.n	2400e2a4 <I2C_ITSlaveCplt+0x32c>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400e298:	687b      	ldr	r3, [r7, #4]
2400e29a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e29c:	f043 0204 	orr.w	r2, r3, #4
2400e2a0:	687b      	ldr	r3, [r7, #4]
2400e2a2:	645a      	str	r2, [r3, #68]	; 0x44
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
2400e2a4:	687b      	ldr	r3, [r7, #4]
2400e2a6:	2200      	movs	r2, #0
2400e2a8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400e2ac:	687b      	ldr	r3, [r7, #4]
2400e2ae:	2200      	movs	r2, #0
2400e2b0:	635a      	str	r2, [r3, #52]	; 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
2400e2b2:	687b      	ldr	r3, [r7, #4]
2400e2b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e2b6:	2b00      	cmp	r3, #0
2400e2b8:	d010      	beq.n	2400e2dc <I2C_ITSlaveCplt+0x364>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
2400e2ba:	687b      	ldr	r3, [r7, #4]
2400e2bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e2be:	4619      	mov	r1, r3
2400e2c0:	6878      	ldr	r0, [r7, #4]
2400e2c2:	f000 f8a3 	bl	2400e40c <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
2400e2c6:	687b      	ldr	r3, [r7, #4]
2400e2c8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e2cc:	b2db      	uxtb	r3, r3
2400e2ce:	2b28      	cmp	r3, #40	; 0x28
2400e2d0:	d141      	bne.n	2400e356 <I2C_ITSlaveCplt+0x3de>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
2400e2d2:	6979      	ldr	r1, [r7, #20]
2400e2d4:	6878      	ldr	r0, [r7, #4]
2400e2d6:	f000 f845 	bl	2400e364 <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400e2da:	e03c      	b.n	2400e356 <I2C_ITSlaveCplt+0x3de>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
2400e2dc:	687b      	ldr	r3, [r7, #4]
2400e2de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400e2e0:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400e2e4:	d014      	beq.n	2400e310 <I2C_ITSlaveCplt+0x398>
    I2C_ITSlaveSeqCplt(hi2c);
2400e2e6:	6878      	ldr	r0, [r7, #4]
2400e2e8:	f7ff fd21 	bl	2400dd2e <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400e2ec:	687b      	ldr	r3, [r7, #4]
2400e2ee:	4a1c      	ldr	r2, [pc, #112]	; (2400e360 <I2C_ITSlaveCplt+0x3e8>)
2400e2f0:	62da      	str	r2, [r3, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
2400e2f2:	687b      	ldr	r3, [r7, #4]
2400e2f4:	2220      	movs	r2, #32
2400e2f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e2fa:	687b      	ldr	r3, [r7, #4]
2400e2fc:	2200      	movs	r2, #0
2400e2fe:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e300:	687b      	ldr	r3, [r7, #4]
2400e302:	2200      	movs	r2, #0
2400e304:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
2400e308:	6878      	ldr	r0, [r7, #4]
2400e30a:	f7fe fe76 	bl	2400cffa <HAL_I2C_ListenCpltCallback>
}
2400e30e:	e022      	b.n	2400e356 <I2C_ITSlaveCplt+0x3de>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
2400e310:	687b      	ldr	r3, [r7, #4]
2400e312:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e316:	b2db      	uxtb	r3, r3
2400e318:	2b22      	cmp	r3, #34	; 0x22
2400e31a:	d10e      	bne.n	2400e33a <I2C_ITSlaveCplt+0x3c2>
    hi2c->State = HAL_I2C_STATE_READY;
2400e31c:	687b      	ldr	r3, [r7, #4]
2400e31e:	2220      	movs	r2, #32
2400e320:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e324:	687b      	ldr	r3, [r7, #4]
2400e326:	2200      	movs	r2, #0
2400e328:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e32a:	687b      	ldr	r3, [r7, #4]
2400e32c:	2200      	movs	r2, #0
2400e32e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
2400e332:	6878      	ldr	r0, [r7, #4]
2400e334:	f7fe fe49 	bl	2400cfca <HAL_I2C_SlaveRxCpltCallback>
}
2400e338:	e00d      	b.n	2400e356 <I2C_ITSlaveCplt+0x3de>
    hi2c->State = HAL_I2C_STATE_READY;
2400e33a:	687b      	ldr	r3, [r7, #4]
2400e33c:	2220      	movs	r2, #32
2400e33e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e342:	687b      	ldr	r3, [r7, #4]
2400e344:	2200      	movs	r2, #0
2400e346:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e348:	687b      	ldr	r3, [r7, #4]
2400e34a:	2200      	movs	r2, #0
2400e34c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
2400e350:	6878      	ldr	r0, [r7, #4]
2400e352:	f7fe fe30 	bl	2400cfb6 <HAL_I2C_SlaveTxCpltCallback>
}
2400e356:	bf00      	nop
2400e358:	3718      	adds	r7, #24
2400e35a:	46bd      	mov	sp, r7
2400e35c:	bd80      	pop	{r7, pc}
2400e35e:	bf00      	nop
2400e360:	ffff0000 	.word	0xffff0000

2400e364 <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
2400e364:	b580      	push	{r7, lr}
2400e366:	b082      	sub	sp, #8
2400e368:	af00      	add	r7, sp, #0
2400e36a:	6078      	str	r0, [r7, #4]
2400e36c:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
2400e36e:	687b      	ldr	r3, [r7, #4]
2400e370:	4a25      	ldr	r2, [pc, #148]	; (2400e408 <I2C_ITListenCplt+0xa4>)
2400e372:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
2400e374:	687b      	ldr	r3, [r7, #4]
2400e376:	2200      	movs	r2, #0
2400e378:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
2400e37a:	687b      	ldr	r3, [r7, #4]
2400e37c:	2220      	movs	r2, #32
2400e37e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
2400e382:	687b      	ldr	r3, [r7, #4]
2400e384:	2200      	movs	r2, #0
2400e386:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferISR = NULL;
2400e38a:	687b      	ldr	r3, [r7, #4]
2400e38c:	2200      	movs	r2, #0
2400e38e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
2400e390:	683b      	ldr	r3, [r7, #0]
2400e392:	f003 0304 	and.w	r3, r3, #4
2400e396:	2b00      	cmp	r3, #0
2400e398:	d022      	beq.n	2400e3e0 <I2C_ITListenCplt+0x7c>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
2400e39a:	687b      	ldr	r3, [r7, #4]
2400e39c:	681b      	ldr	r3, [r3, #0]
2400e39e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2400e3a0:	687b      	ldr	r3, [r7, #4]
2400e3a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e3a4:	b2d2      	uxtb	r2, r2
2400e3a6:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
2400e3a8:	687b      	ldr	r3, [r7, #4]
2400e3aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e3ac:	1c5a      	adds	r2, r3, #1
2400e3ae:	687b      	ldr	r3, [r7, #4]
2400e3b0:	625a      	str	r2, [r3, #36]	; 0x24

    if ((hi2c->XferSize > 0U))
2400e3b2:	687b      	ldr	r3, [r7, #4]
2400e3b4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e3b6:	2b00      	cmp	r3, #0
2400e3b8:	d012      	beq.n	2400e3e0 <I2C_ITListenCplt+0x7c>
    {
      hi2c->XferSize--;
2400e3ba:	687b      	ldr	r3, [r7, #4]
2400e3bc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400e3be:	3b01      	subs	r3, #1
2400e3c0:	b29a      	uxth	r2, r3
2400e3c2:	687b      	ldr	r3, [r7, #4]
2400e3c4:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
2400e3c6:	687b      	ldr	r3, [r7, #4]
2400e3c8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e3ca:	b29b      	uxth	r3, r3
2400e3cc:	3b01      	subs	r3, #1
2400e3ce:	b29a      	uxth	r2, r3
2400e3d0:	687b      	ldr	r3, [r7, #4]
2400e3d2:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
2400e3d4:	687b      	ldr	r3, [r7, #4]
2400e3d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400e3d8:	f043 0204 	orr.w	r2, r3, #4
2400e3dc:	687b      	ldr	r3, [r7, #4]
2400e3de:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400e3e0:	f248 0103 	movw	r1, #32771	; 0x8003
2400e3e4:	6878      	ldr	r0, [r7, #4]
2400e3e6:	f000 fea5 	bl	2400f134 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400e3ea:	687b      	ldr	r3, [r7, #4]
2400e3ec:	681b      	ldr	r3, [r3, #0]
2400e3ee:	2210      	movs	r2, #16
2400e3f0:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
2400e3f2:	687b      	ldr	r3, [r7, #4]
2400e3f4:	2200      	movs	r2, #0
2400e3f6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
2400e3fa:	6878      	ldr	r0, [r7, #4]
2400e3fc:	f7fe fdfd 	bl	2400cffa <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
2400e400:	bf00      	nop
2400e402:	3708      	adds	r7, #8
2400e404:	46bd      	mov	sp, r7
2400e406:	bd80      	pop	{r7, pc}
2400e408:	ffff0000 	.word	0xffff0000

2400e40c <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
2400e40c:	b580      	push	{r7, lr}
2400e40e:	b084      	sub	sp, #16
2400e410:	af00      	add	r7, sp, #0
2400e412:	6078      	str	r0, [r7, #4]
2400e414:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
2400e416:	687b      	ldr	r3, [r7, #4]
2400e418:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e41c:	73fb      	strb	r3, [r7, #15]
  uint32_t tmppreviousstate;

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
2400e41e:	687b      	ldr	r3, [r7, #4]
2400e420:	2200      	movs	r2, #0
2400e422:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
2400e426:	687b      	ldr	r3, [r7, #4]
2400e428:	4a5d      	ldr	r2, [pc, #372]	; (2400e5a0 <I2C_ITError+0x194>)
2400e42a:	62da      	str	r2, [r3, #44]	; 0x2c
  hi2c->XferCount     = 0U;
2400e42c:	687b      	ldr	r3, [r7, #4]
2400e42e:	2200      	movs	r2, #0
2400e430:	855a      	strh	r2, [r3, #42]	; 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
2400e432:	687b      	ldr	r3, [r7, #4]
2400e434:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2400e436:	683b      	ldr	r3, [r7, #0]
2400e438:	431a      	orrs	r2, r3
2400e43a:	687b      	ldr	r3, [r7, #4]
2400e43c:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
2400e43e:	7bfb      	ldrb	r3, [r7, #15]
2400e440:	2b28      	cmp	r3, #40	; 0x28
2400e442:	d005      	beq.n	2400e450 <I2C_ITError+0x44>
2400e444:	7bfb      	ldrb	r3, [r7, #15]
2400e446:	2b29      	cmp	r3, #41	; 0x29
2400e448:	d002      	beq.n	2400e450 <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
2400e44a:	7bfb      	ldrb	r3, [r7, #15]
2400e44c:	2b2a      	cmp	r3, #42	; 0x2a
2400e44e:	d10b      	bne.n	2400e468 <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400e450:	2103      	movs	r1, #3
2400e452:	6878      	ldr	r0, [r7, #4]
2400e454:	f000 fe6e 	bl	2400f134 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
2400e458:	687b      	ldr	r3, [r7, #4]
2400e45a:	2228      	movs	r2, #40	; 0x28
2400e45c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
2400e460:	687b      	ldr	r3, [r7, #4]
2400e462:	4a50      	ldr	r2, [pc, #320]	; (2400e5a4 <I2C_ITError+0x198>)
2400e464:	635a      	str	r2, [r3, #52]	; 0x34
2400e466:	e011      	b.n	2400e48c <I2C_ITError+0x80>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
2400e468:	f248 0103 	movw	r1, #32771	; 0x8003
2400e46c:	6878      	ldr	r0, [r7, #4]
2400e46e:	f000 fe61 	bl	2400f134 <I2C_Disable_IRQ>

    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
2400e472:	687b      	ldr	r3, [r7, #4]
2400e474:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e478:	b2db      	uxtb	r3, r3
2400e47a:	2b60      	cmp	r3, #96	; 0x60
2400e47c:	d003      	beq.n	2400e486 <I2C_ITError+0x7a>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
2400e47e:	687b      	ldr	r3, [r7, #4]
2400e480:	2220      	movs	r2, #32
2400e482:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
    hi2c->XferISR       = NULL;
2400e486:	687b      	ldr	r3, [r7, #4]
2400e488:	2200      	movs	r2, #0
2400e48a:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
2400e48c:	687b      	ldr	r3, [r7, #4]
2400e48e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400e490:	60bb      	str	r3, [r7, #8]
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
2400e492:	687b      	ldr	r3, [r7, #4]
2400e494:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e496:	2b00      	cmp	r3, #0
2400e498:	d039      	beq.n	2400e50e <I2C_ITError+0x102>
2400e49a:	68bb      	ldr	r3, [r7, #8]
2400e49c:	2b11      	cmp	r3, #17
2400e49e:	d002      	beq.n	2400e4a6 <I2C_ITError+0x9a>
2400e4a0:	68bb      	ldr	r3, [r7, #8]
2400e4a2:	2b21      	cmp	r3, #33	; 0x21
2400e4a4:	d133      	bne.n	2400e50e <I2C_ITError+0x102>
                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
2400e4a6:	687b      	ldr	r3, [r7, #4]
2400e4a8:	681b      	ldr	r3, [r3, #0]
2400e4aa:	681b      	ldr	r3, [r3, #0]
2400e4ac:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400e4b0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400e4b4:	d107      	bne.n	2400e4c6 <I2C_ITError+0xba>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e4b6:	687b      	ldr	r3, [r7, #4]
2400e4b8:	681b      	ldr	r3, [r3, #0]
2400e4ba:	681a      	ldr	r2, [r3, #0]
2400e4bc:	687b      	ldr	r3, [r7, #4]
2400e4be:	681b      	ldr	r3, [r3, #0]
2400e4c0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e4c4:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e4c6:	687b      	ldr	r3, [r7, #4]
2400e4c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e4ca:	4618      	mov	r0, r3
2400e4cc:	f7f8 f83e 	bl	2400654c <HAL_DMA_GetState>
2400e4d0:	4603      	mov	r3, r0
2400e4d2:	2b01      	cmp	r3, #1
2400e4d4:	d017      	beq.n	2400e506 <I2C_ITError+0xfa>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
2400e4d6:	687b      	ldr	r3, [r7, #4]
2400e4d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e4da:	4a33      	ldr	r2, [pc, #204]	; (2400e5a8 <I2C_ITError+0x19c>)
2400e4dc:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400e4de:	687b      	ldr	r3, [r7, #4]
2400e4e0:	2200      	movs	r2, #0
2400e4e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
2400e4e6:	687b      	ldr	r3, [r7, #4]
2400e4e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e4ea:	4618      	mov	r0, r3
2400e4ec:	f7f6 fa4c 	bl	24004988 <HAL_DMA_Abort_IT>
2400e4f0:	4603      	mov	r3, r0
2400e4f2:	2b00      	cmp	r3, #0
2400e4f4:	d04d      	beq.n	2400e592 <I2C_ITError+0x186>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
2400e4f6:	687b      	ldr	r3, [r7, #4]
2400e4f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e4fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400e4fc:	687a      	ldr	r2, [r7, #4]
2400e4fe:	6b92      	ldr	r2, [r2, #56]	; 0x38
2400e500:	4610      	mov	r0, r2
2400e502:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e504:	e045      	b.n	2400e592 <I2C_ITError+0x186>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400e506:	6878      	ldr	r0, [r7, #4]
2400e508:	f000 f850 	bl	2400e5ac <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e50c:	e041      	b.n	2400e592 <I2C_ITError+0x186>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
2400e50e:	687b      	ldr	r3, [r7, #4]
2400e510:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e512:	2b00      	cmp	r3, #0
2400e514:	d039      	beq.n	2400e58a <I2C_ITError+0x17e>
2400e516:	68bb      	ldr	r3, [r7, #8]
2400e518:	2b12      	cmp	r3, #18
2400e51a:	d002      	beq.n	2400e522 <I2C_ITError+0x116>
2400e51c:	68bb      	ldr	r3, [r7, #8]
2400e51e:	2b22      	cmp	r3, #34	; 0x22
2400e520:	d133      	bne.n	2400e58a <I2C_ITError+0x17e>
                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
2400e522:	687b      	ldr	r3, [r7, #4]
2400e524:	681b      	ldr	r3, [r3, #0]
2400e526:	681b      	ldr	r3, [r3, #0]
2400e528:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400e52c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400e530:	d107      	bne.n	2400e542 <I2C_ITError+0x136>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400e532:	687b      	ldr	r3, [r7, #4]
2400e534:	681b      	ldr	r3, [r3, #0]
2400e536:	681a      	ldr	r2, [r3, #0]
2400e538:	687b      	ldr	r3, [r7, #4]
2400e53a:	681b      	ldr	r3, [r3, #0]
2400e53c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400e540:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e542:	687b      	ldr	r3, [r7, #4]
2400e544:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e546:	4618      	mov	r0, r3
2400e548:	f7f8 f800 	bl	2400654c <HAL_DMA_GetState>
2400e54c:	4603      	mov	r3, r0
2400e54e:	2b01      	cmp	r3, #1
2400e550:	d017      	beq.n	2400e582 <I2C_ITError+0x176>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
2400e552:	687b      	ldr	r3, [r7, #4]
2400e554:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e556:	4a14      	ldr	r2, [pc, #80]	; (2400e5a8 <I2C_ITError+0x19c>)
2400e558:	651a      	str	r2, [r3, #80]	; 0x50

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400e55a:	687b      	ldr	r3, [r7, #4]
2400e55c:	2200      	movs	r2, #0
2400e55e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
2400e562:	687b      	ldr	r3, [r7, #4]
2400e564:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e566:	4618      	mov	r0, r3
2400e568:	f7f6 fa0e 	bl	24004988 <HAL_DMA_Abort_IT>
2400e56c:	4603      	mov	r3, r0
2400e56e:	2b00      	cmp	r3, #0
2400e570:	d011      	beq.n	2400e596 <I2C_ITError+0x18a>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
2400e572:	687b      	ldr	r3, [r7, #4]
2400e574:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e576:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400e578:	687a      	ldr	r2, [r7, #4]
2400e57a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
2400e57c:	4610      	mov	r0, r2
2400e57e:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e580:	e009      	b.n	2400e596 <I2C_ITError+0x18a>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
2400e582:	6878      	ldr	r0, [r7, #4]
2400e584:	f000 f812 	bl	2400e5ac <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e588:	e005      	b.n	2400e596 <I2C_ITError+0x18a>
    }
  }
  else
  {
    I2C_TreatErrorCallback(hi2c);
2400e58a:	6878      	ldr	r0, [r7, #4]
2400e58c:	f000 f80e 	bl	2400e5ac <I2C_TreatErrorCallback>
  }
}
2400e590:	e002      	b.n	2400e598 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
2400e592:	bf00      	nop
2400e594:	e000      	b.n	2400e598 <I2C_ITError+0x18c>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
2400e596:	bf00      	nop
}
2400e598:	bf00      	nop
2400e59a:	3710      	adds	r7, #16
2400e59c:	46bd      	mov	sp, r7
2400e59e:	bd80      	pop	{r7, pc}
2400e5a0:	ffff0000 	.word	0xffff0000
2400e5a4:	2400d2e7 	.word	0x2400d2e7
2400e5a8:	2400eb89 	.word	0x2400eb89

2400e5ac <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
2400e5ac:	b580      	push	{r7, lr}
2400e5ae:	b082      	sub	sp, #8
2400e5b0:	af00      	add	r7, sp, #0
2400e5b2:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
2400e5b4:	687b      	ldr	r3, [r7, #4]
2400e5b6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400e5ba:	b2db      	uxtb	r3, r3
2400e5bc:	2b60      	cmp	r3, #96	; 0x60
2400e5be:	d10e      	bne.n	2400e5de <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
2400e5c0:	687b      	ldr	r3, [r7, #4]
2400e5c2:	2220      	movs	r2, #32
2400e5c4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
2400e5c8:	687b      	ldr	r3, [r7, #4]
2400e5ca:	2200      	movs	r2, #0
2400e5cc:	631a      	str	r2, [r3, #48]	; 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400e5ce:	687b      	ldr	r3, [r7, #4]
2400e5d0:	2200      	movs	r2, #0
2400e5d2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
2400e5d6:	6878      	ldr	r0, [r7, #4]
2400e5d8:	f7fe fd37 	bl	2400d04a <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
2400e5dc:	e009      	b.n	2400e5f2 <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
2400e5de:	687b      	ldr	r3, [r7, #4]
2400e5e0:	2200      	movs	r2, #0
2400e5e2:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
2400e5e4:	687b      	ldr	r3, [r7, #4]
2400e5e6:	2200      	movs	r2, #0
2400e5e8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
2400e5ec:	6878      	ldr	r0, [r7, #4]
2400e5ee:	f7fe fd22 	bl	2400d036 <HAL_I2C_ErrorCallback>
}
2400e5f2:	bf00      	nop
2400e5f4:	3708      	adds	r7, #8
2400e5f6:	46bd      	mov	sp, r7
2400e5f8:	bd80      	pop	{r7, pc}

2400e5fa <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
2400e5fa:	b480      	push	{r7}
2400e5fc:	b083      	sub	sp, #12
2400e5fe:	af00      	add	r7, sp, #0
2400e600:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
2400e602:	687b      	ldr	r3, [r7, #4]
2400e604:	681b      	ldr	r3, [r3, #0]
2400e606:	699b      	ldr	r3, [r3, #24]
2400e608:	f003 0302 	and.w	r3, r3, #2
2400e60c:	2b02      	cmp	r3, #2
2400e60e:	d103      	bne.n	2400e618 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
2400e610:	687b      	ldr	r3, [r7, #4]
2400e612:	681b      	ldr	r3, [r3, #0]
2400e614:	2200      	movs	r2, #0
2400e616:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
2400e618:	687b      	ldr	r3, [r7, #4]
2400e61a:	681b      	ldr	r3, [r3, #0]
2400e61c:	699b      	ldr	r3, [r3, #24]
2400e61e:	f003 0301 	and.w	r3, r3, #1
2400e622:	2b01      	cmp	r3, #1
2400e624:	d007      	beq.n	2400e636 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
2400e626:	687b      	ldr	r3, [r7, #4]
2400e628:	681b      	ldr	r3, [r3, #0]
2400e62a:	699a      	ldr	r2, [r3, #24]
2400e62c:	687b      	ldr	r3, [r7, #4]
2400e62e:	681b      	ldr	r3, [r3, #0]
2400e630:	f042 0201 	orr.w	r2, r2, #1
2400e634:	619a      	str	r2, [r3, #24]
  }
}
2400e636:	bf00      	nop
2400e638:	370c      	adds	r7, #12
2400e63a:	46bd      	mov	sp, r7
2400e63c:	f85d 7b04 	ldr.w	r7, [sp], #4
2400e640:	4770      	bx	lr

2400e642 <I2C_DMAMasterTransmitCplt>:
  * @brief  DMA I2C master transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400e642:	b580      	push	{r7, lr}
2400e644:	b084      	sub	sp, #16
2400e646:	af00      	add	r7, sp, #0
2400e648:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400e64a:	687b      	ldr	r3, [r7, #4]
2400e64c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e64e:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e650:	68fb      	ldr	r3, [r7, #12]
2400e652:	681b      	ldr	r3, [r3, #0]
2400e654:	681a      	ldr	r2, [r3, #0]
2400e656:	68fb      	ldr	r3, [r7, #12]
2400e658:	681b      	ldr	r3, [r3, #0]
2400e65a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e65e:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400e660:	68fb      	ldr	r3, [r7, #12]
2400e662:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e664:	b29b      	uxth	r3, r3
2400e666:	2b00      	cmp	r3, #0
2400e668:	d104      	bne.n	2400e674 <I2C_DMAMasterTransmitCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400e66a:	2120      	movs	r1, #32
2400e66c:	68f8      	ldr	r0, [r7, #12]
2400e66e:	f000 fcfd 	bl	2400f06c <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400e672:	e02d      	b.n	2400e6d0 <I2C_DMAMasterTransmitCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400e674:	68fb      	ldr	r3, [r7, #12]
2400e676:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e678:	68fa      	ldr	r2, [r7, #12]
2400e67a:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400e67c:	441a      	add	r2, r3
2400e67e:	68fb      	ldr	r3, [r7, #12]
2400e680:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400e682:	68fb      	ldr	r3, [r7, #12]
2400e684:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e686:	b29b      	uxth	r3, r3
2400e688:	2bff      	cmp	r3, #255	; 0xff
2400e68a:	d903      	bls.n	2400e694 <I2C_DMAMasterTransmitCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400e68c:	68fb      	ldr	r3, [r7, #12]
2400e68e:	22ff      	movs	r2, #255	; 0xff
2400e690:	851a      	strh	r2, [r3, #40]	; 0x28
2400e692:	e004      	b.n	2400e69e <I2C_DMAMasterTransmitCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400e694:	68fb      	ldr	r3, [r7, #12]
2400e696:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e698:	b29a      	uxth	r2, r3
2400e69a:	68fb      	ldr	r3, [r7, #12]
2400e69c:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,
2400e69e:	68fb      	ldr	r3, [r7, #12]
2400e6a0:	6b98      	ldr	r0, [r3, #56]	; 0x38
2400e6a2:	68fb      	ldr	r3, [r7, #12]
2400e6a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e6a6:	4619      	mov	r1, r3
2400e6a8:	68fb      	ldr	r3, [r7, #12]
2400e6aa:	681b      	ldr	r3, [r3, #0]
2400e6ac:	3328      	adds	r3, #40	; 0x28
2400e6ae:	461a      	mov	r2, r3
                         hi2c->XferSize) != HAL_OK)
2400e6b0:	68fb      	ldr	r3, [r7, #12]
2400e6b2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR,
2400e6b4:	f7f5 fbe0 	bl	24003e78 <HAL_DMA_Start_IT>
2400e6b8:	4603      	mov	r3, r0
2400e6ba:	2b00      	cmp	r3, #0
2400e6bc:	d004      	beq.n	2400e6c8 <I2C_DMAMasterTransmitCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400e6be:	2110      	movs	r1, #16
2400e6c0:	68f8      	ldr	r0, [r7, #12]
2400e6c2:	f7ff fea3 	bl	2400e40c <I2C_ITError>
}
2400e6c6:	e003      	b.n	2400e6d0 <I2C_DMAMasterTransmitCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400e6c8:	2140      	movs	r1, #64	; 0x40
2400e6ca:	68f8      	ldr	r0, [r7, #12]
2400e6cc:	f000 fcce 	bl	2400f06c <I2C_Enable_IRQ>
}
2400e6d0:	bf00      	nop
2400e6d2:	3710      	adds	r7, #16
2400e6d4:	46bd      	mov	sp, r7
2400e6d6:	bd80      	pop	{r7, pc}

2400e6d8 <I2C_DMASlaveTransmitCplt>:
  * @brief  DMA I2C slave transmit process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma)
{
2400e6d8:	b580      	push	{r7, lr}
2400e6da:	b084      	sub	sp, #16
2400e6dc:	af00      	add	r7, sp, #0
2400e6de:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400e6e0:	687b      	ldr	r3, [r7, #4]
2400e6e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e6e4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400e6e6:	68fb      	ldr	r3, [r7, #12]
2400e6e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400e6ea:	60bb      	str	r3, [r7, #8]

  if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
2400e6ec:	68bb      	ldr	r3, [r7, #8]
2400e6ee:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
2400e6f2:	d002      	beq.n	2400e6fa <I2C_DMASlaveTransmitCplt+0x22>
2400e6f4:	68bb      	ldr	r3, [r7, #8]
2400e6f6:	2b00      	cmp	r3, #0
2400e6f8:	d10a      	bne.n	2400e710 <I2C_DMASlaveTransmitCplt+0x38>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
2400e6fa:	68fb      	ldr	r3, [r7, #12]
2400e6fc:	681b      	ldr	r3, [r3, #0]
2400e6fe:	681a      	ldr	r2, [r3, #0]
2400e700:	68fb      	ldr	r3, [r7, #12]
2400e702:	681b      	ldr	r3, [r3, #0]
2400e704:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
2400e708:	601a      	str	r2, [r3, #0]

    /* Last Byte is Transmitted */
    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400e70a:	68f8      	ldr	r0, [r7, #12]
2400e70c:	f7ff fb0f 	bl	2400dd2e <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400e710:	bf00      	nop
2400e712:	3710      	adds	r7, #16
2400e714:	46bd      	mov	sp, r7
2400e716:	bd80      	pop	{r7, pc}

2400e718 <I2C_DMAMasterReceiveCplt>:
  * @brief DMA I2C master receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400e718:	b580      	push	{r7, lr}
2400e71a:	b084      	sub	sp, #16
2400e71c:	af00      	add	r7, sp, #0
2400e71e:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400e720:	687b      	ldr	r3, [r7, #4]
2400e722:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e724:	60fb      	str	r3, [r7, #12]

  /* Disable DMA Request */
  hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400e726:	68fb      	ldr	r3, [r7, #12]
2400e728:	681b      	ldr	r3, [r3, #0]
2400e72a:	681a      	ldr	r2, [r3, #0]
2400e72c:	68fb      	ldr	r3, [r7, #12]
2400e72e:	681b      	ldr	r3, [r3, #0]
2400e730:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400e734:	601a      	str	r2, [r3, #0]

  /* If last transfer, enable STOP interrupt */
  if (hi2c->XferCount == 0U)
2400e736:	68fb      	ldr	r3, [r7, #12]
2400e738:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e73a:	b29b      	uxth	r3, r3
2400e73c:	2b00      	cmp	r3, #0
2400e73e:	d104      	bne.n	2400e74a <I2C_DMAMasterReceiveCplt+0x32>
  {
    /* Enable STOP interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
2400e740:	2120      	movs	r1, #32
2400e742:	68f8      	ldr	r0, [r7, #12]
2400e744:	f000 fc92 	bl	2400f06c <I2C_Enable_IRQ>
    {
      /* Enable TC interrupts */
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
    }
  }
}
2400e748:	e02d      	b.n	2400e7a6 <I2C_DMAMasterReceiveCplt+0x8e>
    hi2c->pBuffPtr += hi2c->XferSize;
2400e74a:	68fb      	ldr	r3, [r7, #12]
2400e74c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e74e:	68fa      	ldr	r2, [r7, #12]
2400e750:	8d12      	ldrh	r2, [r2, #40]	; 0x28
2400e752:	441a      	add	r2, r3
2400e754:	68fb      	ldr	r3, [r7, #12]
2400e756:	625a      	str	r2, [r3, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
2400e758:	68fb      	ldr	r3, [r7, #12]
2400e75a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e75c:	b29b      	uxth	r3, r3
2400e75e:	2bff      	cmp	r3, #255	; 0xff
2400e760:	d903      	bls.n	2400e76a <I2C_DMAMasterReceiveCplt+0x52>
      hi2c->XferSize = MAX_NBYTE_SIZE;
2400e762:	68fb      	ldr	r3, [r7, #12]
2400e764:	22ff      	movs	r2, #255	; 0xff
2400e766:	851a      	strh	r2, [r3, #40]	; 0x28
2400e768:	e004      	b.n	2400e774 <I2C_DMAMasterReceiveCplt+0x5c>
      hi2c->XferSize = hi2c->XferCount;
2400e76a:	68fb      	ldr	r3, [r7, #12]
2400e76c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
2400e76e:	b29a      	uxth	r2, r3
2400e770:	68fb      	ldr	r3, [r7, #12]
2400e772:	851a      	strh	r2, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr,
2400e774:	68fb      	ldr	r3, [r7, #12]
2400e776:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2400e778:	68fb      	ldr	r3, [r7, #12]
2400e77a:	681b      	ldr	r3, [r3, #0]
2400e77c:	3324      	adds	r3, #36	; 0x24
2400e77e:	4619      	mov	r1, r3
2400e780:	68fb      	ldr	r3, [r7, #12]
2400e782:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400e784:	461a      	mov	r2, r3
                         hi2c->XferSize) != HAL_OK)
2400e786:	68fb      	ldr	r3, [r7, #12]
2400e788:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    if (HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr,
2400e78a:	f7f5 fb75 	bl	24003e78 <HAL_DMA_Start_IT>
2400e78e:	4603      	mov	r3, r0
2400e790:	2b00      	cmp	r3, #0
2400e792:	d004      	beq.n	2400e79e <I2C_DMAMasterReceiveCplt+0x86>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400e794:	2110      	movs	r1, #16
2400e796:	68f8      	ldr	r0, [r7, #12]
2400e798:	f7ff fe38 	bl	2400e40c <I2C_ITError>
}
2400e79c:	e003      	b.n	2400e7a6 <I2C_DMAMasterReceiveCplt+0x8e>
      I2C_Enable_IRQ(hi2c, I2C_XFER_RELOAD_IT);
2400e79e:	2140      	movs	r1, #64	; 0x40
2400e7a0:	68f8      	ldr	r0, [r7, #12]
2400e7a2:	f000 fc63 	bl	2400f06c <I2C_Enable_IRQ>
}
2400e7a6:	bf00      	nop
2400e7a8:	3710      	adds	r7, #16
2400e7aa:	46bd      	mov	sp, r7
2400e7ac:	bd80      	pop	{r7, pc}
	...

2400e7b0 <I2C_DMASlaveReceiveCplt>:
  * @brief  DMA I2C slave receive process complete callback.
  * @param  hdma DMA handle
  * @retval None
  */
static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma)
{
2400e7b0:	b580      	push	{r7, lr}
2400e7b2:	b084      	sub	sp, #16
2400e7b4:	af00      	add	r7, sp, #0
2400e7b6:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400e7b8:	687b      	ldr	r3, [r7, #4]
2400e7ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e7bc:	60fb      	str	r3, [r7, #12]
  uint32_t tmpoptions = hi2c->XferOptions;
2400e7be:	68fb      	ldr	r3, [r7, #12]
2400e7c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400e7c2:	60bb      	str	r3, [r7, #8]

  if ((I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U) && \
2400e7c4:	68fb      	ldr	r3, [r7, #12]
2400e7c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e7c8:	681b      	ldr	r3, [r3, #0]
2400e7ca:	4a42      	ldr	r2, [pc, #264]	; (2400e8d4 <I2C_DMASlaveReceiveCplt+0x124>)
2400e7cc:	4293      	cmp	r3, r2
2400e7ce:	d059      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e7d0:	68fb      	ldr	r3, [r7, #12]
2400e7d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e7d4:	681b      	ldr	r3, [r3, #0]
2400e7d6:	4a40      	ldr	r2, [pc, #256]	; (2400e8d8 <I2C_DMASlaveReceiveCplt+0x128>)
2400e7d8:	4293      	cmp	r3, r2
2400e7da:	d053      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e7dc:	68fb      	ldr	r3, [r7, #12]
2400e7de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e7e0:	681b      	ldr	r3, [r3, #0]
2400e7e2:	4a3e      	ldr	r2, [pc, #248]	; (2400e8dc <I2C_DMASlaveReceiveCplt+0x12c>)
2400e7e4:	4293      	cmp	r3, r2
2400e7e6:	d04d      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e7e8:	68fb      	ldr	r3, [r7, #12]
2400e7ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e7ec:	681b      	ldr	r3, [r3, #0]
2400e7ee:	4a3c      	ldr	r2, [pc, #240]	; (2400e8e0 <I2C_DMASlaveReceiveCplt+0x130>)
2400e7f0:	4293      	cmp	r3, r2
2400e7f2:	d047      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e7f4:	68fb      	ldr	r3, [r7, #12]
2400e7f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e7f8:	681b      	ldr	r3, [r3, #0]
2400e7fa:	4a3a      	ldr	r2, [pc, #232]	; (2400e8e4 <I2C_DMASlaveReceiveCplt+0x134>)
2400e7fc:	4293      	cmp	r3, r2
2400e7fe:	d041      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e800:	68fb      	ldr	r3, [r7, #12]
2400e802:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e804:	681b      	ldr	r3, [r3, #0]
2400e806:	4a38      	ldr	r2, [pc, #224]	; (2400e8e8 <I2C_DMASlaveReceiveCplt+0x138>)
2400e808:	4293      	cmp	r3, r2
2400e80a:	d03b      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e80c:	68fb      	ldr	r3, [r7, #12]
2400e80e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e810:	681b      	ldr	r3, [r3, #0]
2400e812:	4a36      	ldr	r2, [pc, #216]	; (2400e8ec <I2C_DMASlaveReceiveCplt+0x13c>)
2400e814:	4293      	cmp	r3, r2
2400e816:	d035      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e818:	68fb      	ldr	r3, [r7, #12]
2400e81a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e81c:	681b      	ldr	r3, [r3, #0]
2400e81e:	4a34      	ldr	r2, [pc, #208]	; (2400e8f0 <I2C_DMASlaveReceiveCplt+0x140>)
2400e820:	4293      	cmp	r3, r2
2400e822:	d02f      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e824:	68fb      	ldr	r3, [r7, #12]
2400e826:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e828:	681b      	ldr	r3, [r3, #0]
2400e82a:	4a32      	ldr	r2, [pc, #200]	; (2400e8f4 <I2C_DMASlaveReceiveCplt+0x144>)
2400e82c:	4293      	cmp	r3, r2
2400e82e:	d029      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e830:	68fb      	ldr	r3, [r7, #12]
2400e832:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e834:	681b      	ldr	r3, [r3, #0]
2400e836:	4a30      	ldr	r2, [pc, #192]	; (2400e8f8 <I2C_DMASlaveReceiveCplt+0x148>)
2400e838:	4293      	cmp	r3, r2
2400e83a:	d023      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e83c:	68fb      	ldr	r3, [r7, #12]
2400e83e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e840:	681b      	ldr	r3, [r3, #0]
2400e842:	4a2e      	ldr	r2, [pc, #184]	; (2400e8fc <I2C_DMASlaveReceiveCplt+0x14c>)
2400e844:	4293      	cmp	r3, r2
2400e846:	d01d      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e848:	68fb      	ldr	r3, [r7, #12]
2400e84a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e84c:	681b      	ldr	r3, [r3, #0]
2400e84e:	4a2c      	ldr	r2, [pc, #176]	; (2400e900 <I2C_DMASlaveReceiveCplt+0x150>)
2400e850:	4293      	cmp	r3, r2
2400e852:	d017      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e854:	68fb      	ldr	r3, [r7, #12]
2400e856:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e858:	681b      	ldr	r3, [r3, #0]
2400e85a:	4a2a      	ldr	r2, [pc, #168]	; (2400e904 <I2C_DMASlaveReceiveCplt+0x154>)
2400e85c:	4293      	cmp	r3, r2
2400e85e:	d011      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e860:	68fb      	ldr	r3, [r7, #12]
2400e862:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e864:	681b      	ldr	r3, [r3, #0]
2400e866:	4a28      	ldr	r2, [pc, #160]	; (2400e908 <I2C_DMASlaveReceiveCplt+0x158>)
2400e868:	4293      	cmp	r3, r2
2400e86a:	d00b      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e86c:	68fb      	ldr	r3, [r7, #12]
2400e86e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e870:	681b      	ldr	r3, [r3, #0]
2400e872:	4a26      	ldr	r2, [pc, #152]	; (2400e90c <I2C_DMASlaveReceiveCplt+0x15c>)
2400e874:	4293      	cmp	r3, r2
2400e876:	d005      	beq.n	2400e884 <I2C_DMASlaveReceiveCplt+0xd4>
2400e878:	68fb      	ldr	r3, [r7, #12]
2400e87a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e87c:	681b      	ldr	r3, [r3, #0]
2400e87e:	4a24      	ldr	r2, [pc, #144]	; (2400e910 <I2C_DMASlaveReceiveCplt+0x160>)
2400e880:	4293      	cmp	r3, r2
2400e882:	d109      	bne.n	2400e898 <I2C_DMASlaveReceiveCplt+0xe8>
2400e884:	68fb      	ldr	r3, [r7, #12]
2400e886:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e888:	681b      	ldr	r3, [r3, #0]
2400e88a:	685b      	ldr	r3, [r3, #4]
2400e88c:	2b00      	cmp	r3, #0
2400e88e:	bf0c      	ite	eq
2400e890:	2301      	moveq	r3, #1
2400e892:	2300      	movne	r3, #0
2400e894:	b2db      	uxtb	r3, r3
2400e896:	e008      	b.n	2400e8aa <I2C_DMASlaveReceiveCplt+0xfa>
2400e898:	68fb      	ldr	r3, [r7, #12]
2400e89a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400e89c:	681b      	ldr	r3, [r3, #0]
2400e89e:	685b      	ldr	r3, [r3, #4]
2400e8a0:	2b00      	cmp	r3, #0
2400e8a2:	bf0c      	ite	eq
2400e8a4:	2301      	moveq	r3, #1
2400e8a6:	2300      	movne	r3, #0
2400e8a8:	b2db      	uxtb	r3, r3
2400e8aa:	2b00      	cmp	r3, #0
2400e8ac:	d00e      	beq.n	2400e8cc <I2C_DMASlaveReceiveCplt+0x11c>
2400e8ae:	68bb      	ldr	r3, [r7, #8]
2400e8b0:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
2400e8b4:	d00a      	beq.n	2400e8cc <I2C_DMASlaveReceiveCplt+0x11c>
      (tmpoptions != I2C_NO_OPTION_FRAME))
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
2400e8b6:	68fb      	ldr	r3, [r7, #12]
2400e8b8:	681b      	ldr	r3, [r3, #0]
2400e8ba:	681a      	ldr	r2, [r3, #0]
2400e8bc:	68fb      	ldr	r3, [r7, #12]
2400e8be:	681b      	ldr	r3, [r3, #0]
2400e8c0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
2400e8c4:	601a      	str	r2, [r3, #0]

    /* Call I2C Slave Sequential complete process */
    I2C_ITSlaveSeqCplt(hi2c);
2400e8c6:	68f8      	ldr	r0, [r7, #12]
2400e8c8:	f7ff fa31 	bl	2400dd2e <I2C_ITSlaveSeqCplt>
  {
    /* No specific action, Master fully manage the generation of STOP condition */
    /* Mean that this generation can arrive at any time, at the end or during DMA process */
    /* So STOP condition should be manage through Interrupt treatment */
  }
}
2400e8cc:	bf00      	nop
2400e8ce:	3710      	adds	r7, #16
2400e8d0:	46bd      	mov	sp, r7
2400e8d2:	bd80      	pop	{r7, pc}
2400e8d4:	40020010 	.word	0x40020010
2400e8d8:	40020028 	.word	0x40020028
2400e8dc:	40020040 	.word	0x40020040
2400e8e0:	40020058 	.word	0x40020058
2400e8e4:	40020070 	.word	0x40020070
2400e8e8:	40020088 	.word	0x40020088
2400e8ec:	400200a0 	.word	0x400200a0
2400e8f0:	400200b8 	.word	0x400200b8
2400e8f4:	40020410 	.word	0x40020410
2400e8f8:	40020428 	.word	0x40020428
2400e8fc:	40020440 	.word	0x40020440
2400e900:	40020458 	.word	0x40020458
2400e904:	40020470 	.word	0x40020470
2400e908:	40020488 	.word	0x40020488
2400e90c:	400204a0 	.word	0x400204a0
2400e910:	400204b8 	.word	0x400204b8

2400e914 <I2C_DMAError>:
  * @brief  DMA I2C communication error callback.
  * @param hdma DMA handle
  * @retval None
  */
static void I2C_DMAError(DMA_HandleTypeDef *hdma)
{
2400e914:	b580      	push	{r7, lr}
2400e916:	b084      	sub	sp, #16
2400e918:	af00      	add	r7, sp, #0
2400e91a:	6078      	str	r0, [r7, #4]
  uint32_t treatdmaerror = 0U;
2400e91c:	2300      	movs	r3, #0
2400e91e:	60fb      	str	r3, [r7, #12]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400e920:	687b      	ldr	r3, [r7, #4]
2400e922:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e924:	60bb      	str	r3, [r7, #8]

  if (hi2c->hdmatx != NULL)
2400e926:	68bb      	ldr	r3, [r7, #8]
2400e928:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e92a:	2b00      	cmp	r3, #0
2400e92c:	d076      	beq.n	2400ea1c <I2C_DMAError+0x108>
  {
    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)
2400e92e:	68bb      	ldr	r3, [r7, #8]
2400e930:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e932:	681b      	ldr	r3, [r3, #0]
2400e934:	4a71      	ldr	r2, [pc, #452]	; (2400eafc <I2C_DMAError+0x1e8>)
2400e936:	4293      	cmp	r3, r2
2400e938:	d059      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e93a:	68bb      	ldr	r3, [r7, #8]
2400e93c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e93e:	681b      	ldr	r3, [r3, #0]
2400e940:	4a6f      	ldr	r2, [pc, #444]	; (2400eb00 <I2C_DMAError+0x1ec>)
2400e942:	4293      	cmp	r3, r2
2400e944:	d053      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e946:	68bb      	ldr	r3, [r7, #8]
2400e948:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e94a:	681b      	ldr	r3, [r3, #0]
2400e94c:	4a6d      	ldr	r2, [pc, #436]	; (2400eb04 <I2C_DMAError+0x1f0>)
2400e94e:	4293      	cmp	r3, r2
2400e950:	d04d      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e952:	68bb      	ldr	r3, [r7, #8]
2400e954:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e956:	681b      	ldr	r3, [r3, #0]
2400e958:	4a6b      	ldr	r2, [pc, #428]	; (2400eb08 <I2C_DMAError+0x1f4>)
2400e95a:	4293      	cmp	r3, r2
2400e95c:	d047      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e95e:	68bb      	ldr	r3, [r7, #8]
2400e960:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e962:	681b      	ldr	r3, [r3, #0]
2400e964:	4a69      	ldr	r2, [pc, #420]	; (2400eb0c <I2C_DMAError+0x1f8>)
2400e966:	4293      	cmp	r3, r2
2400e968:	d041      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e96a:	68bb      	ldr	r3, [r7, #8]
2400e96c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e96e:	681b      	ldr	r3, [r3, #0]
2400e970:	4a67      	ldr	r2, [pc, #412]	; (2400eb10 <I2C_DMAError+0x1fc>)
2400e972:	4293      	cmp	r3, r2
2400e974:	d03b      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e976:	68bb      	ldr	r3, [r7, #8]
2400e978:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e97a:	681b      	ldr	r3, [r3, #0]
2400e97c:	4a65      	ldr	r2, [pc, #404]	; (2400eb14 <I2C_DMAError+0x200>)
2400e97e:	4293      	cmp	r3, r2
2400e980:	d035      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e982:	68bb      	ldr	r3, [r7, #8]
2400e984:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e986:	681b      	ldr	r3, [r3, #0]
2400e988:	4a63      	ldr	r2, [pc, #396]	; (2400eb18 <I2C_DMAError+0x204>)
2400e98a:	4293      	cmp	r3, r2
2400e98c:	d02f      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e98e:	68bb      	ldr	r3, [r7, #8]
2400e990:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e992:	681b      	ldr	r3, [r3, #0]
2400e994:	4a61      	ldr	r2, [pc, #388]	; (2400eb1c <I2C_DMAError+0x208>)
2400e996:	4293      	cmp	r3, r2
2400e998:	d029      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e99a:	68bb      	ldr	r3, [r7, #8]
2400e99c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e99e:	681b      	ldr	r3, [r3, #0]
2400e9a0:	4a5f      	ldr	r2, [pc, #380]	; (2400eb20 <I2C_DMAError+0x20c>)
2400e9a2:	4293      	cmp	r3, r2
2400e9a4:	d023      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e9a6:	68bb      	ldr	r3, [r7, #8]
2400e9a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9aa:	681b      	ldr	r3, [r3, #0]
2400e9ac:	4a5d      	ldr	r2, [pc, #372]	; (2400eb24 <I2C_DMAError+0x210>)
2400e9ae:	4293      	cmp	r3, r2
2400e9b0:	d01d      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e9b2:	68bb      	ldr	r3, [r7, #8]
2400e9b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9b6:	681b      	ldr	r3, [r3, #0]
2400e9b8:	4a5b      	ldr	r2, [pc, #364]	; (2400eb28 <I2C_DMAError+0x214>)
2400e9ba:	4293      	cmp	r3, r2
2400e9bc:	d017      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e9be:	68bb      	ldr	r3, [r7, #8]
2400e9c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9c2:	681b      	ldr	r3, [r3, #0]
2400e9c4:	4a59      	ldr	r2, [pc, #356]	; (2400eb2c <I2C_DMAError+0x218>)
2400e9c6:	4293      	cmp	r3, r2
2400e9c8:	d011      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e9ca:	68bb      	ldr	r3, [r7, #8]
2400e9cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9ce:	681b      	ldr	r3, [r3, #0]
2400e9d0:	4a57      	ldr	r2, [pc, #348]	; (2400eb30 <I2C_DMAError+0x21c>)
2400e9d2:	4293      	cmp	r3, r2
2400e9d4:	d00b      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e9d6:	68bb      	ldr	r3, [r7, #8]
2400e9d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9da:	681b      	ldr	r3, [r3, #0]
2400e9dc:	4a55      	ldr	r2, [pc, #340]	; (2400eb34 <I2C_DMAError+0x220>)
2400e9de:	4293      	cmp	r3, r2
2400e9e0:	d005      	beq.n	2400e9ee <I2C_DMAError+0xda>
2400e9e2:	68bb      	ldr	r3, [r7, #8]
2400e9e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9e6:	681b      	ldr	r3, [r3, #0]
2400e9e8:	4a53      	ldr	r2, [pc, #332]	; (2400eb38 <I2C_DMAError+0x224>)
2400e9ea:	4293      	cmp	r3, r2
2400e9ec:	d109      	bne.n	2400ea02 <I2C_DMAError+0xee>
2400e9ee:	68bb      	ldr	r3, [r7, #8]
2400e9f0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400e9f2:	681b      	ldr	r3, [r3, #0]
2400e9f4:	685b      	ldr	r3, [r3, #4]
2400e9f6:	2b00      	cmp	r3, #0
2400e9f8:	bf0c      	ite	eq
2400e9fa:	2301      	moveq	r3, #1
2400e9fc:	2300      	movne	r3, #0
2400e9fe:	b2db      	uxtb	r3, r3
2400ea00:	e008      	b.n	2400ea14 <I2C_DMAError+0x100>
2400ea02:	68bb      	ldr	r3, [r7, #8]
2400ea04:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400ea06:	681b      	ldr	r3, [r3, #0]
2400ea08:	685b      	ldr	r3, [r3, #4]
2400ea0a:	2b00      	cmp	r3, #0
2400ea0c:	bf0c      	ite	eq
2400ea0e:	2301      	moveq	r3, #1
2400ea10:	2300      	movne	r3, #0
2400ea12:	b2db      	uxtb	r3, r3
2400ea14:	2b00      	cmp	r3, #0
2400ea16:	d001      	beq.n	2400ea1c <I2C_DMAError+0x108>
    {
      treatdmaerror = 1U;
2400ea18:	2301      	movs	r3, #1
2400ea1a:	60fb      	str	r3, [r7, #12]
    }
  }

  if (hi2c->hdmarx != NULL)
2400ea1c:	68bb      	ldr	r3, [r7, #8]
2400ea1e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea20:	2b00      	cmp	r3, #0
2400ea22:	f000 8098 	beq.w	2400eb56 <I2C_DMAError+0x242>
  {
    if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)
2400ea26:	68bb      	ldr	r3, [r7, #8]
2400ea28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea2a:	681b      	ldr	r3, [r3, #0]
2400ea2c:	4a33      	ldr	r2, [pc, #204]	; (2400eafc <I2C_DMAError+0x1e8>)
2400ea2e:	4293      	cmp	r3, r2
2400ea30:	d059      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea32:	68bb      	ldr	r3, [r7, #8]
2400ea34:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea36:	681b      	ldr	r3, [r3, #0]
2400ea38:	4a31      	ldr	r2, [pc, #196]	; (2400eb00 <I2C_DMAError+0x1ec>)
2400ea3a:	4293      	cmp	r3, r2
2400ea3c:	d053      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea3e:	68bb      	ldr	r3, [r7, #8]
2400ea40:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea42:	681b      	ldr	r3, [r3, #0]
2400ea44:	4a2f      	ldr	r2, [pc, #188]	; (2400eb04 <I2C_DMAError+0x1f0>)
2400ea46:	4293      	cmp	r3, r2
2400ea48:	d04d      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea4a:	68bb      	ldr	r3, [r7, #8]
2400ea4c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea4e:	681b      	ldr	r3, [r3, #0]
2400ea50:	4a2d      	ldr	r2, [pc, #180]	; (2400eb08 <I2C_DMAError+0x1f4>)
2400ea52:	4293      	cmp	r3, r2
2400ea54:	d047      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea56:	68bb      	ldr	r3, [r7, #8]
2400ea58:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea5a:	681b      	ldr	r3, [r3, #0]
2400ea5c:	4a2b      	ldr	r2, [pc, #172]	; (2400eb0c <I2C_DMAError+0x1f8>)
2400ea5e:	4293      	cmp	r3, r2
2400ea60:	d041      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea62:	68bb      	ldr	r3, [r7, #8]
2400ea64:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea66:	681b      	ldr	r3, [r3, #0]
2400ea68:	4a29      	ldr	r2, [pc, #164]	; (2400eb10 <I2C_DMAError+0x1fc>)
2400ea6a:	4293      	cmp	r3, r2
2400ea6c:	d03b      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea6e:	68bb      	ldr	r3, [r7, #8]
2400ea70:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea72:	681b      	ldr	r3, [r3, #0]
2400ea74:	4a27      	ldr	r2, [pc, #156]	; (2400eb14 <I2C_DMAError+0x200>)
2400ea76:	4293      	cmp	r3, r2
2400ea78:	d035      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea7a:	68bb      	ldr	r3, [r7, #8]
2400ea7c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea7e:	681b      	ldr	r3, [r3, #0]
2400ea80:	4a25      	ldr	r2, [pc, #148]	; (2400eb18 <I2C_DMAError+0x204>)
2400ea82:	4293      	cmp	r3, r2
2400ea84:	d02f      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea86:	68bb      	ldr	r3, [r7, #8]
2400ea88:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea8a:	681b      	ldr	r3, [r3, #0]
2400ea8c:	4a23      	ldr	r2, [pc, #140]	; (2400eb1c <I2C_DMAError+0x208>)
2400ea8e:	4293      	cmp	r3, r2
2400ea90:	d029      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea92:	68bb      	ldr	r3, [r7, #8]
2400ea94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ea96:	681b      	ldr	r3, [r3, #0]
2400ea98:	4a21      	ldr	r2, [pc, #132]	; (2400eb20 <I2C_DMAError+0x20c>)
2400ea9a:	4293      	cmp	r3, r2
2400ea9c:	d023      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400ea9e:	68bb      	ldr	r3, [r7, #8]
2400eaa0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eaa2:	681b      	ldr	r3, [r3, #0]
2400eaa4:	4a1f      	ldr	r2, [pc, #124]	; (2400eb24 <I2C_DMAError+0x210>)
2400eaa6:	4293      	cmp	r3, r2
2400eaa8:	d01d      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400eaaa:	68bb      	ldr	r3, [r7, #8]
2400eaac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eaae:	681b      	ldr	r3, [r3, #0]
2400eab0:	4a1d      	ldr	r2, [pc, #116]	; (2400eb28 <I2C_DMAError+0x214>)
2400eab2:	4293      	cmp	r3, r2
2400eab4:	d017      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400eab6:	68bb      	ldr	r3, [r7, #8]
2400eab8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eaba:	681b      	ldr	r3, [r3, #0]
2400eabc:	4a1b      	ldr	r2, [pc, #108]	; (2400eb2c <I2C_DMAError+0x218>)
2400eabe:	4293      	cmp	r3, r2
2400eac0:	d011      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400eac2:	68bb      	ldr	r3, [r7, #8]
2400eac4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eac6:	681b      	ldr	r3, [r3, #0]
2400eac8:	4a19      	ldr	r2, [pc, #100]	; (2400eb30 <I2C_DMAError+0x21c>)
2400eaca:	4293      	cmp	r3, r2
2400eacc:	d00b      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400eace:	68bb      	ldr	r3, [r7, #8]
2400ead0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ead2:	681b      	ldr	r3, [r3, #0]
2400ead4:	4a17      	ldr	r2, [pc, #92]	; (2400eb34 <I2C_DMAError+0x220>)
2400ead6:	4293      	cmp	r3, r2
2400ead8:	d005      	beq.n	2400eae6 <I2C_DMAError+0x1d2>
2400eada:	68bb      	ldr	r3, [r7, #8]
2400eadc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eade:	681b      	ldr	r3, [r3, #0]
2400eae0:	4a15      	ldr	r2, [pc, #84]	; (2400eb38 <I2C_DMAError+0x224>)
2400eae2:	4293      	cmp	r3, r2
2400eae4:	d12a      	bne.n	2400eb3c <I2C_DMAError+0x228>
2400eae6:	68bb      	ldr	r3, [r7, #8]
2400eae8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eaea:	681b      	ldr	r3, [r3, #0]
2400eaec:	685b      	ldr	r3, [r3, #4]
2400eaee:	2b00      	cmp	r3, #0
2400eaf0:	bf0c      	ite	eq
2400eaf2:	2301      	moveq	r3, #1
2400eaf4:	2300      	movne	r3, #0
2400eaf6:	b2db      	uxtb	r3, r3
2400eaf8:	e029      	b.n	2400eb4e <I2C_DMAError+0x23a>
2400eafa:	bf00      	nop
2400eafc:	40020010 	.word	0x40020010
2400eb00:	40020028 	.word	0x40020028
2400eb04:	40020040 	.word	0x40020040
2400eb08:	40020058 	.word	0x40020058
2400eb0c:	40020070 	.word	0x40020070
2400eb10:	40020088 	.word	0x40020088
2400eb14:	400200a0 	.word	0x400200a0
2400eb18:	400200b8 	.word	0x400200b8
2400eb1c:	40020410 	.word	0x40020410
2400eb20:	40020428 	.word	0x40020428
2400eb24:	40020440 	.word	0x40020440
2400eb28:	40020458 	.word	0x40020458
2400eb2c:	40020470 	.word	0x40020470
2400eb30:	40020488 	.word	0x40020488
2400eb34:	400204a0 	.word	0x400204a0
2400eb38:	400204b8 	.word	0x400204b8
2400eb3c:	68bb      	ldr	r3, [r7, #8]
2400eb3e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400eb40:	681b      	ldr	r3, [r3, #0]
2400eb42:	685b      	ldr	r3, [r3, #4]
2400eb44:	2b00      	cmp	r3, #0
2400eb46:	bf0c      	ite	eq
2400eb48:	2301      	moveq	r3, #1
2400eb4a:	2300      	movne	r3, #0
2400eb4c:	b2db      	uxtb	r3, r3
2400eb4e:	2b00      	cmp	r3, #0
2400eb50:	d001      	beq.n	2400eb56 <I2C_DMAError+0x242>
    {
      treatdmaerror = 1U;
2400eb52:	2301      	movs	r3, #1
2400eb54:	60fb      	str	r3, [r7, #12]
    }
  }

  /* Check if a FIFO error is detected, if true normal use case, so no specific action to perform */
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
2400eb56:	6878      	ldr	r0, [r7, #4]
2400eb58:	f7f7 fd06 	bl	24006568 <HAL_DMA_GetError>
2400eb5c:	4603      	mov	r3, r0
2400eb5e:	2b02      	cmp	r3, #2
2400eb60:	d00e      	beq.n	2400eb80 <I2C_DMAError+0x26c>
2400eb62:	68fb      	ldr	r3, [r7, #12]
2400eb64:	2b00      	cmp	r3, #0
2400eb66:	d00b      	beq.n	2400eb80 <I2C_DMAError+0x26c>
  {
    /* Disable Acknowledge */
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
2400eb68:	68bb      	ldr	r3, [r7, #8]
2400eb6a:	681b      	ldr	r3, [r3, #0]
2400eb6c:	685a      	ldr	r2, [r3, #4]
2400eb6e:	68bb      	ldr	r3, [r7, #8]
2400eb70:	681b      	ldr	r3, [r3, #0]
2400eb72:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
2400eb76:	605a      	str	r2, [r3, #4]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
2400eb78:	2110      	movs	r1, #16
2400eb7a:	68b8      	ldr	r0, [r7, #8]
2400eb7c:	f7ff fc46 	bl	2400e40c <I2C_ITError>
  }
}
2400eb80:	bf00      	nop
2400eb82:	3710      	adds	r7, #16
2400eb84:	46bd      	mov	sp, r7
2400eb86:	bd80      	pop	{r7, pc}

2400eb88 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
2400eb88:	b580      	push	{r7, lr}
2400eb8a:	b084      	sub	sp, #16
2400eb8c:	af00      	add	r7, sp, #0
2400eb8e:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
2400eb90:	687b      	ldr	r3, [r7, #4]
2400eb92:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400eb94:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
2400eb96:	68fb      	ldr	r3, [r7, #12]
2400eb98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400eb9a:	2b00      	cmp	r3, #0
2400eb9c:	d003      	beq.n	2400eba6 <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
2400eb9e:	68fb      	ldr	r3, [r7, #12]
2400eba0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400eba2:	2200      	movs	r2, #0
2400eba4:	651a      	str	r2, [r3, #80]	; 0x50
  }
  if (hi2c->hdmarx != NULL)
2400eba6:	68fb      	ldr	r3, [r7, #12]
2400eba8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ebaa:	2b00      	cmp	r3, #0
2400ebac:	d003      	beq.n	2400ebb6 <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
2400ebae:	68fb      	ldr	r3, [r7, #12]
2400ebb0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400ebb2:	2200      	movs	r2, #0
2400ebb4:	651a      	str	r2, [r3, #80]	; 0x50
  }

  I2C_TreatErrorCallback(hi2c);
2400ebb6:	68f8      	ldr	r0, [r7, #12]
2400ebb8:	f7ff fcf8 	bl	2400e5ac <I2C_TreatErrorCallback>
}
2400ebbc:	bf00      	nop
2400ebbe:	3710      	adds	r7, #16
2400ebc0:	46bd      	mov	sp, r7
2400ebc2:	bd80      	pop	{r7, pc}

2400ebc4 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
2400ebc4:	b580      	push	{r7, lr}
2400ebc6:	b084      	sub	sp, #16
2400ebc8:	af00      	add	r7, sp, #0
2400ebca:	60f8      	str	r0, [r7, #12]
2400ebcc:	60b9      	str	r1, [r7, #8]
2400ebce:	603b      	str	r3, [r7, #0]
2400ebd0:	4613      	mov	r3, r2
2400ebd2:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400ebd4:	e022      	b.n	2400ec1c <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400ebd6:	683b      	ldr	r3, [r7, #0]
2400ebd8:	f1b3 3fff 	cmp.w	r3, #4294967295
2400ebdc:	d01e      	beq.n	2400ec1c <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400ebde:	f7f3 fbb1 	bl	24002344 <HAL_GetTick>
2400ebe2:	4602      	mov	r2, r0
2400ebe4:	69bb      	ldr	r3, [r7, #24]
2400ebe6:	1ad3      	subs	r3, r2, r3
2400ebe8:	683a      	ldr	r2, [r7, #0]
2400ebea:	429a      	cmp	r2, r3
2400ebec:	d302      	bcc.n	2400ebf4 <I2C_WaitOnFlagUntilTimeout+0x30>
2400ebee:	683b      	ldr	r3, [r7, #0]
2400ebf0:	2b00      	cmp	r3, #0
2400ebf2:	d113      	bne.n	2400ec1c <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ebf4:	68fb      	ldr	r3, [r7, #12]
2400ebf6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ebf8:	f043 0220 	orr.w	r2, r3, #32
2400ebfc:	68fb      	ldr	r3, [r7, #12]
2400ebfe:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400ec00:	68fb      	ldr	r3, [r7, #12]
2400ec02:	2220      	movs	r2, #32
2400ec04:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400ec08:	68fb      	ldr	r3, [r7, #12]
2400ec0a:	2200      	movs	r2, #0
2400ec0c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400ec10:	68fb      	ldr	r3, [r7, #12]
2400ec12:	2200      	movs	r2, #0
2400ec14:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
2400ec18:	2301      	movs	r3, #1
2400ec1a:	e00f      	b.n	2400ec3c <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
2400ec1c:	68fb      	ldr	r3, [r7, #12]
2400ec1e:	681b      	ldr	r3, [r3, #0]
2400ec20:	699a      	ldr	r2, [r3, #24]
2400ec22:	68bb      	ldr	r3, [r7, #8]
2400ec24:	4013      	ands	r3, r2
2400ec26:	68ba      	ldr	r2, [r7, #8]
2400ec28:	429a      	cmp	r2, r3
2400ec2a:	bf0c      	ite	eq
2400ec2c:	2301      	moveq	r3, #1
2400ec2e:	2300      	movne	r3, #0
2400ec30:	b2db      	uxtb	r3, r3
2400ec32:	461a      	mov	r2, r3
2400ec34:	79fb      	ldrb	r3, [r7, #7]
2400ec36:	429a      	cmp	r2, r3
2400ec38:	d0cd      	beq.n	2400ebd6 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
2400ec3a:	2300      	movs	r3, #0
}
2400ec3c:	4618      	mov	r0, r3
2400ec3e:	3710      	adds	r7, #16
2400ec40:	46bd      	mov	sp, r7
2400ec42:	bd80      	pop	{r7, pc}

2400ec44 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
2400ec44:	b580      	push	{r7, lr}
2400ec46:	b084      	sub	sp, #16
2400ec48:	af00      	add	r7, sp, #0
2400ec4a:	60f8      	str	r0, [r7, #12]
2400ec4c:	60b9      	str	r1, [r7, #8]
2400ec4e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400ec50:	e02c      	b.n	2400ecac <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2400ec52:	687a      	ldr	r2, [r7, #4]
2400ec54:	68b9      	ldr	r1, [r7, #8]
2400ec56:	68f8      	ldr	r0, [r7, #12]
2400ec58:	f000 f8ea 	bl	2400ee30 <I2C_IsErrorOccurred>
2400ec5c:	4603      	mov	r3, r0
2400ec5e:	2b00      	cmp	r3, #0
2400ec60:	d001      	beq.n	2400ec66 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400ec62:	2301      	movs	r3, #1
2400ec64:	e02a      	b.n	2400ecbc <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
2400ec66:	68bb      	ldr	r3, [r7, #8]
2400ec68:	f1b3 3fff 	cmp.w	r3, #4294967295
2400ec6c:	d01e      	beq.n	2400ecac <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400ec6e:	f7f3 fb69 	bl	24002344 <HAL_GetTick>
2400ec72:	4602      	mov	r2, r0
2400ec74:	687b      	ldr	r3, [r7, #4]
2400ec76:	1ad3      	subs	r3, r2, r3
2400ec78:	68ba      	ldr	r2, [r7, #8]
2400ec7a:	429a      	cmp	r2, r3
2400ec7c:	d302      	bcc.n	2400ec84 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
2400ec7e:	68bb      	ldr	r3, [r7, #8]
2400ec80:	2b00      	cmp	r3, #0
2400ec82:	d113      	bne.n	2400ecac <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ec84:	68fb      	ldr	r3, [r7, #12]
2400ec86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ec88:	f043 0220 	orr.w	r2, r3, #32
2400ec8c:	68fb      	ldr	r3, [r7, #12]
2400ec8e:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
2400ec90:	68fb      	ldr	r3, [r7, #12]
2400ec92:	2220      	movs	r2, #32
2400ec94:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400ec98:	68fb      	ldr	r3, [r7, #12]
2400ec9a:	2200      	movs	r2, #0
2400ec9c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400eca0:	68fb      	ldr	r3, [r7, #12]
2400eca2:	2200      	movs	r2, #0
2400eca4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400eca8:	2301      	movs	r3, #1
2400ecaa:	e007      	b.n	2400ecbc <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
2400ecac:	68fb      	ldr	r3, [r7, #12]
2400ecae:	681b      	ldr	r3, [r3, #0]
2400ecb0:	699b      	ldr	r3, [r3, #24]
2400ecb2:	f003 0302 	and.w	r3, r3, #2
2400ecb6:	2b02      	cmp	r3, #2
2400ecb8:	d1cb      	bne.n	2400ec52 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
2400ecba:	2300      	movs	r3, #0
}
2400ecbc:	4618      	mov	r0, r3
2400ecbe:	3710      	adds	r7, #16
2400ecc0:	46bd      	mov	sp, r7
2400ecc2:	bd80      	pop	{r7, pc}

2400ecc4 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
2400ecc4:	b580      	push	{r7, lr}
2400ecc6:	b084      	sub	sp, #16
2400ecc8:	af00      	add	r7, sp, #0
2400ecca:	60f8      	str	r0, [r7, #12]
2400eccc:	60b9      	str	r1, [r7, #8]
2400ecce:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400ecd0:	e028      	b.n	2400ed24 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2400ecd2:	687a      	ldr	r2, [r7, #4]
2400ecd4:	68b9      	ldr	r1, [r7, #8]
2400ecd6:	68f8      	ldr	r0, [r7, #12]
2400ecd8:	f000 f8aa 	bl	2400ee30 <I2C_IsErrorOccurred>
2400ecdc:	4603      	mov	r3, r0
2400ecde:	2b00      	cmp	r3, #0
2400ece0:	d001      	beq.n	2400ece6 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400ece2:	2301      	movs	r3, #1
2400ece4:	e026      	b.n	2400ed34 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400ece6:	f7f3 fb2d 	bl	24002344 <HAL_GetTick>
2400ecea:	4602      	mov	r2, r0
2400ecec:	687b      	ldr	r3, [r7, #4]
2400ecee:	1ad3      	subs	r3, r2, r3
2400ecf0:	68ba      	ldr	r2, [r7, #8]
2400ecf2:	429a      	cmp	r2, r3
2400ecf4:	d302      	bcc.n	2400ecfc <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
2400ecf6:	68bb      	ldr	r3, [r7, #8]
2400ecf8:	2b00      	cmp	r3, #0
2400ecfa:	d113      	bne.n	2400ed24 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400ecfc:	68fb      	ldr	r3, [r7, #12]
2400ecfe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400ed00:	f043 0220 	orr.w	r2, r3, #32
2400ed04:	68fb      	ldr	r3, [r7, #12]
2400ed06:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2400ed08:	68fb      	ldr	r3, [r7, #12]
2400ed0a:	2220      	movs	r2, #32
2400ed0c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
2400ed10:	68fb      	ldr	r3, [r7, #12]
2400ed12:	2200      	movs	r2, #0
2400ed14:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ed18:	68fb      	ldr	r3, [r7, #12]
2400ed1a:	2200      	movs	r2, #0
2400ed1c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2400ed20:	2301      	movs	r3, #1
2400ed22:	e007      	b.n	2400ed34 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400ed24:	68fb      	ldr	r3, [r7, #12]
2400ed26:	681b      	ldr	r3, [r3, #0]
2400ed28:	699b      	ldr	r3, [r3, #24]
2400ed2a:	f003 0320 	and.w	r3, r3, #32
2400ed2e:	2b20      	cmp	r3, #32
2400ed30:	d1cf      	bne.n	2400ecd2 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2400ed32:	2300      	movs	r3, #0
}
2400ed34:	4618      	mov	r0, r3
2400ed36:	3710      	adds	r7, #16
2400ed38:	46bd      	mov	sp, r7
2400ed3a:	bd80      	pop	{r7, pc}

2400ed3c <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
2400ed3c:	b580      	push	{r7, lr}
2400ed3e:	b084      	sub	sp, #16
2400ed40:	af00      	add	r7, sp, #0
2400ed42:	60f8      	str	r0, [r7, #12]
2400ed44:	60b9      	str	r1, [r7, #8]
2400ed46:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400ed48:	e064      	b.n	2400ee14 <I2C_WaitOnRXNEFlagUntilTimeout+0xd8>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
2400ed4a:	687a      	ldr	r2, [r7, #4]
2400ed4c:	68b9      	ldr	r1, [r7, #8]
2400ed4e:	68f8      	ldr	r0, [r7, #12]
2400ed50:	f000 f86e 	bl	2400ee30 <I2C_IsErrorOccurred>
2400ed54:	4603      	mov	r3, r0
2400ed56:	2b00      	cmp	r3, #0
2400ed58:	d001      	beq.n	2400ed5e <I2C_WaitOnRXNEFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
2400ed5a:	2301      	movs	r3, #1
2400ed5c:	e062      	b.n	2400ee24 <I2C_WaitOnRXNEFlagUntilTimeout+0xe8>
    }

    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
2400ed5e:	68fb      	ldr	r3, [r7, #12]
2400ed60:	681b      	ldr	r3, [r3, #0]
2400ed62:	699b      	ldr	r3, [r3, #24]
2400ed64:	f003 0320 	and.w	r3, r3, #32
2400ed68:	2b20      	cmp	r3, #32
2400ed6a:	d138      	bne.n	2400edde <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
    {
      /* Check if an RXNE is pending */
      /* Store Last receive data if any */
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
2400ed6c:	68fb      	ldr	r3, [r7, #12]
2400ed6e:	681b      	ldr	r3, [r3, #0]
2400ed70:	699b      	ldr	r3, [r3, #24]
2400ed72:	f003 0304 	and.w	r3, r3, #4
2400ed76:	2b04      	cmp	r3, #4
2400ed78:	d105      	bne.n	2400ed86 <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
2400ed7a:	68fb      	ldr	r3, [r7, #12]
2400ed7c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
2400ed7e:	2b00      	cmp	r3, #0
2400ed80:	d001      	beq.n	2400ed86 <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
      {
        /* Return HAL_OK */
        /* The Reading of data from RXDR will be done in caller function */
        return HAL_OK;
2400ed82:	2300      	movs	r3, #0
2400ed84:	e04e      	b.n	2400ee24 <I2C_WaitOnRXNEFlagUntilTimeout+0xe8>
      }
      else
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
2400ed86:	68fb      	ldr	r3, [r7, #12]
2400ed88:	681b      	ldr	r3, [r3, #0]
2400ed8a:	699b      	ldr	r3, [r3, #24]
2400ed8c:	f003 0310 	and.w	r3, r3, #16
2400ed90:	2b10      	cmp	r3, #16
2400ed92:	d107      	bne.n	2400eda4 <I2C_WaitOnRXNEFlagUntilTimeout+0x68>
        {
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400ed94:	68fb      	ldr	r3, [r7, #12]
2400ed96:	681b      	ldr	r3, [r3, #0]
2400ed98:	2210      	movs	r2, #16
2400ed9a:	61da      	str	r2, [r3, #28]
          hi2c->ErrorCode = HAL_I2C_ERROR_AF;
2400ed9c:	68fb      	ldr	r3, [r7, #12]
2400ed9e:	2204      	movs	r2, #4
2400eda0:	645a      	str	r2, [r3, #68]	; 0x44
2400eda2:	e002      	b.n	2400edaa <I2C_WaitOnRXNEFlagUntilTimeout+0x6e>
        }
        else
        {
          hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
2400eda4:	68fb      	ldr	r3, [r7, #12]
2400eda6:	2200      	movs	r2, #0
2400eda8:	645a      	str	r2, [r3, #68]	; 0x44
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400edaa:	68fb      	ldr	r3, [r7, #12]
2400edac:	681b      	ldr	r3, [r3, #0]
2400edae:	2220      	movs	r2, #32
2400edb0:	61da      	str	r2, [r3, #28]

        /* Clear Configuration Register 2 */
        I2C_RESET_CR2(hi2c);
2400edb2:	68fb      	ldr	r3, [r7, #12]
2400edb4:	681b      	ldr	r3, [r3, #0]
2400edb6:	6859      	ldr	r1, [r3, #4]
2400edb8:	68fb      	ldr	r3, [r7, #12]
2400edba:	681a      	ldr	r2, [r3, #0]
2400edbc:	4b1b      	ldr	r3, [pc, #108]	; (2400ee2c <I2C_WaitOnRXNEFlagUntilTimeout+0xf0>)
2400edbe:	400b      	ands	r3, r1
2400edc0:	6053      	str	r3, [r2, #4]

        hi2c->State = HAL_I2C_STATE_READY;
2400edc2:	68fb      	ldr	r3, [r7, #12]
2400edc4:	2220      	movs	r2, #32
2400edc6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
2400edca:	68fb      	ldr	r3, [r7, #12]
2400edcc:	2200      	movs	r2, #0
2400edce:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
2400edd2:	68fb      	ldr	r3, [r7, #12]
2400edd4:	2200      	movs	r2, #0
2400edd6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
2400edda:	2301      	movs	r3, #1
2400eddc:	e022      	b.n	2400ee24 <I2C_WaitOnRXNEFlagUntilTimeout+0xe8>
      }
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
2400edde:	f7f3 fab1 	bl	24002344 <HAL_GetTick>
2400ede2:	4602      	mov	r2, r0
2400ede4:	687b      	ldr	r3, [r7, #4]
2400ede6:	1ad3      	subs	r3, r2, r3
2400ede8:	68ba      	ldr	r2, [r7, #8]
2400edea:	429a      	cmp	r2, r3
2400edec:	d302      	bcc.n	2400edf4 <I2C_WaitOnRXNEFlagUntilTimeout+0xb8>
2400edee:	68bb      	ldr	r3, [r7, #8]
2400edf0:	2b00      	cmp	r3, #0
2400edf2:	d10f      	bne.n	2400ee14 <I2C_WaitOnRXNEFlagUntilTimeout+0xd8>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400edf4:	68fb      	ldr	r3, [r7, #12]
2400edf6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400edf8:	f043 0220 	orr.w	r2, r3, #32
2400edfc:	68fb      	ldr	r3, [r7, #12]
2400edfe:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
2400ee00:	68fb      	ldr	r3, [r7, #12]
2400ee02:	2220      	movs	r2, #32
2400ee04:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
2400ee08:	68fb      	ldr	r3, [r7, #12]
2400ee0a:	2200      	movs	r2, #0
2400ee0c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
2400ee10:	2301      	movs	r3, #1
2400ee12:	e007      	b.n	2400ee24 <I2C_WaitOnRXNEFlagUntilTimeout+0xe8>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
2400ee14:	68fb      	ldr	r3, [r7, #12]
2400ee16:	681b      	ldr	r3, [r3, #0]
2400ee18:	699b      	ldr	r3, [r3, #24]
2400ee1a:	f003 0304 	and.w	r3, r3, #4
2400ee1e:	2b04      	cmp	r3, #4
2400ee20:	d193      	bne.n	2400ed4a <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
2400ee22:	2300      	movs	r3, #0
}
2400ee24:	4618      	mov	r0, r3
2400ee26:	3710      	adds	r7, #16
2400ee28:	46bd      	mov	sp, r7
2400ee2a:	bd80      	pop	{r7, pc}
2400ee2c:	fe00e800 	.word	0xfe00e800

2400ee30 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
2400ee30:	b580      	push	{r7, lr}
2400ee32:	b08a      	sub	sp, #40	; 0x28
2400ee34:	af00      	add	r7, sp, #0
2400ee36:	60f8      	str	r0, [r7, #12]
2400ee38:	60b9      	str	r1, [r7, #8]
2400ee3a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2400ee3c:	2300      	movs	r3, #0
2400ee3e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
2400ee42:	68fb      	ldr	r3, [r7, #12]
2400ee44:	681b      	ldr	r3, [r3, #0]
2400ee46:	699b      	ldr	r3, [r3, #24]
2400ee48:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
2400ee4a:	2300      	movs	r3, #0
2400ee4c:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
2400ee4e:	687b      	ldr	r3, [r7, #4]
2400ee50:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
2400ee52:	69bb      	ldr	r3, [r7, #24]
2400ee54:	f003 0310 	and.w	r3, r3, #16
2400ee58:	2b00      	cmp	r3, #0
2400ee5a:	d075      	beq.n	2400ef48 <I2C_IsErrorOccurred+0x118>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
2400ee5c:	68fb      	ldr	r3, [r7, #12]
2400ee5e:	681b      	ldr	r3, [r3, #0]
2400ee60:	2210      	movs	r2, #16
2400ee62:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
2400ee64:	e056      	b.n	2400ef14 <I2C_IsErrorOccurred+0xe4>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
2400ee66:	68bb      	ldr	r3, [r7, #8]
2400ee68:	f1b3 3fff 	cmp.w	r3, #4294967295
2400ee6c:	d052      	beq.n	2400ef14 <I2C_IsErrorOccurred+0xe4>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
2400ee6e:	f7f3 fa69 	bl	24002344 <HAL_GetTick>
2400ee72:	4602      	mov	r2, r0
2400ee74:	69fb      	ldr	r3, [r7, #28]
2400ee76:	1ad3      	subs	r3, r2, r3
2400ee78:	68ba      	ldr	r2, [r7, #8]
2400ee7a:	429a      	cmp	r2, r3
2400ee7c:	d302      	bcc.n	2400ee84 <I2C_IsErrorOccurred+0x54>
2400ee7e:	68bb      	ldr	r3, [r7, #8]
2400ee80:	2b00      	cmp	r3, #0
2400ee82:	d147      	bne.n	2400ef14 <I2C_IsErrorOccurred+0xe4>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
2400ee84:	68fb      	ldr	r3, [r7, #12]
2400ee86:	681b      	ldr	r3, [r3, #0]
2400ee88:	685b      	ldr	r3, [r3, #4]
2400ee8a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
2400ee8e:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
2400ee90:	68fb      	ldr	r3, [r7, #12]
2400ee92:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
2400ee96:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
2400ee98:	68fb      	ldr	r3, [r7, #12]
2400ee9a:	681b      	ldr	r3, [r3, #0]
2400ee9c:	699b      	ldr	r3, [r3, #24]
2400ee9e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2400eea2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
2400eea6:	d12e      	bne.n	2400ef06 <I2C_IsErrorOccurred+0xd6>
2400eea8:	697b      	ldr	r3, [r7, #20]
2400eeaa:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2400eeae:	d02a      	beq.n	2400ef06 <I2C_IsErrorOccurred+0xd6>
              (tmp1 != I2C_CR2_STOP) && \
2400eeb0:	7cfb      	ldrb	r3, [r7, #19]
2400eeb2:	2b20      	cmp	r3, #32
2400eeb4:	d027      	beq.n	2400ef06 <I2C_IsErrorOccurred+0xd6>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
2400eeb6:	68fb      	ldr	r3, [r7, #12]
2400eeb8:	681b      	ldr	r3, [r3, #0]
2400eeba:	685a      	ldr	r2, [r3, #4]
2400eebc:	68fb      	ldr	r3, [r7, #12]
2400eebe:	681b      	ldr	r3, [r3, #0]
2400eec0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
2400eec4:	605a      	str	r2, [r3, #4]
            
            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
2400eec6:	f7f3 fa3d 	bl	24002344 <HAL_GetTick>
2400eeca:	61f8      	str	r0, [r7, #28]
          }
          
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400eecc:	e01b      	b.n	2400ef06 <I2C_IsErrorOccurred+0xd6>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
2400eece:	f7f3 fa39 	bl	24002344 <HAL_GetTick>
2400eed2:	4602      	mov	r2, r0
2400eed4:	69fb      	ldr	r3, [r7, #28]
2400eed6:	1ad3      	subs	r3, r2, r3
2400eed8:	2b19      	cmp	r3, #25
2400eeda:	d914      	bls.n	2400ef06 <I2C_IsErrorOccurred+0xd6>
            {
              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
2400eedc:	68fb      	ldr	r3, [r7, #12]
2400eede:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400eee0:	f043 0220 	orr.w	r2, r3, #32
2400eee4:	68fb      	ldr	r3, [r7, #12]
2400eee6:	645a      	str	r2, [r3, #68]	; 0x44
              hi2c->State = HAL_I2C_STATE_READY;
2400eee8:	68fb      	ldr	r3, [r7, #12]
2400eeea:	2220      	movs	r2, #32
2400eeec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
              hi2c->Mode = HAL_I2C_MODE_NONE;
2400eef0:	68fb      	ldr	r3, [r7, #12]
2400eef2:	2200      	movs	r2, #0
2400eef4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
              
              /* Process Unlocked */
              __HAL_UNLOCK(hi2c);
2400eef8:	68fb      	ldr	r3, [r7, #12]
2400eefa:	2200      	movs	r2, #0
2400eefc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              
              status = HAL_ERROR;
2400ef00:	2301      	movs	r3, #1
2400ef02:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
2400ef06:	68fb      	ldr	r3, [r7, #12]
2400ef08:	681b      	ldr	r3, [r3, #0]
2400ef0a:	699b      	ldr	r3, [r3, #24]
2400ef0c:	f003 0320 	and.w	r3, r3, #32
2400ef10:	2b20      	cmp	r3, #32
2400ef12:	d1dc      	bne.n	2400eece <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
2400ef14:	68fb      	ldr	r3, [r7, #12]
2400ef16:	681b      	ldr	r3, [r3, #0]
2400ef18:	699b      	ldr	r3, [r3, #24]
2400ef1a:	f003 0320 	and.w	r3, r3, #32
2400ef1e:	2b20      	cmp	r3, #32
2400ef20:	d003      	beq.n	2400ef2a <I2C_IsErrorOccurred+0xfa>
2400ef22:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
2400ef26:	2b00      	cmp	r3, #0
2400ef28:	d09d      	beq.n	2400ee66 <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
2400ef2a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
2400ef2e:	2b00      	cmp	r3, #0
2400ef30:	d103      	bne.n	2400ef3a <I2C_IsErrorOccurred+0x10a>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
2400ef32:	68fb      	ldr	r3, [r7, #12]
2400ef34:	681b      	ldr	r3, [r3, #0]
2400ef36:	2220      	movs	r2, #32
2400ef38:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
2400ef3a:	6a3b      	ldr	r3, [r7, #32]
2400ef3c:	f043 0304 	orr.w	r3, r3, #4
2400ef40:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
2400ef42:	2301      	movs	r3, #1
2400ef44:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
2400ef48:	68fb      	ldr	r3, [r7, #12]
2400ef4a:	681b      	ldr	r3, [r3, #0]
2400ef4c:	699b      	ldr	r3, [r3, #24]
2400ef4e:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
2400ef50:	69bb      	ldr	r3, [r7, #24]
2400ef52:	f403 7380 	and.w	r3, r3, #256	; 0x100
2400ef56:	2b00      	cmp	r3, #0
2400ef58:	d00b      	beq.n	2400ef72 <I2C_IsErrorOccurred+0x142>
  {
    error_code |= HAL_I2C_ERROR_BERR;
2400ef5a:	6a3b      	ldr	r3, [r7, #32]
2400ef5c:	f043 0301 	orr.w	r3, r3, #1
2400ef60:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
2400ef62:	68fb      	ldr	r3, [r7, #12]
2400ef64:	681b      	ldr	r3, [r3, #0]
2400ef66:	f44f 7280 	mov.w	r2, #256	; 0x100
2400ef6a:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
2400ef6c:	2301      	movs	r3, #1
2400ef6e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
2400ef72:	69bb      	ldr	r3, [r7, #24]
2400ef74:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2400ef78:	2b00      	cmp	r3, #0
2400ef7a:	d00b      	beq.n	2400ef94 <I2C_IsErrorOccurred+0x164>
  {
    error_code |= HAL_I2C_ERROR_OVR;
2400ef7c:	6a3b      	ldr	r3, [r7, #32]
2400ef7e:	f043 0308 	orr.w	r3, r3, #8
2400ef82:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
2400ef84:	68fb      	ldr	r3, [r7, #12]
2400ef86:	681b      	ldr	r3, [r3, #0]
2400ef88:	f44f 6280 	mov.w	r2, #1024	; 0x400
2400ef8c:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
2400ef8e:	2301      	movs	r3, #1
2400ef90:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
2400ef94:	69bb      	ldr	r3, [r7, #24]
2400ef96:	f403 7300 	and.w	r3, r3, #512	; 0x200
2400ef9a:	2b00      	cmp	r3, #0
2400ef9c:	d00b      	beq.n	2400efb6 <I2C_IsErrorOccurred+0x186>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
2400ef9e:	6a3b      	ldr	r3, [r7, #32]
2400efa0:	f043 0302 	orr.w	r3, r3, #2
2400efa4:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
2400efa6:	68fb      	ldr	r3, [r7, #12]
2400efa8:	681b      	ldr	r3, [r3, #0]
2400efaa:	f44f 7200 	mov.w	r2, #512	; 0x200
2400efae:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
2400efb0:	2301      	movs	r3, #1
2400efb2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  if (status != HAL_OK)
2400efb6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
2400efba:	2b00      	cmp	r3, #0
2400efbc:	d01c      	beq.n	2400eff8 <I2C_IsErrorOccurred+0x1c8>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
2400efbe:	68f8      	ldr	r0, [r7, #12]
2400efc0:	f7ff fb1b 	bl	2400e5fa <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
2400efc4:	68fb      	ldr	r3, [r7, #12]
2400efc6:	681b      	ldr	r3, [r3, #0]
2400efc8:	6859      	ldr	r1, [r3, #4]
2400efca:	68fb      	ldr	r3, [r7, #12]
2400efcc:	681a      	ldr	r2, [r3, #0]
2400efce:	4b0d      	ldr	r3, [pc, #52]	; (2400f004 <I2C_IsErrorOccurred+0x1d4>)
2400efd0:	400b      	ands	r3, r1
2400efd2:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
2400efd4:	68fb      	ldr	r3, [r7, #12]
2400efd6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
2400efd8:	6a3b      	ldr	r3, [r7, #32]
2400efda:	431a      	orrs	r2, r3
2400efdc:	68fb      	ldr	r3, [r7, #12]
2400efde:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
2400efe0:	68fb      	ldr	r3, [r7, #12]
2400efe2:	2220      	movs	r2, #32
2400efe4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
2400efe8:	68fb      	ldr	r3, [r7, #12]
2400efea:	2200      	movs	r2, #0
2400efec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400eff0:	68fb      	ldr	r3, [r7, #12]
2400eff2:	2200      	movs	r2, #0
2400eff4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
2400eff8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
2400effc:	4618      	mov	r0, r3
2400effe:	3728      	adds	r7, #40	; 0x28
2400f000:	46bd      	mov	sp, r7
2400f002:	bd80      	pop	{r7, pc}
2400f004:	fe00e800 	.word	0xfe00e800

2400f008 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
2400f008:	b480      	push	{r7}
2400f00a:	b087      	sub	sp, #28
2400f00c:	af00      	add	r7, sp, #0
2400f00e:	60f8      	str	r0, [r7, #12]
2400f010:	607b      	str	r3, [r7, #4]
2400f012:	460b      	mov	r3, r1
2400f014:	817b      	strh	r3, [r7, #10]
2400f016:	4613      	mov	r3, r2
2400f018:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2400f01a:	897b      	ldrh	r3, [r7, #10]
2400f01c:	f3c3 0209 	ubfx	r2, r3, #0, #10
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2400f020:	7a7b      	ldrb	r3, [r7, #9]
2400f022:	041b      	lsls	r3, r3, #16
2400f024:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2400f028:	431a      	orrs	r2, r3
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
2400f02a:	687b      	ldr	r3, [r7, #4]
2400f02c:	431a      	orrs	r2, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
2400f02e:	6a3b      	ldr	r3, [r7, #32]
2400f030:	4313      	orrs	r3, r2
2400f032:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
2400f036:	617b      	str	r3, [r7, #20]
                              (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
2400f038:	68fb      	ldr	r3, [r7, #12]
2400f03a:	681b      	ldr	r3, [r3, #0]
2400f03c:	685a      	ldr	r2, [r3, #4]
2400f03e:	6a3b      	ldr	r3, [r7, #32]
2400f040:	0d5b      	lsrs	r3, r3, #21
2400f042:	f403 6180 	and.w	r1, r3, #1024	; 0x400
2400f046:	4b08      	ldr	r3, [pc, #32]	; (2400f068 <I2C_TransferConfig+0x60>)
2400f048:	430b      	orrs	r3, r1
2400f04a:	43db      	mvns	r3, r3
2400f04c:	ea02 0103 	and.w	r1, r2, r3
2400f050:	68fb      	ldr	r3, [r7, #12]
2400f052:	681b      	ldr	r3, [r3, #0]
2400f054:	697a      	ldr	r2, [r7, #20]
2400f056:	430a      	orrs	r2, r1
2400f058:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
                I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
2400f05a:	bf00      	nop
2400f05c:	371c      	adds	r7, #28
2400f05e:	46bd      	mov	sp, r7
2400f060:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f064:	4770      	bx	lr
2400f066:	bf00      	nop
2400f068:	03ff63ff 	.word	0x03ff63ff

2400f06c <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400f06c:	b480      	push	{r7}
2400f06e:	b085      	sub	sp, #20
2400f070:	af00      	add	r7, sp, #0
2400f072:	6078      	str	r0, [r7, #4]
2400f074:	460b      	mov	r3, r1
2400f076:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400f078:	2300      	movs	r3, #0
2400f07a:	60fb      	str	r3, [r7, #12]

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400f07c:	687b      	ldr	r3, [r7, #4]
2400f07e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f080:	4a2a      	ldr	r2, [pc, #168]	; (2400f12c <I2C_Enable_IRQ+0xc0>)
2400f082:	4293      	cmp	r3, r2
2400f084:	d004      	beq.n	2400f090 <I2C_Enable_IRQ+0x24>
      (hi2c->XferISR == I2C_Slave_ISR_DMA))
2400f086:	687b      	ldr	r3, [r7, #4]
2400f088:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
2400f08a:	4a29      	ldr	r2, [pc, #164]	; (2400f130 <I2C_Enable_IRQ+0xc4>)
2400f08c:	4293      	cmp	r3, r2
2400f08e:	d11d      	bne.n	2400f0cc <I2C_Enable_IRQ+0x60>
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400f090:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400f094:	2b00      	cmp	r3, #0
2400f096:	da03      	bge.n	2400f0a0 <I2C_Enable_IRQ+0x34>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f098:	68fb      	ldr	r3, [r7, #12]
2400f09a:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400f09e:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
2400f0a0:	887b      	ldrh	r3, [r7, #2]
2400f0a2:	2b10      	cmp	r3, #16
2400f0a4:	d103      	bne.n	2400f0ae <I2C_Enable_IRQ+0x42>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400f0a6:	68fb      	ldr	r3, [r7, #12]
2400f0a8:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400f0ac:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400f0ae:	887b      	ldrh	r3, [r7, #2]
2400f0b0:	2b20      	cmp	r3, #32
2400f0b2:	d103      	bne.n	2400f0bc <I2C_Enable_IRQ+0x50>
    {
      /* Enable STOP interrupts */
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
2400f0b4:	68fb      	ldr	r3, [r7, #12]
2400f0b6:	f043 0360 	orr.w	r3, r3, #96	; 0x60
2400f0ba:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400f0bc:	887b      	ldrh	r3, [r7, #2]
2400f0be:	2b40      	cmp	r3, #64	; 0x40
2400f0c0:	d125      	bne.n	2400f10e <I2C_Enable_IRQ+0xa2>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
2400f0c2:	68fb      	ldr	r3, [r7, #12]
2400f0c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400f0c8:	60fb      	str	r3, [r7, #12]
    if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400f0ca:	e020      	b.n	2400f10e <I2C_Enable_IRQ+0xa2>
    }
  }
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400f0cc:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400f0d0:	2b00      	cmp	r3, #0
2400f0d2:	da03      	bge.n	2400f0dc <I2C_Enable_IRQ+0x70>
    {
      /* Enable ERR, STOP, NACK, and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f0d4:	68fb      	ldr	r3, [r7, #12]
2400f0d6:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400f0da:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400f0dc:	887b      	ldrh	r3, [r7, #2]
2400f0de:	f003 0301 	and.w	r3, r3, #1
2400f0e2:	2b00      	cmp	r3, #0
2400f0e4:	d003      	beq.n	2400f0ee <I2C_Enable_IRQ+0x82>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
2400f0e6:	68fb      	ldr	r3, [r7, #12]
2400f0e8:	f043 03f2 	orr.w	r3, r3, #242	; 0xf2
2400f0ec:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400f0ee:	887b      	ldrh	r3, [r7, #2]
2400f0f0:	f003 0302 	and.w	r3, r3, #2
2400f0f4:	2b00      	cmp	r3, #0
2400f0f6:	d003      	beq.n	2400f100 <I2C_Enable_IRQ+0x94>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
2400f0f8:	68fb      	ldr	r3, [r7, #12]
2400f0fa:	f043 03f4 	orr.w	r3, r3, #244	; 0xf4
2400f0fe:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
2400f100:	887b      	ldrh	r3, [r7, #2]
2400f102:	2b20      	cmp	r3, #32
2400f104:	d103      	bne.n	2400f10e <I2C_Enable_IRQ+0xa2>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
2400f106:	68fb      	ldr	r3, [r7, #12]
2400f108:	f043 0320 	orr.w	r3, r3, #32
2400f10c:	60fb      	str	r3, [r7, #12]
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
2400f10e:	687b      	ldr	r3, [r7, #4]
2400f110:	681b      	ldr	r3, [r3, #0]
2400f112:	6819      	ldr	r1, [r3, #0]
2400f114:	687b      	ldr	r3, [r7, #4]
2400f116:	681b      	ldr	r3, [r3, #0]
2400f118:	68fa      	ldr	r2, [r7, #12]
2400f11a:	430a      	orrs	r2, r1
2400f11c:	601a      	str	r2, [r3, #0]
}
2400f11e:	bf00      	nop
2400f120:	3714      	adds	r7, #20
2400f122:	46bd      	mov	sp, r7
2400f124:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f128:	4770      	bx	lr
2400f12a:	bf00      	nop
2400f12c:	2400d4d7 	.word	0x2400d4d7
2400f130:	2400d6ad 	.word	0x2400d6ad

2400f134 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
2400f134:	b480      	push	{r7}
2400f136:	b085      	sub	sp, #20
2400f138:	af00      	add	r7, sp, #0
2400f13a:	6078      	str	r0, [r7, #4]
2400f13c:	460b      	mov	r3, r1
2400f13e:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
2400f140:	2300      	movs	r3, #0
2400f142:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
2400f144:	887b      	ldrh	r3, [r7, #2]
2400f146:	f003 0301 	and.w	r3, r3, #1
2400f14a:	2b00      	cmp	r3, #0
2400f14c:	d00f      	beq.n	2400f16e <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
2400f14e:	68fb      	ldr	r3, [r7, #12]
2400f150:	f043 0342 	orr.w	r3, r3, #66	; 0x42
2400f154:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400f156:	687b      	ldr	r3, [r7, #4]
2400f158:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f15c:	b2db      	uxtb	r3, r3
2400f15e:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400f162:	2b28      	cmp	r3, #40	; 0x28
2400f164:	d003      	beq.n	2400f16e <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f166:	68fb      	ldr	r3, [r7, #12]
2400f168:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400f16c:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
2400f16e:	887b      	ldrh	r3, [r7, #2]
2400f170:	f003 0302 	and.w	r3, r3, #2
2400f174:	2b00      	cmp	r3, #0
2400f176:	d00f      	beq.n	2400f198 <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
2400f178:	68fb      	ldr	r3, [r7, #12]
2400f17a:	f043 0344 	orr.w	r3, r3, #68	; 0x44
2400f17e:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
2400f180:	687b      	ldr	r3, [r7, #4]
2400f182:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f186:	b2db      	uxtb	r3, r3
2400f188:	f003 0328 	and.w	r3, r3, #40	; 0x28
2400f18c:	2b28      	cmp	r3, #40	; 0x28
2400f18e:	d003      	beq.n	2400f198 <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f190:	68fb      	ldr	r3, [r7, #12]
2400f192:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
2400f196:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
2400f198:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
2400f19c:	2b00      	cmp	r3, #0
2400f19e:	da03      	bge.n	2400f1a8 <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
2400f1a0:	68fb      	ldr	r3, [r7, #12]
2400f1a2:	f043 03b8 	orr.w	r3, r3, #184	; 0xb8
2400f1a6:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
2400f1a8:	887b      	ldrh	r3, [r7, #2]
2400f1aa:	2b10      	cmp	r3, #16
2400f1ac:	d103      	bne.n	2400f1b6 <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
2400f1ae:	68fb      	ldr	r3, [r7, #12]
2400f1b0:	f043 0390 	orr.w	r3, r3, #144	; 0x90
2400f1b4:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
2400f1b6:	887b      	ldrh	r3, [r7, #2]
2400f1b8:	2b20      	cmp	r3, #32
2400f1ba:	d103      	bne.n	2400f1c4 <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
2400f1bc:	68fb      	ldr	r3, [r7, #12]
2400f1be:	f043 0320 	orr.w	r3, r3, #32
2400f1c2:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
2400f1c4:	887b      	ldrh	r3, [r7, #2]
2400f1c6:	2b40      	cmp	r3, #64	; 0x40
2400f1c8:	d103      	bne.n	2400f1d2 <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
2400f1ca:	68fb      	ldr	r3, [r7, #12]
2400f1cc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
2400f1d0:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
2400f1d2:	687b      	ldr	r3, [r7, #4]
2400f1d4:	681b      	ldr	r3, [r3, #0]
2400f1d6:	6819      	ldr	r1, [r3, #0]
2400f1d8:	68fb      	ldr	r3, [r7, #12]
2400f1da:	43da      	mvns	r2, r3
2400f1dc:	687b      	ldr	r3, [r7, #4]
2400f1de:	681b      	ldr	r3, [r3, #0]
2400f1e0:	400a      	ands	r2, r1
2400f1e2:	601a      	str	r2, [r3, #0]
}
2400f1e4:	bf00      	nop
2400f1e6:	3714      	adds	r7, #20
2400f1e8:	46bd      	mov	sp, r7
2400f1ea:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f1ee:	4770      	bx	lr

2400f1f0 <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functional XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
2400f1f0:	b480      	push	{r7}
2400f1f2:	b083      	sub	sp, #12
2400f1f4:	af00      	add	r7, sp, #0
2400f1f6:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
2400f1f8:	687b      	ldr	r3, [r7, #4]
2400f1fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f1fc:	2baa      	cmp	r3, #170	; 0xaa
2400f1fe:	d103      	bne.n	2400f208 <I2C_ConvertOtherXferOptions+0x18>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
2400f200:	687b      	ldr	r3, [r7, #4]
2400f202:	2200      	movs	r2, #0
2400f204:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
2400f206:	e008      	b.n	2400f21a <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
2400f208:	687b      	ldr	r3, [r7, #4]
2400f20a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2400f20c:	f5b3 4f2a 	cmp.w	r3, #43520	; 0xaa00
2400f210:	d103      	bne.n	2400f21a <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
2400f212:	687b      	ldr	r3, [r7, #4]
2400f214:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
2400f218:	62da      	str	r2, [r3, #44]	; 0x2c
}
2400f21a:	bf00      	nop
2400f21c:	370c      	adds	r7, #12
2400f21e:	46bd      	mov	sp, r7
2400f220:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f224:	4770      	bx	lr

2400f226 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
2400f226:	b480      	push	{r7}
2400f228:	b083      	sub	sp, #12
2400f22a:	af00      	add	r7, sp, #0
2400f22c:	6078      	str	r0, [r7, #4]
2400f22e:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f230:	687b      	ldr	r3, [r7, #4]
2400f232:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f236:	b2db      	uxtb	r3, r3
2400f238:	2b20      	cmp	r3, #32
2400f23a:	d138      	bne.n	2400f2ae <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f23c:	687b      	ldr	r3, [r7, #4]
2400f23e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f242:	2b01      	cmp	r3, #1
2400f244:	d101      	bne.n	2400f24a <HAL_I2CEx_ConfigAnalogFilter+0x24>
2400f246:	2302      	movs	r3, #2
2400f248:	e032      	b.n	2400f2b0 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
2400f24a:	687b      	ldr	r3, [r7, #4]
2400f24c:	2201      	movs	r2, #1
2400f24e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f252:	687b      	ldr	r3, [r7, #4]
2400f254:	2224      	movs	r2, #36	; 0x24
2400f256:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f25a:	687b      	ldr	r3, [r7, #4]
2400f25c:	681b      	ldr	r3, [r3, #0]
2400f25e:	681a      	ldr	r2, [r3, #0]
2400f260:	687b      	ldr	r3, [r7, #4]
2400f262:	681b      	ldr	r3, [r3, #0]
2400f264:	f022 0201 	bic.w	r2, r2, #1
2400f268:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
2400f26a:	687b      	ldr	r3, [r7, #4]
2400f26c:	681b      	ldr	r3, [r3, #0]
2400f26e:	681a      	ldr	r2, [r3, #0]
2400f270:	687b      	ldr	r3, [r7, #4]
2400f272:	681b      	ldr	r3, [r3, #0]
2400f274:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
2400f278:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
2400f27a:	687b      	ldr	r3, [r7, #4]
2400f27c:	681b      	ldr	r3, [r3, #0]
2400f27e:	6819      	ldr	r1, [r3, #0]
2400f280:	687b      	ldr	r3, [r7, #4]
2400f282:	681b      	ldr	r3, [r3, #0]
2400f284:	683a      	ldr	r2, [r7, #0]
2400f286:	430a      	orrs	r2, r1
2400f288:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f28a:	687b      	ldr	r3, [r7, #4]
2400f28c:	681b      	ldr	r3, [r3, #0]
2400f28e:	681a      	ldr	r2, [r3, #0]
2400f290:	687b      	ldr	r3, [r7, #4]
2400f292:	681b      	ldr	r3, [r3, #0]
2400f294:	f042 0201 	orr.w	r2, r2, #1
2400f298:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f29a:	687b      	ldr	r3, [r7, #4]
2400f29c:	2220      	movs	r2, #32
2400f29e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f2a2:	687b      	ldr	r3, [r7, #4]
2400f2a4:	2200      	movs	r2, #0
2400f2a6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f2aa:	2300      	movs	r3, #0
2400f2ac:	e000      	b.n	2400f2b0 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
2400f2ae:	2302      	movs	r3, #2
  }
}
2400f2b0:	4618      	mov	r0, r3
2400f2b2:	370c      	adds	r7, #12
2400f2b4:	46bd      	mov	sp, r7
2400f2b6:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f2ba:	4770      	bx	lr

2400f2bc <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
2400f2bc:	b480      	push	{r7}
2400f2be:	b085      	sub	sp, #20
2400f2c0:	af00      	add	r7, sp, #0
2400f2c2:	6078      	str	r0, [r7, #4]
2400f2c4:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f2c6:	687b      	ldr	r3, [r7, #4]
2400f2c8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f2cc:	b2db      	uxtb	r3, r3
2400f2ce:	2b20      	cmp	r3, #32
2400f2d0:	d139      	bne.n	2400f346 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f2d2:	687b      	ldr	r3, [r7, #4]
2400f2d4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f2d8:	2b01      	cmp	r3, #1
2400f2da:	d101      	bne.n	2400f2e0 <HAL_I2CEx_ConfigDigitalFilter+0x24>
2400f2dc:	2302      	movs	r3, #2
2400f2de:	e033      	b.n	2400f348 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
2400f2e0:	687b      	ldr	r3, [r7, #4]
2400f2e2:	2201      	movs	r2, #1
2400f2e4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f2e8:	687b      	ldr	r3, [r7, #4]
2400f2ea:	2224      	movs	r2, #36	; 0x24
2400f2ec:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f2f0:	687b      	ldr	r3, [r7, #4]
2400f2f2:	681b      	ldr	r3, [r3, #0]
2400f2f4:	681a      	ldr	r2, [r3, #0]
2400f2f6:	687b      	ldr	r3, [r7, #4]
2400f2f8:	681b      	ldr	r3, [r3, #0]
2400f2fa:	f022 0201 	bic.w	r2, r2, #1
2400f2fe:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
2400f300:	687b      	ldr	r3, [r7, #4]
2400f302:	681b      	ldr	r3, [r3, #0]
2400f304:	681b      	ldr	r3, [r3, #0]
2400f306:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
2400f308:	68fb      	ldr	r3, [r7, #12]
2400f30a:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
2400f30e:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
2400f310:	683b      	ldr	r3, [r7, #0]
2400f312:	021b      	lsls	r3, r3, #8
2400f314:	68fa      	ldr	r2, [r7, #12]
2400f316:	4313      	orrs	r3, r2
2400f318:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
2400f31a:	687b      	ldr	r3, [r7, #4]
2400f31c:	681b      	ldr	r3, [r3, #0]
2400f31e:	68fa      	ldr	r2, [r7, #12]
2400f320:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f322:	687b      	ldr	r3, [r7, #4]
2400f324:	681b      	ldr	r3, [r3, #0]
2400f326:	681a      	ldr	r2, [r3, #0]
2400f328:	687b      	ldr	r3, [r7, #4]
2400f32a:	681b      	ldr	r3, [r3, #0]
2400f32c:	f042 0201 	orr.w	r2, r2, #1
2400f330:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f332:	687b      	ldr	r3, [r7, #4]
2400f334:	2220      	movs	r2, #32
2400f336:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f33a:	687b      	ldr	r3, [r7, #4]
2400f33c:	2200      	movs	r2, #0
2400f33e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f342:	2300      	movs	r3, #0
2400f344:	e000      	b.n	2400f348 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
2400f346:	2302      	movs	r3, #2
  }
}
2400f348:	4618      	mov	r0, r3
2400f34a:	3714      	adds	r7, #20
2400f34c:	46bd      	mov	sp, r7
2400f34e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f352:	4770      	bx	lr

2400f354 <HAL_I2CEx_EnableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_EnableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400f354:	b480      	push	{r7}
2400f356:	b083      	sub	sp, #12
2400f358:	af00      	add	r7, sp, #0
2400f35a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f35c:	687b      	ldr	r3, [r7, #4]
2400f35e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f362:	b2db      	uxtb	r3, r3
2400f364:	2b20      	cmp	r3, #32
2400f366:	d130      	bne.n	2400f3ca <HAL_I2CEx_EnableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f368:	687b      	ldr	r3, [r7, #4]
2400f36a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f36e:	2b01      	cmp	r3, #1
2400f370:	d101      	bne.n	2400f376 <HAL_I2CEx_EnableWakeUp+0x22>
2400f372:	2302      	movs	r3, #2
2400f374:	e02a      	b.n	2400f3cc <HAL_I2CEx_EnableWakeUp+0x78>
2400f376:	687b      	ldr	r3, [r7, #4]
2400f378:	2201      	movs	r2, #1
2400f37a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f37e:	687b      	ldr	r3, [r7, #4]
2400f380:	2224      	movs	r2, #36	; 0x24
2400f382:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f386:	687b      	ldr	r3, [r7, #4]
2400f388:	681b      	ldr	r3, [r3, #0]
2400f38a:	681a      	ldr	r2, [r3, #0]
2400f38c:	687b      	ldr	r3, [r7, #4]
2400f38e:	681b      	ldr	r3, [r3, #0]
2400f390:	f022 0201 	bic.w	r2, r2, #1
2400f394:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 |= I2C_CR1_WUPEN;
2400f396:	687b      	ldr	r3, [r7, #4]
2400f398:	681b      	ldr	r3, [r3, #0]
2400f39a:	681a      	ldr	r2, [r3, #0]
2400f39c:	687b      	ldr	r3, [r7, #4]
2400f39e:	681b      	ldr	r3, [r3, #0]
2400f3a0:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2400f3a4:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f3a6:	687b      	ldr	r3, [r7, #4]
2400f3a8:	681b      	ldr	r3, [r3, #0]
2400f3aa:	681a      	ldr	r2, [r3, #0]
2400f3ac:	687b      	ldr	r3, [r7, #4]
2400f3ae:	681b      	ldr	r3, [r3, #0]
2400f3b0:	f042 0201 	orr.w	r2, r2, #1
2400f3b4:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f3b6:	687b      	ldr	r3, [r7, #4]
2400f3b8:	2220      	movs	r2, #32
2400f3ba:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f3be:	687b      	ldr	r3, [r7, #4]
2400f3c0:	2200      	movs	r2, #0
2400f3c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f3c6:	2300      	movs	r3, #0
2400f3c8:	e000      	b.n	2400f3cc <HAL_I2CEx_EnableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400f3ca:	2302      	movs	r3, #2
  }
}
2400f3cc:	4618      	mov	r0, r3
2400f3ce:	370c      	adds	r7, #12
2400f3d0:	46bd      	mov	sp, r7
2400f3d2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f3d6:	4770      	bx	lr

2400f3d8 <HAL_I2CEx_DisableWakeUp>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2Cx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_DisableWakeUp(I2C_HandleTypeDef *hi2c)
{
2400f3d8:	b480      	push	{r7}
2400f3da:	b083      	sub	sp, #12
2400f3dc:	af00      	add	r7, sp, #0
2400f3de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_WAKEUP_FROMSTOP_INSTANCE(hi2c->Instance));

  if (hi2c->State == HAL_I2C_STATE_READY)
2400f3e0:	687b      	ldr	r3, [r7, #4]
2400f3e2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2400f3e6:	b2db      	uxtb	r3, r3
2400f3e8:	2b20      	cmp	r3, #32
2400f3ea:	d130      	bne.n	2400f44e <HAL_I2CEx_DisableWakeUp+0x76>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
2400f3ec:	687b      	ldr	r3, [r7, #4]
2400f3ee:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2400f3f2:	2b01      	cmp	r3, #1
2400f3f4:	d101      	bne.n	2400f3fa <HAL_I2CEx_DisableWakeUp+0x22>
2400f3f6:	2302      	movs	r3, #2
2400f3f8:	e02a      	b.n	2400f450 <HAL_I2CEx_DisableWakeUp+0x78>
2400f3fa:	687b      	ldr	r3, [r7, #4]
2400f3fc:	2201      	movs	r2, #1
2400f3fe:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
2400f402:	687b      	ldr	r3, [r7, #4]
2400f404:	2224      	movs	r2, #36	; 0x24
2400f406:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
2400f40a:	687b      	ldr	r3, [r7, #4]
2400f40c:	681b      	ldr	r3, [r3, #0]
2400f40e:	681a      	ldr	r2, [r3, #0]
2400f410:	687b      	ldr	r3, [r7, #4]
2400f412:	681b      	ldr	r3, [r3, #0]
2400f414:	f022 0201 	bic.w	r2, r2, #1
2400f418:	601a      	str	r2, [r3, #0]

    /* Enable wakeup from stop mode */
    hi2c->Instance->CR1 &= ~(I2C_CR1_WUPEN);
2400f41a:	687b      	ldr	r3, [r7, #4]
2400f41c:	681b      	ldr	r3, [r3, #0]
2400f41e:	681a      	ldr	r2, [r3, #0]
2400f420:	687b      	ldr	r3, [r7, #4]
2400f422:	681b      	ldr	r3, [r3, #0]
2400f424:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2400f428:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
2400f42a:	687b      	ldr	r3, [r7, #4]
2400f42c:	681b      	ldr	r3, [r3, #0]
2400f42e:	681a      	ldr	r2, [r3, #0]
2400f430:	687b      	ldr	r3, [r7, #4]
2400f432:	681b      	ldr	r3, [r3, #0]
2400f434:	f042 0201 	orr.w	r2, r2, #1
2400f438:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
2400f43a:	687b      	ldr	r3, [r7, #4]
2400f43c:	2220      	movs	r2, #32
2400f43e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
2400f442:	687b      	ldr	r3, [r7, #4]
2400f444:	2200      	movs	r2, #0
2400f446:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
2400f44a:	2300      	movs	r3, #0
2400f44c:	e000      	b.n	2400f450 <HAL_I2CEx_DisableWakeUp+0x78>
  }
  else
  {
    return HAL_BUSY;
2400f44e:	2302      	movs	r3, #2
  }
}
2400f450:	4618      	mov	r0, r3
2400f452:	370c      	adds	r7, #12
2400f454:	46bd      	mov	sp, r7
2400f456:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f45a:	4770      	bx	lr

2400f45c <HAL_I2CEx_EnableFastModePlus>:
  * @note  For all I2C5 pins fast mode plus driving capability can be enabled
  *        only by using I2C_FASTMODEPLUS_I2C5 parameter.
  * @retval None
  */
void HAL_I2CEx_EnableFastModePlus(uint32_t ConfigFastModePlus)
{
2400f45c:	b480      	push	{r7}
2400f45e:	b085      	sub	sp, #20
2400f460:	af00      	add	r7, sp, #0
2400f462:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400f464:	4b0d      	ldr	r3, [pc, #52]	; (2400f49c <HAL_I2CEx_EnableFastModePlus+0x40>)
2400f466:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f46a:	4a0c      	ldr	r2, [pc, #48]	; (2400f49c <HAL_I2CEx_EnableFastModePlus+0x40>)
2400f46c:	f043 0302 	orr.w	r3, r3, #2
2400f470:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400f474:	4b09      	ldr	r3, [pc, #36]	; (2400f49c <HAL_I2CEx_EnableFastModePlus+0x40>)
2400f476:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f47a:	f003 0302 	and.w	r3, r3, #2
2400f47e:	60fb      	str	r3, [r7, #12]
2400f480:	68fb      	ldr	r3, [r7, #12]

  /* Enable fast mode plus driving capability for selected pin */
  SET_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400f482:	4b07      	ldr	r3, [pc, #28]	; (2400f4a0 <HAL_I2CEx_EnableFastModePlus+0x44>)
2400f484:	685a      	ldr	r2, [r3, #4]
2400f486:	4906      	ldr	r1, [pc, #24]	; (2400f4a0 <HAL_I2CEx_EnableFastModePlus+0x44>)
2400f488:	687b      	ldr	r3, [r7, #4]
2400f48a:	4313      	orrs	r3, r2
2400f48c:	604b      	str	r3, [r1, #4]
}
2400f48e:	bf00      	nop
2400f490:	3714      	adds	r7, #20
2400f492:	46bd      	mov	sp, r7
2400f494:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f498:	4770      	bx	lr
2400f49a:	bf00      	nop
2400f49c:	58024400 	.word	0x58024400
2400f4a0:	58000400 	.word	0x58000400

2400f4a4 <HAL_I2CEx_DisableFastModePlus>:
  * @note  For all I2C5 pins fast mode plus driving capability can be disabled
  *        only by using I2C_FASTMODEPLUS_I2C5 parameter.
  * @retval None
  */
void HAL_I2CEx_DisableFastModePlus(uint32_t ConfigFastModePlus)
{
2400f4a4:	b480      	push	{r7}
2400f4a6:	b085      	sub	sp, #20
2400f4a8:	af00      	add	r7, sp, #0
2400f4aa:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_I2C_FASTMODEPLUS(ConfigFastModePlus));

  /* Enable SYSCFG clock */
  __HAL_RCC_SYSCFG_CLK_ENABLE();
2400f4ac:	4b0d      	ldr	r3, [pc, #52]	; (2400f4e4 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400f4ae:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f4b2:	4a0c      	ldr	r2, [pc, #48]	; (2400f4e4 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400f4b4:	f043 0302 	orr.w	r3, r3, #2
2400f4b8:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
2400f4bc:	4b09      	ldr	r3, [pc, #36]	; (2400f4e4 <HAL_I2CEx_DisableFastModePlus+0x40>)
2400f4be:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
2400f4c2:	f003 0302 	and.w	r3, r3, #2
2400f4c6:	60fb      	str	r3, [r7, #12]
2400f4c8:	68fb      	ldr	r3, [r7, #12]

  /* Disable fast mode plus driving capability for selected pin */
  CLEAR_BIT(SYSCFG->PMCR, (uint32_t)ConfigFastModePlus);
2400f4ca:	4b07      	ldr	r3, [pc, #28]	; (2400f4e8 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400f4cc:	685a      	ldr	r2, [r3, #4]
2400f4ce:	687b      	ldr	r3, [r7, #4]
2400f4d0:	43db      	mvns	r3, r3
2400f4d2:	4905      	ldr	r1, [pc, #20]	; (2400f4e8 <HAL_I2CEx_DisableFastModePlus+0x44>)
2400f4d4:	4013      	ands	r3, r2
2400f4d6:	604b      	str	r3, [r1, #4]
}
2400f4d8:	bf00      	nop
2400f4da:	3714      	adds	r7, #20
2400f4dc:	46bd      	mov	sp, r7
2400f4de:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f4e2:	4770      	bx	lr
2400f4e4:	58024400 	.word	0x58024400
2400f4e8:	58000400 	.word	0x58000400

2400f4ec <HAL_MDMA_Init>:
  * @param  hmdma: Pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
2400f4ec:	b580      	push	{r7, lr}
2400f4ee:	b084      	sub	sp, #16
2400f4f0:	af00      	add	r7, sp, #0
2400f4f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
2400f4f4:	f7f2 ff26 	bl	24002344 <HAL_GetTick>
2400f4f8:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f4fa:	687b      	ldr	r3, [r7, #4]
2400f4fc:	2b00      	cmp	r3, #0
2400f4fe:	d101      	bne.n	2400f504 <HAL_MDMA_Init+0x18>
  {
    return HAL_ERROR;
2400f500:	2301      	movs	r3, #1
2400f502:	e03b      	b.n	2400f57c <HAL_MDMA_Init+0x90>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.SourceBlockAddressOffset));
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.DestBlockAddressOffset));


  /* Allocate lock resource */
  __HAL_UNLOCK(hmdma);
2400f504:	687b      	ldr	r3, [r7, #4]
2400f506:	2200      	movs	r2, #0
2400f508:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change MDMA peripheral state */
  hmdma->State = HAL_MDMA_STATE_BUSY;
2400f50c:	687b      	ldr	r3, [r7, #4]
2400f50e:	2202      	movs	r2, #2
2400f510:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
2400f514:	687b      	ldr	r3, [r7, #4]
2400f516:	681b      	ldr	r3, [r3, #0]
2400f518:	68da      	ldr	r2, [r3, #12]
2400f51a:	687b      	ldr	r3, [r7, #4]
2400f51c:	681b      	ldr	r3, [r3, #0]
2400f51e:	f022 0201 	bic.w	r2, r2, #1
2400f522:	60da      	str	r2, [r3, #12]

  /* Check if the MDMA channel is effectively disabled */
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400f524:	e00f      	b.n	2400f546 <HAL_MDMA_Init+0x5a>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2400f526:	f7f2 ff0d 	bl	24002344 <HAL_GetTick>
2400f52a:	4602      	mov	r2, r0
2400f52c:	68fb      	ldr	r3, [r7, #12]
2400f52e:	1ad3      	subs	r3, r2, r3
2400f530:	2b05      	cmp	r3, #5
2400f532:	d908      	bls.n	2400f546 <HAL_MDMA_Init+0x5a>
    {
      /* Update error code */
      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;
2400f534:	687b      	ldr	r3, [r7, #4]
2400f536:	2240      	movs	r2, #64	; 0x40
2400f538:	669a      	str	r2, [r3, #104]	; 0x68

      /* Change the MDMA state */
      hmdma->State = HAL_MDMA_STATE_ERROR;
2400f53a:	687b      	ldr	r3, [r7, #4]
2400f53c:	2203      	movs	r2, #3
2400f53e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      return HAL_ERROR;
2400f542:	2301      	movs	r3, #1
2400f544:	e01a      	b.n	2400f57c <HAL_MDMA_Init+0x90>
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2400f546:	687b      	ldr	r3, [r7, #4]
2400f548:	681b      	ldr	r3, [r3, #0]
2400f54a:	68db      	ldr	r3, [r3, #12]
2400f54c:	f003 0301 	and.w	r3, r3, #1
2400f550:	2b00      	cmp	r3, #0
2400f552:	d1e8      	bne.n	2400f526 <HAL_MDMA_Init+0x3a>
    }
  }

  /* Initialize the MDMA channel registers */
  MDMA_Init(hmdma);
2400f554:	6878      	ldr	r0, [r7, #4]
2400f556:	f001 f899 	bl	2401068c <MDMA_Init>

  /* Reset the MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400f55a:	687b      	ldr	r3, [r7, #4]
2400f55c:	2200      	movs	r2, #0
2400f55e:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400f560:	687b      	ldr	r3, [r7, #4]
2400f562:	2200      	movs	r2, #0
2400f564:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400f566:	687b      	ldr	r3, [r7, #4]
2400f568:	2200      	movs	r2, #0
2400f56a:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400f56c:	687b      	ldr	r3, [r7, #4]
2400f56e:	2200      	movs	r2, #0
2400f570:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_READY;
2400f572:	687b      	ldr	r3, [r7, #4]
2400f574:	2201      	movs	r2, #1
2400f576:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
2400f57a:	2300      	movs	r3, #0
}
2400f57c:	4618      	mov	r0, r3
2400f57e:	3710      	adds	r7, #16
2400f580:	46bd      	mov	sp, r7
2400f582:	bd80      	pop	{r7, pc}

2400f584 <HAL_MDMA_DeInit>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_DeInit(MDMA_HandleTypeDef *hmdma)
{
2400f584:	b480      	push	{r7}
2400f586:	b083      	sub	sp, #12
2400f588:	af00      	add	r7, sp, #0
2400f58a:	6078      	str	r0, [r7, #4]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f58c:	687b      	ldr	r3, [r7, #4]
2400f58e:	2b00      	cmp	r3, #0
2400f590:	d101      	bne.n	2400f596 <HAL_MDMA_DeInit+0x12>
  {
    return HAL_ERROR;
2400f592:	2301      	movs	r3, #1
2400f594:	e048      	b.n	2400f628 <HAL_MDMA_DeInit+0xa4>
  }

  /* Disable the selected MDMA Channelx */
  __HAL_MDMA_DISABLE(hmdma);
2400f596:	687b      	ldr	r3, [r7, #4]
2400f598:	681b      	ldr	r3, [r3, #0]
2400f59a:	68da      	ldr	r2, [r3, #12]
2400f59c:	687b      	ldr	r3, [r7, #4]
2400f59e:	681b      	ldr	r3, [r3, #0]
2400f5a0:	f022 0201 	bic.w	r2, r2, #1
2400f5a4:	60da      	str	r2, [r3, #12]

  /* Reset MDMA Channel control register */
  hmdma->Instance->CCR  = 0;
2400f5a6:	687b      	ldr	r3, [r7, #4]
2400f5a8:	681b      	ldr	r3, [r3, #0]
2400f5aa:	2200      	movs	r2, #0
2400f5ac:	60da      	str	r2, [r3, #12]
  hmdma->Instance->CTCR = 0;
2400f5ae:	687b      	ldr	r3, [r7, #4]
2400f5b0:	681b      	ldr	r3, [r3, #0]
2400f5b2:	2200      	movs	r2, #0
2400f5b4:	611a      	str	r2, [r3, #16]
  hmdma->Instance->CBNDTR = 0;
2400f5b6:	687b      	ldr	r3, [r7, #4]
2400f5b8:	681b      	ldr	r3, [r3, #0]
2400f5ba:	2200      	movs	r2, #0
2400f5bc:	615a      	str	r2, [r3, #20]
  hmdma->Instance->CSAR = 0;
2400f5be:	687b      	ldr	r3, [r7, #4]
2400f5c0:	681b      	ldr	r3, [r3, #0]
2400f5c2:	2200      	movs	r2, #0
2400f5c4:	619a      	str	r2, [r3, #24]
  hmdma->Instance->CDAR = 0;
2400f5c6:	687b      	ldr	r3, [r7, #4]
2400f5c8:	681b      	ldr	r3, [r3, #0]
2400f5ca:	2200      	movs	r2, #0
2400f5cc:	61da      	str	r2, [r3, #28]
  hmdma->Instance->CBRUR = 0;
2400f5ce:	687b      	ldr	r3, [r7, #4]
2400f5d0:	681b      	ldr	r3, [r3, #0]
2400f5d2:	2200      	movs	r2, #0
2400f5d4:	621a      	str	r2, [r3, #32]
  hmdma->Instance->CLAR = 0;
2400f5d6:	687b      	ldr	r3, [r7, #4]
2400f5d8:	681b      	ldr	r3, [r3, #0]
2400f5da:	2200      	movs	r2, #0
2400f5dc:	625a      	str	r2, [r3, #36]	; 0x24
  hmdma->Instance->CTBR = 0;
2400f5de:	687b      	ldr	r3, [r7, #4]
2400f5e0:	681b      	ldr	r3, [r3, #0]
2400f5e2:	2200      	movs	r2, #0
2400f5e4:	629a      	str	r2, [r3, #40]	; 0x28
  hmdma->Instance->CMAR = 0;
2400f5e6:	687b      	ldr	r3, [r7, #4]
2400f5e8:	681b      	ldr	r3, [r3, #0]
2400f5ea:	2200      	movs	r2, #0
2400f5ec:	631a      	str	r2, [r3, #48]	; 0x30
  hmdma->Instance->CMDR = 0;
2400f5ee:	687b      	ldr	r3, [r7, #4]
2400f5f0:	681b      	ldr	r3, [r3, #0]
2400f5f2:	2200      	movs	r2, #0
2400f5f4:	635a      	str	r2, [r3, #52]	; 0x34

  /* Clear all flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
2400f5f6:	687b      	ldr	r3, [r7, #4]
2400f5f8:	681b      	ldr	r3, [r3, #0]
2400f5fa:	221f      	movs	r2, #31
2400f5fc:	605a      	str	r2, [r3, #4]

  /* Reset the  MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
2400f5fe:	687b      	ldr	r3, [r7, #4]
2400f600:	2200      	movs	r2, #0
2400f602:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
2400f604:	687b      	ldr	r3, [r7, #4]
2400f606:	2200      	movs	r2, #0
2400f608:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
2400f60a:	687b      	ldr	r3, [r7, #4]
2400f60c:	2200      	movs	r2, #0
2400f60e:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400f610:	687b      	ldr	r3, [r7, #4]
2400f612:	2200      	movs	r2, #0
2400f614:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_RESET;
2400f616:	687b      	ldr	r3, [r7, #4]
2400f618:	2200      	movs	r2, #0
2400f61a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400f61e:	687b      	ldr	r3, [r7, #4]
2400f620:	2200      	movs	r2, #0
2400f622:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
2400f626:	2300      	movs	r3, #0
}
2400f628:	4618      	mov	r0, r3
2400f62a:	370c      	adds	r7, #12
2400f62c:	46bd      	mov	sp, r7
2400f62e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f632:	4770      	bx	lr

2400f634 <HAL_MDMA_ConfigPostRequestMask>:
  * @param  MaskData:    specifies the value to be written to MaskAddress after a request is served.
  *                      MaskAddress and MaskData could be used to automatically clear a peripheral flag when the request is served.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_ConfigPostRequestMask(MDMA_HandleTypeDef *hmdma, uint32_t MaskAddress, uint32_t MaskData)
{
2400f634:	b480      	push	{r7}
2400f636:	b087      	sub	sp, #28
2400f638:	af00      	add	r7, sp, #0
2400f63a:	60f8      	str	r0, [r7, #12]
2400f63c:	60b9      	str	r1, [r7, #8]
2400f63e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
2400f640:	2300      	movs	r3, #0
2400f642:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f644:	68fb      	ldr	r3, [r7, #12]
2400f646:	2b00      	cmp	r3, #0
2400f648:	d101      	bne.n	2400f64e <HAL_MDMA_ConfigPostRequestMask+0x1a>
  {
    return HAL_ERROR;
2400f64a:	2301      	movs	r3, #1
2400f64c:	e03e      	b.n	2400f6cc <HAL_MDMA_ConfigPostRequestMask+0x98>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400f64e:	68fb      	ldr	r3, [r7, #12]
2400f650:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400f654:	2b01      	cmp	r3, #1
2400f656:	d101      	bne.n	2400f65c <HAL_MDMA_ConfigPostRequestMask+0x28>
2400f658:	2302      	movs	r3, #2
2400f65a:	e037      	b.n	2400f6cc <HAL_MDMA_ConfigPostRequestMask+0x98>
2400f65c:	68fb      	ldr	r3, [r7, #12]
2400f65e:	2201      	movs	r2, #1
2400f660:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400f664:	68fb      	ldr	r3, [r7, #12]
2400f666:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f66a:	b2db      	uxtb	r3, r3
2400f66c:	2b01      	cmp	r3, #1
2400f66e:	d126      	bne.n	2400f6be <HAL_MDMA_ConfigPostRequestMask+0x8a>
  {
    /* if HW request set Post Request MaskAddress and MaskData,  */
    if((hmdma->Instance->CTCR & MDMA_CTCR_SWRM) == 0U)
2400f670:	68fb      	ldr	r3, [r7, #12]
2400f672:	681b      	ldr	r3, [r3, #0]
2400f674:	691b      	ldr	r3, [r3, #16]
2400f676:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2400f67a:	2b00      	cmp	r3, #0
2400f67c:	d11c      	bne.n	2400f6b8 <HAL_MDMA_ConfigPostRequestMask+0x84>
    {
      /* Set the HW request clear Mask and Data */
      hmdma->Instance->CMAR = MaskAddress;
2400f67e:	68fb      	ldr	r3, [r7, #12]
2400f680:	681b      	ldr	r3, [r3, #0]
2400f682:	68ba      	ldr	r2, [r7, #8]
2400f684:	631a      	str	r2, [r3, #48]	; 0x30
      hmdma->Instance->CMDR = MaskData;
2400f686:	68fb      	ldr	r3, [r7, #12]
2400f688:	681b      	ldr	r3, [r3, #0]
2400f68a:	687a      	ldr	r2, [r7, #4]
2400f68c:	635a      	str	r2, [r3, #52]	; 0x34
      -If the request is done by SW : BWM could be set to 1 or 0.
      -If the request is done by a peripheral :
         If mask address not set (0) => BWM must be set to 0
         If mask address set (different than 0) => BWM could be set to 1 or 0
      */
      if(MaskAddress == 0U)
2400f68e:	68bb      	ldr	r3, [r7, #8]
2400f690:	2b00      	cmp	r3, #0
2400f692:	d108      	bne.n	2400f6a6 <HAL_MDMA_ConfigPostRequestMask+0x72>
      {
        hmdma->Instance->CTCR &=  ~MDMA_CTCR_BWM;
2400f694:	68fb      	ldr	r3, [r7, #12]
2400f696:	681b      	ldr	r3, [r3, #0]
2400f698:	691a      	ldr	r2, [r3, #16]
2400f69a:	68fb      	ldr	r3, [r7, #12]
2400f69c:	681b      	ldr	r3, [r3, #0]
2400f69e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
2400f6a2:	611a      	str	r2, [r3, #16]
2400f6a4:	e00d      	b.n	2400f6c2 <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
      else
      {
        hmdma->Instance->CTCR |=  MDMA_CTCR_BWM;
2400f6a6:	68fb      	ldr	r3, [r7, #12]
2400f6a8:	681b      	ldr	r3, [r3, #0]
2400f6aa:	691a      	ldr	r2, [r3, #16]
2400f6ac:	68fb      	ldr	r3, [r7, #12]
2400f6ae:	681b      	ldr	r3, [r3, #0]
2400f6b0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
2400f6b4:	611a      	str	r2, [r3, #16]
2400f6b6:	e004      	b.n	2400f6c2 <HAL_MDMA_ConfigPostRequestMask+0x8e>
      }
    }
    else
    {
      /* Return error status */
      status =  HAL_ERROR;
2400f6b8:	2301      	movs	r3, #1
2400f6ba:	75fb      	strb	r3, [r7, #23]
2400f6bc:	e001      	b.n	2400f6c2 <HAL_MDMA_ConfigPostRequestMask+0x8e>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400f6be:	2301      	movs	r3, #1
2400f6c0:	75fb      	strb	r3, [r7, #23]
  }
  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400f6c2:	68fb      	ldr	r3, [r7, #12]
2400f6c4:	2200      	movs	r2, #0
2400f6c6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400f6ca:	7dfb      	ldrb	r3, [r7, #23]
}
2400f6cc:	4618      	mov	r0, r3
2400f6ce:	371c      	adds	r7, #28
2400f6d0:	46bd      	mov	sp, r7
2400f6d2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f6d6:	4770      	bx	lr

2400f6d8 <HAL_MDMA_RegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  * @param  pCallback:            pointer to callbacsk function.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_RegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID, void (* pCallback)(MDMA_HandleTypeDef *_hmdma))
{
2400f6d8:	b480      	push	{r7}
2400f6da:	b087      	sub	sp, #28
2400f6dc:	af00      	add	r7, sp, #0
2400f6de:	60f8      	str	r0, [r7, #12]
2400f6e0:	460b      	mov	r3, r1
2400f6e2:	607a      	str	r2, [r7, #4]
2400f6e4:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
2400f6e6:	2300      	movs	r3, #0
2400f6e8:	75fb      	strb	r3, [r7, #23]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f6ea:	68fb      	ldr	r3, [r7, #12]
2400f6ec:	2b00      	cmp	r3, #0
2400f6ee:	d101      	bne.n	2400f6f4 <HAL_MDMA_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
2400f6f0:	2301      	movs	r3, #1
2400f6f2:	e044      	b.n	2400f77e <HAL_MDMA_RegisterCallback+0xa6>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400f6f4:	68fb      	ldr	r3, [r7, #12]
2400f6f6:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400f6fa:	2b01      	cmp	r3, #1
2400f6fc:	d101      	bne.n	2400f702 <HAL_MDMA_RegisterCallback+0x2a>
2400f6fe:	2302      	movs	r3, #2
2400f700:	e03d      	b.n	2400f77e <HAL_MDMA_RegisterCallback+0xa6>
2400f702:	68fb      	ldr	r3, [r7, #12]
2400f704:	2201      	movs	r2, #1
2400f706:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400f70a:	68fb      	ldr	r3, [r7, #12]
2400f70c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f710:	b2db      	uxtb	r3, r3
2400f712:	2b01      	cmp	r3, #1
2400f714:	d12a      	bne.n	2400f76c <HAL_MDMA_RegisterCallback+0x94>
  {
    switch (CallbackID)
2400f716:	7afb      	ldrb	r3, [r7, #11]
2400f718:	2b05      	cmp	r3, #5
2400f71a:	d82a      	bhi.n	2400f772 <HAL_MDMA_RegisterCallback+0x9a>
2400f71c:	a201      	add	r2, pc, #4	; (adr r2, 2400f724 <HAL_MDMA_RegisterCallback+0x4c>)
2400f71e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400f722:	bf00      	nop
2400f724:	2400f73d 	.word	0x2400f73d
2400f728:	2400f745 	.word	0x2400f745
2400f72c:	2400f74d 	.word	0x2400f74d
2400f730:	2400f755 	.word	0x2400f755
2400f734:	2400f75d 	.word	0x2400f75d
2400f738:	2400f765 	.word	0x2400f765
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = pCallback;
2400f73c:	68fb      	ldr	r3, [r7, #12]
2400f73e:	687a      	ldr	r2, [r7, #4]
2400f740:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400f742:	e017      	b.n	2400f774 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = pCallback;
2400f744:	68fb      	ldr	r3, [r7, #12]
2400f746:	687a      	ldr	r2, [r7, #4]
2400f748:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400f74a:	e013      	b.n	2400f774 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = pCallback;
2400f74c:	68fb      	ldr	r3, [r7, #12]
2400f74e:	687a      	ldr	r2, [r7, #4]
2400f750:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400f752:	e00f      	b.n	2400f774 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = pCallback;
2400f754:	68fb      	ldr	r3, [r7, #12]
2400f756:	687a      	ldr	r2, [r7, #4]
2400f758:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400f75a:	e00b      	b.n	2400f774 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = pCallback;
2400f75c:	68fb      	ldr	r3, [r7, #12]
2400f75e:	687a      	ldr	r2, [r7, #4]
2400f760:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400f762:	e007      	b.n	2400f774 <HAL_MDMA_RegisterCallback+0x9c>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = pCallback;
2400f764:	68fb      	ldr	r3, [r7, #12]
2400f766:	687a      	ldr	r2, [r7, #4]
2400f768:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400f76a:	e003      	b.n	2400f774 <HAL_MDMA_RegisterCallback+0x9c>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
2400f76c:	2301      	movs	r3, #1
2400f76e:	75fb      	strb	r3, [r7, #23]
2400f770:	e000      	b.n	2400f774 <HAL_MDMA_RegisterCallback+0x9c>
      break;
2400f772:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400f774:	68fb      	ldr	r3, [r7, #12]
2400f776:	2200      	movs	r2, #0
2400f778:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400f77c:	7dfb      	ldrb	r3, [r7, #23]
}
2400f77e:	4618      	mov	r0, r3
2400f780:	371c      	adds	r7, #28
2400f782:	46bd      	mov	sp, r7
2400f784:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f788:	4770      	bx	lr
2400f78a:	bf00      	nop

2400f78c <HAL_MDMA_UnRegisterCallback>:
  * @param  CallbackID:           User Callback identifier
  *                               a HAL_MDMA_CallbackIDTypeDef ENUM as parameter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_UnRegisterCallback(MDMA_HandleTypeDef *hmdma, HAL_MDMA_CallbackIDTypeDef CallbackID)
{
2400f78c:	b480      	push	{r7}
2400f78e:	b085      	sub	sp, #20
2400f790:	af00      	add	r7, sp, #0
2400f792:	6078      	str	r0, [r7, #4]
2400f794:	460b      	mov	r3, r1
2400f796:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef status = HAL_OK;
2400f798:	2300      	movs	r3, #0
2400f79a:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400f79c:	687b      	ldr	r3, [r7, #4]
2400f79e:	2b00      	cmp	r3, #0
2400f7a0:	d101      	bne.n	2400f7a6 <HAL_MDMA_UnRegisterCallback+0x1a>
  {
    return HAL_ERROR;
2400f7a2:	2301      	movs	r3, #1
2400f7a4:	e059      	b.n	2400f85a <HAL_MDMA_UnRegisterCallback+0xce>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400f7a6:	687b      	ldr	r3, [r7, #4]
2400f7a8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400f7ac:	2b01      	cmp	r3, #1
2400f7ae:	d101      	bne.n	2400f7b4 <HAL_MDMA_UnRegisterCallback+0x28>
2400f7b0:	2302      	movs	r3, #2
2400f7b2:	e052      	b.n	2400f85a <HAL_MDMA_UnRegisterCallback+0xce>
2400f7b4:	687b      	ldr	r3, [r7, #4]
2400f7b6:	2201      	movs	r2, #1
2400f7b8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400f7bc:	687b      	ldr	r3, [r7, #4]
2400f7be:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400f7c2:	b2db      	uxtb	r3, r3
2400f7c4:	2b01      	cmp	r3, #1
2400f7c6:	d141      	bne.n	2400f84c <HAL_MDMA_UnRegisterCallback+0xc0>
  {
    switch (CallbackID)
2400f7c8:	78fb      	ldrb	r3, [r7, #3]
2400f7ca:	2b06      	cmp	r3, #6
2400f7cc:	d83b      	bhi.n	2400f846 <HAL_MDMA_UnRegisterCallback+0xba>
2400f7ce:	a201      	add	r2, pc, #4	; (adr r2, 2400f7d4 <HAL_MDMA_UnRegisterCallback+0x48>)
2400f7d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
2400f7d4:	2400f7f1 	.word	0x2400f7f1
2400f7d8:	2400f7f9 	.word	0x2400f7f9
2400f7dc:	2400f801 	.word	0x2400f801
2400f7e0:	2400f809 	.word	0x2400f809
2400f7e4:	2400f811 	.word	0x2400f811
2400f7e8:	2400f819 	.word	0x2400f819
2400f7ec:	2400f821 	.word	0x2400f821
    {
    case  HAL_MDMA_XFER_CPLT_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400f7f0:	687b      	ldr	r3, [r7, #4]
2400f7f2:	2200      	movs	r2, #0
2400f7f4:	645a      	str	r2, [r3, #68]	; 0x44
      break;
2400f7f6:	e02b      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_BUFFERCPLT_CB_ID:
      hmdma->XferBufferCpltCallback = NULL;
2400f7f8:	687b      	ldr	r3, [r7, #4]
2400f7fa:	2200      	movs	r2, #0
2400f7fc:	649a      	str	r2, [r3, #72]	; 0x48
      break;
2400f7fe:	e027      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_BLOCKCPLT_CB_ID:
      hmdma->XferBlockCpltCallback = NULL;
2400f800:	687b      	ldr	r3, [r7, #4]
2400f802:	2200      	movs	r2, #0
2400f804:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
2400f806:	e023      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_REPBLOCKCPLT_CB_ID:
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400f808:	687b      	ldr	r3, [r7, #4]
2400f80a:	2200      	movs	r2, #0
2400f80c:	651a      	str	r2, [r3, #80]	; 0x50
      break;
2400f80e:	e01f      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_ERROR_CB_ID:
      hmdma->XferErrorCallback = NULL;
2400f810:	687b      	ldr	r3, [r7, #4]
2400f812:	2200      	movs	r2, #0
2400f814:	655a      	str	r2, [r3, #84]	; 0x54
      break;
2400f816:	e01b      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>

    case  HAL_MDMA_XFER_ABORT_CB_ID:
      hmdma->XferAbortCallback = NULL;
2400f818:	687b      	ldr	r3, [r7, #4]
2400f81a:	2200      	movs	r2, #0
2400f81c:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400f81e:	e017      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>

    case   HAL_MDMA_XFER_ALL_CB_ID:
      hmdma->XferCpltCallback = NULL;
2400f820:	687b      	ldr	r3, [r7, #4]
2400f822:	2200      	movs	r2, #0
2400f824:	645a      	str	r2, [r3, #68]	; 0x44
      hmdma->XferBufferCpltCallback = NULL;
2400f826:	687b      	ldr	r3, [r7, #4]
2400f828:	2200      	movs	r2, #0
2400f82a:	649a      	str	r2, [r3, #72]	; 0x48
      hmdma->XferBlockCpltCallback = NULL;
2400f82c:	687b      	ldr	r3, [r7, #4]
2400f82e:	2200      	movs	r2, #0
2400f830:	64da      	str	r2, [r3, #76]	; 0x4c
      hmdma->XferRepeatBlockCpltCallback = NULL;
2400f832:	687b      	ldr	r3, [r7, #4]
2400f834:	2200      	movs	r2, #0
2400f836:	651a      	str	r2, [r3, #80]	; 0x50
      hmdma->XferErrorCallback = NULL;
2400f838:	687b      	ldr	r3, [r7, #4]
2400f83a:	2200      	movs	r2, #0
2400f83c:	655a      	str	r2, [r3, #84]	; 0x54
      hmdma->XferAbortCallback = NULL;
2400f83e:	687b      	ldr	r3, [r7, #4]
2400f840:	2200      	movs	r2, #0
2400f842:	659a      	str	r2, [r3, #88]	; 0x58
      break;
2400f844:	e004      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>

    default:
      status = HAL_ERROR;
2400f846:	2301      	movs	r3, #1
2400f848:	73fb      	strb	r3, [r7, #15]
      break;
2400f84a:	e001      	b.n	2400f850 <HAL_MDMA_UnRegisterCallback+0xc4>
    }
  }
  else
  {
    status = HAL_ERROR;
2400f84c:	2301      	movs	r3, #1
2400f84e:	73fb      	strb	r3, [r7, #15]
  }

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
2400f850:	687b      	ldr	r3, [r7, #4]
2400f852:	2200      	movs	r2, #0
2400f854:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
2400f858:	7bfb      	ldrb	r3, [r7, #15]
}
2400f85a:	4618      	mov	r0, r3
2400f85c:	3714      	adds	r7, #20
2400f85e:	46bd      	mov	sp, r7
2400f860:	f85d 7b04 	ldr.w	r7, [sp], #4
2400f864:	4770      	bx	lr
2400f866:	bf00      	nop

2400f868 <HAL_MDMA_LinkedList_CreateNode>:
  * @param  pNodeConfig: Pointer to a MDMA_LinkNodeConfTypeDef structure that contains
  *               the configuration information for the specified MDMA Linked List Node.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_CreateNode(MDMA_LinkNodeTypeDef *pNode, MDMA_LinkNodeConfTypeDef *pNodeConfig)
{
2400f868:	b480      	push	{r7}
2400f86a:	b085      	sub	sp, #20
2400f86c:	af00      	add	r7, sp, #0
2400f86e:	6078      	str	r0, [r7, #4]
2400f870:	6039      	str	r1, [r7, #0]
  uint32_t addressMask;
  uint32_t blockoffset;

  /* Check the MDMA peripheral state */
  if((pNode == NULL) || (pNodeConfig == NULL))
2400f872:	687b      	ldr	r3, [r7, #4]
2400f874:	2b00      	cmp	r3, #0
2400f876:	d002      	beq.n	2400f87e <HAL_MDMA_LinkedList_CreateNode+0x16>
2400f878:	683b      	ldr	r3, [r7, #0]
2400f87a:	2b00      	cmp	r3, #0
2400f87c:	d101      	bne.n	2400f882 <HAL_MDMA_LinkedList_CreateNode+0x1a>
  {
    return HAL_ERROR;
2400f87e:	2301      	movs	r3, #1
2400f880:	e0c8      	b.n	2400fa14 <HAL_MDMA_LinkedList_CreateNode+0x1ac>
  assert_param(IS_MDMA_TRANSFER_LENGTH(pNodeConfig->BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(pNodeConfig->BlockCount));


  /* Configure next Link node Address Register to zero */
  pNode->CLAR =  0;
2400f882:	687b      	ldr	r3, [r7, #4]
2400f884:	2200      	movs	r2, #0
2400f886:	615a      	str	r2, [r3, #20]

  /* Configure the Link Node registers*/
  pNode->CTBR   = 0;
2400f888:	687b      	ldr	r3, [r7, #4]
2400f88a:	2200      	movs	r2, #0
2400f88c:	619a      	str	r2, [r3, #24]
  pNode->CMAR   = 0;
2400f88e:	687b      	ldr	r3, [r7, #4]
2400f890:	2200      	movs	r2, #0
2400f892:	621a      	str	r2, [r3, #32]
  pNode->CMDR   = 0;
2400f894:	687b      	ldr	r3, [r7, #4]
2400f896:	2200      	movs	r2, #0
2400f898:	625a      	str	r2, [r3, #36]	; 0x24
  pNode->Reserved = 0;
2400f89a:	687b      	ldr	r3, [r7, #4]
2400f89c:	2200      	movs	r2, #0
2400f89e:	61da      	str	r2, [r3, #28]

  /* Write new CTCR Register value */
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400f8a0:	683b      	ldr	r3, [r7, #0]
2400f8a2:	691a      	ldr	r2, [r3, #16]
2400f8a4:	683b      	ldr	r3, [r7, #0]
2400f8a6:	695b      	ldr	r3, [r3, #20]
2400f8a8:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400f8aa:	683b      	ldr	r3, [r7, #0]
2400f8ac:	699b      	ldr	r3, [r3, #24]
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400f8ae:	431a      	orrs	r2, r3
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400f8b0:	683b      	ldr	r3, [r7, #0]
2400f8b2:	69db      	ldr	r3, [r3, #28]
2400f8b4:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400f8b6:	683b      	ldr	r3, [r7, #0]
2400f8b8:	6a1b      	ldr	r3, [r3, #32]
    pNodeConfig->Init.SourceDataSize | pNodeConfig->Init.DestDataSize           | \
2400f8ba:	431a      	orrs	r2, r3
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400f8bc:	683b      	ldr	r3, [r7, #0]
2400f8be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2400f8c0:	431a      	orrs	r2, r3
        pNodeConfig->Init.DestBurst                                             | \
2400f8c2:	683b      	ldr	r3, [r7, #0]
2400f8c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      pNodeConfig->Init.DataAlignment| pNodeConfig->Init.SourceBurst            | \
2400f8c6:	431a      	orrs	r2, r3
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400f8c8:	683b      	ldr	r3, [r7, #0]
2400f8ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400f8cc:	3b01      	subs	r3, #1
2400f8ce:	049b      	lsls	r3, r3, #18
        pNodeConfig->Init.DestBurst                                             | \
2400f8d0:	431a      	orrs	r2, r3
            pNodeConfig->Init.TransferTriggerMode;
2400f8d2:	683b      	ldr	r3, [r7, #0]
2400f8d4:	685b      	ldr	r3, [r3, #4]
          ((pNodeConfig->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
2400f8d6:	431a      	orrs	r2, r3
  pNode->CTCR =  pNodeConfig->Init.SourceInc | pNodeConfig->Init.DestinationInc | \
2400f8d8:	687b      	ldr	r3, [r7, #4]
2400f8da:	601a      	str	r2, [r3, #0]

  /* If SW request set the CTCR register to SW Request Mode*/
  if(pNodeConfig->Init.Request == MDMA_REQUEST_SW)
2400f8dc:	683b      	ldr	r3, [r7, #0]
2400f8de:	681b      	ldr	r3, [r3, #0]
2400f8e0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400f8e4:	d105      	bne.n	2400f8f2 <HAL_MDMA_LinkedList_CreateNode+0x8a>
  {
    pNode->CTCR |= MDMA_CTCR_SWRM;
2400f8e6:	687b      	ldr	r3, [r7, #4]
2400f8e8:	681b      	ldr	r3, [r3, #0]
2400f8ea:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
2400f8ee:	687b      	ldr	r3, [r7, #4]
2400f8f0:	601a      	str	r2, [r3, #0]
  -If the request is done by SW : BWM could be set to 1 or 0.
  -If the request is done by a peripheral :
     If mask address not set (0) => BWM must be set to 0
     If mask address set (different than 0) => BWM could be set to 1 or 0
  */
  if((pNodeConfig->Init.Request == MDMA_REQUEST_SW) || (pNodeConfig->PostRequestMaskAddress != 0U))
2400f8f2:	683b      	ldr	r3, [r7, #0]
2400f8f4:	681b      	ldr	r3, [r3, #0]
2400f8f6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400f8fa:	d003      	beq.n	2400f904 <HAL_MDMA_LinkedList_CreateNode+0x9c>
2400f8fc:	683b      	ldr	r3, [r7, #0]
2400f8fe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400f900:	2b00      	cmp	r3, #0
2400f902:	d005      	beq.n	2400f910 <HAL_MDMA_LinkedList_CreateNode+0xa8>
  {
    pNode->CTCR |=  MDMA_CTCR_BWM;
2400f904:	687b      	ldr	r3, [r7, #4]
2400f906:	681b      	ldr	r3, [r3, #0]
2400f908:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
2400f90c:	687b      	ldr	r3, [r7, #4]
2400f90e:	601a      	str	r2, [r3, #0]
  }

  /* Set the new CBNDTR Register value */
  pNode->CBNDTR = ((pNodeConfig->BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC;
2400f910:	683b      	ldr	r3, [r7, #0]
2400f912:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2400f914:	3b01      	subs	r3, #1
2400f916:	051a      	lsls	r2, r3, #20
2400f918:	687b      	ldr	r3, [r7, #4]
2400f91a:	605a      	str	r2, [r3, #4]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(pNodeConfig->Init.SourceBlockAddressOffset < 0)
2400f91c:	683b      	ldr	r3, [r7, #0]
2400f91e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400f920:	2b00      	cmp	r3, #0
2400f922:	da0e      	bge.n	2400f942 <HAL_MDMA_LinkedList_CreateNode+0xda>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRSUM;
2400f924:	687b      	ldr	r3, [r7, #4]
2400f926:	685b      	ldr	r3, [r3, #4]
2400f928:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
2400f92c:	687b      	ldr	r3, [r7, #4]
2400f92e:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.SourceBlockAddressOffset);
2400f930:	683b      	ldr	r3, [r7, #0]
2400f932:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400f934:	425b      	negs	r3, r3
2400f936:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR = blockoffset & 0x0000FFFFU;
2400f938:	68fb      	ldr	r3, [r7, #12]
2400f93a:	b29a      	uxth	r2, r3
2400f93c:	687b      	ldr	r3, [r7, #4]
2400f93e:	611a      	str	r2, [r3, #16]
2400f940:	e004      	b.n	2400f94c <HAL_MDMA_LinkedList_CreateNode+0xe4>
  }
  else
  {
    /*write new CBRUR Register value : source repeat block offset */
    pNode->CBRUR = (((uint32_t) pNodeConfig->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
2400f942:	683b      	ldr	r3, [r7, #0]
2400f944:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2400f946:	b29a      	uxth	r2, r3
2400f948:	687b      	ldr	r3, [r7, #4]
2400f94a:	611a      	str	r2, [r3, #16]
  }

  /* if block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(pNodeConfig->Init.DestBlockAddressOffset < 0)
2400f94c:	683b      	ldr	r3, [r7, #0]
2400f94e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f950:	2b00      	cmp	r3, #0
2400f952:	da11      	bge.n	2400f978 <HAL_MDMA_LinkedList_CreateNode+0x110>
  {
    pNode->CBNDTR |= MDMA_CBNDTR_BRDUM;
2400f954:	687b      	ldr	r3, [r7, #4]
2400f956:	685b      	ldr	r3, [r3, #4]
2400f958:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
2400f95c:	687b      	ldr	r3, [r7, #4]
2400f95e:	605a      	str	r2, [r3, #4]
    /*write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- pNodeConfig->Init.DestBlockAddressOffset);
2400f960:	683b      	ldr	r3, [r7, #0]
2400f962:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f964:	425b      	negs	r3, r3
2400f966:	60fb      	str	r3, [r7, #12]
    pNode->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400f968:	687b      	ldr	r3, [r7, #4]
2400f96a:	691a      	ldr	r2, [r3, #16]
2400f96c:	68fb      	ldr	r3, [r7, #12]
2400f96e:	041b      	lsls	r3, r3, #16
2400f970:	431a      	orrs	r2, r3
2400f972:	687b      	ldr	r3, [r7, #4]
2400f974:	611a      	str	r2, [r3, #16]
2400f976:	e007      	b.n	2400f988 <HAL_MDMA_LinkedList_CreateNode+0x120>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    pNode->CBRUR |= ((((uint32_t)pNodeConfig->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
2400f978:	687b      	ldr	r3, [r7, #4]
2400f97a:	691a      	ldr	r2, [r3, #16]
2400f97c:	683b      	ldr	r3, [r7, #0]
2400f97e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2400f980:	041b      	lsls	r3, r3, #16
2400f982:	431a      	orrs	r2, r3
2400f984:	687b      	ldr	r3, [r7, #4]
2400f986:	611a      	str	r2, [r3, #16]
  }

  /* Configure MDMA Link Node data length */
  pNode->CBNDTR |=  pNodeConfig->BlockDataLength;
2400f988:	687b      	ldr	r3, [r7, #4]
2400f98a:	685a      	ldr	r2, [r3, #4]
2400f98c:	683b      	ldr	r3, [r7, #0]
2400f98e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2400f990:	431a      	orrs	r2, r3
2400f992:	687b      	ldr	r3, [r7, #4]
2400f994:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Link Node destination address */
  pNode->CDAR = pNodeConfig->DstAddress;
2400f996:	683b      	ldr	r3, [r7, #0]
2400f998:	6bda      	ldr	r2, [r3, #60]	; 0x3c
2400f99a:	687b      	ldr	r3, [r7, #4]
2400f99c:	60da      	str	r2, [r3, #12]

  /* Configure MDMA Link Node Source address */
  pNode->CSAR = pNodeConfig->SrcAddress;
2400f99e:	683b      	ldr	r3, [r7, #0]
2400f9a0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
2400f9a2:	687b      	ldr	r3, [r7, #4]
2400f9a4:	609a      	str	r2, [r3, #8]

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData,  */
  if(pNodeConfig->Init.Request != MDMA_REQUEST_SW)
2400f9a6:	683b      	ldr	r3, [r7, #0]
2400f9a8:	681b      	ldr	r3, [r3, #0]
2400f9aa:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400f9ae:	d00c      	beq.n	2400f9ca <HAL_MDMA_LinkedList_CreateNode+0x162>
  {
    /* Set the HW request in CTBR register  */
    pNode->CTBR = pNodeConfig->Init.Request & MDMA_CTBR_TSEL;
2400f9b0:	683b      	ldr	r3, [r7, #0]
2400f9b2:	681b      	ldr	r3, [r3, #0]
2400f9b4:	b2da      	uxtb	r2, r3
2400f9b6:	687b      	ldr	r3, [r7, #4]
2400f9b8:	619a      	str	r2, [r3, #24]
    /* Set the HW request clear Mask and Data */
    pNode->CMAR = pNodeConfig->PostRequestMaskAddress;
2400f9ba:	683b      	ldr	r3, [r7, #0]
2400f9bc:	6c9a      	ldr	r2, [r3, #72]	; 0x48
2400f9be:	687b      	ldr	r3, [r7, #4]
2400f9c0:	621a      	str	r2, [r3, #32]
    pNode->CMDR = pNodeConfig->PostRequestMaskData;
2400f9c2:	683b      	ldr	r3, [r7, #0]
2400f9c4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
2400f9c6:	687b      	ldr	r3, [r7, #4]
2400f9c8:	625a      	str	r2, [r3, #36]	; 0x24
  }

  addressMask = pNodeConfig->SrcAddress & 0xFF000000U;
2400f9ca:	683b      	ldr	r3, [r7, #0]
2400f9cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2400f9ce:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400f9d2:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400f9d4:	68bb      	ldr	r3, [r7, #8]
2400f9d6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400f9da:	d002      	beq.n	2400f9e2 <HAL_MDMA_LinkedList_CreateNode+0x17a>
2400f9dc:	68bb      	ldr	r3, [r7, #8]
2400f9de:	2b00      	cmp	r3, #0
2400f9e0:	d105      	bne.n	2400f9ee <HAL_MDMA_LinkedList_CreateNode+0x186>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_SBUS;
2400f9e2:	687b      	ldr	r3, [r7, #4]
2400f9e4:	699b      	ldr	r3, [r3, #24]
2400f9e6:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
2400f9ea:	687b      	ldr	r3, [r7, #4]
2400f9ec:	619a      	str	r2, [r3, #24]
  }

  addressMask = pNodeConfig->DstAddress & 0xFF000000U;
2400f9ee:	683b      	ldr	r3, [r7, #0]
2400f9f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2400f9f2:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
2400f9f6:	60bb      	str	r3, [r7, #8]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2400f9f8:	68bb      	ldr	r3, [r7, #8]
2400f9fa:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2400f9fe:	d002      	beq.n	2400fa06 <HAL_MDMA_LinkedList_CreateNode+0x19e>
2400fa00:	68bb      	ldr	r3, [r7, #8]
2400fa02:	2b00      	cmp	r3, #0
2400fa04:	d105      	bne.n	2400fa12 <HAL_MDMA_LinkedList_CreateNode+0x1aa>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    pNode->CTBR |= MDMA_CTBR_DBUS;
2400fa06:	687b      	ldr	r3, [r7, #4]
2400fa08:	699b      	ldr	r3, [r3, #24]
2400fa0a:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
2400fa0e:	687b      	ldr	r3, [r7, #4]
2400fa10:	619a      	str	r2, [r3, #24]
  }

  return HAL_OK;
2400fa12:	2300      	movs	r3, #0
}
2400fa14:	4618      	mov	r0, r3
2400fa16:	3714      	adds	r7, #20
2400fa18:	46bd      	mov	sp, r7
2400fa1a:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fa1e:	4770      	bx	lr

2400fa20 <HAL_MDMA_LinkedList_AddNode>:
  *                    at the end of the list
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_AddNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNewNode, MDMA_LinkNodeTypeDef *pPrevNode)
{
2400fa20:	b480      	push	{r7}
2400fa22:	b089      	sub	sp, #36	; 0x24
2400fa24:	af00      	add	r7, sp, #0
2400fa26:	60f8      	str	r0, [r7, #12]
2400fa28:	60b9      	str	r1, [r7, #8]
2400fa2a:	607a      	str	r2, [r7, #4]
  MDMA_LinkNodeTypeDef *pNode;
  uint32_t counter = 0, nodeInserted = 0;
2400fa2c:	2300      	movs	r3, #0
2400fa2e:	61bb      	str	r3, [r7, #24]
2400fa30:	2300      	movs	r3, #0
2400fa32:	617b      	str	r3, [r7, #20]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400fa34:	2300      	movs	r3, #0
2400fa36:	74fb      	strb	r3, [r7, #19]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNewNode == NULL))
2400fa38:	68fb      	ldr	r3, [r7, #12]
2400fa3a:	2b00      	cmp	r3, #0
2400fa3c:	d002      	beq.n	2400fa44 <HAL_MDMA_LinkedList_AddNode+0x24>
2400fa3e:	68bb      	ldr	r3, [r7, #8]
2400fa40:	2b00      	cmp	r3, #0
2400fa42:	d101      	bne.n	2400fa48 <HAL_MDMA_LinkedList_AddNode+0x28>
  {
    return HAL_ERROR;
2400fa44:	2301      	movs	r3, #1
2400fa46:	e0a9      	b.n	2400fb9c <HAL_MDMA_LinkedList_AddNode+0x17c>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fa48:	68fb      	ldr	r3, [r7, #12]
2400fa4a:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fa4e:	2b01      	cmp	r3, #1
2400fa50:	d101      	bne.n	2400fa56 <HAL_MDMA_LinkedList_AddNode+0x36>
2400fa52:	2302      	movs	r3, #2
2400fa54:	e0a2      	b.n	2400fb9c <HAL_MDMA_LinkedList_AddNode+0x17c>
2400fa56:	68fb      	ldr	r3, [r7, #12]
2400fa58:	2201      	movs	r2, #1
2400fa5a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fa5e:	68fb      	ldr	r3, [r7, #12]
2400fa60:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fa64:	b2db      	uxtb	r3, r3
2400fa66:	2b01      	cmp	r3, #1
2400fa68:	f040 8093 	bne.w	2400fb92 <HAL_MDMA_LinkedList_AddNode+0x172>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400fa6c:	68fb      	ldr	r3, [r7, #12]
2400fa6e:	2202      	movs	r2, #2
2400fa70:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Check if this is the first node (after the Inititlization node) */
    if((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U)
2400fa74:	68fb      	ldr	r3, [r7, #12]
2400fa76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fa78:	2b00      	cmp	r3, #0
2400fa7a:	d116      	bne.n	2400faaa <HAL_MDMA_LinkedList_AddNode+0x8a>
    {
      if(pPrevNode == NULL)
2400fa7c:	687b      	ldr	r3, [r7, #4]
2400fa7e:	2b00      	cmp	r3, #0
2400fa80:	d110      	bne.n	2400faa4 <HAL_MDMA_LinkedList_AddNode+0x84>
      {
        /* if this is the first node after the initialization
        connect this node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = (uint32_t)pNewNode;
2400fa82:	68fb      	ldr	r3, [r7, #12]
2400fa84:	681b      	ldr	r3, [r3, #0]
2400fa86:	68ba      	ldr	r2, [r7, #8]
2400fa88:	625a      	str	r2, [r3, #36]	; 0x24
        /* Set the MDMA handle First linked List node*/
        hmdma->FirstLinkedListNodeAddress = pNewNode;
2400fa8a:	68fb      	ldr	r3, [r7, #12]
2400fa8c:	68ba      	ldr	r2, [r7, #8]
2400fa8e:	65da      	str	r2, [r3, #92]	; 0x5c

        /*reset New node link */
        pNewNode->CLAR = 0;
2400fa90:	68bb      	ldr	r3, [r7, #8]
2400fa92:	2200      	movs	r2, #0
2400fa94:	615a      	str	r2, [r3, #20]

        /* Update the Handle last node address */
        hmdma->LastLinkedListNodeAddress = pNewNode;
2400fa96:	68fb      	ldr	r3, [r7, #12]
2400fa98:	68ba      	ldr	r2, [r7, #8]
2400fa9a:	661a      	str	r2, [r3, #96]	; 0x60

        hmdma->LinkedListNodeCounter = 1;
2400fa9c:	68fb      	ldr	r3, [r7, #12]
2400fa9e:	2201      	movs	r2, #1
2400faa0:	665a      	str	r2, [r3, #100]	; 0x64
2400faa2:	e06c      	b.n	2400fb7e <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
      else
      {
        hal_status = HAL_ERROR;
2400faa4:	2301      	movs	r3, #1
2400faa6:	74fb      	strb	r3, [r7, #19]
2400faa8:	e069      	b.n	2400fb7e <HAL_MDMA_LinkedList_AddNode+0x15e>
      }
    }
    else if(hmdma->FirstLinkedListNodeAddress != pNewNode)
2400faaa:	68fb      	ldr	r3, [r7, #12]
2400faac:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400faae:	68ba      	ldr	r2, [r7, #8]
2400fab0:	429a      	cmp	r2, r3
2400fab2:	d062      	beq.n	2400fb7a <HAL_MDMA_LinkedList_AddNode+0x15a>
    {
      /* Check if the node to insert already exists*/
      pNode = hmdma->FirstLinkedListNodeAddress;
2400fab4:	68fb      	ldr	r3, [r7, #12]
2400fab6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fab8:	61fb      	str	r3, [r7, #28]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400faba:	e00c      	b.n	2400fad6 <HAL_MDMA_LinkedList_AddNode+0xb6>
      {
        if(pNode->CLAR == (uint32_t)pNewNode)
2400fabc:	69fb      	ldr	r3, [r7, #28]
2400fabe:	695a      	ldr	r2, [r3, #20]
2400fac0:	68bb      	ldr	r3, [r7, #8]
2400fac2:	429a      	cmp	r2, r3
2400fac4:	d101      	bne.n	2400faca <HAL_MDMA_LinkedList_AddNode+0xaa>
        {
          hal_status = HAL_ERROR; /* error this node already exist in the linked list and it is not first node */
2400fac6:	2301      	movs	r3, #1
2400fac8:	74fb      	strb	r3, [r7, #19]
        }
        pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400faca:	69fb      	ldr	r3, [r7, #28]
2400facc:	695b      	ldr	r3, [r3, #20]
2400face:	61fb      	str	r3, [r7, #28]
        counter++;
2400fad0:	69bb      	ldr	r3, [r7, #24]
2400fad2:	3301      	adds	r3, #1
2400fad4:	61bb      	str	r3, [r7, #24]
      while((counter < hmdma->LinkedListNodeCounter) && (hal_status == HAL_OK))
2400fad6:	68fb      	ldr	r3, [r7, #12]
2400fad8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fada:	69ba      	ldr	r2, [r7, #24]
2400fadc:	429a      	cmp	r2, r3
2400fade:	d202      	bcs.n	2400fae6 <HAL_MDMA_LinkedList_AddNode+0xc6>
2400fae0:	7cfb      	ldrb	r3, [r7, #19]
2400fae2:	2b00      	cmp	r3, #0
2400fae4:	d0ea      	beq.n	2400fabc <HAL_MDMA_LinkedList_AddNode+0x9c>
      }

      if(hal_status == HAL_OK)
2400fae6:	7cfb      	ldrb	r3, [r7, #19]
2400fae8:	2b00      	cmp	r3, #0
2400faea:	d148      	bne.n	2400fb7e <HAL_MDMA_LinkedList_AddNode+0x15e>
      {
        /* Check if the previous node is the last one in the current list or zero */
        if((pPrevNode == hmdma->LastLinkedListNodeAddress) || (pPrevNode == NULL))
2400faec:	68fb      	ldr	r3, [r7, #12]
2400faee:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400faf0:	687a      	ldr	r2, [r7, #4]
2400faf2:	429a      	cmp	r2, r3
2400faf4:	d002      	beq.n	2400fafc <HAL_MDMA_LinkedList_AddNode+0xdc>
2400faf6:	687b      	ldr	r3, [r7, #4]
2400faf8:	2b00      	cmp	r3, #0
2400fafa:	d111      	bne.n	2400fb20 <HAL_MDMA_LinkedList_AddNode+0x100>
        {
          /* insert the new node at the end of the list */
          pNewNode->CLAR = hmdma->LastLinkedListNodeAddress->CLAR;
2400fafc:	68fb      	ldr	r3, [r7, #12]
2400fafe:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fb00:	695a      	ldr	r2, [r3, #20]
2400fb02:	68bb      	ldr	r3, [r7, #8]
2400fb04:	615a      	str	r2, [r3, #20]
          hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)pNewNode;
2400fb06:	68fb      	ldr	r3, [r7, #12]
2400fb08:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fb0a:	68ba      	ldr	r2, [r7, #8]
2400fb0c:	615a      	str	r2, [r3, #20]
          /* Update the Handle last node address */
          hmdma->LastLinkedListNodeAddress = pNewNode;
2400fb0e:	68fb      	ldr	r3, [r7, #12]
2400fb10:	68ba      	ldr	r2, [r7, #8]
2400fb12:	661a      	str	r2, [r3, #96]	; 0x60
          /* Increment the linked list node counter */
          hmdma->LinkedListNodeCounter++;
2400fb14:	68fb      	ldr	r3, [r7, #12]
2400fb16:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fb18:	1c5a      	adds	r2, r3, #1
2400fb1a:	68fb      	ldr	r3, [r7, #12]
2400fb1c:	665a      	str	r2, [r3, #100]	; 0x64
2400fb1e:	e02e      	b.n	2400fb7e <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
        else
        {
          /*insert the new node after the pPreviousNode node */
          pNode = hmdma->FirstLinkedListNodeAddress;
2400fb20:	68fb      	ldr	r3, [r7, #12]
2400fb22:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fb24:	61fb      	str	r3, [r7, #28]
          counter = 0;
2400fb26:	2300      	movs	r3, #0
2400fb28:	61bb      	str	r3, [r7, #24]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400fb2a:	e018      	b.n	2400fb5e <HAL_MDMA_LinkedList_AddNode+0x13e>
          {
            counter++;
2400fb2c:	69bb      	ldr	r3, [r7, #24]
2400fb2e:	3301      	adds	r3, #1
2400fb30:	61bb      	str	r3, [r7, #24]
            if(pNode == pPrevNode)
2400fb32:	69fa      	ldr	r2, [r7, #28]
2400fb34:	687b      	ldr	r3, [r7, #4]
2400fb36:	429a      	cmp	r2, r3
2400fb38:	d10e      	bne.n	2400fb58 <HAL_MDMA_LinkedList_AddNode+0x138>
            {
              /*Insert the new node after the previous one */
              pNewNode->CLAR = pNode->CLAR;
2400fb3a:	69fb      	ldr	r3, [r7, #28]
2400fb3c:	695a      	ldr	r2, [r3, #20]
2400fb3e:	68bb      	ldr	r3, [r7, #8]
2400fb40:	615a      	str	r2, [r3, #20]
              pNode->CLAR = (uint32_t)pNewNode;
2400fb42:	68ba      	ldr	r2, [r7, #8]
2400fb44:	69fb      	ldr	r3, [r7, #28]
2400fb46:	615a      	str	r2, [r3, #20]
              /* Increment the linked list node counter */
              hmdma->LinkedListNodeCounter++;
2400fb48:	68fb      	ldr	r3, [r7, #12]
2400fb4a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fb4c:	1c5a      	adds	r2, r3, #1
2400fb4e:	68fb      	ldr	r3, [r7, #12]
2400fb50:	665a      	str	r2, [r3, #100]	; 0x64
              nodeInserted = 1;
2400fb52:	2301      	movs	r3, #1
2400fb54:	617b      	str	r3, [r7, #20]
2400fb56:	e002      	b.n	2400fb5e <HAL_MDMA_LinkedList_AddNode+0x13e>
            }
            else
            {
              pNode = (MDMA_LinkNodeTypeDef *)pNode->CLAR;
2400fb58:	69fb      	ldr	r3, [r7, #28]
2400fb5a:	695b      	ldr	r3, [r3, #20]
2400fb5c:	61fb      	str	r3, [r7, #28]
          while((counter < hmdma->LinkedListNodeCounter) && (nodeInserted == 0U))
2400fb5e:	68fb      	ldr	r3, [r7, #12]
2400fb60:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fb62:	69ba      	ldr	r2, [r7, #24]
2400fb64:	429a      	cmp	r2, r3
2400fb66:	d202      	bcs.n	2400fb6e <HAL_MDMA_LinkedList_AddNode+0x14e>
2400fb68:	697b      	ldr	r3, [r7, #20]
2400fb6a:	2b00      	cmp	r3, #0
2400fb6c:	d0de      	beq.n	2400fb2c <HAL_MDMA_LinkedList_AddNode+0x10c>
            }
          }

          if(nodeInserted == 0U)
2400fb6e:	697b      	ldr	r3, [r7, #20]
2400fb70:	2b00      	cmp	r3, #0
2400fb72:	d104      	bne.n	2400fb7e <HAL_MDMA_LinkedList_AddNode+0x15e>
          {
            hal_status = HAL_ERROR;
2400fb74:	2301      	movs	r3, #1
2400fb76:	74fb      	strb	r3, [r7, #19]
2400fb78:	e001      	b.n	2400fb7e <HAL_MDMA_LinkedList_AddNode+0x15e>
        }
      }
    }
    else
    {
      hal_status = HAL_ERROR;
2400fb7a:	2301      	movs	r3, #1
2400fb7c:	74fb      	strb	r3, [r7, #19]
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400fb7e:	68fb      	ldr	r3, [r7, #12]
2400fb80:	2200      	movs	r2, #0
2400fb82:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400fb86:	68fb      	ldr	r3, [r7, #12]
2400fb88:	2201      	movs	r2, #1
2400fb8a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
2400fb8e:	7cfb      	ldrb	r3, [r7, #19]
2400fb90:	e004      	b.n	2400fb9c <HAL_MDMA_LinkedList_AddNode+0x17c>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400fb92:	68fb      	ldr	r3, [r7, #12]
2400fb94:	2200      	movs	r2, #0
2400fb96:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400fb9a:	2302      	movs	r3, #2
  }
}
2400fb9c:	4618      	mov	r0, r3
2400fb9e:	3724      	adds	r7, #36	; 0x24
2400fba0:	46bd      	mov	sp, r7
2400fba2:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fba6:	4770      	bx	lr

2400fba8 <HAL_MDMA_LinkedList_RemoveNode>:
  *                 to be removed from the list.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_RemoveNode(MDMA_HandleTypeDef *hmdma, MDMA_LinkNodeTypeDef *pNode)
{
2400fba8:	b480      	push	{r7}
2400fbaa:	b087      	sub	sp, #28
2400fbac:	af00      	add	r7, sp, #0
2400fbae:	6078      	str	r0, [r7, #4]
2400fbb0:	6039      	str	r1, [r7, #0]
  MDMA_LinkNodeTypeDef *ptmpNode;
  uint32_t counter = 0, nodeDeleted = 0;
2400fbb2:	2300      	movs	r3, #0
2400fbb4:	613b      	str	r3, [r7, #16]
2400fbb6:	2300      	movs	r3, #0
2400fbb8:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400fbba:	2300      	movs	r3, #0
2400fbbc:	72fb      	strb	r3, [r7, #11]

  /* Check the MDMA peripheral handle */
  if((hmdma == NULL) || (pNode == NULL))
2400fbbe:	687b      	ldr	r3, [r7, #4]
2400fbc0:	2b00      	cmp	r3, #0
2400fbc2:	d002      	beq.n	2400fbca <HAL_MDMA_LinkedList_RemoveNode+0x22>
2400fbc4:	683b      	ldr	r3, [r7, #0]
2400fbc6:	2b00      	cmp	r3, #0
2400fbc8:	d101      	bne.n	2400fbce <HAL_MDMA_LinkedList_RemoveNode+0x26>
  {
    return HAL_ERROR;
2400fbca:	2301      	movs	r3, #1
2400fbcc:	e099      	b.n	2400fd02 <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fbce:	687b      	ldr	r3, [r7, #4]
2400fbd0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fbd4:	2b01      	cmp	r3, #1
2400fbd6:	d101      	bne.n	2400fbdc <HAL_MDMA_LinkedList_RemoveNode+0x34>
2400fbd8:	2302      	movs	r3, #2
2400fbda:	e092      	b.n	2400fd02 <HAL_MDMA_LinkedList_RemoveNode+0x15a>
2400fbdc:	687b      	ldr	r3, [r7, #4]
2400fbde:	2201      	movs	r2, #1
2400fbe0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fbe4:	687b      	ldr	r3, [r7, #4]
2400fbe6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fbea:	b2db      	uxtb	r3, r3
2400fbec:	2b01      	cmp	r3, #1
2400fbee:	f040 8083 	bne.w	2400fcf8 <HAL_MDMA_LinkedList_RemoveNode+0x150>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400fbf2:	687b      	ldr	r3, [r7, #4]
2400fbf4:	2202      	movs	r2, #2
2400fbf6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400fbfa:	687b      	ldr	r3, [r7, #4]
2400fbfc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fbfe:	2b00      	cmp	r3, #0
2400fc00:	d007      	beq.n	2400fc12 <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400fc02:	687b      	ldr	r3, [r7, #4]
2400fc04:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fc06:	2b00      	cmp	r3, #0
2400fc08:	d003      	beq.n	2400fc12 <HAL_MDMA_LinkedList_RemoveNode+0x6a>
2400fc0a:	687b      	ldr	r3, [r7, #4]
2400fc0c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fc0e:	2b00      	cmp	r3, #0
2400fc10:	d102      	bne.n	2400fc18 <HAL_MDMA_LinkedList_RemoveNode+0x70>
    {
      hal_status = HAL_ERROR;
2400fc12:	2301      	movs	r3, #1
2400fc14:	72fb      	strb	r3, [r7, #11]
2400fc16:	e065      	b.n	2400fce4 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
    }
    else if(hmdma->FirstLinkedListNodeAddress == pNode) /* Deleting first node */
2400fc18:	687b      	ldr	r3, [r7, #4]
2400fc1a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fc1c:	683a      	ldr	r2, [r7, #0]
2400fc1e:	429a      	cmp	r2, r3
2400fc20:	d130      	bne.n	2400fc84 <HAL_MDMA_LinkedList_RemoveNode+0xdc>
    {
      /* Delete 1st node */
      if(hmdma->LastLinkedListNodeAddress == pNode)
2400fc22:	687b      	ldr	r3, [r7, #4]
2400fc24:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fc26:	683a      	ldr	r2, [r7, #0]
2400fc28:	429a      	cmp	r2, r3
2400fc2a:	d10d      	bne.n	2400fc48 <HAL_MDMA_LinkedList_RemoveNode+0xa0>
      {
        /*if the last node is at the same time the first one (1 single node after the init node 0)
        then update the last node too */

        hmdma->FirstLinkedListNodeAddress = 0;
2400fc2c:	687b      	ldr	r3, [r7, #4]
2400fc2e:	2200      	movs	r2, #0
2400fc30:	65da      	str	r2, [r3, #92]	; 0x5c
        hmdma->LastLinkedListNodeAddress  = 0;
2400fc32:	687b      	ldr	r3, [r7, #4]
2400fc34:	2200      	movs	r2, #0
2400fc36:	661a      	str	r2, [r3, #96]	; 0x60
        hmdma->LinkedListNodeCounter = 0;
2400fc38:	687b      	ldr	r3, [r7, #4]
2400fc3a:	2200      	movs	r2, #0
2400fc3c:	665a      	str	r2, [r3, #100]	; 0x64

        hmdma->Instance->CLAR = 0;
2400fc3e:	687b      	ldr	r3, [r7, #4]
2400fc40:	681b      	ldr	r3, [r3, #0]
2400fc42:	2200      	movs	r2, #0
2400fc44:	625a      	str	r2, [r3, #36]	; 0x24
2400fc46:	e04d      	b.n	2400fce4 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
      else
      {
        if((uint32_t)hmdma->FirstLinkedListNodeAddress == hmdma->LastLinkedListNodeAddress->CLAR)
2400fc48:	687b      	ldr	r3, [r7, #4]
2400fc4a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fc4c:	461a      	mov	r2, r3
2400fc4e:	687b      	ldr	r3, [r7, #4]
2400fc50:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fc52:	695b      	ldr	r3, [r3, #20]
2400fc54:	429a      	cmp	r2, r3
2400fc56:	d104      	bne.n	2400fc62 <HAL_MDMA_LinkedList_RemoveNode+0xba>
        {
          /* if last node is looping to first (circular list) one update the last node connection */
          hmdma->LastLinkedListNodeAddress->CLAR = pNode->CLAR;
2400fc58:	687b      	ldr	r3, [r7, #4]
2400fc5a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fc5c:	683a      	ldr	r2, [r7, #0]
2400fc5e:	6952      	ldr	r2, [r2, #20]
2400fc60:	615a      	str	r2, [r3, #20]
        }

        /* if deleting the first node after the initialization
        connect the next node to the node 0 by updating
        the MDMA channel CLAR register to this node address */
        hmdma->Instance->CLAR = pNode->CLAR;
2400fc62:	687b      	ldr	r3, [r7, #4]
2400fc64:	681b      	ldr	r3, [r3, #0]
2400fc66:	683a      	ldr	r2, [r7, #0]
2400fc68:	6952      	ldr	r2, [r2, #20]
2400fc6a:	625a      	str	r2, [r3, #36]	; 0x24
        hmdma->FirstLinkedListNodeAddress = (MDMA_LinkNodeTypeDef *)hmdma->Instance->CLAR;
2400fc6c:	687b      	ldr	r3, [r7, #4]
2400fc6e:	681b      	ldr	r3, [r3, #0]
2400fc70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2400fc72:	461a      	mov	r2, r3
2400fc74:	687b      	ldr	r3, [r7, #4]
2400fc76:	65da      	str	r2, [r3, #92]	; 0x5c
        /* Update the Handle node counter */
        hmdma->LinkedListNodeCounter--;
2400fc78:	687b      	ldr	r3, [r7, #4]
2400fc7a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fc7c:	1e5a      	subs	r2, r3, #1
2400fc7e:	687b      	ldr	r3, [r7, #4]
2400fc80:	665a      	str	r2, [r3, #100]	; 0x64
2400fc82:	e02f      	b.n	2400fce4 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      }
    }
    else /* Deleting any other node */
    {
      /*Deleted node is not the first one : find it  */
      ptmpNode = hmdma->FirstLinkedListNodeAddress;
2400fc84:	687b      	ldr	r3, [r7, #4]
2400fc86:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fc88:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400fc8a:	e01e      	b.n	2400fcca <HAL_MDMA_LinkedList_RemoveNode+0x122>
      {
        counter++;
2400fc8c:	693b      	ldr	r3, [r7, #16]
2400fc8e:	3301      	adds	r3, #1
2400fc90:	613b      	str	r3, [r7, #16]
        if(ptmpNode->CLAR == ((uint32_t)pNode))
2400fc92:	697b      	ldr	r3, [r7, #20]
2400fc94:	695a      	ldr	r2, [r3, #20]
2400fc96:	683b      	ldr	r3, [r7, #0]
2400fc98:	429a      	cmp	r2, r3
2400fc9a:	d113      	bne.n	2400fcc4 <HAL_MDMA_LinkedList_RemoveNode+0x11c>
        {
          /* if deleting the last node */
          if(pNode == hmdma->LastLinkedListNodeAddress)
2400fc9c:	687b      	ldr	r3, [r7, #4]
2400fc9e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fca0:	683a      	ldr	r2, [r7, #0]
2400fca2:	429a      	cmp	r2, r3
2400fca4:	d102      	bne.n	2400fcac <HAL_MDMA_LinkedList_RemoveNode+0x104>
          {
            /*Update the linked list last node address in the handle*/
            hmdma->LastLinkedListNodeAddress = ptmpNode;
2400fca6:	687b      	ldr	r3, [r7, #4]
2400fca8:	697a      	ldr	r2, [r7, #20]
2400fcaa:	661a      	str	r2, [r3, #96]	; 0x60
          }
          /* update the next node link after deleting pMDMA_LinkedListNode */
          ptmpNode->CLAR = pNode->CLAR;
2400fcac:	683b      	ldr	r3, [r7, #0]
2400fcae:	695a      	ldr	r2, [r3, #20]
2400fcb0:	697b      	ldr	r3, [r7, #20]
2400fcb2:	615a      	str	r2, [r3, #20]
          nodeDeleted = 1;
2400fcb4:	2301      	movs	r3, #1
2400fcb6:	60fb      	str	r3, [r7, #12]
          /* Update the Handle node counter */
          hmdma->LinkedListNodeCounter--;
2400fcb8:	687b      	ldr	r3, [r7, #4]
2400fcba:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fcbc:	1e5a      	subs	r2, r3, #1
2400fcbe:	687b      	ldr	r3, [r7, #4]
2400fcc0:	665a      	str	r2, [r3, #100]	; 0x64
2400fcc2:	e002      	b.n	2400fcca <HAL_MDMA_LinkedList_RemoveNode+0x122>
        }
        else
        {
          ptmpNode = (MDMA_LinkNodeTypeDef *)ptmpNode->CLAR;
2400fcc4:	697b      	ldr	r3, [r7, #20]
2400fcc6:	695b      	ldr	r3, [r3, #20]
2400fcc8:	617b      	str	r3, [r7, #20]
      while((counter < hmdma->LinkedListNodeCounter) && (nodeDeleted == 0U))
2400fcca:	687b      	ldr	r3, [r7, #4]
2400fccc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fcce:	693a      	ldr	r2, [r7, #16]
2400fcd0:	429a      	cmp	r2, r3
2400fcd2:	d202      	bcs.n	2400fcda <HAL_MDMA_LinkedList_RemoveNode+0x132>
2400fcd4:	68fb      	ldr	r3, [r7, #12]
2400fcd6:	2b00      	cmp	r3, #0
2400fcd8:	d0d8      	beq.n	2400fc8c <HAL_MDMA_LinkedList_RemoveNode+0xe4>
        }
      }

      if(nodeDeleted == 0U)
2400fcda:	68fb      	ldr	r3, [r7, #12]
2400fcdc:	2b00      	cmp	r3, #0
2400fcde:	d101      	bne.n	2400fce4 <HAL_MDMA_LinkedList_RemoveNode+0x13c>
      {
        /* last node reashed without finding the node to delete : return error */
        hal_status = HAL_ERROR;
2400fce0:	2301      	movs	r3, #1
2400fce2:	72fb      	strb	r3, [r7, #11]
      }
    }

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400fce4:	687b      	ldr	r3, [r7, #4]
2400fce6:	2200      	movs	r2, #0
2400fce8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
2400fcec:	687b      	ldr	r3, [r7, #4]
2400fcee:	2201      	movs	r2, #1
2400fcf0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    return hal_status;
2400fcf4:	7afb      	ldrb	r3, [r7, #11]
2400fcf6:	e004      	b.n	2400fd02 <HAL_MDMA_LinkedList_RemoveNode+0x15a>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400fcf8:	687b      	ldr	r3, [r7, #4]
2400fcfa:	2200      	movs	r2, #0
2400fcfc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400fd00:	2302      	movs	r3, #2
  }
}
2400fd02:	4618      	mov	r0, r3
2400fd04:	371c      	adds	r7, #28
2400fd06:	46bd      	mov	sp, r7
2400fd08:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fd0c:	4770      	bx	lr

2400fd0e <HAL_MDMA_LinkedList_EnableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_EnableCircularMode(MDMA_HandleTypeDef *hmdma)
{
2400fd0e:	b480      	push	{r7}
2400fd10:	b085      	sub	sp, #20
2400fd12:	af00      	add	r7, sp, #0
2400fd14:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400fd16:	2300      	movs	r3, #0
2400fd18:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400fd1a:	687b      	ldr	r3, [r7, #4]
2400fd1c:	2b00      	cmp	r3, #0
2400fd1e:	d101      	bne.n	2400fd24 <HAL_MDMA_LinkedList_EnableCircularMode+0x16>
  {
    return HAL_ERROR;
2400fd20:	2301      	movs	r3, #1
2400fd22:	e031      	b.n	2400fd88 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fd24:	687b      	ldr	r3, [r7, #4]
2400fd26:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fd2a:	2b01      	cmp	r3, #1
2400fd2c:	d101      	bne.n	2400fd32 <HAL_MDMA_LinkedList_EnableCircularMode+0x24>
2400fd2e:	2302      	movs	r3, #2
2400fd30:	e02a      	b.n	2400fd88 <HAL_MDMA_LinkedList_EnableCircularMode+0x7a>
2400fd32:	687b      	ldr	r3, [r7, #4]
2400fd34:	2201      	movs	r2, #1
2400fd36:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fd3a:	687b      	ldr	r3, [r7, #4]
2400fd3c:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fd40:	b2db      	uxtb	r3, r3
2400fd42:	2b01      	cmp	r3, #1
2400fd44:	d117      	bne.n	2400fd76 <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400fd46:	687b      	ldr	r3, [r7, #4]
2400fd48:	2202      	movs	r2, #2
2400fd4a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400fd4e:	687b      	ldr	r3, [r7, #4]
2400fd50:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fd52:	2b00      	cmp	r3, #0
2400fd54:	d007      	beq.n	2400fd66 <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2400fd56:	687b      	ldr	r3, [r7, #4]
2400fd58:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fd5a:	2b00      	cmp	r3, #0
2400fd5c:	d003      	beq.n	2400fd66 <HAL_MDMA_LinkedList_EnableCircularMode+0x58>
2400fd5e:	687b      	ldr	r3, [r7, #4]
2400fd60:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fd62:	2b00      	cmp	r3, #0
2400fd64:	d102      	bne.n	2400fd6c <HAL_MDMA_LinkedList_EnableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
2400fd66:	2301      	movs	r3, #1
2400fd68:	73fb      	strb	r3, [r7, #15]
2400fd6a:	e004      	b.n	2400fd76 <HAL_MDMA_LinkedList_EnableCircularMode+0x68>
    }
    else
    {
      /* to enable circular mode Last Node should be connected to first node */
      hmdma->LastLinkedListNodeAddress->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
2400fd6c:	687b      	ldr	r3, [r7, #4]
2400fd6e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
2400fd70:	687b      	ldr	r3, [r7, #4]
2400fd72:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fd74:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
2400fd76:	687b      	ldr	r3, [r7, #4]
2400fd78:	2200      	movs	r2, #0
2400fd7a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
2400fd7e:	687b      	ldr	r3, [r7, #4]
2400fd80:	2201      	movs	r2, #1
2400fd82:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
2400fd86:	7bfb      	ldrb	r3, [r7, #15]
}
2400fd88:	4618      	mov	r0, r3
2400fd8a:	3714      	adds	r7, #20
2400fd8c:	46bd      	mov	sp, r7
2400fd8e:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fd92:	4770      	bx	lr

2400fd94 <HAL_MDMA_LinkedList_DisableCircularMode>:
  * @param  hmdma : Pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_LinkedList_DisableCircularMode(MDMA_HandleTypeDef *hmdma)
{
2400fd94:	b480      	push	{r7}
2400fd96:	b085      	sub	sp, #20
2400fd98:	af00      	add	r7, sp, #0
2400fd9a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
2400fd9c:	2300      	movs	r3, #0
2400fd9e:	73fb      	strb	r3, [r7, #15]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400fda0:	687b      	ldr	r3, [r7, #4]
2400fda2:	2b00      	cmp	r3, #0
2400fda4:	d101      	bne.n	2400fdaa <HAL_MDMA_LinkedList_DisableCircularMode+0x16>
  {
    return HAL_ERROR;
2400fda6:	2301      	movs	r3, #1
2400fda8:	e030      	b.n	2400fe0c <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fdaa:	687b      	ldr	r3, [r7, #4]
2400fdac:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fdb0:	2b01      	cmp	r3, #1
2400fdb2:	d101      	bne.n	2400fdb8 <HAL_MDMA_LinkedList_DisableCircularMode+0x24>
2400fdb4:	2302      	movs	r3, #2
2400fdb6:	e029      	b.n	2400fe0c <HAL_MDMA_LinkedList_DisableCircularMode+0x78>
2400fdb8:	687b      	ldr	r3, [r7, #4]
2400fdba:	2201      	movs	r2, #1
2400fdbc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fdc0:	687b      	ldr	r3, [r7, #4]
2400fdc2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fdc6:	b2db      	uxtb	r3, r3
2400fdc8:	2b01      	cmp	r3, #1
2400fdca:	d116      	bne.n	2400fdfa <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400fdcc:	687b      	ldr	r3, [r7, #4]
2400fdce:	2202      	movs	r2, #2
2400fdd0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* If first and last node are null (no nodes in the list) : return error*/
    if(((uint32_t)hmdma->FirstLinkedListNodeAddress == 0U) || ((uint32_t)hmdma->LastLinkedListNodeAddress == 0U) || (hmdma->LinkedListNodeCounter == 0U))
2400fdd4:	687b      	ldr	r3, [r7, #4]
2400fdd6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
2400fdd8:	2b00      	cmp	r3, #0
2400fdda:	d007      	beq.n	2400fdec <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
2400fddc:	687b      	ldr	r3, [r7, #4]
2400fdde:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fde0:	2b00      	cmp	r3, #0
2400fde2:	d003      	beq.n	2400fdec <HAL_MDMA_LinkedList_DisableCircularMode+0x58>
2400fde4:	687b      	ldr	r3, [r7, #4]
2400fde6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
2400fde8:	2b00      	cmp	r3, #0
2400fdea:	d102      	bne.n	2400fdf2 <HAL_MDMA_LinkedList_DisableCircularMode+0x5e>
    {
      hal_status = HAL_ERROR;
2400fdec:	2301      	movs	r3, #1
2400fdee:	73fb      	strb	r3, [r7, #15]
2400fdf0:	e003      	b.n	2400fdfa <HAL_MDMA_LinkedList_DisableCircularMode+0x66>
    }
    else
    {
      /* to disable circular mode Last Node should be connected to NULL */
      hmdma->LastLinkedListNodeAddress->CLAR = 0;
2400fdf2:	687b      	ldr	r3, [r7, #4]
2400fdf4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2400fdf6:	2200      	movs	r2, #0
2400fdf8:	615a      	str	r2, [r3, #20]
    }

  }
  /* Process unlocked */
  __HAL_UNLOCK(hmdma);
2400fdfa:	687b      	ldr	r3, [r7, #4]
2400fdfc:	2200      	movs	r2, #0
2400fdfe:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  hmdma->State = HAL_MDMA_STATE_READY;
2400fe02:	687b      	ldr	r3, [r7, #4]
2400fe04:	2201      	movs	r2, #1
2400fe06:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return hal_status;
2400fe0a:	7bfb      	ldrb	r3, [r7, #15]
}
2400fe0c:	4618      	mov	r0, r3
2400fe0e:	3714      	adds	r7, #20
2400fe10:	46bd      	mov	sp, r7
2400fe12:	f85d 7b04 	ldr.w	r7, [sp], #4
2400fe16:	4770      	bx	lr

2400fe18 <HAL_MDMA_Start>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400fe18:	b580      	push	{r7, lr}
2400fe1a:	b086      	sub	sp, #24
2400fe1c:	af02      	add	r7, sp, #8
2400fe1e:	60f8      	str	r0, [r7, #12]
2400fe20:	60b9      	str	r1, [r7, #8]
2400fe22:	607a      	str	r2, [r7, #4]
2400fe24:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400fe26:	68fb      	ldr	r3, [r7, #12]
2400fe28:	2b00      	cmp	r3, #0
2400fe2a:	d101      	bne.n	2400fe30 <HAL_MDMA_Start+0x18>
  {
    return HAL_ERROR;
2400fe2c:	2301      	movs	r3, #1
2400fe2e:	e044      	b.n	2400feba <HAL_MDMA_Start+0xa2>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400fe30:	68fb      	ldr	r3, [r7, #12]
2400fe32:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fe36:	2b01      	cmp	r3, #1
2400fe38:	d101      	bne.n	2400fe3e <HAL_MDMA_Start+0x26>
2400fe3a:	2302      	movs	r3, #2
2400fe3c:	e03d      	b.n	2400feba <HAL_MDMA_Start+0xa2>
2400fe3e:	68fb      	ldr	r3, [r7, #12]
2400fe40:	2201      	movs	r2, #1
2400fe42:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fe46:	68fb      	ldr	r3, [r7, #12]
2400fe48:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fe4c:	b2db      	uxtb	r3, r3
2400fe4e:	2b01      	cmp	r3, #1
2400fe50:	d12c      	bne.n	2400feac <HAL_MDMA_Start+0x94>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400fe52:	68fb      	ldr	r3, [r7, #12]
2400fe54:	2202      	movs	r2, #2
2400fe56:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400fe5a:	68fb      	ldr	r3, [r7, #12]
2400fe5c:	2200      	movs	r2, #0
2400fe5e:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
2400fe60:	68fb      	ldr	r3, [r7, #12]
2400fe62:	681b      	ldr	r3, [r3, #0]
2400fe64:	68da      	ldr	r2, [r3, #12]
2400fe66:	68fb      	ldr	r3, [r7, #12]
2400fe68:	681b      	ldr	r3, [r3, #0]
2400fe6a:	f022 0201 	bic.w	r2, r2, #1
2400fe6e:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
2400fe70:	69bb      	ldr	r3, [r7, #24]
2400fe72:	9300      	str	r3, [sp, #0]
2400fe74:	683b      	ldr	r3, [r7, #0]
2400fe76:	687a      	ldr	r2, [r7, #4]
2400fe78:	68b9      	ldr	r1, [r7, #8]
2400fe7a:	68f8      	ldr	r0, [r7, #12]
2400fe7c:	f000 fb96 	bl	240105ac <MDMA_SetConfig>

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
2400fe80:	68fb      	ldr	r3, [r7, #12]
2400fe82:	681b      	ldr	r3, [r3, #0]
2400fe84:	68da      	ldr	r2, [r3, #12]
2400fe86:	68fb      	ldr	r3, [r7, #12]
2400fe88:	681b      	ldr	r3, [r3, #0]
2400fe8a:	f042 0201 	orr.w	r2, r2, #1
2400fe8e:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400fe90:	68fb      	ldr	r3, [r7, #12]
2400fe92:	685b      	ldr	r3, [r3, #4]
2400fe94:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400fe98:	d10e      	bne.n	2400feb8 <HAL_MDMA_Start+0xa0>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
2400fe9a:	68fb      	ldr	r3, [r7, #12]
2400fe9c:	681b      	ldr	r3, [r3, #0]
2400fe9e:	68da      	ldr	r2, [r3, #12]
2400fea0:	68fb      	ldr	r3, [r7, #12]
2400fea2:	681b      	ldr	r3, [r3, #0]
2400fea4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400fea8:	60da      	str	r2, [r3, #12]
2400feaa:	e005      	b.n	2400feb8 <HAL_MDMA_Start+0xa0>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400feac:	68fb      	ldr	r3, [r7, #12]
2400feae:	2200      	movs	r2, #0
2400feb0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400feb4:	2302      	movs	r3, #2
2400feb6:	e000      	b.n	2400feba <HAL_MDMA_Start+0xa2>
  }

  return HAL_OK;
2400feb8:	2300      	movs	r3, #0
}
2400feba:	4618      	mov	r0, r3
2400febc:	3710      	adds	r7, #16
2400febe:	46bd      	mov	sp, r7
2400fec0:	bd80      	pop	{r7, pc}

2400fec2 <HAL_MDMA_Start_IT>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start_IT(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
2400fec2:	b580      	push	{r7, lr}
2400fec4:	b086      	sub	sp, #24
2400fec6:	af02      	add	r7, sp, #8
2400fec8:	60f8      	str	r0, [r7, #12]
2400feca:	60b9      	str	r1, [r7, #8]
2400fecc:	607a      	str	r2, [r7, #4]
2400fece:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400fed0:	68fb      	ldr	r3, [r7, #12]
2400fed2:	2b00      	cmp	r3, #0
2400fed4:	d101      	bne.n	2400feda <HAL_MDMA_Start_IT+0x18>
  {
    return HAL_ERROR;
2400fed6:	2301      	movs	r3, #1
2400fed8:	e070      	b.n	2400ffbc <HAL_MDMA_Start_IT+0xfa>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
2400feda:	68fb      	ldr	r3, [r7, #12]
2400fedc:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
2400fee0:	2b01      	cmp	r3, #1
2400fee2:	d101      	bne.n	2400fee8 <HAL_MDMA_Start_IT+0x26>
2400fee4:	2302      	movs	r3, #2
2400fee6:	e069      	b.n	2400ffbc <HAL_MDMA_Start_IT+0xfa>
2400fee8:	68fb      	ldr	r3, [r7, #12]
2400feea:	2201      	movs	r2, #1
2400feec:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
2400fef0:	68fb      	ldr	r3, [r7, #12]
2400fef2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400fef6:	b2db      	uxtb	r3, r3
2400fef8:	2b01      	cmp	r3, #1
2400fefa:	d158      	bne.n	2400ffae <HAL_MDMA_Start_IT+0xec>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
2400fefc:	68fb      	ldr	r3, [r7, #12]
2400fefe:	2202      	movs	r2, #2
2400ff00:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
2400ff04:	68fb      	ldr	r3, [r7, #12]
2400ff06:	2200      	movs	r2, #0
2400ff08:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
2400ff0a:	68fb      	ldr	r3, [r7, #12]
2400ff0c:	681b      	ldr	r3, [r3, #0]
2400ff0e:	68da      	ldr	r2, [r3, #12]
2400ff10:	68fb      	ldr	r3, [r7, #12]
2400ff12:	681b      	ldr	r3, [r3, #0]
2400ff14:	f022 0201 	bic.w	r2, r2, #1
2400ff18:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
2400ff1a:	69bb      	ldr	r3, [r7, #24]
2400ff1c:	9300      	str	r3, [sp, #0]
2400ff1e:	683b      	ldr	r3, [r7, #0]
2400ff20:	687a      	ldr	r2, [r7, #4]
2400ff22:	68b9      	ldr	r1, [r7, #8]
2400ff24:	68f8      	ldr	r0, [r7, #12]
2400ff26:	f000 fb41 	bl	240105ac <MDMA_SetConfig>

    /* Enable Common interrupts i.e Transfer Error IT and Channel Transfer Complete IT*/
    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));
2400ff2a:	68fb      	ldr	r3, [r7, #12]
2400ff2c:	681b      	ldr	r3, [r3, #0]
2400ff2e:	68da      	ldr	r2, [r3, #12]
2400ff30:	68fb      	ldr	r3, [r7, #12]
2400ff32:	681b      	ldr	r3, [r3, #0]
2400ff34:	f042 0206 	orr.w	r2, r2, #6
2400ff38:	60da      	str	r2, [r3, #12]

    if(hmdma->XferBlockCpltCallback != NULL)
2400ff3a:	68fb      	ldr	r3, [r7, #12]
2400ff3c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2400ff3e:	2b00      	cmp	r3, #0
2400ff40:	d007      	beq.n	2400ff52 <HAL_MDMA_Start_IT+0x90>
    {
      /* if Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);
2400ff42:	68fb      	ldr	r3, [r7, #12]
2400ff44:	681b      	ldr	r3, [r3, #0]
2400ff46:	68da      	ldr	r2, [r3, #12]
2400ff48:	68fb      	ldr	r3, [r7, #12]
2400ff4a:	681b      	ldr	r3, [r3, #0]
2400ff4c:	f042 0210 	orr.w	r2, r2, #16
2400ff50:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferRepeatBlockCpltCallback != NULL)
2400ff52:	68fb      	ldr	r3, [r7, #12]
2400ff54:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2400ff56:	2b00      	cmp	r3, #0
2400ff58:	d007      	beq.n	2400ff6a <HAL_MDMA_Start_IT+0xa8>
    {
      /* if Repeated Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);
2400ff5a:	68fb      	ldr	r3, [r7, #12]
2400ff5c:	681b      	ldr	r3, [r3, #0]
2400ff5e:	68da      	ldr	r2, [r3, #12]
2400ff60:	68fb      	ldr	r3, [r7, #12]
2400ff62:	681b      	ldr	r3, [r3, #0]
2400ff64:	f042 0208 	orr.w	r2, r2, #8
2400ff68:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferBufferCpltCallback != NULL)
2400ff6a:	68fb      	ldr	r3, [r7, #12]
2400ff6c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2400ff6e:	2b00      	cmp	r3, #0
2400ff70:	d007      	beq.n	2400ff82 <HAL_MDMA_Start_IT+0xc0>
    {
      /* if buffer transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);
2400ff72:	68fb      	ldr	r3, [r7, #12]
2400ff74:	681b      	ldr	r3, [r3, #0]
2400ff76:	68da      	ldr	r2, [r3, #12]
2400ff78:	68fb      	ldr	r3, [r7, #12]
2400ff7a:	681b      	ldr	r3, [r3, #0]
2400ff7c:	f042 0220 	orr.w	r2, r2, #32
2400ff80:	60da      	str	r2, [r3, #12]
    }

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
2400ff82:	68fb      	ldr	r3, [r7, #12]
2400ff84:	681b      	ldr	r3, [r3, #0]
2400ff86:	68da      	ldr	r2, [r3, #12]
2400ff88:	68fb      	ldr	r3, [r7, #12]
2400ff8a:	681b      	ldr	r3, [r3, #0]
2400ff8c:	f042 0201 	orr.w	r2, r2, #1
2400ff90:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
2400ff92:	68fb      	ldr	r3, [r7, #12]
2400ff94:	685b      	ldr	r3, [r3, #4]
2400ff96:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
2400ff9a:	d10e      	bne.n	2400ffba <HAL_MDMA_Start_IT+0xf8>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
2400ff9c:	68fb      	ldr	r3, [r7, #12]
2400ff9e:	681b      	ldr	r3, [r3, #0]
2400ffa0:	68da      	ldr	r2, [r3, #12]
2400ffa2:	68fb      	ldr	r3, [r7, #12]
2400ffa4:	681b      	ldr	r3, [r3, #0]
2400ffa6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2400ffaa:	60da      	str	r2, [r3, #12]
2400ffac:	e005      	b.n	2400ffba <HAL_MDMA_Start_IT+0xf8>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2400ffae:	68fb      	ldr	r3, [r7, #12]
2400ffb0:	2200      	movs	r2, #0
2400ffb2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
2400ffb6:	2302      	movs	r3, #2
2400ffb8:	e000      	b.n	2400ffbc <HAL_MDMA_Start_IT+0xfa>
  }

  return HAL_OK;
2400ffba:	2300      	movs	r3, #0
}
2400ffbc:	4618      	mov	r0, r3
2400ffbe:	3710      	adds	r7, #16
2400ffc0:	46bd      	mov	sp, r7
2400ffc2:	bd80      	pop	{r7, pc}

2400ffc4 <HAL_MDMA_Abort>:
  *        and the Channel will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort(MDMA_HandleTypeDef *hmdma)
{
2400ffc4:	b580      	push	{r7, lr}
2400ffc6:	b084      	sub	sp, #16
2400ffc8:	af00      	add	r7, sp, #0
2400ffca:	6078      	str	r0, [r7, #4]
  uint32_t tickstart =  HAL_GetTick();
2400ffcc:	f7f2 f9ba 	bl	24002344 <HAL_GetTick>
2400ffd0:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
2400ffd2:	687b      	ldr	r3, [r7, #4]
2400ffd4:	2b00      	cmp	r3, #0
2400ffd6:	d101      	bne.n	2400ffdc <HAL_MDMA_Abort+0x18>
  {
    return HAL_ERROR;
2400ffd8:	2301      	movs	r3, #1
2400ffda:	e04a      	b.n	24010072 <HAL_MDMA_Abort+0xae>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2400ffdc:	687b      	ldr	r3, [r7, #4]
2400ffde:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
2400ffe2:	b2db      	uxtb	r3, r3
2400ffe4:	2b02      	cmp	r3, #2
2400ffe6:	d008      	beq.n	2400fffa <HAL_MDMA_Abort+0x36>
  {
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
2400ffe8:	687b      	ldr	r3, [r7, #4]
2400ffea:	2280      	movs	r2, #128	; 0x80
2400ffec:	669a      	str	r2, [r3, #104]	; 0x68

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
2400ffee:	687b      	ldr	r3, [r7, #4]
2400fff0:	2200      	movs	r2, #0
2400fff2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    return HAL_ERROR;
2400fff6:	2301      	movs	r3, #1
2400fff8:	e03b      	b.n	24010072 <HAL_MDMA_Abort+0xae>
  }
  else
  {
    /* Disable all the transfer interrupts */
    __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
2400fffa:	687b      	ldr	r3, [r7, #4]
2400fffc:	681b      	ldr	r3, [r3, #0]
2400fffe:	68da      	ldr	r2, [r3, #12]
24010000:	687b      	ldr	r3, [r7, #4]
24010002:	681b      	ldr	r3, [r3, #0]
24010004:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
24010008:	60da      	str	r2, [r3, #12]

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
2401000a:	687b      	ldr	r3, [r7, #4]
2401000c:	681b      	ldr	r3, [r3, #0]
2401000e:	68da      	ldr	r2, [r3, #12]
24010010:	687b      	ldr	r3, [r7, #4]
24010012:	681b      	ldr	r3, [r3, #0]
24010014:	f022 0201 	bic.w	r2, r2, #1
24010018:	60da      	str	r2, [r3, #12]

    /* Check if the MDMA Channel is effectively disabled */
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2401001a:	e016      	b.n	2401004a <HAL_MDMA_Abort+0x86>
    {
      /* Check for the Timeout */
      if( (HAL_GetTick()  - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
2401001c:	f7f2 f992 	bl	24002344 <HAL_GetTick>
24010020:	4602      	mov	r2, r0
24010022:	68fb      	ldr	r3, [r7, #12]
24010024:	1ad3      	subs	r3, r2, r3
24010026:	2b05      	cmp	r3, #5
24010028:	d90f      	bls.n	2401004a <HAL_MDMA_Abort+0x86>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
2401002a:	687b      	ldr	r3, [r7, #4]
2401002c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401002e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
24010032:	687b      	ldr	r3, [r7, #4]
24010034:	669a      	str	r2, [r3, #104]	; 0x68

        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
24010036:	687b      	ldr	r3, [r7, #4]
24010038:	2200      	movs	r2, #0
2401003a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the MDMA state */
        hmdma->State = HAL_MDMA_STATE_ERROR;
2401003e:	687b      	ldr	r3, [r7, #4]
24010040:	2203      	movs	r2, #3
24010042:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        return HAL_ERROR;
24010046:	2301      	movs	r3, #1
24010048:	e013      	b.n	24010072 <HAL_MDMA_Abort+0xae>
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2401004a:	687b      	ldr	r3, [r7, #4]
2401004c:	681b      	ldr	r3, [r3, #0]
2401004e:	68db      	ldr	r3, [r3, #12]
24010050:	f003 0301 	and.w	r3, r3, #1
24010054:	2b00      	cmp	r3, #0
24010056:	d1e1      	bne.n	2401001c <HAL_MDMA_Abort+0x58>
      }
    }

    /* Clear all interrupt flags */
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BT | MDMA_FLAG_BRT | MDMA_FLAG_BFTC));
24010058:	687b      	ldr	r3, [r7, #4]
2401005a:	681b      	ldr	r3, [r3, #0]
2401005c:	221f      	movs	r2, #31
2401005e:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
24010060:	687b      	ldr	r3, [r7, #4]
24010062:	2200      	movs	r2, #0
24010064:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Change the MDMA state*/
    hmdma->State = HAL_MDMA_STATE_READY;
24010068:	687b      	ldr	r3, [r7, #4]
2401006a:	2201      	movs	r2, #1
2401006c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  }

  return HAL_OK;
24010070:	2300      	movs	r3, #0
}
24010072:	4618      	mov	r0, r3
24010074:	3710      	adds	r7, #16
24010076:	46bd      	mov	sp, r7
24010078:	bd80      	pop	{r7, pc}

2401007a <HAL_MDMA_Abort_IT>:
  * @param  hmdma  : pointer to a MDMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Abort_IT(MDMA_HandleTypeDef *hmdma)
{
2401007a:	b480      	push	{r7}
2401007c:	b083      	sub	sp, #12
2401007e:	af00      	add	r7, sp, #0
24010080:	6078      	str	r0, [r7, #4]
  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
24010082:	687b      	ldr	r3, [r7, #4]
24010084:	2b00      	cmp	r3, #0
24010086:	d101      	bne.n	2401008c <HAL_MDMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
24010088:	2301      	movs	r3, #1
2401008a:	e017      	b.n	240100bc <HAL_MDMA_Abort_IT+0x42>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
2401008c:	687b      	ldr	r3, [r7, #4]
2401008e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24010092:	b2db      	uxtb	r3, r3
24010094:	2b02      	cmp	r3, #2
24010096:	d004      	beq.n	240100a2 <HAL_MDMA_Abort_IT+0x28>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24010098:	687b      	ldr	r3, [r7, #4]
2401009a:	2280      	movs	r2, #128	; 0x80
2401009c:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2401009e:	2301      	movs	r3, #1
240100a0:	e00c      	b.n	240100bc <HAL_MDMA_Abort_IT+0x42>
  }
  else
  {
    /* Set Abort State  */
    hmdma->State = HAL_MDMA_STATE_ABORT;
240100a2:	687b      	ldr	r3, [r7, #4]
240100a4:	2204      	movs	r2, #4
240100a6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the stream */
    __HAL_MDMA_DISABLE(hmdma);
240100aa:	687b      	ldr	r3, [r7, #4]
240100ac:	681b      	ldr	r3, [r3, #0]
240100ae:	68da      	ldr	r2, [r3, #12]
240100b0:	687b      	ldr	r3, [r7, #4]
240100b2:	681b      	ldr	r3, [r3, #0]
240100b4:	f022 0201 	bic.w	r2, r2, #1
240100b8:	60da      	str	r2, [r3, #12]
  }

  return HAL_OK;
240100ba:	2300      	movs	r3, #0
}
240100bc:	4618      	mov	r0, r3
240100be:	370c      	adds	r7, #12
240100c0:	46bd      	mov	sp, r7
240100c2:	f85d 7b04 	ldr.w	r7, [sp], #4
240100c6:	4770      	bx	lr

240100c8 <HAL_MDMA_PollForTransfer>:
  * @param  CompleteLevel: Specifies the MDMA level complete.
  * @param  Timeout:       Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_PollForTransfer(MDMA_HandleTypeDef *hmdma, HAL_MDMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
{
240100c8:	b580      	push	{r7, lr}
240100ca:	b088      	sub	sp, #32
240100cc:	af00      	add	r7, sp, #0
240100ce:	60f8      	str	r0, [r7, #12]
240100d0:	460b      	mov	r3, r1
240100d2:	607a      	str	r2, [r7, #4]
240100d4:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_MDMA_LEVEL_COMPLETE(CompleteLevel));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
240100d6:	68fb      	ldr	r3, [r7, #12]
240100d8:	2b00      	cmp	r3, #0
240100da:	d101      	bne.n	240100e0 <HAL_MDMA_PollForTransfer+0x18>
  {
    return HAL_ERROR;
240100dc:	2301      	movs	r3, #1
240100de:	e0b9      	b.n	24010254 <HAL_MDMA_PollForTransfer+0x18c>
  }

  if(HAL_MDMA_STATE_BUSY != hmdma->State)
240100e0:	68fb      	ldr	r3, [r7, #12]
240100e2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
240100e6:	b2db      	uxtb	r3, r3
240100e8:	2b02      	cmp	r3, #2
240100ea:	d004      	beq.n	240100f6 <HAL_MDMA_PollForTransfer+0x2e>
  {
    /* No transfer ongoing */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
240100ec:	68fb      	ldr	r3, [r7, #12]
240100ee:	2280      	movs	r2, #128	; 0x80
240100f0:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
240100f2:	2301      	movs	r3, #1
240100f4:	e0ae      	b.n	24010254 <HAL_MDMA_PollForTransfer+0x18c>
  }

  /* Get the level transfer complete flag */
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
240100f6:	7afb      	ldrb	r3, [r7, #11]
240100f8:	2b00      	cmp	r3, #0
240100fa:	d00b      	beq.n	24010114 <HAL_MDMA_PollForTransfer+0x4c>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
240100fc:	7afb      	ldrb	r3, [r7, #11]
240100fe:	2b01      	cmp	r3, #1
24010100:	d006      	beq.n	24010110 <HAL_MDMA_PollForTransfer+0x48>
               (CompleteLevel == HAL_MDMA_BLOCK_TRANSFER) ? MDMA_FLAG_BT   : \
24010102:	7afb      	ldrb	r3, [r7, #11]
24010104:	2b02      	cmp	r3, #2
24010106:	d101      	bne.n	2401010c <HAL_MDMA_PollForTransfer+0x44>
24010108:	2308      	movs	r3, #8
2401010a:	e004      	b.n	24010116 <HAL_MDMA_PollForTransfer+0x4e>
2401010c:	2304      	movs	r3, #4
2401010e:	e002      	b.n	24010116 <HAL_MDMA_PollForTransfer+0x4e>
               (CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)? MDMA_FLAG_BFTC : \
24010110:	2310      	movs	r3, #16
24010112:	e000      	b.n	24010116 <HAL_MDMA_PollForTransfer+0x4e>
  levelFlag = ((CompleteLevel == HAL_MDMA_FULL_TRANSFER)  ? MDMA_FLAG_CTC  : \
24010114:	2302      	movs	r3, #2
24010116:	61fb      	str	r3, [r7, #28]
               MDMA_FLAG_BRT);


  /* Get timeout */
  tickstart = HAL_GetTick();
24010118:	f7f2 f914 	bl	24002344 <HAL_GetTick>
2401011c:	61b8      	str	r0, [r7, #24]

  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
2401011e:	e067      	b.n	240101f0 <HAL_MDMA_PollForTransfer+0x128>
  {
    if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
24010120:	68fb      	ldr	r3, [r7, #12]
24010122:	681b      	ldr	r3, [r3, #0]
24010124:	681b      	ldr	r3, [r3, #0]
24010126:	f003 0301 	and.w	r3, r3, #1
2401012a:	2b00      	cmp	r3, #0
2401012c:	d046      	beq.n	240101bc <HAL_MDMA_PollForTransfer+0xf4>
    {
      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2401012e:	68fb      	ldr	r3, [r7, #12]
24010130:	681b      	ldr	r3, [r3, #0]
24010132:	689b      	ldr	r3, [r3, #8]
24010134:	617b      	str	r3, [r7, #20]

      if((errorFlag & MDMA_CESR_TED) == 0U)
24010136:	697b      	ldr	r3, [r7, #20]
24010138:	f003 0380 	and.w	r3, r3, #128	; 0x80
2401013c:	2b00      	cmp	r3, #0
2401013e:	d106      	bne.n	2401014e <HAL_MDMA_PollForTransfer+0x86>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
24010140:	68fb      	ldr	r3, [r7, #12]
24010142:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010144:	f043 0201 	orr.w	r2, r3, #1
24010148:	68fb      	ldr	r3, [r7, #12]
2401014a:	669a      	str	r2, [r3, #104]	; 0x68
2401014c:	e005      	b.n	2401015a <HAL_MDMA_PollForTransfer+0x92>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2401014e:	68fb      	ldr	r3, [r7, #12]
24010150:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010152:	f043 0202 	orr.w	r2, r3, #2
24010156:	68fb      	ldr	r3, [r7, #12]
24010158:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
2401015a:	697b      	ldr	r3, [r7, #20]
2401015c:	f403 7300 	and.w	r3, r3, #512	; 0x200
24010160:	2b00      	cmp	r3, #0
24010162:	d005      	beq.n	24010170 <HAL_MDMA_PollForTransfer+0xa8>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
24010164:	68fb      	ldr	r3, [r7, #12]
24010166:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010168:	f043 0204 	orr.w	r2, r3, #4
2401016c:	68fb      	ldr	r3, [r7, #12]
2401016e:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
24010170:	697b      	ldr	r3, [r7, #20]
24010172:	f403 7380 	and.w	r3, r3, #256	; 0x100
24010176:	2b00      	cmp	r3, #0
24010178:	d005      	beq.n	24010186 <HAL_MDMA_PollForTransfer+0xbe>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
2401017a:	68fb      	ldr	r3, [r7, #12]
2401017c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401017e:	f043 0208 	orr.w	r2, r3, #8
24010182:	68fb      	ldr	r3, [r7, #12]
24010184:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
24010186:	697b      	ldr	r3, [r7, #20]
24010188:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2401018c:	2b00      	cmp	r3, #0
2401018e:	d005      	beq.n	2401019c <HAL_MDMA_PollForTransfer+0xd4>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
24010190:	68fb      	ldr	r3, [r7, #12]
24010192:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010194:	f043 0210 	orr.w	r2, r3, #16
24010198:	68fb      	ldr	r3, [r7, #12]
2401019a:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
2401019c:	697b      	ldr	r3, [r7, #20]
2401019e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
240101a2:	2b00      	cmp	r3, #0
240101a4:	d005      	beq.n	240101b2 <HAL_MDMA_PollForTransfer+0xea>
      {
        /* Update error code : Block Size error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
240101a6:	68fb      	ldr	r3, [r7, #12]
240101a8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240101aa:	f043 0220 	orr.w	r2, r3, #32
240101ae:	68fb      	ldr	r3, [r7, #12]
240101b0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      (void) HAL_MDMA_Abort(hmdma); /* if error then abort the current transfer */
240101b2:	68f8      	ldr	r0, [r7, #12]
240101b4:	f7ff ff06 	bl	2400ffc4 <HAL_MDMA_Abort>
          - Clear all transfer flags
          - Unlock
          - Set the State
      */

      return HAL_ERROR;
240101b8:	2301      	movs	r3, #1
240101ba:	e04b      	b.n	24010254 <HAL_MDMA_PollForTransfer+0x18c>

    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
240101bc:	687b      	ldr	r3, [r7, #4]
240101be:	f1b3 3fff 	cmp.w	r3, #4294967295
240101c2:	d015      	beq.n	240101f0 <HAL_MDMA_PollForTransfer+0x128>
    {
      if(((HAL_GetTick() - tickstart ) > Timeout) || (Timeout == 0U))
240101c4:	f7f2 f8be 	bl	24002344 <HAL_GetTick>
240101c8:	4602      	mov	r2, r0
240101ca:	69bb      	ldr	r3, [r7, #24]
240101cc:	1ad3      	subs	r3, r2, r3
240101ce:	687a      	ldr	r2, [r7, #4]
240101d0:	429a      	cmp	r2, r3
240101d2:	d302      	bcc.n	240101da <HAL_MDMA_PollForTransfer+0x112>
240101d4:	687b      	ldr	r3, [r7, #4]
240101d6:	2b00      	cmp	r3, #0
240101d8:	d10a      	bne.n	240101f0 <HAL_MDMA_PollForTransfer+0x128>
      {
        /* Update error code */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_TIMEOUT;
240101da:	68fb      	ldr	r3, [r7, #12]
240101dc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240101de:	f043 0240 	orr.w	r2, r3, #64	; 0x40
240101e2:	68fb      	ldr	r3, [r7, #12]
240101e4:	669a      	str	r2, [r3, #104]	; 0x68

        (void) HAL_MDMA_Abort(hmdma); /* if timeout then abort the current transfer */
240101e6:	68f8      	ldr	r0, [r7, #12]
240101e8:	f7ff feec 	bl	2400ffc4 <HAL_MDMA_Abort>
            - Clear all transfer flags
            - Unlock
            - Set the State
        */

        return HAL_ERROR;
240101ec:	2301      	movs	r3, #1
240101ee:	e031      	b.n	24010254 <HAL_MDMA_PollForTransfer+0x18c>
  while(__HAL_MDMA_GET_FLAG(hmdma, levelFlag) == 0U)
240101f0:	68fb      	ldr	r3, [r7, #12]
240101f2:	681b      	ldr	r3, [r3, #0]
240101f4:	681a      	ldr	r2, [r3, #0]
240101f6:	69fb      	ldr	r3, [r7, #28]
240101f8:	4013      	ands	r3, r2
240101fa:	2b00      	cmp	r3, #0
240101fc:	d090      	beq.n	24010120 <HAL_MDMA_PollForTransfer+0x58>
      }
    }
  }

  /* Clear the transfer level flag */
  if(CompleteLevel == HAL_MDMA_BUFFER_TRANSFER)
240101fe:	7afb      	ldrb	r3, [r7, #11]
24010200:	2b01      	cmp	r3, #1
24010202:	d104      	bne.n	2401020e <HAL_MDMA_PollForTransfer+0x146>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
24010204:	68fb      	ldr	r3, [r7, #12]
24010206:	681b      	ldr	r3, [r3, #0]
24010208:	2210      	movs	r2, #16
2401020a:	605a      	str	r2, [r3, #4]
2401020c:	e021      	b.n	24010252 <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_BLOCK_TRANSFER)
2401020e:	7afb      	ldrb	r3, [r7, #11]
24010210:	2b02      	cmp	r3, #2
24010212:	d104      	bne.n	2401021e <HAL_MDMA_PollForTransfer+0x156>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT));
24010214:	68fb      	ldr	r3, [r7, #12]
24010216:	681b      	ldr	r3, [r3, #0]
24010218:	2218      	movs	r2, #24
2401021a:	605a      	str	r2, [r3, #4]
2401021c:	e019      	b.n	24010252 <HAL_MDMA_PollForTransfer+0x18a>

  }
  else if(CompleteLevel == HAL_MDMA_REPEAT_BLOCK_TRANSFER)
2401021e:	7afb      	ldrb	r3, [r7, #11]
24010220:	2b03      	cmp	r3, #3
24010222:	d104      	bne.n	2401022e <HAL_MDMA_PollForTransfer+0x166>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BFTC | MDMA_FLAG_BT | MDMA_FLAG_BRT));
24010224:	68fb      	ldr	r3, [r7, #12]
24010226:	681b      	ldr	r3, [r3, #0]
24010228:	221c      	movs	r2, #28
2401022a:	605a      	str	r2, [r3, #4]
2401022c:	e011      	b.n	24010252 <HAL_MDMA_PollForTransfer+0x18a>
  }
  else if(CompleteLevel == HAL_MDMA_FULL_TRANSFER)
2401022e:	7afb      	ldrb	r3, [r7, #11]
24010230:	2b00      	cmp	r3, #0
24010232:	d10c      	bne.n	2401024e <HAL_MDMA_PollForTransfer+0x186>
  {
    __HAL_MDMA_CLEAR_FLAG(hmdma, (MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC | MDMA_FLAG_CTC));
24010234:	68fb      	ldr	r3, [r7, #12]
24010236:	681b      	ldr	r3, [r3, #0]
24010238:	221e      	movs	r2, #30
2401023a:	605a      	str	r2, [r3, #4]

    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
2401023c:	68fb      	ldr	r3, [r7, #12]
2401023e:	2200      	movs	r2, #0
24010240:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    hmdma->State = HAL_MDMA_STATE_READY;
24010244:	68fb      	ldr	r3, [r7, #12]
24010246:	2201      	movs	r2, #1
24010248:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
2401024c:	e001      	b.n	24010252 <HAL_MDMA_PollForTransfer+0x18a>
  }
  else
  {
    return HAL_ERROR;
2401024e:	2301      	movs	r3, #1
24010250:	e000      	b.n	24010254 <HAL_MDMA_PollForTransfer+0x18c>
  }

  return HAL_OK;
24010252:	2300      	movs	r3, #0
}
24010254:	4618      	mov	r0, r3
24010256:	3720      	adds	r7, #32
24010258:	46bd      	mov	sp, r7
2401025a:	bd80      	pop	{r7, pc}

2401025c <HAL_MDMA_GenerateSWRequest>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_GenerateSWRequest(MDMA_HandleTypeDef *hmdma)
{
2401025c:	b480      	push	{r7}
2401025e:	b085      	sub	sp, #20
24010260:	af00      	add	r7, sp, #0
24010262:	6078      	str	r0, [r7, #4]
  uint32_t request_mode;

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
24010264:	687b      	ldr	r3, [r7, #4]
24010266:	2b00      	cmp	r3, #0
24010268:	d101      	bne.n	2401026e <HAL_MDMA_GenerateSWRequest+0x12>
  {
    return HAL_ERROR;
2401026a:	2301      	movs	r3, #1
2401026c:	e02a      	b.n	240102c4 <HAL_MDMA_GenerateSWRequest+0x68>
  }

  /* Get the softawre request mode */
  request_mode = hmdma->Instance->CTCR & MDMA_CTCR_SWRM;
2401026e:	687b      	ldr	r3, [r7, #4]
24010270:	681b      	ldr	r3, [r3, #0]
24010272:	691b      	ldr	r3, [r3, #16]
24010274:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
24010278:	60fb      	str	r3, [r7, #12]

  if((hmdma->Instance->CCR &  MDMA_CCR_EN) == 0U)
2401027a:	687b      	ldr	r3, [r7, #4]
2401027c:	681b      	ldr	r3, [r3, #0]
2401027e:	68db      	ldr	r3, [r3, #12]
24010280:	f003 0301 	and.w	r3, r3, #1
24010284:	2b00      	cmp	r3, #0
24010286:	d104      	bne.n	24010292 <HAL_MDMA_GenerateSWRequest+0x36>
  {
    /* if no Transfer on going (MDMA enable bit not set) return error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NO_XFER;
24010288:	687b      	ldr	r3, [r7, #4]
2401028a:	2280      	movs	r2, #128	; 0x80
2401028c:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
2401028e:	2301      	movs	r3, #1
24010290:	e018      	b.n	240102c4 <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else if(((hmdma->Instance->CISR &  MDMA_CISR_CRQA) != 0U) || (request_mode == 0U))
24010292:	687b      	ldr	r3, [r7, #4]
24010294:	681b      	ldr	r3, [r3, #0]
24010296:	681b      	ldr	r3, [r3, #0]
24010298:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401029c:	2b00      	cmp	r3, #0
2401029e:	d102      	bne.n	240102a6 <HAL_MDMA_GenerateSWRequest+0x4a>
240102a0:	68fb      	ldr	r3, [r7, #12]
240102a2:	2b00      	cmp	r3, #0
240102a4:	d105      	bne.n	240102b2 <HAL_MDMA_GenerateSWRequest+0x56>
  {
    /* if an MDMA ongoing request has not yet end or if request mode is not SW request return error */
    hmdma->ErrorCode = HAL_MDMA_ERROR_BUSY;
240102a6:	687b      	ldr	r3, [r7, #4]
240102a8:	f44f 7280 	mov.w	r2, #256	; 0x100
240102ac:	669a      	str	r2, [r3, #104]	; 0x68

    return HAL_ERROR;
240102ae:	2301      	movs	r3, #1
240102b0:	e008      	b.n	240102c4 <HAL_MDMA_GenerateSWRequest+0x68>
  }
  else
  {
    /* Set the SW request bit to activate the request on the Channel */
    hmdma->Instance->CCR |= MDMA_CCR_SWRQ;
240102b2:	687b      	ldr	r3, [r7, #4]
240102b4:	681b      	ldr	r3, [r3, #0]
240102b6:	68da      	ldr	r2, [r3, #12]
240102b8:	687b      	ldr	r3, [r7, #4]
240102ba:	681b      	ldr	r3, [r3, #0]
240102bc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
240102c0:	60da      	str	r2, [r3, #12]

    return HAL_OK;
240102c2:	2300      	movs	r3, #0
  }
}
240102c4:	4618      	mov	r0, r3
240102c6:	3714      	adds	r7, #20
240102c8:	46bd      	mov	sp, r7
240102ca:	f85d 7b04 	ldr.w	r7, [sp], #4
240102ce:	4770      	bx	lr

240102d0 <HAL_MDMA_IRQHandler>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval None
  */
void HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma)
{
240102d0:	b580      	push	{r7, lr}
240102d2:	b086      	sub	sp, #24
240102d4:	af00      	add	r7, sp, #0
240102d6:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0;
240102d8:	2300      	movs	r3, #0
240102da:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
240102dc:	4b91      	ldr	r3, [pc, #580]	; (24010524 <HAL_MDMA_IRQHandler+0x254>)
240102de:	681b      	ldr	r3, [r3, #0]
240102e0:	4a91      	ldr	r2, [pc, #580]	; (24010528 <HAL_MDMA_IRQHandler+0x258>)
240102e2:	fba2 2303 	umull	r2, r3, r2, r3
240102e6:	0a9b      	lsrs	r3, r3, #10
240102e8:	617b      	str	r3, [r7, #20]

  uint32_t generalIntFlag, errorFlag;

  /* General Interrupt Flag management ****************************************/
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
240102ea:	687b      	ldr	r3, [r7, #4]
240102ec:	681b      	ldr	r3, [r3, #0]
240102ee:	461a      	mov	r2, r3
240102f0:	4b8e      	ldr	r3, [pc, #568]	; (2401052c <HAL_MDMA_IRQHandler+0x25c>)
240102f2:	4413      	add	r3, r2
240102f4:	099b      	lsrs	r3, r3, #6
240102f6:	f003 031f 	and.w	r3, r3, #31
240102fa:	2201      	movs	r2, #1
240102fc:	fa02 f303 	lsl.w	r3, r2, r3
24010300:	613b      	str	r3, [r7, #16]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
24010302:	f04f 43a4 	mov.w	r3, #1375731712	; 0x52000000
24010306:	681a      	ldr	r2, [r3, #0]
24010308:	693b      	ldr	r3, [r7, #16]
2401030a:	4013      	ands	r3, r2
2401030c:	2b00      	cmp	r3, #0
2401030e:	f000 812d 	beq.w	2401056c <HAL_MDMA_IRQHandler+0x29c>
  {
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
  }

  /* Transfer Error Interrupt management ***************************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
24010312:	687b      	ldr	r3, [r7, #4]
24010314:	681b      	ldr	r3, [r3, #0]
24010316:	681b      	ldr	r3, [r3, #0]
24010318:	f003 0301 	and.w	r3, r3, #1
2401031c:	2b00      	cmp	r3, #0
2401031e:	d054      	beq.n	240103ca <HAL_MDMA_IRQHandler+0xfa>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)
24010320:	687b      	ldr	r3, [r7, #4]
24010322:	681b      	ldr	r3, [r3, #0]
24010324:	68db      	ldr	r3, [r3, #12]
24010326:	f003 0302 	and.w	r3, r3, #2
2401032a:	2b00      	cmp	r3, #0
2401032c:	d04d      	beq.n	240103ca <HAL_MDMA_IRQHandler+0xfa>
    {
      /* Disable the transfer error interrupt */
      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);
2401032e:	687b      	ldr	r3, [r7, #4]
24010330:	681b      	ldr	r3, [r3, #0]
24010332:	68da      	ldr	r2, [r3, #12]
24010334:	687b      	ldr	r3, [r7, #4]
24010336:	681b      	ldr	r3, [r3, #0]
24010338:	f022 0202 	bic.w	r2, r2, #2
2401033c:	60da      	str	r2, [r3, #12]

      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
2401033e:	687b      	ldr	r3, [r7, #4]
24010340:	681b      	ldr	r3, [r3, #0]
24010342:	689b      	ldr	r3, [r3, #8]
24010344:	60fb      	str	r3, [r7, #12]

      if((errorFlag & MDMA_CESR_TED) == 0U)
24010346:	68fb      	ldr	r3, [r7, #12]
24010348:	f003 0380 	and.w	r3, r3, #128	; 0x80
2401034c:	2b00      	cmp	r3, #0
2401034e:	d106      	bne.n	2401035e <HAL_MDMA_IRQHandler+0x8e>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
24010350:	687b      	ldr	r3, [r7, #4]
24010352:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010354:	f043 0201 	orr.w	r2, r3, #1
24010358:	687b      	ldr	r3, [r7, #4]
2401035a:	669a      	str	r2, [r3, #104]	; 0x68
2401035c:	e005      	b.n	2401036a <HAL_MDMA_IRQHandler+0x9a>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
2401035e:	687b      	ldr	r3, [r7, #4]
24010360:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010362:	f043 0202 	orr.w	r2, r3, #2
24010366:	687b      	ldr	r3, [r7, #4]
24010368:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
2401036a:	68fb      	ldr	r3, [r7, #12]
2401036c:	f403 7300 	and.w	r3, r3, #512	; 0x200
24010370:	2b00      	cmp	r3, #0
24010372:	d005      	beq.n	24010380 <HAL_MDMA_IRQHandler+0xb0>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
24010374:	687b      	ldr	r3, [r7, #4]
24010376:	6e9b      	ldr	r3, [r3, #104]	; 0x68
24010378:	f043 0204 	orr.w	r2, r3, #4
2401037c:	687b      	ldr	r3, [r7, #4]
2401037e:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
24010380:	68fb      	ldr	r3, [r7, #12]
24010382:	f403 7380 	and.w	r3, r3, #256	; 0x100
24010386:	2b00      	cmp	r3, #0
24010388:	d005      	beq.n	24010396 <HAL_MDMA_IRQHandler+0xc6>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
2401038a:	687b      	ldr	r3, [r7, #4]
2401038c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401038e:	f043 0208 	orr.w	r2, r3, #8
24010392:	687b      	ldr	r3, [r7, #4]
24010394:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
24010396:	68fb      	ldr	r3, [r7, #12]
24010398:	f403 6380 	and.w	r3, r3, #1024	; 0x400
2401039c:	2b00      	cmp	r3, #0
2401039e:	d005      	beq.n	240103ac <HAL_MDMA_IRQHandler+0xdc>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
240103a0:	687b      	ldr	r3, [r7, #4]
240103a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240103a4:	f043 0210 	orr.w	r2, r3, #16
240103a8:	687b      	ldr	r3, [r7, #4]
240103aa:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
240103ac:	68fb      	ldr	r3, [r7, #12]
240103ae:	f403 6300 	and.w	r3, r3, #2048	; 0x800
240103b2:	2b00      	cmp	r3, #0
240103b4:	d005      	beq.n	240103c2 <HAL_MDMA_IRQHandler+0xf2>
      {
        /* Update error code : Block Size error error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
240103b6:	687b      	ldr	r3, [r7, #4]
240103b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240103ba:	f043 0220 	orr.w	r2, r3, #32
240103be:	687b      	ldr	r3, [r7, #4]
240103c0:	669a      	str	r2, [r3, #104]	; 0x68
      }

      /* Clear the transfer error flags */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);
240103c2:	687b      	ldr	r3, [r7, #4]
240103c4:	681b      	ldr	r3, [r3, #0]
240103c6:	2201      	movs	r2, #1
240103c8:	605a      	str	r2, [r3, #4]
    }
  }

  /* Buffer Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))
240103ca:	687b      	ldr	r3, [r7, #4]
240103cc:	681b      	ldr	r3, [r3, #0]
240103ce:	681b      	ldr	r3, [r3, #0]
240103d0:	f003 0310 	and.w	r3, r3, #16
240103d4:	2b00      	cmp	r3, #0
240103d6:	d012      	beq.n	240103fe <HAL_MDMA_IRQHandler+0x12e>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)
240103d8:	687b      	ldr	r3, [r7, #4]
240103da:	681b      	ldr	r3, [r3, #0]
240103dc:	68db      	ldr	r3, [r3, #12]
240103de:	f003 0320 	and.w	r3, r3, #32
240103e2:	2b00      	cmp	r3, #0
240103e4:	d00b      	beq.n	240103fe <HAL_MDMA_IRQHandler+0x12e>
    {
      /* Clear the buffer transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
240103e6:	687b      	ldr	r3, [r7, #4]
240103e8:	681b      	ldr	r3, [r3, #0]
240103ea:	2210      	movs	r2, #16
240103ec:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBufferCpltCallback != NULL)
240103ee:	687b      	ldr	r3, [r7, #4]
240103f0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240103f2:	2b00      	cmp	r3, #0
240103f4:	d003      	beq.n	240103fe <HAL_MDMA_IRQHandler+0x12e>
      {
        /* Buffer transfer callback */
        hmdma->XferBufferCpltCallback(hmdma);
240103f6:	687b      	ldr	r3, [r7, #4]
240103f8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240103fa:	6878      	ldr	r0, [r7, #4]
240103fc:	4798      	blx	r3
      }
    }
  }

  /* Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))
240103fe:	687b      	ldr	r3, [r7, #4]
24010400:	681b      	ldr	r3, [r3, #0]
24010402:	681b      	ldr	r3, [r3, #0]
24010404:	f003 0308 	and.w	r3, r3, #8
24010408:	2b00      	cmp	r3, #0
2401040a:	d012      	beq.n	24010432 <HAL_MDMA_IRQHandler+0x162>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)
2401040c:	687b      	ldr	r3, [r7, #4]
2401040e:	681b      	ldr	r3, [r3, #0]
24010410:	68db      	ldr	r3, [r3, #12]
24010412:	f003 0310 	and.w	r3, r3, #16
24010416:	2b00      	cmp	r3, #0
24010418:	d00b      	beq.n	24010432 <HAL_MDMA_IRQHandler+0x162>
    {
      /* Clear the block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);
2401041a:	687b      	ldr	r3, [r7, #4]
2401041c:	681b      	ldr	r3, [r3, #0]
2401041e:	2208      	movs	r2, #8
24010420:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBlockCpltCallback != NULL)
24010422:	687b      	ldr	r3, [r7, #4]
24010424:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24010426:	2b00      	cmp	r3, #0
24010428:	d003      	beq.n	24010432 <HAL_MDMA_IRQHandler+0x162>
      {
        /* Block transfer callback */
        hmdma->XferBlockCpltCallback(hmdma);
2401042a:	687b      	ldr	r3, [r7, #4]
2401042c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401042e:	6878      	ldr	r0, [r7, #4]
24010430:	4798      	blx	r3
      }
    }
  }

  /* Repeated Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))
24010432:	687b      	ldr	r3, [r7, #4]
24010434:	681b      	ldr	r3, [r3, #0]
24010436:	681b      	ldr	r3, [r3, #0]
24010438:	f003 0304 	and.w	r3, r3, #4
2401043c:	2b00      	cmp	r3, #0
2401043e:	d012      	beq.n	24010466 <HAL_MDMA_IRQHandler+0x196>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)
24010440:	687b      	ldr	r3, [r7, #4]
24010442:	681b      	ldr	r3, [r3, #0]
24010444:	68db      	ldr	r3, [r3, #12]
24010446:	f003 0308 	and.w	r3, r3, #8
2401044a:	2b00      	cmp	r3, #0
2401044c:	d00b      	beq.n	24010466 <HAL_MDMA_IRQHandler+0x196>
    {
      /* Clear the repeat block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);
2401044e:	687b      	ldr	r3, [r7, #4]
24010450:	681b      	ldr	r3, [r3, #0]
24010452:	2204      	movs	r2, #4
24010454:	605a      	str	r2, [r3, #4]

      if(hmdma->XferRepeatBlockCpltCallback != NULL)
24010456:	687b      	ldr	r3, [r7, #4]
24010458:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401045a:	2b00      	cmp	r3, #0
2401045c:	d003      	beq.n	24010466 <HAL_MDMA_IRQHandler+0x196>
      {
        /* Repeated Block transfer callback */
        hmdma->XferRepeatBlockCpltCallback(hmdma);
2401045e:	687b      	ldr	r3, [r7, #4]
24010460:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24010462:	6878      	ldr	r0, [r7, #4]
24010464:	4798      	blx	r3
      }
    }
  }

  /* Channel Transfer Complete Interrupt management ***********************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))
24010466:	687b      	ldr	r3, [r7, #4]
24010468:	681b      	ldr	r3, [r3, #0]
2401046a:	681b      	ldr	r3, [r3, #0]
2401046c:	f003 0302 	and.w	r3, r3, #2
24010470:	2b00      	cmp	r3, #0
24010472:	d039      	beq.n	240104e8 <HAL_MDMA_IRQHandler+0x218>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)
24010474:	687b      	ldr	r3, [r7, #4]
24010476:	681b      	ldr	r3, [r3, #0]
24010478:	68db      	ldr	r3, [r3, #12]
2401047a:	f003 0304 	and.w	r3, r3, #4
2401047e:	2b00      	cmp	r3, #0
24010480:	d032      	beq.n	240104e8 <HAL_MDMA_IRQHandler+0x218>
    {
      /* Disable all the transfer interrupts */
      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
24010482:	687b      	ldr	r3, [r7, #4]
24010484:	681b      	ldr	r3, [r3, #0]
24010486:	68da      	ldr	r2, [r3, #12]
24010488:	687b      	ldr	r3, [r7, #4]
2401048a:	681b      	ldr	r3, [r3, #0]
2401048c:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
24010490:	60da      	str	r2, [r3, #12]

      if(HAL_MDMA_STATE_ABORT == hmdma->State)
24010492:	687b      	ldr	r3, [r7, #4]
24010494:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24010498:	b2db      	uxtb	r3, r3
2401049a:	2b04      	cmp	r3, #4
2401049c:	d110      	bne.n	240104c0 <HAL_MDMA_IRQHandler+0x1f0>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
2401049e:	687b      	ldr	r3, [r7, #4]
240104a0:	2200      	movs	r2, #0
240104a2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the DMA state */
        hmdma->State = HAL_MDMA_STATE_READY;
240104a6:	687b      	ldr	r3, [r7, #4]
240104a8:	2201      	movs	r2, #1
240104aa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        if(hmdma->XferAbortCallback != NULL)
240104ae:	687b      	ldr	r3, [r7, #4]
240104b0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240104b2:	2b00      	cmp	r3, #0
240104b4:	d05c      	beq.n	24010570 <HAL_MDMA_IRQHandler+0x2a0>
        {
          hmdma->XferAbortCallback(hmdma);
240104b6:	687b      	ldr	r3, [r7, #4]
240104b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240104ba:	6878      	ldr	r0, [r7, #4]
240104bc:	4798      	blx	r3
        }
        return;
240104be:	e057      	b.n	24010570 <HAL_MDMA_IRQHandler+0x2a0>
      }

      /* Clear the Channel Transfer Complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);
240104c0:	687b      	ldr	r3, [r7, #4]
240104c2:	681b      	ldr	r3, [r3, #0]
240104c4:	2202      	movs	r2, #2
240104c6:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hmdma);
240104c8:	687b      	ldr	r3, [r7, #4]
240104ca:	2200      	movs	r2, #0
240104cc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

      /* Change MDMA peripheral state */
      hmdma->State = HAL_MDMA_STATE_READY;
240104d0:	687b      	ldr	r3, [r7, #4]
240104d2:	2201      	movs	r2, #1
240104d4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      if(hmdma->XferCpltCallback != NULL)
240104d8:	687b      	ldr	r3, [r7, #4]
240104da:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240104dc:	2b00      	cmp	r3, #0
240104de:	d003      	beq.n	240104e8 <HAL_MDMA_IRQHandler+0x218>
      {
        /* Channel Transfer Complete callback */
        hmdma->XferCpltCallback(hmdma);
240104e0:	687b      	ldr	r3, [r7, #4]
240104e2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240104e4:	6878      	ldr	r0, [r7, #4]
240104e6:	4798      	blx	r3
      }
    }
  }

  /* manage error case */
  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)
240104e8:	687b      	ldr	r3, [r7, #4]
240104ea:	6e9b      	ldr	r3, [r3, #104]	; 0x68
240104ec:	2b00      	cmp	r3, #0
240104ee:	d040      	beq.n	24010572 <HAL_MDMA_IRQHandler+0x2a2>
  {
    hmdma->State = HAL_MDMA_STATE_ABORT;
240104f0:	687b      	ldr	r3, [r7, #4]
240104f2:	2204      	movs	r2, #4
240104f4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
240104f8:	687b      	ldr	r3, [r7, #4]
240104fa:	681b      	ldr	r3, [r3, #0]
240104fc:	68da      	ldr	r2, [r3, #12]
240104fe:	687b      	ldr	r3, [r7, #4]
24010500:	681b      	ldr	r3, [r3, #0]
24010502:	f022 0201 	bic.w	r2, r2, #1
24010506:	60da      	str	r2, [r3, #12]

    do
    {
      if (++count > timeout)
24010508:	68bb      	ldr	r3, [r7, #8]
2401050a:	3301      	adds	r3, #1
2401050c:	60bb      	str	r3, [r7, #8]
2401050e:	697a      	ldr	r2, [r7, #20]
24010510:	429a      	cmp	r2, r3
24010512:	d30d      	bcc.n	24010530 <HAL_MDMA_IRQHandler+0x260>
      {
        break;
      }
    }
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);
24010514:	687b      	ldr	r3, [r7, #4]
24010516:	681b      	ldr	r3, [r3, #0]
24010518:	68db      	ldr	r3, [r3, #12]
2401051a:	f003 0301 	and.w	r3, r3, #1
2401051e:	2b00      	cmp	r3, #0
24010520:	d1f2      	bne.n	24010508 <HAL_MDMA_IRQHandler+0x238>
24010522:	e006      	b.n	24010532 <HAL_MDMA_IRQHandler+0x262>
24010524:	240004b0 	.word	0x240004b0
24010528:	1b4e81b5 	.word	0x1b4e81b5
2401052c:	adffffc0 	.word	0xadffffc0
        break;
24010530:	bf00      	nop

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
24010532:	687b      	ldr	r3, [r7, #4]
24010534:	2200      	movs	r2, #0
24010536:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
2401053a:	687b      	ldr	r3, [r7, #4]
2401053c:	681b      	ldr	r3, [r3, #0]
2401053e:	68db      	ldr	r3, [r3, #12]
24010540:	f003 0301 	and.w	r3, r3, #1
24010544:	2b00      	cmp	r3, #0
24010546:	d004      	beq.n	24010552 <HAL_MDMA_IRQHandler+0x282>
    {
      /* Change the MDMA state to error if MDMA disable fails */
      hmdma->State = HAL_MDMA_STATE_ERROR;
24010548:	687b      	ldr	r3, [r7, #4]
2401054a:	2203      	movs	r2, #3
2401054c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
24010550:	e003      	b.n	2401055a <HAL_MDMA_IRQHandler+0x28a>
    }
    else
    {
      /* Change the MDMA state to Ready if MDMA disable success */
      hmdma->State = HAL_MDMA_STATE_READY;
24010552:	687b      	ldr	r3, [r7, #4]
24010554:	2201      	movs	r2, #1
24010556:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }


    if (hmdma->XferErrorCallback != NULL)
2401055a:	687b      	ldr	r3, [r7, #4]
2401055c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401055e:	2b00      	cmp	r3, #0
24010560:	d007      	beq.n	24010572 <HAL_MDMA_IRQHandler+0x2a2>
    {
      /* Transfer error callback */
      hmdma->XferErrorCallback(hmdma);
24010562:	687b      	ldr	r3, [r7, #4]
24010564:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24010566:	6878      	ldr	r0, [r7, #4]
24010568:	4798      	blx	r3
2401056a:	e002      	b.n	24010572 <HAL_MDMA_IRQHandler+0x2a2>
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
2401056c:	bf00      	nop
2401056e:	e000      	b.n	24010572 <HAL_MDMA_IRQHandler+0x2a2>
        return;
24010570:	bf00      	nop
    }
  }
}
24010572:	3718      	adds	r7, #24
24010574:	46bd      	mov	sp, r7
24010576:	bd80      	pop	{r7, pc}

24010578 <HAL_MDMA_GetState>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL state
  */
HAL_MDMA_StateTypeDef HAL_MDMA_GetState(MDMA_HandleTypeDef *hmdma)
{
24010578:	b480      	push	{r7}
2401057a:	b083      	sub	sp, #12
2401057c:	af00      	add	r7, sp, #0
2401057e:	6078      	str	r0, [r7, #4]
  return hmdma->State;
24010580:	687b      	ldr	r3, [r7, #4]
24010582:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
24010586:	b2db      	uxtb	r3, r3
}
24010588:	4618      	mov	r0, r3
2401058a:	370c      	adds	r7, #12
2401058c:	46bd      	mov	sp, r7
2401058e:	f85d 7b04 	ldr.w	r7, [sp], #4
24010592:	4770      	bx	lr

24010594 <HAL_MDMA_GetError>:
  * @param  hmdma : pointer to a MDMA_HandleTypeDef structure that contains
  *              the configuration information for the specified MDMA Channel.
  * @retval MDMA Error Code
  */
uint32_t HAL_MDMA_GetError(MDMA_HandleTypeDef *hmdma)
{
24010594:	b480      	push	{r7}
24010596:	b083      	sub	sp, #12
24010598:	af00      	add	r7, sp, #0
2401059a:	6078      	str	r0, [r7, #4]
  return hmdma->ErrorCode;
2401059c:	687b      	ldr	r3, [r7, #4]
2401059e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
}
240105a0:	4618      	mov	r0, r3
240105a2:	370c      	adds	r7, #12
240105a4:	46bd      	mov	sp, r7
240105a6:	f85d 7b04 	ldr.w	r7, [sp], #4
240105aa:	4770      	bx	lr

240105ac <MDMA_SetConfig>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount: The number of blocks to be transferred
  * @retval HAL status
  */
static void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
240105ac:	b480      	push	{r7}
240105ae:	b087      	sub	sp, #28
240105b0:	af00      	add	r7, sp, #0
240105b2:	60f8      	str	r0, [r7, #12]
240105b4:	60b9      	str	r1, [r7, #8]
240105b6:	607a      	str	r2, [r7, #4]
240105b8:	603b      	str	r3, [r7, #0]
  uint32_t addressMask;

  /* Configure the MDMA Channel data length */
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
240105ba:	68fb      	ldr	r3, [r7, #12]
240105bc:	681b      	ldr	r3, [r3, #0]
240105be:	695a      	ldr	r2, [r3, #20]
240105c0:	4b31      	ldr	r3, [pc, #196]	; (24010688 <MDMA_SetConfig+0xdc>)
240105c2:	4013      	ands	r3, r2
240105c4:	683a      	ldr	r2, [r7, #0]
240105c6:	f3c2 0110 	ubfx	r1, r2, #0, #17
240105ca:	68fa      	ldr	r2, [r7, #12]
240105cc:	6812      	ldr	r2, [r2, #0]
240105ce:	430b      	orrs	r3, r1
240105d0:	6153      	str	r3, [r2, #20]

  /* Configure the MDMA block repeat count */
  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);
240105d2:	68fb      	ldr	r3, [r7, #12]
240105d4:	681b      	ldr	r3, [r3, #0]
240105d6:	695b      	ldr	r3, [r3, #20]
240105d8:	f3c3 0113 	ubfx	r1, r3, #0, #20
240105dc:	6a3b      	ldr	r3, [r7, #32]
240105de:	3b01      	subs	r3, #1
240105e0:	051a      	lsls	r2, r3, #20
240105e2:	68fb      	ldr	r3, [r7, #12]
240105e4:	681b      	ldr	r3, [r3, #0]
240105e6:	430a      	orrs	r2, r1
240105e8:	615a      	str	r2, [r3, #20]

  /* Clear all interrupt flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);
240105ea:	68fb      	ldr	r3, [r7, #12]
240105ec:	681b      	ldr	r3, [r3, #0]
240105ee:	221f      	movs	r2, #31
240105f0:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Channel destination address */
  hmdma->Instance->CDAR = DstAddress;
240105f2:	68fb      	ldr	r3, [r7, #12]
240105f4:	681b      	ldr	r3, [r3, #0]
240105f6:	687a      	ldr	r2, [r7, #4]
240105f8:	61da      	str	r2, [r3, #28]

  /* Configure MDMA Channel Source address */
  hmdma->Instance->CSAR = SrcAddress;
240105fa:	68fb      	ldr	r3, [r7, #12]
240105fc:	681b      	ldr	r3, [r3, #0]
240105fe:	68ba      	ldr	r2, [r7, #8]
24010600:	619a      	str	r2, [r3, #24]

  addressMask = SrcAddress & 0xFF000000U;
24010602:	68bb      	ldr	r3, [r7, #8]
24010604:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
24010608:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
2401060a:	697b      	ldr	r3, [r7, #20]
2401060c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24010610:	d002      	beq.n	24010618 <MDMA_SetConfig+0x6c>
24010612:	697b      	ldr	r3, [r7, #20]
24010614:	2b00      	cmp	r3, #0
24010616:	d108      	bne.n	2401062a <MDMA_SetConfig+0x7e>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;
24010618:	68fb      	ldr	r3, [r7, #12]
2401061a:	681b      	ldr	r3, [r3, #0]
2401061c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2401061e:	68fb      	ldr	r3, [r7, #12]
24010620:	681b      	ldr	r3, [r3, #0]
24010622:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
24010626:	629a      	str	r2, [r3, #40]	; 0x28
24010628:	e007      	b.n	2401063a <MDMA_SetConfig+0x8e>
  }
  else
  {
    /*The AXI bus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
2401062a:	68fb      	ldr	r3, [r7, #12]
2401062c:	681b      	ldr	r3, [r3, #0]
2401062e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010630:	68fb      	ldr	r3, [r7, #12]
24010632:	681b      	ldr	r3, [r3, #0]
24010634:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
24010638:	629a      	str	r2, [r3, #40]	; 0x28
  }

  addressMask = DstAddress & 0xFF000000U;
2401063a:	687b      	ldr	r3, [r7, #4]
2401063c:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
24010640:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
24010642:	697b      	ldr	r3, [r7, #20]
24010644:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24010648:	d002      	beq.n	24010650 <MDMA_SetConfig+0xa4>
2401064a:	697b      	ldr	r3, [r7, #20]
2401064c:	2b00      	cmp	r3, #0
2401064e:	d108      	bne.n	24010662 <MDMA_SetConfig+0xb6>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;
24010650:	68fb      	ldr	r3, [r7, #12]
24010652:	681b      	ldr	r3, [r3, #0]
24010654:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010656:	68fb      	ldr	r3, [r7, #12]
24010658:	681b      	ldr	r3, [r3, #0]
2401065a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
2401065e:	629a      	str	r2, [r3, #40]	; 0x28
24010660:	e007      	b.n	24010672 <MDMA_SetConfig+0xc6>
  }
  else
  {
    /*The AXI bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);
24010662:	68fb      	ldr	r3, [r7, #12]
24010664:	681b      	ldr	r3, [r3, #0]
24010666:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010668:	68fb      	ldr	r3, [r7, #12]
2401066a:	681b      	ldr	r3, [r3, #0]
2401066c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
24010670:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Set the linked list register to the first node of the list */
  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
24010672:	68fb      	ldr	r3, [r7, #12]
24010674:	6dda      	ldr	r2, [r3, #92]	; 0x5c
24010676:	68fb      	ldr	r3, [r7, #12]
24010678:	681b      	ldr	r3, [r3, #0]
2401067a:	625a      	str	r2, [r3, #36]	; 0x24
}
2401067c:	bf00      	nop
2401067e:	371c      	adds	r7, #28
24010680:	46bd      	mov	sp, r7
24010682:	f85d 7b04 	ldr.w	r7, [sp], #4
24010686:	4770      	bx	lr
24010688:	fffe0000 	.word	0xfffe0000

2401068c <MDMA_Init>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Channel.
  * @retval None
  */
static void MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
2401068c:	b480      	push	{r7}
2401068e:	b085      	sub	sp, #20
24010690:	af00      	add	r7, sp, #0
24010692:	6078      	str	r0, [r7, #4]
  uint32_t blockoffset;

  /* Prepare the MDMA Channel configuration */
  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;
24010694:	687b      	ldr	r3, [r7, #4]
24010696:	68d9      	ldr	r1, [r3, #12]
24010698:	687b      	ldr	r3, [r7, #4]
2401069a:	691a      	ldr	r2, [r3, #16]
2401069c:	687b      	ldr	r3, [r7, #4]
2401069e:	681b      	ldr	r3, [r3, #0]
240106a0:	430a      	orrs	r2, r1
240106a2:	60da      	str	r2, [r3, #12]

  /* Write new CTCR Register value */
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
240106a4:	687b      	ldr	r3, [r7, #4]
240106a6:	695a      	ldr	r2, [r3, #20]
240106a8:	687b      	ldr	r3, [r7, #4]
240106aa:	699b      	ldr	r3, [r3, #24]
240106ac:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
240106ae:	687b      	ldr	r3, [r7, #4]
240106b0:	69db      	ldr	r3, [r3, #28]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
240106b2:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
240106b4:	687b      	ldr	r3, [r7, #4]
240106b6:	6a1b      	ldr	r3, [r3, #32]
240106b8:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
240106ba:	687b      	ldr	r3, [r7, #4]
240106bc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
240106be:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
240106c0:	687b      	ldr	r3, [r7, #4]
240106c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240106c4:	431a      	orrs	r2, r3
                           hmdma->Init.DestBurst                                   | \
240106c6:	687b      	ldr	r3, [r7, #4]
240106c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
240106ca:	431a      	orrs	r2, r3
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
240106cc:	687b      	ldr	r3, [r7, #4]
240106ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240106d0:	3b01      	subs	r3, #1
240106d2:	049b      	lsls	r3, r3, #18
                           hmdma->Init.DestBurst                                   | \
240106d4:	ea42 0103 	orr.w	r1, r2, r3
                           hmdma->Init.TransferTriggerMode;
240106d8:	687b      	ldr	r3, [r7, #4]
240106da:	689a      	ldr	r2, [r3, #8]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
240106dc:	687b      	ldr	r3, [r7, #4]
240106de:	681b      	ldr	r3, [r3, #0]
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
240106e0:	430a      	orrs	r2, r1
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
240106e2:	611a      	str	r2, [r3, #16]

  /* If SW request set the CTCR register to SW Request Mode */
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
240106e4:	687b      	ldr	r3, [r7, #4]
240106e6:	685b      	ldr	r3, [r3, #4]
240106e8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240106ec:	d107      	bne.n	240106fe <MDMA_Init+0x72>
    -If the request is done by SW : BWM could be set to 1 or 0.
    -If the request is done by a peripheral :
    If mask address not set (0) => BWM must be set to 0
    If mask address set (different than 0) => BWM could be set to 1 or 0
    */
    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);
240106ee:	687b      	ldr	r3, [r7, #4]
240106f0:	681b      	ldr	r3, [r3, #0]
240106f2:	691a      	ldr	r2, [r3, #16]
240106f4:	687b      	ldr	r3, [r7, #4]
240106f6:	681b      	ldr	r3, [r3, #0]
240106f8:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
240106fc:	611a      	str	r2, [r3, #16]
  }

  /* Reset CBNDTR Register */
  hmdma->Instance->CBNDTR = 0;
240106fe:	687b      	ldr	r3, [r7, #4]
24010700:	681b      	ldr	r3, [r3, #0]
24010702:	2200      	movs	r2, #0
24010704:	615a      	str	r2, [r3, #20]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(hmdma->Init.SourceBlockAddressOffset < 0)
24010706:	687b      	ldr	r3, [r7, #4]
24010708:	6b5b      	ldr	r3, [r3, #52]	; 0x34
2401070a:	2b00      	cmp	r3, #0
2401070c:	da11      	bge.n	24010732 <MDMA_Init+0xa6>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
2401070e:	687b      	ldr	r3, [r7, #4]
24010710:	681b      	ldr	r3, [r3, #0]
24010712:	695a      	ldr	r2, [r3, #20]
24010714:	687b      	ldr	r3, [r7, #4]
24010716:	681b      	ldr	r3, [r3, #0]
24010718:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
2401071c:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);
2401071e:	687b      	ldr	r3, [r7, #4]
24010720:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24010722:	425b      	negs	r3, r3
24010724:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);
24010726:	687b      	ldr	r3, [r7, #4]
24010728:	681b      	ldr	r3, [r3, #0]
2401072a:	68fa      	ldr	r2, [r7, #12]
2401072c:	b292      	uxth	r2, r2
2401072e:	621a      	str	r2, [r3, #32]
24010730:	e006      	b.n	24010740 <MDMA_Init+0xb4>
  }
  else
  {
    /* Write new CBRUR Register value : source repeat block offset */
    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
24010732:	687b      	ldr	r3, [r7, #4]
24010734:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24010736:	461a      	mov	r2, r3
24010738:	687b      	ldr	r3, [r7, #4]
2401073a:	681b      	ldr	r3, [r3, #0]
2401073c:	b292      	uxth	r2, r2
2401073e:	621a      	str	r2, [r3, #32]
  }

  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(hmdma->Init.DestBlockAddressOffset < 0)
24010740:	687b      	ldr	r3, [r7, #4]
24010742:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24010744:	2b00      	cmp	r3, #0
24010746:	da15      	bge.n	24010774 <MDMA_Init+0xe8>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
24010748:	687b      	ldr	r3, [r7, #4]
2401074a:	681b      	ldr	r3, [r3, #0]
2401074c:	695a      	ldr	r2, [r3, #20]
2401074e:	687b      	ldr	r3, [r7, #4]
24010750:	681b      	ldr	r3, [r3, #0]
24010752:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
24010756:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);
24010758:	687b      	ldr	r3, [r7, #4]
2401075a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401075c:	425b      	negs	r3, r3
2401075e:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24010760:	687b      	ldr	r3, [r7, #4]
24010762:	681b      	ldr	r3, [r3, #0]
24010764:	6a19      	ldr	r1, [r3, #32]
24010766:	68fb      	ldr	r3, [r7, #12]
24010768:	041a      	lsls	r2, r3, #16
2401076a:	687b      	ldr	r3, [r7, #4]
2401076c:	681b      	ldr	r3, [r3, #0]
2401076e:	430a      	orrs	r2, r1
24010770:	621a      	str	r2, [r3, #32]
24010772:	e009      	b.n	24010788 <MDMA_Init+0xfc>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
24010774:	687b      	ldr	r3, [r7, #4]
24010776:	681b      	ldr	r3, [r3, #0]
24010778:	6a19      	ldr	r1, [r3, #32]
2401077a:	687b      	ldr	r3, [r7, #4]
2401077c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401077e:	041a      	lsls	r2, r3, #16
24010780:	687b      	ldr	r3, [r7, #4]
24010782:	681b      	ldr	r3, [r3, #0]
24010784:	430a      	orrs	r2, r1
24010786:	621a      	str	r2, [r3, #32]
  }

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
24010788:	687b      	ldr	r3, [r7, #4]
2401078a:	685b      	ldr	r3, [r3, #4]
2401078c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24010790:	d006      	beq.n	240107a0 <MDMA_Init+0x114>
  {
    /* Set the HW request in CTRB register  */
    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;
24010792:	687b      	ldr	r3, [r7, #4]
24010794:	685a      	ldr	r2, [r3, #4]
24010796:	687b      	ldr	r3, [r7, #4]
24010798:	681b      	ldr	r3, [r3, #0]
2401079a:	b2d2      	uxtb	r2, r2
2401079c:	629a      	str	r2, [r3, #40]	; 0x28
2401079e:	e003      	b.n	240107a8 <MDMA_Init+0x11c>
  }
  else /* SW request : reset the CTBR register */
  {
    hmdma->Instance->CTBR = 0;
240107a0:	687b      	ldr	r3, [r7, #4]
240107a2:	681b      	ldr	r3, [r3, #0]
240107a4:	2200      	movs	r2, #0
240107a6:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Write Link Address Register */
  hmdma->Instance->CLAR =  0;
240107a8:	687b      	ldr	r3, [r7, #4]
240107aa:	681b      	ldr	r3, [r3, #0]
240107ac:	2200      	movs	r2, #0
240107ae:	625a      	str	r2, [r3, #36]	; 0x24
}
240107b0:	bf00      	nop
240107b2:	3714      	adds	r7, #20
240107b4:	46bd      	mov	sp, r7
240107b6:	f85d 7b04 	ldr.w	r7, [sp], #4
240107ba:	4770      	bx	lr

240107bc <HAL_PWR_DeInit>:
  *         The prototype is kept just to maintain compatibility with other
  *         products.
  * @retval None.
  */
void HAL_PWR_DeInit (void)
{
240107bc:	b480      	push	{r7}
240107be:	af00      	add	r7, sp, #0
}
240107c0:	bf00      	nop
240107c2:	46bd      	mov	sp, r7
240107c4:	f85d 7b04 	ldr.w	r7, [sp], #4
240107c8:	4770      	bx	lr
	...

240107cc <HAL_PWR_EnableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_EnableBkUpAccess (void)
{
240107cc:	b480      	push	{r7}
240107ce:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT (PWR->CR1, PWR_CR1_DBP);
240107d0:	4b05      	ldr	r3, [pc, #20]	; (240107e8 <HAL_PWR_EnableBkUpAccess+0x1c>)
240107d2:	681b      	ldr	r3, [r3, #0]
240107d4:	4a04      	ldr	r2, [pc, #16]	; (240107e8 <HAL_PWR_EnableBkUpAccess+0x1c>)
240107d6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
240107da:	6013      	str	r3, [r2, #0]
}
240107dc:	bf00      	nop
240107de:	46bd      	mov	sp, r7
240107e0:	f85d 7b04 	ldr.w	r7, [sp], #4
240107e4:	4770      	bx	lr
240107e6:	bf00      	nop
240107e8:	58024800 	.word	0x58024800

240107ec <HAL_PWR_DisableBkUpAccess>:
  * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the
  *         Backup Domain Access should be kept enabled.
  * @retval None.
  */
void HAL_PWR_DisableBkUpAccess (void)
{
240107ec:	b480      	push	{r7}
240107ee:	af00      	add	r7, sp, #0
  /* Disable access to RTC and backup registers */
  CLEAR_BIT (PWR->CR1, PWR_CR1_DBP);
240107f0:	4b05      	ldr	r3, [pc, #20]	; (24010808 <HAL_PWR_DisableBkUpAccess+0x1c>)
240107f2:	681b      	ldr	r3, [r3, #0]
240107f4:	4a04      	ldr	r2, [pc, #16]	; (24010808 <HAL_PWR_DisableBkUpAccess+0x1c>)
240107f6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
240107fa:	6013      	str	r3, [r2, #0]
}
240107fc:	bf00      	nop
240107fe:	46bd      	mov	sp, r7
24010800:	f85d 7b04 	ldr.w	r7, [sp], #4
24010804:	4770      	bx	lr
24010806:	bf00      	nop
24010808:	58024800 	.word	0x58024800

2401080c <HAL_PWR_ConfigPVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 or wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWR_ConfigPVD (PWR_PVDTypeDef *sConfigPVD)
{
2401080c:	b480      	push	{r7}
2401080e:	b083      	sub	sp, #12
24010810:	af00      	add	r7, sp, #0
24010812:	6078      	str	r0, [r7, #4]
  /* Check the PVD configuration parameter */
  if (sConfigPVD == NULL)
24010814:	687b      	ldr	r3, [r7, #4]
24010816:	2b00      	cmp	r3, #0
24010818:	d069      	beq.n	240108ee <HAL_PWR_ConfigPVD+0xe2>
  /* Check the parameters */
  assert_param (IS_PWR_PVD_LEVEL (sConfigPVD->PVDLevel));
  assert_param (IS_PWR_PVD_MODE (sConfigPVD->Mode));

  /* Set PLS[7:5] bits according to PVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_PLS, sConfigPVD->PVDLevel);
2401081a:	4b38      	ldr	r3, [pc, #224]	; (240108fc <HAL_PWR_ConfigPVD+0xf0>)
2401081c:	681b      	ldr	r3, [r3, #0]
2401081e:	f023 02e0 	bic.w	r2, r3, #224	; 0xe0
24010822:	687b      	ldr	r3, [r7, #4]
24010824:	681b      	ldr	r3, [r3, #0]
24010826:	4935      	ldr	r1, [pc, #212]	; (240108fc <HAL_PWR_ConfigPVD+0xf0>)
24010828:	4313      	orrs	r3, r2
2401082a:	600b      	str	r3, [r1, #0]

  /* Clear previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_PVD_EXTI_DISABLE_EVENT ();
2401082c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010830:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24010834:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010838:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401083c:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_PVD_EXTI_DISABLE_IT ();
24010840:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010844:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010848:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401084c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010850:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE ();
24010854:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010858:	681b      	ldr	r3, [r3, #0]
2401085a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401085e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010862:	6013      	str	r3, [r2, #0]
  __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE ();
24010864:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010868:	685b      	ldr	r3, [r3, #4]
2401086a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401086e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24010872:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Interrupt mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
24010874:	687b      	ldr	r3, [r7, #4]
24010876:	685b      	ldr	r3, [r3, #4]
24010878:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401087c:	2b00      	cmp	r3, #0
2401087e:	d009      	beq.n	24010894 <HAL_PWR_ConfigPVD+0x88>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_IT ();
24010880:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010884:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24010888:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401088c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010890:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Event mode configuration */
  if ((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
24010894:	687b      	ldr	r3, [r7, #4]
24010896:	685b      	ldr	r3, [r3, #4]
24010898:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401089c:	2b00      	cmp	r3, #0
2401089e:	d009      	beq.n	240108b4 <HAL_PWR_ConfigPVD+0xa8>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_EVENT ();
240108a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240108a4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
240108a8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240108ac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240108b0:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
240108b4:	687b      	ldr	r3, [r7, #4]
240108b6:	685b      	ldr	r3, [r3, #4]
240108b8:	f003 0301 	and.w	r3, r3, #1
240108bc:	2b00      	cmp	r3, #0
240108be:	d007      	beq.n	240108d0 <HAL_PWR_ConfigPVD+0xc4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE ();
240108c0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240108c4:	681b      	ldr	r3, [r3, #0]
240108c6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240108ca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240108ce:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
240108d0:	687b      	ldr	r3, [r7, #4]
240108d2:	685b      	ldr	r3, [r3, #4]
240108d4:	f003 0302 	and.w	r3, r3, #2
240108d8:	2b00      	cmp	r3, #0
240108da:	d009      	beq.n	240108f0 <HAL_PWR_ConfigPVD+0xe4>
  {
    __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE ();
240108dc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240108e0:	685b      	ldr	r3, [r3, #4]
240108e2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240108e6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240108ea:	6053      	str	r3, [r2, #4]
240108ec:	e000      	b.n	240108f0 <HAL_PWR_ConfigPVD+0xe4>
    return;
240108ee:	bf00      	nop
  }
}
240108f0:	370c      	adds	r7, #12
240108f2:	46bd      	mov	sp, r7
240108f4:	f85d 7b04 	ldr.w	r7, [sp], #4
240108f8:	4770      	bx	lr
240108fa:	bf00      	nop
240108fc:	58024800 	.word	0x58024800

24010900 <HAL_PWR_EnablePVD>:
/**
  * @brief Enable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_EnablePVD (void)
{
24010900:	b480      	push	{r7}
24010902:	af00      	add	r7, sp, #0
  /* Enable the power voltage detector */
  SET_BIT (PWR->CR1, PWR_CR1_PVDEN);
24010904:	4b05      	ldr	r3, [pc, #20]	; (2401091c <HAL_PWR_EnablePVD+0x1c>)
24010906:	681b      	ldr	r3, [r3, #0]
24010908:	4a04      	ldr	r2, [pc, #16]	; (2401091c <HAL_PWR_EnablePVD+0x1c>)
2401090a:	f043 0310 	orr.w	r3, r3, #16
2401090e:	6013      	str	r3, [r2, #0]
}
24010910:	bf00      	nop
24010912:	46bd      	mov	sp, r7
24010914:	f85d 7b04 	ldr.w	r7, [sp], #4
24010918:	4770      	bx	lr
2401091a:	bf00      	nop
2401091c:	58024800 	.word	0x58024800

24010920 <HAL_PWR_DisablePVD>:
/**
  * @brief Disable the Programmable Voltage Detector (PVD).
  * @retval None.
  */
void HAL_PWR_DisablePVD (void)
{
24010920:	b480      	push	{r7}
24010922:	af00      	add	r7, sp, #0
  /* Disable the power voltage detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_PVDEN);
24010924:	4b05      	ldr	r3, [pc, #20]	; (2401093c <HAL_PWR_DisablePVD+0x1c>)
24010926:	681b      	ldr	r3, [r3, #0]
24010928:	4a04      	ldr	r2, [pc, #16]	; (2401093c <HAL_PWR_DisablePVD+0x1c>)
2401092a:	f023 0310 	bic.w	r3, r3, #16
2401092e:	6013      	str	r3, [r2, #0]
}
24010930:	bf00      	nop
24010932:	46bd      	mov	sp, r7
24010934:	f85d 7b04 	ldr.w	r7, [sp], #4
24010938:	4770      	bx	lr
2401093a:	bf00      	nop
2401093c:	58024800 	.word	0x58024800

24010940 <HAL_PWR_EnableWakeUpPin>:
  *         and PWR_WAKEUP_PIN5_LOW are available only for devices that includes
  *         GPIOI port.
  * @retval None.
  */
void HAL_PWR_EnableWakeUpPin (uint32_t WakeUpPinPolarity)
{
24010940:	b480      	push	{r7}
24010942:	b083      	sub	sp, #12
24010944:	af00      	add	r7, sp, #0
24010946:	6078      	str	r0, [r7, #4]

  /*
     Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge).
  */
  MODIFY_REG (PWR->WKUPEPR, PWR_EWUP_MASK, WakeUpPinPolarity);
24010948:	4b06      	ldr	r3, [pc, #24]	; (24010964 <HAL_PWR_EnableWakeUpPin+0x24>)
2401094a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2401094c:	4b06      	ldr	r3, [pc, #24]	; (24010968 <HAL_PWR_EnableWakeUpPin+0x28>)
2401094e:	4013      	ands	r3, r2
24010950:	4904      	ldr	r1, [pc, #16]	; (24010964 <HAL_PWR_EnableWakeUpPin+0x24>)
24010952:	687a      	ldr	r2, [r7, #4]
24010954:	4313      	orrs	r3, r2
24010956:	628b      	str	r3, [r1, #40]	; 0x28
}
24010958:	bf00      	nop
2401095a:	370c      	adds	r7, #12
2401095c:	46bd      	mov	sp, r7
2401095e:	f85d 7b04 	ldr.w	r7, [sp], #4
24010962:	4770      	bx	lr
24010964:	58024800 	.word	0x58024800
24010968:	f000c0c0 	.word	0xf000c0c0

2401096c <HAL_PWR_DisableWakeUpPin>:
  *         and PWR_WAKEUP_PIN5_LOW are available only for devices that includes
  *         GPIOI port.
  * @retval None.
  */
void HAL_PWR_DisableWakeUpPin (uint32_t WakeUpPinx)
{
2401096c:	b480      	push	{r7}
2401096e:	b083      	sub	sp, #12
24010970:	af00      	add	r7, sp, #0
24010972:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPinx));

  /* Disable the wake up pin selected */
  CLEAR_BIT (PWR->WKUPEPR, (PWR_WKUPEPR_WKUPEN & WakeUpPinx));
24010974:	4b07      	ldr	r3, [pc, #28]	; (24010994 <HAL_PWR_DisableWakeUpPin+0x28>)
24010976:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010978:	687b      	ldr	r3, [r7, #4]
2401097a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
2401097e:	43db      	mvns	r3, r3
24010980:	4904      	ldr	r1, [pc, #16]	; (24010994 <HAL_PWR_DisableWakeUpPin+0x28>)
24010982:	4013      	ands	r3, r2
24010984:	628b      	str	r3, [r1, #40]	; 0x28
}
24010986:	bf00      	nop
24010988:	370c      	adds	r7, #12
2401098a:	46bd      	mov	sp, r7
2401098c:	f85d 7b04 	ldr.w	r7, [sp], #4
24010990:	4770      	bx	lr
24010992:	bf00      	nop
24010994:	58024800 	.word	0x58024800

24010998 <HAL_PWR_EnterSLEEPMode>:
  * @note   Ensure to clear pending events before calling this API through
  *         HAL_PWREx_ClearPendingEvent() when the SLEEP entry is WFE.
  * @retval None.
  */
void HAL_PWR_EnterSLEEPMode (uint32_t Regulator, uint8_t SLEEPEntry)
{
24010998:	b480      	push	{r7}
2401099a:	b083      	sub	sp, #12
2401099c:	af00      	add	r7, sp, #0
2401099e:	6078      	str	r0, [r7, #4]
240109a0:	460b      	mov	r3, r1
240109a2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_SLEEP_ENTRY (SLEEPEntry));

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
240109a4:	4b08      	ldr	r3, [pc, #32]	; (240109c8 <HAL_PWR_EnterSLEEPMode+0x30>)
240109a6:	691b      	ldr	r3, [r3, #16]
240109a8:	4a07      	ldr	r2, [pc, #28]	; (240109c8 <HAL_PWR_EnterSLEEPMode+0x30>)
240109aa:	f023 0304 	bic.w	r3, r3, #4
240109ae:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry */
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
240109b0:	78fb      	ldrb	r3, [r7, #3]
240109b2:	2b01      	cmp	r3, #1
240109b4:	d101      	bne.n	240109ba <HAL_PWR_EnterSLEEPMode+0x22>
  {
    /* Request Wait For Interrupt */
    __WFI ();
240109b6:	bf30      	wfi
  else
  {
    /* Request Wait For Event */
    __WFE ();
  }
}
240109b8:	e000      	b.n	240109bc <HAL_PWR_EnterSLEEPMode+0x24>
    __WFE ();
240109ba:	bf20      	wfe
}
240109bc:	bf00      	nop
240109be:	370c      	adds	r7, #12
240109c0:	46bd      	mov	sp, r7
240109c2:	f85d 7b04 	ldr.w	r7, [sp], #4
240109c6:	4770      	bx	lr
240109c8:	e000ed00 	.word	0xe000ed00

240109cc <HAL_PWR_EnterSTOPMode>:
  *         is waking up. By keeping the internal regulator ON during STOP mode,
  *         the consumption is higher although the startup time is reduced.
  * @retval None.
  */
void HAL_PWR_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry)
{
240109cc:	b480      	push	{r7}
240109ce:	b083      	sub	sp, #12
240109d0:	af00      	add	r7, sp, #0
240109d2:	6078      	str	r0, [r7, #4]
240109d4:	460b      	mov	r3, r1
240109d6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));

  /* Select the regulator state in STOP mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
240109d8:	4b18      	ldr	r3, [pc, #96]	; (24010a3c <HAL_PWR_EnterSTOPMode+0x70>)
240109da:	681b      	ldr	r3, [r3, #0]
240109dc:	f023 0201 	bic.w	r2, r3, #1
240109e0:	4916      	ldr	r1, [pc, #88]	; (24010a3c <HAL_PWR_EnterSTOPMode+0x70>)
240109e2:	687b      	ldr	r3, [r7, #4]
240109e4:	4313      	orrs	r3, r2
240109e6:	600b      	str	r3, [r1, #0]
    /* Keep DSTOP mode when Cortex-M4 enters DEEP-SLEEP */
    CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
  }
#else /* Single core devices */
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
240109e8:	4b14      	ldr	r3, [pc, #80]	; (24010a3c <HAL_PWR_EnterSTOPMode+0x70>)
240109ea:	691b      	ldr	r3, [r3, #16]
240109ec:	4a13      	ldr	r2, [pc, #76]	; (24010a3c <HAL_PWR_EnterSTOPMode+0x70>)
240109ee:	f023 0305 	bic.w	r3, r3, #5
240109f2:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Keep DSTOP mode when Cortex-M7 enter in DEEP-SLEEP */
  CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
240109f4:	4b11      	ldr	r3, [pc, #68]	; (24010a3c <HAL_PWR_EnterSTOPMode+0x70>)
240109f6:	691b      	ldr	r3, [r3, #16]
240109f8:	4a10      	ldr	r2, [pc, #64]	; (24010a3c <HAL_PWR_EnterSTOPMode+0x70>)
240109fa:	f023 0302 	bic.w	r3, r3, #2
240109fe:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010a00:	4b0f      	ldr	r3, [pc, #60]	; (24010a40 <HAL_PWR_EnterSTOPMode+0x74>)
24010a02:	691b      	ldr	r3, [r3, #16]
24010a04:	4a0e      	ldr	r2, [pc, #56]	; (24010a40 <HAL_PWR_EnterSTOPMode+0x74>)
24010a06:	f043 0304 	orr.w	r3, r3, #4
24010a0a:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
24010a0c:	f3bf 8f4f 	dsb	sy
}
24010a10:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
24010a12:	f3bf 8f6f 	isb	sy
}
24010a16:	bf00      	nop
  /* Ensure that all instructions are done before entering STOP mode */
  __DSB ();
  __ISB ();

  /* Select STOP mode entry */
  if (STOPEntry == PWR_STOPENTRY_WFI)
24010a18:	78fb      	ldrb	r3, [r7, #3]
24010a1a:	2b01      	cmp	r3, #1
24010a1c:	d101      	bne.n	24010a22 <HAL_PWR_EnterSTOPMode+0x56>
  {
    /* Request Wait For Interrupt */
    __WFI ();
24010a1e:	bf30      	wfi
24010a20:	e000      	b.n	24010a24 <HAL_PWR_EnterSTOPMode+0x58>
  }
  else
  {
    /* Request Wait For Event */
    __WFE ();
24010a22:	bf20      	wfe
  }

  /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010a24:	4b06      	ldr	r3, [pc, #24]	; (24010a40 <HAL_PWR_EnterSTOPMode+0x74>)
24010a26:	691b      	ldr	r3, [r3, #16]
24010a28:	4a05      	ldr	r2, [pc, #20]	; (24010a40 <HAL_PWR_EnterSTOPMode+0x74>)
24010a2a:	f023 0304 	bic.w	r3, r3, #4
24010a2e:	6113      	str	r3, [r2, #16]
}
24010a30:	bf00      	nop
24010a32:	370c      	adds	r7, #12
24010a34:	46bd      	mov	sp, r7
24010a36:	f85d 7b04 	ldr.w	r7, [sp], #4
24010a3a:	4770      	bx	lr
24010a3c:	58024800 	.word	0x58024800
24010a40:	e000ed00 	.word	0xe000ed00

24010a44 <HAL_PWR_EnterSTANDBYMode>:
  * @note   It is recommended to disable all regulators before entring STANDBY
  *         mode for power consumption saving purpose.
  * @retval None.
  */
void HAL_PWR_EnterSTANDBYMode (void)
{
24010a44:	b480      	push	{r7}
24010a46:	af00      	add	r7, sp, #0
    SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D2 | PWR_CPUCR_PDDS_D3));
    SET_BIT (PWR->CPU2CR, (PWR_CPU2CR_PDDS_D2 | PWR_CPU2CR_PDDS_D3));
  }
#else /* Single core devices */
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, (PWR_CPUCR_PDDS_D1 | PWR_CPUCR_PDDS_D3));
24010a48:	4b0e      	ldr	r3, [pc, #56]	; (24010a84 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010a4a:	691b      	ldr	r3, [r3, #16]
24010a4c:	4a0d      	ldr	r2, [pc, #52]	; (24010a84 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010a4e:	f043 0305 	orr.w	r3, r3, #5
24010a52:	6113      	str	r3, [r2, #16]

#if defined (PWR_CPUCR_PDDS_D2)
  /* Enter DSTANDBY mode when Cortex-M7 enters DEEP-SLEEP */
  SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
24010a54:	4b0b      	ldr	r3, [pc, #44]	; (24010a84 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010a56:	691b      	ldr	r3, [r3, #16]
24010a58:	4a0a      	ldr	r2, [pc, #40]	; (24010a84 <HAL_PWR_EnterSTANDBYMode+0x40>)
24010a5a:	f043 0302 	orr.w	r3, r3, #2
24010a5e:	6113      	str	r3, [r2, #16]
#endif /* PWR_CPUCR_PDDS_D2 */
#endif /* defined (DUAL_CORE) */

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010a60:	4b09      	ldr	r3, [pc, #36]	; (24010a88 <HAL_PWR_EnterSTANDBYMode+0x44>)
24010a62:	691b      	ldr	r3, [r3, #16]
24010a64:	4a08      	ldr	r2, [pc, #32]	; (24010a88 <HAL_PWR_EnterSTANDBYMode+0x44>)
24010a66:	f043 0304 	orr.w	r3, r3, #4
24010a6a:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
24010a6c:	f3bf 8f4f 	dsb	sy
}
24010a70:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
24010a72:	f3bf 8f6f 	isb	sy
}
24010a76:	bf00      	nop
#if defined (__CC_ARM)
  __force_stores();
#endif /* defined (__CC_ARM) */

  /* Request Wait For Interrupt */
  __WFI ();
24010a78:	bf30      	wfi
}
24010a7a:	bf00      	nop
24010a7c:	46bd      	mov	sp, r7
24010a7e:	f85d 7b04 	ldr.w	r7, [sp], #4
24010a82:	4770      	bx	lr
24010a84:	58024800 	.word	0x58024800
24010a88:	e000ed00 	.word	0xe000ed00

24010a8c <HAL_PWR_EnableSleepOnExit>:
  *         Setting this bit is useful when the processor is expected to run
  *         only on interruptions handling.
  * @retval None.
  */
void HAL_PWR_EnableSleepOnExit (void)
{
24010a8c:	b480      	push	{r7}
24010a8e:	af00      	add	r7, sp, #0
  /* Set SLEEPONEXIT bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
24010a90:	4b05      	ldr	r3, [pc, #20]	; (24010aa8 <HAL_PWR_EnableSleepOnExit+0x1c>)
24010a92:	691b      	ldr	r3, [r3, #16]
24010a94:	4a04      	ldr	r2, [pc, #16]	; (24010aa8 <HAL_PWR_EnableSleepOnExit+0x1c>)
24010a96:	f043 0302 	orr.w	r3, r3, #2
24010a9a:	6113      	str	r3, [r2, #16]
}
24010a9c:	bf00      	nop
24010a9e:	46bd      	mov	sp, r7
24010aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
24010aa4:	4770      	bx	lr
24010aa6:	bf00      	nop
24010aa8:	e000ed00 	.word	0xe000ed00

24010aac <HAL_PWR_DisableSleepOnExit>:
  * @note   Clears SLEEPONEXIT bit of SCR register. When this bit is set, the
  *         processor re-enters SLEEP mode when an interruption handling is over.
  * @retval None
  */
void HAL_PWR_DisableSleepOnExit (void)
{
24010aac:	b480      	push	{r7}
24010aae:	af00      	add	r7, sp, #0
  /* Clear SLEEPONEXIT bit of Cortex-Mx System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPONEXIT_Msk);
24010ab0:	4b05      	ldr	r3, [pc, #20]	; (24010ac8 <HAL_PWR_DisableSleepOnExit+0x1c>)
24010ab2:	691b      	ldr	r3, [r3, #16]
24010ab4:	4a04      	ldr	r2, [pc, #16]	; (24010ac8 <HAL_PWR_DisableSleepOnExit+0x1c>)
24010ab6:	f023 0302 	bic.w	r3, r3, #2
24010aba:	6113      	str	r3, [r2, #16]
}
24010abc:	bf00      	nop
24010abe:	46bd      	mov	sp, r7
24010ac0:	f85d 7b04 	ldr.w	r7, [sp], #4
24010ac4:	4770      	bx	lr
24010ac6:	bf00      	nop
24010ac8:	e000ed00 	.word	0xe000ed00

24010acc <HAL_PWR_EnableSEVOnPend>:
  *         pending event / interrupt even if it's disabled or has insufficient
  *         priority to cause exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_EnableSEVOnPend (void)
{
24010acc:	b480      	push	{r7}
24010ace:	af00      	add	r7, sp, #0
  /* Set SEVONPEND bit of Cortex-Mx System Control Register */
  SET_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
24010ad0:	4b05      	ldr	r3, [pc, #20]	; (24010ae8 <HAL_PWR_EnableSEVOnPend+0x1c>)
24010ad2:	691b      	ldr	r3, [r3, #16]
24010ad4:	4a04      	ldr	r2, [pc, #16]	; (24010ae8 <HAL_PWR_EnableSEVOnPend+0x1c>)
24010ad6:	f043 0310 	orr.w	r3, r3, #16
24010ada:	6113      	str	r3, [r2, #16]
}
24010adc:	bf00      	nop
24010ade:	46bd      	mov	sp, r7
24010ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
24010ae4:	4770      	bx	lr
24010ae6:	bf00      	nop
24010ae8:	e000ed00 	.word	0xe000ed00

24010aec <HAL_PWR_DisableSEVOnPend>:
  * @note   Resets SEVONPEND bit of SCR register. When this bit is reset, only
  *         enabled pending causes exception entry wakes up the Cortex-Mx.
  * @retval None.
  */
void HAL_PWR_DisableSEVOnPend (void)
{
24010aec:	b480      	push	{r7}
24010aee:	af00      	add	r7, sp, #0
  /* Clear SEVONPEND bit of Cortex System Control Register */
  CLEAR_BIT (SCB->SCR, SCB_SCR_SEVONPEND_Msk);
24010af0:	4b05      	ldr	r3, [pc, #20]	; (24010b08 <HAL_PWR_DisableSEVOnPend+0x1c>)
24010af2:	691b      	ldr	r3, [r3, #16]
24010af4:	4a04      	ldr	r2, [pc, #16]	; (24010b08 <HAL_PWR_DisableSEVOnPend+0x1c>)
24010af6:	f023 0310 	bic.w	r3, r3, #16
24010afa:	6113      	str	r3, [r2, #16]
}
24010afc:	bf00      	nop
24010afe:	46bd      	mov	sp, r7
24010b00:	f85d 7b04 	ldr.w	r7, [sp], #4
24010b04:	4770      	bx	lr
24010b06:	bf00      	nop
24010b08:	e000ed00 	.word	0xe000ed00

24010b0c <HAL_PWR_PVD_IRQHandler>:
  * @brief  This function handles the PWR PVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None.
  */
void HAL_PWR_PVD_IRQHandler (void)
{
24010b0c:	b580      	push	{r7, lr}
24010b0e:	af00      	add	r7, sp, #0
      HAL_PWR_PVDCallback ();
    }
  }
#else /* Single core devices */
  /* PVD EXTI line interrupt detected */
  if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
24010b10:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010b14:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010b18:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24010b1c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24010b20:	d10b      	bne.n	24010b3a <HAL_PWR_PVD_IRQHandler+0x2e>
  {
    /* Clear PWR EXTI pending bit */
    __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
24010b22:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010b26:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24010b2a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24010b2e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24010b32:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    /* PWR PVD interrupt user callback */
    HAL_PWR_PVDCallback ();
24010b36:	f000 f802 	bl	24010b3e <HAL_PWR_PVDCallback>
  }
#endif /* defined (DUAL_CORE) */
}
24010b3a:	bf00      	nop
24010b3c:	bd80      	pop	{r7, pc}

24010b3e <HAL_PWR_PVDCallback>:
/**
  * @brief  PWR PVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWR_PVDCallback (void)
{
24010b3e:	b480      	push	{r7}
24010b40:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_PVDCallback can be implemented in the user file
  */
}
24010b42:	bf00      	nop
24010b44:	46bd      	mov	sp, r7
24010b46:	f85d 7b04 	ldr.w	r7, [sp], #4
24010b4a:	4770      	bx	lr

24010b4c <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
24010b4c:	b580      	push	{r7, lr}
24010b4e:	b084      	sub	sp, #16
24010b50:	af00      	add	r7, sp, #0
24010b52:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
24010b54:	4b19      	ldr	r3, [pc, #100]	; (24010bbc <HAL_PWREx_ConfigSupply+0x70>)
24010b56:	68db      	ldr	r3, [r3, #12]
24010b58:	f003 0304 	and.w	r3, r3, #4
24010b5c:	2b04      	cmp	r3, #4
24010b5e:	d00a      	beq.n	24010b76 <HAL_PWREx_ConfigSupply+0x2a>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
24010b60:	4b16      	ldr	r3, [pc, #88]	; (24010bbc <HAL_PWREx_ConfigSupply+0x70>)
24010b62:	68db      	ldr	r3, [r3, #12]
24010b64:	f003 0307 	and.w	r3, r3, #7
24010b68:	687a      	ldr	r2, [r7, #4]
24010b6a:	429a      	cmp	r2, r3
24010b6c:	d001      	beq.n	24010b72 <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
24010b6e:	2301      	movs	r3, #1
24010b70:	e01f      	b.n	24010bb2 <HAL_PWREx_ConfigSupply+0x66>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
24010b72:	2300      	movs	r3, #0
24010b74:	e01d      	b.n	24010bb2 <HAL_PWREx_ConfigSupply+0x66>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
24010b76:	4b11      	ldr	r3, [pc, #68]	; (24010bbc <HAL_PWREx_ConfigSupply+0x70>)
24010b78:	68db      	ldr	r3, [r3, #12]
24010b7a:	f023 0207 	bic.w	r2, r3, #7
24010b7e:	490f      	ldr	r1, [pc, #60]	; (24010bbc <HAL_PWREx_ConfigSupply+0x70>)
24010b80:	687b      	ldr	r3, [r7, #4]
24010b82:	4313      	orrs	r3, r2
24010b84:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
24010b86:	f7f1 fbdd 	bl	24002344 <HAL_GetTick>
24010b8a:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010b8c:	e009      	b.n	24010ba2 <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
24010b8e:	f7f1 fbd9 	bl	24002344 <HAL_GetTick>
24010b92:	4602      	mov	r2, r0
24010b94:	68fb      	ldr	r3, [r7, #12]
24010b96:	1ad3      	subs	r3, r2, r3
24010b98:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010b9c:	d901      	bls.n	24010ba2 <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
24010b9e:	2301      	movs	r3, #1
24010ba0:	e007      	b.n	24010bb2 <HAL_PWREx_ConfigSupply+0x66>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010ba2:	4b06      	ldr	r3, [pc, #24]	; (24010bbc <HAL_PWREx_ConfigSupply+0x70>)
24010ba4:	685b      	ldr	r3, [r3, #4]
24010ba6:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24010baa:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24010bae:	d1ee      	bne.n	24010b8e <HAL_PWREx_ConfigSupply+0x42>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
24010bb0:	2300      	movs	r3, #0
}
24010bb2:	4618      	mov	r0, r3
24010bb4:	3710      	adds	r7, #16
24010bb6:	46bd      	mov	sp, r7
24010bb8:	bd80      	pop	{r7, pc}
24010bba:	bf00      	nop
24010bbc:	58024800 	.word	0x58024800

24010bc0 <HAL_PWREx_GetSupplyConfig>:
/**
  * @brief Get the power supply configuration.
  * @retval The supply configuration.
  */
uint32_t HAL_PWREx_GetSupplyConfig (void)
{
24010bc0:	b480      	push	{r7}
24010bc2:	af00      	add	r7, sp, #0
  return (PWR->CR3 & PWR_SUPPLY_CONFIG_MASK);
24010bc4:	4b04      	ldr	r3, [pc, #16]	; (24010bd8 <HAL_PWREx_GetSupplyConfig+0x18>)
24010bc6:	68db      	ldr	r3, [r3, #12]
24010bc8:	f003 0307 	and.w	r3, r3, #7
}
24010bcc:	4618      	mov	r0, r3
24010bce:	46bd      	mov	sp, r7
24010bd0:	f85d 7b04 	ldr.w	r7, [sp], #4
24010bd4:	4770      	bx	lr
24010bd6:	bf00      	nop
24010bd8:	58024800 	.word	0x58024800

24010bdc <HAL_PWREx_ControlVoltageScaling>:
  *         Voltage Scale 0 then first switch to Voltage Scale 1 before entering
  *         low power mode.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling (uint32_t VoltageScaling)
{
24010bdc:	b580      	push	{r7, lr}
24010bde:	b084      	sub	sp, #16
24010be0:	af00      	add	r7, sp, #0
24010be2:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param (IS_PWR_REGULATOR_VOLTAGE (VoltageScaling));

  /* Get the voltage scaling  */
  if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == VoltageScaling)
24010be4:	4b3f      	ldr	r3, [pc, #252]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010be6:	685b      	ldr	r3, [r3, #4]
24010be8:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
24010bec:	687a      	ldr	r2, [r7, #4]
24010bee:	429a      	cmp	r2, r3
24010bf0:	d101      	bne.n	24010bf6 <HAL_PWREx_ControlVoltageScaling+0x1a>
  {
    /* Old and new voltage scaling configuration match : nothing to do */
    return HAL_OK;
24010bf2:	2300      	movs	r3, #0
24010bf4:	e072      	b.n	24010cdc <HAL_PWREx_ControlVoltageScaling+0x100>
#if defined (PWR_SRDCR_VOS)
  /* Set the voltage range */
  MODIFY_REG (PWR->SRDCR, PWR_SRDCR_VOS, VoltageScaling);
#else
#if defined(SYSCFG_PWRCR_ODEN) /* STM32H74xxx and STM32H75xxx lines */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE0)
24010bf6:	687b      	ldr	r3, [r7, #4]
24010bf8:	2b00      	cmp	r3, #0
24010bfa:	d129      	bne.n	24010c50 <HAL_PWREx_ControlVoltageScaling+0x74>
  {
    if ((PWR->CR3 & PWR_CR3_LDOEN) == PWR_CR3_LDOEN)
24010bfc:	4b39      	ldr	r3, [pc, #228]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010bfe:	68db      	ldr	r3, [r3, #12]
24010c00:	f003 0302 	and.w	r3, r3, #2
24010c04:	2b02      	cmp	r3, #2
24010c06:	d121      	bne.n	24010c4c <HAL_PWREx_ControlVoltageScaling+0x70>
    {
      /* Set the voltage range */
      MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
24010c08:	4b36      	ldr	r3, [pc, #216]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010c0a:	699b      	ldr	r3, [r3, #24]
24010c0c:	4a35      	ldr	r2, [pc, #212]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010c0e:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
24010c12:	6193      	str	r3, [r2, #24]

      /* Get tick */
      tickstart = HAL_GetTick ();
24010c14:	f7f1 fb96 	bl	24002344 <HAL_GetTick>
24010c18:	60f8      	str	r0, [r7, #12]

      /* Wait till voltage level flag is set */
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010c1a:	e009      	b.n	24010c30 <HAL_PWREx_ControlVoltageScaling+0x54>
      {
        if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
24010c1c:	f7f1 fb92 	bl	24002344 <HAL_GetTick>
24010c20:	4602      	mov	r2, r0
24010c22:	68fb      	ldr	r3, [r7, #12]
24010c24:	1ad3      	subs	r3, r2, r3
24010c26:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010c2a:	d901      	bls.n	24010c30 <HAL_PWREx_ControlVoltageScaling+0x54>
        {
          return HAL_ERROR;
24010c2c:	2301      	movs	r3, #1
24010c2e:	e055      	b.n	24010cdc <HAL_PWREx_ControlVoltageScaling+0x100>
      while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010c30:	4b2c      	ldr	r3, [pc, #176]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010c32:	685b      	ldr	r3, [r3, #4]
24010c34:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24010c38:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24010c3c:	d1ee      	bne.n	24010c1c <HAL_PWREx_ControlVoltageScaling+0x40>
        }
      }

      /* Enable the PWR overdrive */
      SET_BIT (SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
24010c3e:	4b2a      	ldr	r3, [pc, #168]	; (24010ce8 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010c40:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010c42:	4a29      	ldr	r2, [pc, #164]	; (24010ce8 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010c44:	f043 0301 	orr.w	r3, r3, #1
24010c48:	62d3      	str	r3, [r2, #44]	; 0x2c
24010c4a:	e031      	b.n	24010cb0 <HAL_PWREx_ControlVoltageScaling+0xd4>
    }
    else
    {
      /* The voltage scale 0 is only possible when LDO regulator is enabled */
      return HAL_ERROR;
24010c4c:	2301      	movs	r3, #1
24010c4e:	e045      	b.n	24010cdc <HAL_PWREx_ControlVoltageScaling+0x100>
    }
  }
  else
  {
    if ((PWR->CSR1 & PWR_CSR1_ACTVOS) == PWR_REGULATOR_VOLTAGE_SCALE1)
24010c50:	4b24      	ldr	r3, [pc, #144]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010c52:	685b      	ldr	r3, [r3, #4]
24010c54:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
24010c58:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
24010c5c:	d120      	bne.n	24010ca0 <HAL_PWREx_ControlVoltageScaling+0xc4>
    {
      if ((SYSCFG->PWRCR & SYSCFG_PWRCR_ODEN) != 0U)
24010c5e:	4b22      	ldr	r3, [pc, #136]	; (24010ce8 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010c60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010c62:	f003 0301 	and.w	r3, r3, #1
24010c66:	2b00      	cmp	r3, #0
24010c68:	d01a      	beq.n	24010ca0 <HAL_PWREx_ControlVoltageScaling+0xc4>
      {
        /* Disable the PWR overdrive */
        CLEAR_BIT(SYSCFG->PWRCR, SYSCFG_PWRCR_ODEN);
24010c6a:	4b1f      	ldr	r3, [pc, #124]	; (24010ce8 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010c6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24010c6e:	4a1e      	ldr	r2, [pc, #120]	; (24010ce8 <HAL_PWREx_ControlVoltageScaling+0x10c>)
24010c70:	f023 0301 	bic.w	r3, r3, #1
24010c74:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Get tick */
        tickstart = HAL_GetTick ();
24010c76:	f7f1 fb65 	bl	24002344 <HAL_GetTick>
24010c7a:	60f8      	str	r0, [r7, #12]

        /* Wait till voltage level flag is set */
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010c7c:	e009      	b.n	24010c92 <HAL_PWREx_ControlVoltageScaling+0xb6>
        {
          if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
24010c7e:	f7f1 fb61 	bl	24002344 <HAL_GetTick>
24010c82:	4602      	mov	r2, r0
24010c84:	68fb      	ldr	r3, [r7, #12]
24010c86:	1ad3      	subs	r3, r2, r3
24010c88:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010c8c:	d901      	bls.n	24010c92 <HAL_PWREx_ControlVoltageScaling+0xb6>
          {
            return HAL_ERROR;
24010c8e:	2301      	movs	r3, #1
24010c90:	e024      	b.n	24010cdc <HAL_PWREx_ControlVoltageScaling+0x100>
        while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010c92:	4b14      	ldr	r3, [pc, #80]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010c94:	685b      	ldr	r3, [r3, #4]
24010c96:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24010c9a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24010c9e:	d1ee      	bne.n	24010c7e <HAL_PWREx_ControlVoltageScaling+0xa2>
        }
      }
    }

    /* Set the voltage range */
    MODIFY_REG (PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
24010ca0:	4b10      	ldr	r3, [pc, #64]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010ca2:	699b      	ldr	r3, [r3, #24]
24010ca4:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
24010ca8:	490e      	ldr	r1, [pc, #56]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010caa:	687b      	ldr	r3, [r7, #4]
24010cac:	4313      	orrs	r3, r2
24010cae:	618b      	str	r3, [r1, #24]
  MODIFY_REG(PWR->D3CR, PWR_D3CR_VOS, VoltageScaling);
#endif /* defined (SYSCFG_PWRCR_ODEN) */
#endif /* defined (PWR_SRDCR_VOS) */

  /* Get tick */
  tickstart = HAL_GetTick ();
24010cb0:	f7f1 fb48 	bl	24002344 <HAL_GetTick>
24010cb4:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010cb6:	e009      	b.n	24010ccc <HAL_PWREx_ControlVoltageScaling+0xf0>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
24010cb8:	f7f1 fb44 	bl	24002344 <HAL_GetTick>
24010cbc:	4602      	mov	r2, r0
24010cbe:	68fb      	ldr	r3, [r7, #12]
24010cc0:	1ad3      	subs	r3, r2, r3
24010cc2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24010cc6:	d901      	bls.n	24010ccc <HAL_PWREx_ControlVoltageScaling+0xf0>
    {
      return HAL_ERROR;
24010cc8:	2301      	movs	r3, #1
24010cca:	e007      	b.n	24010cdc <HAL_PWREx_ControlVoltageScaling+0x100>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
24010ccc:	4b05      	ldr	r3, [pc, #20]	; (24010ce4 <HAL_PWREx_ControlVoltageScaling+0x108>)
24010cce:	685b      	ldr	r3, [r3, #4]
24010cd0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24010cd4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24010cd8:	d1ee      	bne.n	24010cb8 <HAL_PWREx_ControlVoltageScaling+0xdc>
    }
  }

  return HAL_OK;
24010cda:	2300      	movs	r3, #0
}
24010cdc:	4618      	mov	r0, r3
24010cde:	3710      	adds	r7, #16
24010ce0:	46bd      	mov	sp, r7
24010ce2:	bd80      	pop	{r7, pc}
24010ce4:	58024800 	.word	0x58024800
24010ce8:	58000400 	.word	0x58000400

24010cec <HAL_PWREx_GetVoltageRange>:
  * @brief Get the main internal regulator output voltage. Reflecting the last
  *        VOS value applied to the PMU.
  * @retval The current applied VOS selection.
  */
uint32_t HAL_PWREx_GetVoltageRange (void)
{
24010cec:	b480      	push	{r7}
24010cee:	af00      	add	r7, sp, #0
  /* Get the active voltage scaling */
  return (PWR->CSR1 & PWR_CSR1_ACTVOS);
24010cf0:	4b04      	ldr	r3, [pc, #16]	; (24010d04 <HAL_PWREx_GetVoltageRange+0x18>)
24010cf2:	685b      	ldr	r3, [r3, #4]
24010cf4:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
24010cf8:	4618      	mov	r0, r3
24010cfa:	46bd      	mov	sp, r7
24010cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
24010d00:	4770      	bx	lr
24010d02:	bf00      	nop
24010d04:	58024800 	.word	0x58024800

24010d08 <HAL_PWREx_ControlStopModeVoltageScaling>:
  * @note   The selected SVOS4 and SVOS5 levels add an additional startup delay
  *         when exiting from system Stop mode.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_PWREx_ControlStopModeVoltageScaling (uint32_t VoltageScaling)
{
24010d08:	b480      	push	{r7}
24010d0a:	b083      	sub	sp, #12
24010d0c:	af00      	add	r7, sp, #0
24010d0e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_STOP_MODE_REGULATOR_VOLTAGE (VoltageScaling));

  /* Return the stop mode voltage range */
  MODIFY_REG (PWR->CR1, PWR_CR1_SVOS, VoltageScaling);
24010d10:	4b07      	ldr	r3, [pc, #28]	; (24010d30 <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
24010d12:	681b      	ldr	r3, [r3, #0]
24010d14:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
24010d18:	4905      	ldr	r1, [pc, #20]	; (24010d30 <HAL_PWREx_ControlStopModeVoltageScaling+0x28>)
24010d1a:	687b      	ldr	r3, [r7, #4]
24010d1c:	4313      	orrs	r3, r2
24010d1e:	600b      	str	r3, [r1, #0]

  return HAL_OK;
24010d20:	2300      	movs	r3, #0
}
24010d22:	4618      	mov	r0, r3
24010d24:	370c      	adds	r7, #12
24010d26:	46bd      	mov	sp, r7
24010d28:	f85d 7b04 	ldr.w	r7, [sp], #4
24010d2c:	4770      	bx	lr
24010d2e:	bf00      	nop
24010d30:	58024800 	.word	0x58024800

24010d34 <HAL_PWREx_GetStopModeVoltageRange>:
/**
  * @brief Get the main internal regulator output voltage in STOP mode.
  * @retval The actual applied VOS selection.
  */
uint32_t HAL_PWREx_GetStopModeVoltageRange (void)
{
24010d34:	b480      	push	{r7}
24010d36:	af00      	add	r7, sp, #0
  /* Return the stop voltage scaling */
  return (PWR->CR1 & PWR_CR1_SVOS);
24010d38:	4b04      	ldr	r3, [pc, #16]	; (24010d4c <HAL_PWREx_GetStopModeVoltageRange+0x18>)
24010d3a:	681b      	ldr	r3, [r3, #0]
24010d3c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
}
24010d40:	4618      	mov	r0, r3
24010d42:	46bd      	mov	sp, r7
24010d44:	f85d 7b04 	ldr.w	r7, [sp], #4
24010d48:	4770      	bx	lr
24010d4a:	bf00      	nop
24010d4c:	58024800 	.word	0x58024800

24010d50 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
24010d50:	b480      	push	{r7}
24010d52:	b085      	sub	sp, #20
24010d54:	af00      	add	r7, sp, #0
24010d56:	60f8      	str	r0, [r7, #12]
24010d58:	460b      	mov	r3, r1
24010d5a:	607a      	str	r2, [r7, #4]
24010d5c:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
24010d5e:	4b20      	ldr	r3, [pc, #128]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010d60:	681b      	ldr	r3, [r3, #0]
24010d62:	f023 0201 	bic.w	r2, r3, #1
24010d66:	491e      	ldr	r1, [pc, #120]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010d68:	68fb      	ldr	r3, [r7, #12]
24010d6a:	4313      	orrs	r3, r2
24010d6c:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
24010d6e:	687b      	ldr	r3, [r7, #4]
24010d70:	2b00      	cmp	r3, #0
24010d72:	d11e      	bne.n	24010db2 <HAL_PWREx_EnterSTOPMode+0x62>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
24010d74:	4b1a      	ldr	r3, [pc, #104]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010d76:	691b      	ldr	r3, [r3, #16]
24010d78:	4a19      	ldr	r2, [pc, #100]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010d7a:	f023 0301 	bic.w	r3, r3, #1
24010d7e:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010d80:	4b18      	ldr	r3, [pc, #96]	; (24010de4 <HAL_PWREx_EnterSTOPMode+0x94>)
24010d82:	691b      	ldr	r3, [r3, #16]
24010d84:	4a17      	ldr	r2, [pc, #92]	; (24010de4 <HAL_PWREx_EnterSTOPMode+0x94>)
24010d86:	f043 0304 	orr.w	r3, r3, #4
24010d8a:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
24010d8c:	f3bf 8f4f 	dsb	sy
}
24010d90:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
24010d92:	f3bf 8f6f 	isb	sy
}
24010d96:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
24010d98:	7afb      	ldrb	r3, [r7, #11]
24010d9a:	2b01      	cmp	r3, #1
24010d9c:	d101      	bne.n	24010da2 <HAL_PWREx_EnterSTOPMode+0x52>
    {
      /* Request Wait For Interrupt */
      __WFI ();
24010d9e:	bf30      	wfi
24010da0:	e000      	b.n	24010da4 <HAL_PWREx_EnterSTOPMode+0x54>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
24010da2:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010da4:	4b0f      	ldr	r3, [pc, #60]	; (24010de4 <HAL_PWREx_EnterSTOPMode+0x94>)
24010da6:	691b      	ldr	r3, [r3, #16]
24010da8:	4a0e      	ldr	r2, [pc, #56]	; (24010de4 <HAL_PWREx_EnterSTOPMode+0x94>)
24010daa:	f023 0304 	bic.w	r3, r3, #4
24010dae:	6113      	str	r3, [r2, #16]
#else
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
#endif  /* defined (DUAL_CORE) */
  }
}
24010db0:	e00f      	b.n	24010dd2 <HAL_PWREx_EnterSTOPMode+0x82>
  else if (Domain == PWR_D2_DOMAIN)
24010db2:	687b      	ldr	r3, [r7, #4]
24010db4:	2b01      	cmp	r3, #1
24010db6:	d106      	bne.n	24010dc6 <HAL_PWREx_EnterSTOPMode+0x76>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D2);
24010db8:	4b09      	ldr	r3, [pc, #36]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010dba:	691b      	ldr	r3, [r3, #16]
24010dbc:	4a08      	ldr	r2, [pc, #32]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010dbe:	f023 0302 	bic.w	r3, r3, #2
24010dc2:	6113      	str	r3, [r2, #16]
}
24010dc4:	e005      	b.n	24010dd2 <HAL_PWREx_EnterSTOPMode+0x82>
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
24010dc6:	4b06      	ldr	r3, [pc, #24]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010dc8:	691b      	ldr	r3, [r3, #16]
24010dca:	4a05      	ldr	r2, [pc, #20]	; (24010de0 <HAL_PWREx_EnterSTOPMode+0x90>)
24010dcc:	f023 0304 	bic.w	r3, r3, #4
24010dd0:	6113      	str	r3, [r2, #16]
}
24010dd2:	bf00      	nop
24010dd4:	3714      	adds	r7, #20
24010dd6:	46bd      	mov	sp, r7
24010dd8:	f85d 7b04 	ldr.w	r7, [sp], #4
24010ddc:	4770      	bx	lr
24010dde:	bf00      	nop
24010de0:	58024800 	.word	0x58024800
24010de4:	e000ed00 	.word	0xe000ed00

24010de8 <HAL_PWREx_ClearPendingEvent>:
  *         enter low power mode using Wait For Event request.
  * @note   Cortex-M7 must be in CRUN mode when calling this API by Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
24010de8:	b480      	push	{r7}
24010dea:	af00      	add	r7, sp, #0
  {
    __SEV ();
    __WFE ();
  }
#else
  __WFE ();
24010dec:	bf20      	wfe
#endif /* defined (DUAL_CORE) */
}
24010dee:	bf00      	nop
24010df0:	46bd      	mov	sp, r7
24010df2:	f85d 7b04 	ldr.w	r7, [sp], #4
24010df6:	4770      	bx	lr

24010df8 <HAL_PWREx_EnterSTANDBYMode>:
  *            @arg PWR_D2_DOMAIN: Enter D2 Domain to DSTANDBY mode.
  *            @arg PWR_D3_DOMAIN: Enter D3/SRD Domain to DSTANDBY mode.
  * @retval None
  */
void HAL_PWREx_EnterSTANDBYMode (uint32_t Domain)
{
24010df8:	b480      	push	{r7}
24010dfa:	b083      	sub	sp, #12
24010dfc:	af00      	add	r7, sp, #0
24010dfe:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
24010e00:	687b      	ldr	r3, [r7, #4]
24010e02:	2b00      	cmp	r3, #0
24010e04:	d10d      	bne.n	24010e22 <HAL_PWREx_EnterSTANDBYMode+0x2a>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D1);
24010e06:	4b12      	ldr	r3, [pc, #72]	; (24010e50 <HAL_PWREx_EnterSTANDBYMode+0x58>)
24010e08:	691b      	ldr	r3, [r3, #16]
24010e0a:	4a11      	ldr	r2, [pc, #68]	; (24010e50 <HAL_PWREx_EnterSTANDBYMode+0x58>)
24010e0c:	f043 0301 	orr.w	r3, r3, #1
24010e10:	6113      	str	r3, [r2, #16]
    /* Allow DSTANDBY mode when D1/CD domain enters Deepsleep */
    SET_BIT (PWR-> CPU2CR, PWR_CPU2CR_PDDS_D1);
#endif /*DUAL_CORE*/

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
24010e12:	4b10      	ldr	r3, [pc, #64]	; (24010e54 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
24010e14:	691b      	ldr	r3, [r3, #16]
24010e16:	4a0f      	ldr	r2, [pc, #60]	; (24010e54 <HAL_PWREx_EnterSTANDBYMode+0x5c>)
24010e18:	f043 0304 	orr.w	r3, r3, #4
24010e1c:	6113      	str	r3, [r2, #16]
#if defined (__CC_ARM)
    __force_stores ();
#endif /* defined (__CC_ARM) */

    /* Request Wait For Interrupt */
    __WFI ();
24010e1e:	bf30      	wfi
#if defined (DUAL_CORE)
    /* Allow DSTANDBY mode when D3/SRD domain enters Deepsleep */
    SET_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);
#endif /* defined (DUAL_CORE) */
  }
}
24010e20:	e00f      	b.n	24010e42 <HAL_PWREx_EnterSTANDBYMode+0x4a>
  else if (Domain == PWR_D2_DOMAIN)
24010e22:	687b      	ldr	r3, [r7, #4]
24010e24:	2b01      	cmp	r3, #1
24010e26:	d106      	bne.n	24010e36 <HAL_PWREx_EnterSTANDBYMode+0x3e>
    SET_BIT (PWR-> CPUCR, PWR_CPUCR_PDDS_D2);
24010e28:	4b09      	ldr	r3, [pc, #36]	; (24010e50 <HAL_PWREx_EnterSTANDBYMode+0x58>)
24010e2a:	691b      	ldr	r3, [r3, #16]
24010e2c:	4a08      	ldr	r2, [pc, #32]	; (24010e50 <HAL_PWREx_EnterSTANDBYMode+0x58>)
24010e2e:	f043 0302 	orr.w	r3, r3, #2
24010e32:	6113      	str	r3, [r2, #16]
}
24010e34:	e005      	b.n	24010e42 <HAL_PWREx_EnterSTANDBYMode+0x4a>
    SET_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
24010e36:	4b06      	ldr	r3, [pc, #24]	; (24010e50 <HAL_PWREx_EnterSTANDBYMode+0x58>)
24010e38:	691b      	ldr	r3, [r3, #16]
24010e3a:	4a05      	ldr	r2, [pc, #20]	; (24010e50 <HAL_PWREx_EnterSTANDBYMode+0x58>)
24010e3c:	f043 0304 	orr.w	r3, r3, #4
24010e40:	6113      	str	r3, [r2, #16]
}
24010e42:	bf00      	nop
24010e44:	370c      	adds	r7, #12
24010e46:	46bd      	mov	sp, r7
24010e48:	f85d 7b04 	ldr.w	r7, [sp], #4
24010e4c:	4770      	bx	lr
24010e4e:	bf00      	nop
24010e50:	58024800 	.word	0x58024800
24010e54:	e000ed00 	.word	0xe000ed00

24010e58 <HAL_PWREx_ConfigD3Domain>:
  *                                     regardless of the CPU sub-system low
  *                                     power mode.
  * @retval None
  */
void HAL_PWREx_ConfigD3Domain (uint32_t D3State)
{
24010e58:	b480      	push	{r7}
24010e5a:	b083      	sub	sp, #12
24010e5c:	af00      	add	r7, sp, #0
24010e5e:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_D3_STATE (D3State));

  /* Keep D3/SRD in run mode */
  MODIFY_REG (PWR->CPUCR, PWR_CPUCR_RUN_D3, D3State);
24010e60:	4b06      	ldr	r3, [pc, #24]	; (24010e7c <HAL_PWREx_ConfigD3Domain+0x24>)
24010e62:	691b      	ldr	r3, [r3, #16]
24010e64:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
24010e68:	4904      	ldr	r1, [pc, #16]	; (24010e7c <HAL_PWREx_ConfigD3Domain+0x24>)
24010e6a:	687b      	ldr	r3, [r7, #4]
24010e6c:	4313      	orrs	r3, r2
24010e6e:	610b      	str	r3, [r1, #16]
}
24010e70:	bf00      	nop
24010e72:	370c      	adds	r7, #12
24010e74:	46bd      	mov	sp, r7
24010e76:	f85d 7b04 	ldr.w	r7, [sp], #4
24010e7a:	4770      	bx	lr
24010e7c:	58024800 	.word	0x58024800

24010e80 <HAL_PWREx_EnableFlashPowerDown>:
  *         obtain the best trade-off between low-power consumption and restart
  *         time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_EnableFlashPowerDown (void)
{
24010e80:	b480      	push	{r7}
24010e82:	af00      	add	r7, sp, #0
  /* Enable the Flash Power Down */
  SET_BIT (PWR->CR1, PWR_CR1_FLPS);
24010e84:	4b05      	ldr	r3, [pc, #20]	; (24010e9c <HAL_PWREx_EnableFlashPowerDown+0x1c>)
24010e86:	681b      	ldr	r3, [r3, #0]
24010e88:	4a04      	ldr	r2, [pc, #16]	; (24010e9c <HAL_PWREx_EnableFlashPowerDown+0x1c>)
24010e8a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
24010e8e:	6013      	str	r3, [r2, #0]
}
24010e90:	bf00      	nop
24010e92:	46bd      	mov	sp, r7
24010e94:	f85d 7b04 	ldr.w	r7, [sp], #4
24010e98:	4770      	bx	lr
24010e9a:	bf00      	nop
24010e9c:	58024800 	.word	0x58024800

24010ea0 <HAL_PWREx_DisableFlashPowerDown>:
  *         to obtain the best trade-off between low-power consumption and
  *         restart time when exiting from DStop mode.
  * @retval None.
  */
void HAL_PWREx_DisableFlashPowerDown (void)
{
24010ea0:	b480      	push	{r7}
24010ea2:	af00      	add	r7, sp, #0
  /* Disable the Flash Power Down */
  CLEAR_BIT (PWR->CR1, PWR_CR1_FLPS);
24010ea4:	4b05      	ldr	r3, [pc, #20]	; (24010ebc <HAL_PWREx_DisableFlashPowerDown+0x1c>)
24010ea6:	681b      	ldr	r3, [r3, #0]
24010ea8:	4a04      	ldr	r2, [pc, #16]	; (24010ebc <HAL_PWREx_DisableFlashPowerDown+0x1c>)
24010eaa:	f423 7300 	bic.w	r3, r3, #512	; 0x200
24010eae:	6013      	str	r3, [r2, #0]
}
24010eb0:	bf00      	nop
24010eb2:	46bd      	mov	sp, r7
24010eb4:	f85d 7b04 	ldr.w	r7, [sp], #4
24010eb8:	4770      	bx	lr
24010eba:	bf00      	nop
24010ebc:	58024800 	.word	0x58024800

24010ec0 <HAL_PWREx_EnableWakeUpPin>:
  *         Cortex-M7, wake up only Cortex-M4 and wake up Cortex-M7 and
  *         Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_EnableWakeUpPin (PWREx_WakeupPinTypeDef *sPinParams)
{
24010ec0:	b480      	push	{r7}
24010ec2:	b093      	sub	sp, #76	; 0x4c
24010ec4:	af00      	add	r7, sp, #0
24010ec6:	6078      	str	r0, [r7, #4]
  uint32_t pinConfig;
  uint32_t regMask;
  const uint32_t pullMask = PWR_WKUPEPR_WKUPPUPD1;
24010ec8:	f44f 3340 	mov.w	r3, #196608	; 0x30000
24010ecc:	647b      	str	r3, [r7, #68]	; 0x44
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_PIN (sPinParams->WakeUpPin));
  assert_param (IS_PWR_WAKEUP_PIN_POLARITY (sPinParams->PinPolarity));
  assert_param (IS_PWR_WAKEUP_PIN_PULL (sPinParams->PinPull));

  pinConfig = sPinParams->WakeUpPin | \
24010ece:	687b      	ldr	r3, [r7, #4]
24010ed0:	681a      	ldr	r2, [r3, #0]
              (sPinParams->PinPolarity << ((POSITION_VAL(sPinParams->WakeUpPin) + PWR_WKUPEPR_WKUPP1_Pos) & 0x1FU)) | \
24010ed2:	687b      	ldr	r3, [r7, #4]
24010ed4:	6859      	ldr	r1, [r3, #4]
24010ed6:	687b      	ldr	r3, [r7, #4]
24010ed8:	681b      	ldr	r3, [r3, #0]
24010eda:	613b      	str	r3, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24010edc:	693b      	ldr	r3, [r7, #16]
24010ede:	fa93 f3a3 	rbit	r3, r3
24010ee2:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
24010ee4:	68fb      	ldr	r3, [r7, #12]
24010ee6:	617b      	str	r3, [r7, #20]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
24010ee8:	697b      	ldr	r3, [r7, #20]
24010eea:	2b00      	cmp	r3, #0
24010eec:	d101      	bne.n	24010ef2 <HAL_PWREx_EnableWakeUpPin+0x32>
  {
    return 32U;
24010eee:	2320      	movs	r3, #32
24010ef0:	e003      	b.n	24010efa <HAL_PWREx_EnableWakeUpPin+0x3a>
  }
  return __builtin_clz(value);
24010ef2:	697b      	ldr	r3, [r7, #20]
24010ef4:	fab3 f383 	clz	r3, r3
24010ef8:	b2db      	uxtb	r3, r3
24010efa:	3308      	adds	r3, #8
24010efc:	f003 031f 	and.w	r3, r3, #31
24010f00:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
24010f04:	431a      	orrs	r2, r3
              (sPinParams->PinPull << (((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) + PWR_WKUPEPR_WKUPPUPD1_Pos) & 0x1FU));
24010f06:	687b      	ldr	r3, [r7, #4]
24010f08:	6899      	ldr	r1, [r3, #8]
24010f0a:	687b      	ldr	r3, [r7, #4]
24010f0c:	681b      	ldr	r3, [r3, #0]
24010f0e:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24010f10:	69fb      	ldr	r3, [r7, #28]
24010f12:	fa93 f3a3 	rbit	r3, r3
24010f16:	61bb      	str	r3, [r7, #24]
  return result;
24010f18:	69bb      	ldr	r3, [r7, #24]
24010f1a:	623b      	str	r3, [r7, #32]
  if (value == 0U)
24010f1c:	6a3b      	ldr	r3, [r7, #32]
24010f1e:	2b00      	cmp	r3, #0
24010f20:	d101      	bne.n	24010f26 <HAL_PWREx_EnableWakeUpPin+0x66>
    return 32U;
24010f22:	2320      	movs	r3, #32
24010f24:	e003      	b.n	24010f2e <HAL_PWREx_EnableWakeUpPin+0x6e>
  return __builtin_clz(value);
24010f26:	6a3b      	ldr	r3, [r7, #32]
24010f28:	fab3 f383 	clz	r3, r3
24010f2c:	b2db      	uxtb	r3, r3
24010f2e:	3308      	adds	r3, #8
24010f30:	005b      	lsls	r3, r3, #1
24010f32:	f003 031e 	and.w	r3, r3, #30
24010f36:	fa01 f303 	lsl.w	r3, r1, r3
  pinConfig = sPinParams->WakeUpPin | \
24010f3a:	4313      	orrs	r3, r2
24010f3c:	643b      	str	r3, [r7, #64]	; 0x40

  regMask   = sPinParams->WakeUpPin | \
24010f3e:	687b      	ldr	r3, [r7, #4]
24010f40:	681a      	ldr	r2, [r3, #0]
              (PWR_WKUPEPR_WKUPP1 << (POSITION_VAL(sPinParams->WakeUpPin) & 0x1FU)) | \
24010f42:	687b      	ldr	r3, [r7, #4]
24010f44:	681b      	ldr	r3, [r3, #0]
24010f46:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24010f48:	6abb      	ldr	r3, [r7, #40]	; 0x28
24010f4a:	fa93 f3a3 	rbit	r3, r3
24010f4e:	627b      	str	r3, [r7, #36]	; 0x24
  return result;
24010f50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24010f52:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (value == 0U)
24010f54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24010f56:	2b00      	cmp	r3, #0
24010f58:	d101      	bne.n	24010f5e <HAL_PWREx_EnableWakeUpPin+0x9e>
    return 32U;
24010f5a:	2320      	movs	r3, #32
24010f5c:	e003      	b.n	24010f66 <HAL_PWREx_EnableWakeUpPin+0xa6>
  return __builtin_clz(value);
24010f5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24010f60:	fab3 f383 	clz	r3, r3
24010f64:	b2db      	uxtb	r3, r3
24010f66:	f003 031f 	and.w	r3, r3, #31
24010f6a:	f44f 7180 	mov.w	r1, #256	; 0x100
24010f6e:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
24010f72:	431a      	orrs	r2, r3
              (pullMask << ((POSITION_VAL(sPinParams->WakeUpPin) * PWR_WAKEUP_PINS_PULL_SHIFT_OFFSET) & 0x1FU));
24010f74:	687b      	ldr	r3, [r7, #4]
24010f76:	681b      	ldr	r3, [r3, #0]
24010f78:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
24010f7a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24010f7c:	fa93 f3a3 	rbit	r3, r3
24010f80:	633b      	str	r3, [r7, #48]	; 0x30
  return result;
24010f82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24010f84:	63bb      	str	r3, [r7, #56]	; 0x38
  if (value == 0U)
24010f86:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24010f88:	2b00      	cmp	r3, #0
24010f8a:	d101      	bne.n	24010f90 <HAL_PWREx_EnableWakeUpPin+0xd0>
    return 32U;
24010f8c:	2320      	movs	r3, #32
24010f8e:	e003      	b.n	24010f98 <HAL_PWREx_EnableWakeUpPin+0xd8>
  return __builtin_clz(value);
24010f90:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24010f92:	fab3 f383 	clz	r3, r3
24010f96:	b2db      	uxtb	r3, r3
24010f98:	005b      	lsls	r3, r3, #1
24010f9a:	f003 031e 	and.w	r3, r3, #30
24010f9e:	6c79      	ldr	r1, [r7, #68]	; 0x44
24010fa0:	fa01 f303 	lsl.w	r3, r1, r3
  regMask   = sPinParams->WakeUpPin | \
24010fa4:	4313      	orrs	r3, r2
24010fa6:	63fb      	str	r3, [r7, #60]	; 0x3c

  /* Enable and Specify the Wake-Up pin polarity and the pull configuration
     for the event detection (rising or falling edge) */
  MODIFY_REG (PWR->WKUPEPR, regMask, pinConfig);
24010fa8:	4b0e      	ldr	r3, [pc, #56]	; (24010fe4 <HAL_PWREx_EnableWakeUpPin+0x124>)
24010faa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010fac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
24010fae:	43db      	mvns	r3, r3
24010fb0:	401a      	ands	r2, r3
24010fb2:	490c      	ldr	r1, [pc, #48]	; (24010fe4 <HAL_PWREx_EnableWakeUpPin+0x124>)
24010fb4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
24010fb6:	4313      	orrs	r3, r2
24010fb8:	628b      	str	r3, [r1, #40]	; 0x28
#ifndef DUAL_CORE
  /* Configure the Wakeup Pin EXTI Line */
  MODIFY_REG (EXTI->IMR2, PWR_EXTI_WAKEUP_PINS_MASK, (sPinParams->WakeUpPin << EXTI_IMR2_IM55_Pos));
24010fba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24010fbe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
24010fc2:	f023 52fc 	bic.w	r2, r3, #528482304	; 0x1f800000
24010fc6:	687b      	ldr	r3, [r7, #4]
24010fc8:	681b      	ldr	r3, [r3, #0]
24010fca:	05db      	lsls	r3, r3, #23
24010fcc:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
24010fd0:	4313      	orrs	r3, r2
24010fd2:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
#endif /* !DUAL_CORE */
}
24010fd6:	bf00      	nop
24010fd8:	374c      	adds	r7, #76	; 0x4c
24010fda:	46bd      	mov	sp, r7
24010fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
24010fe0:	4770      	bx	lr
24010fe2:	bf00      	nop
24010fe4:	58024800 	.word	0x58024800

24010fe8 <HAL_PWREx_DisableWakeUpPin>:
  * @note   The PWR_WAKEUP_PIN3 and PWR_WAKEUP_PIN5 are available only for
  *         devices that support GPIOI port.
  * @retval None
  */
void HAL_PWREx_DisableWakeUpPin (uint32_t WakeUpPin)
{
24010fe8:	b480      	push	{r7}
24010fea:	b083      	sub	sp, #12
24010fec:	af00      	add	r7, sp, #0
24010fee:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_PIN (WakeUpPin));

  /* Disable the WakeUpPin */
  CLEAR_BIT (PWR->WKUPEPR, WakeUpPin);
24010ff0:	4b06      	ldr	r3, [pc, #24]	; (2401100c <HAL_PWREx_DisableWakeUpPin+0x24>)
24010ff2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24010ff4:	687b      	ldr	r3, [r7, #4]
24010ff6:	43db      	mvns	r3, r3
24010ff8:	4904      	ldr	r1, [pc, #16]	; (2401100c <HAL_PWREx_DisableWakeUpPin+0x24>)
24010ffa:	4013      	ands	r3, r2
24010ffc:	628b      	str	r3, [r1, #40]	; 0x28
}
24010ffe:	bf00      	nop
24011000:	370c      	adds	r7, #12
24011002:	46bd      	mov	sp, r7
24011004:	f85d 7b04 	ldr.w	r7, [sp], #4
24011008:	4770      	bx	lr
2401100a:	bf00      	nop
2401100c:	58024800 	.word	0x58024800

24011010 <HAL_PWREx_GetWakeupFlag>:
  * @note   The PWR_WAKEUP_FLAG3 and PWR_WAKEUP_FLAG5 are available only for
  *         devices that support GPIOI port.
  * @retval The Wake-Up pin flag.
  */
uint32_t HAL_PWREx_GetWakeupFlag (uint32_t WakeUpFlag)
{
24011010:	b480      	push	{r7}
24011012:	b083      	sub	sp, #12
24011014:	af00      	add	r7, sp, #0
24011016:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Return the wake up pin flag */
  return (PWR->WKUPFR & WakeUpFlag);
24011018:	4b04      	ldr	r3, [pc, #16]	; (2401102c <HAL_PWREx_GetWakeupFlag+0x1c>)
2401101a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
2401101c:	687b      	ldr	r3, [r7, #4]
2401101e:	4013      	ands	r3, r2
}
24011020:	4618      	mov	r0, r3
24011022:	370c      	adds	r7, #12
24011024:	46bd      	mov	sp, r7
24011026:	f85d 7b04 	ldr.w	r7, [sp], #4
2401102a:	4770      	bx	lr
2401102c:	58024800 	.word	0x58024800

24011030 <HAL_PWREx_ClearWakeupFlag>:
  * @note   The PWR_WAKEUP_FLAG3 and PWR_WAKEUP_FLAG5 are available only for
  *         devices that support GPIOI port.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ClearWakeupFlag (uint32_t WakeUpFlag)
{
24011030:	b480      	push	{r7}
24011032:	b083      	sub	sp, #12
24011034:	af00      	add	r7, sp, #0
24011036:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_WAKEUP_FLAG (WakeUpFlag));

  /* Clear the wake up event received from wake up pin x */
  SET_BIT (PWR->WKUPCR, WakeUpFlag);
24011038:	4b0a      	ldr	r3, [pc, #40]	; (24011064 <HAL_PWREx_ClearWakeupFlag+0x34>)
2401103a:	6a1a      	ldr	r2, [r3, #32]
2401103c:	4909      	ldr	r1, [pc, #36]	; (24011064 <HAL_PWREx_ClearWakeupFlag+0x34>)
2401103e:	687b      	ldr	r3, [r7, #4]
24011040:	4313      	orrs	r3, r2
24011042:	620b      	str	r3, [r1, #32]

  /* Check if the wake up event is well cleared */
  if ((PWR->WKUPFR & WakeUpFlag) != 0U)
24011044:	4b07      	ldr	r3, [pc, #28]	; (24011064 <HAL_PWREx_ClearWakeupFlag+0x34>)
24011046:	6a5a      	ldr	r2, [r3, #36]	; 0x24
24011048:	687b      	ldr	r3, [r7, #4]
2401104a:	4013      	ands	r3, r2
2401104c:	2b00      	cmp	r3, #0
2401104e:	d001      	beq.n	24011054 <HAL_PWREx_ClearWakeupFlag+0x24>
  {
    return HAL_ERROR;
24011050:	2301      	movs	r3, #1
24011052:	e000      	b.n	24011056 <HAL_PWREx_ClearWakeupFlag+0x26>
  }

  return HAL_OK;
24011054:	2300      	movs	r3, #0
}
24011056:	4618      	mov	r0, r3
24011058:	370c      	adds	r7, #12
2401105a:	46bd      	mov	sp, r7
2401105c:	f85d 7b04 	ldr.w	r7, [sp], #4
24011060:	4770      	bx	lr
24011062:	bf00      	nop
24011064:	58024800 	.word	0x58024800

24011068 <HAL_PWREx_WAKEUP_PIN_IRQHandler>:
  * @brief This function handles the PWR WAKEUP PIN interrupt request.
  * @note   This API should be called under the WAKEUP_PIN_IRQHandler().
  * @retval None.
  */
void HAL_PWREx_WAKEUP_PIN_IRQHandler (void)
{
24011068:	b580      	push	{r7, lr}
2401106a:	af00      	add	r7, sp, #0
  /* Wakeup pin EXTI line interrupt detected */
  if (READ_BIT(PWR->WKUPFR, PWR_WKUPFR_WKUPF1) != 0U)
2401106c:	4b2a      	ldr	r3, [pc, #168]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2401106e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011070:	f003 0301 	and.w	r3, r3, #1
24011074:	2b00      	cmp	r3, #0
24011076:	d008      	beq.n	2401108a <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x22>
  {
    /* Clear PWR WKUPF1 flag */
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP1);
24011078:	4b27      	ldr	r3, [pc, #156]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2401107a:	6a1b      	ldr	r3, [r3, #32]
2401107c:	4a26      	ldr	r2, [pc, #152]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2401107e:	f043 0301 	orr.w	r3, r3, #1
24011082:	6213      	str	r3, [r2, #32]

    /* PWR WKUP1 interrupt user callback */
    HAL_PWREx_WKUP1_Callback ();
24011084:	f000 f84a 	bl	2401111c <HAL_PWREx_WKUP1_Callback>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);

    /* PWR WKUP6 interrupt user callback */
    HAL_PWREx_WKUP6_Callback ();
  }
}
24011088:	e043      	b.n	24011112 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF2) != 0U)
2401108a:	4b23      	ldr	r3, [pc, #140]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2401108c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401108e:	f003 0302 	and.w	r3, r3, #2
24011092:	2b00      	cmp	r3, #0
24011094:	d008      	beq.n	240110a8 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x40>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP2);
24011096:	4b20      	ldr	r3, [pc, #128]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011098:	6a1b      	ldr	r3, [r3, #32]
2401109a:	4a1f      	ldr	r2, [pc, #124]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
2401109c:	f043 0302 	orr.w	r3, r3, #2
240110a0:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP2_Callback ();
240110a2:	f000 f842 	bl	2401112a <HAL_PWREx_WKUP2_Callback>
}
240110a6:	e034      	b.n	24011112 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF3) != 0U)
240110a8:	4b1b      	ldr	r3, [pc, #108]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240110ac:	f003 0304 	and.w	r3, r3, #4
240110b0:	2b00      	cmp	r3, #0
240110b2:	d008      	beq.n	240110c6 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x5e>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP3);
240110b4:	4b18      	ldr	r3, [pc, #96]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110b6:	6a1b      	ldr	r3, [r3, #32]
240110b8:	4a17      	ldr	r2, [pc, #92]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110ba:	f043 0304 	orr.w	r3, r3, #4
240110be:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP3_Callback ();
240110c0:	f000 f83a 	bl	24011138 <HAL_PWREx_WKUP3_Callback>
}
240110c4:	e025      	b.n	24011112 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF4) != 0U)
240110c6:	4b14      	ldr	r3, [pc, #80]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240110ca:	f003 0308 	and.w	r3, r3, #8
240110ce:	2b00      	cmp	r3, #0
240110d0:	d008      	beq.n	240110e4 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x7c>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP4);
240110d2:	4b11      	ldr	r3, [pc, #68]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110d4:	6a1b      	ldr	r3, [r3, #32]
240110d6:	4a10      	ldr	r2, [pc, #64]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110d8:	f043 0308 	orr.w	r3, r3, #8
240110dc:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP4_Callback ();
240110de:	f000 f832 	bl	24011146 <HAL_PWREx_WKUP4_Callback>
}
240110e2:	e016      	b.n	24011112 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
  else if (READ_BIT (PWR->WKUPFR, PWR_WKUPFR_WKUPF5) != 0U)
240110e4:	4b0c      	ldr	r3, [pc, #48]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240110e8:	f003 0310 	and.w	r3, r3, #16
240110ec:	2b00      	cmp	r3, #0
240110ee:	d008      	beq.n	24011102 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0x9a>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP5);
240110f0:	4b09      	ldr	r3, [pc, #36]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110f2:	6a1b      	ldr	r3, [r3, #32]
240110f4:	4a08      	ldr	r2, [pc, #32]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
240110f6:	f043 0310 	orr.w	r3, r3, #16
240110fa:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP5_Callback ();
240110fc:	f000 f82a 	bl	24011154 <HAL_PWREx_WKUP5_Callback>
}
24011100:	e007      	b.n	24011112 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xaa>
    __HAL_PWR_CLEAR_WAKEUPFLAG (PWR_FLAG_WKUP6);
24011102:	4b05      	ldr	r3, [pc, #20]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011104:	6a1b      	ldr	r3, [r3, #32]
24011106:	4a04      	ldr	r2, [pc, #16]	; (24011118 <HAL_PWREx_WAKEUP_PIN_IRQHandler+0xb0>)
24011108:	f043 0320 	orr.w	r3, r3, #32
2401110c:	6213      	str	r3, [r2, #32]
    HAL_PWREx_WKUP6_Callback ();
2401110e:	f000 f828 	bl	24011162 <HAL_PWREx_WKUP6_Callback>
}
24011112:	bf00      	nop
24011114:	bd80      	pop	{r7, pc}
24011116:	bf00      	nop
24011118:	58024800 	.word	0x58024800

2401111c <HAL_PWREx_WKUP1_Callback>:
/**
  * @brief PWR WKUP1 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP1_Callback (void)
{
2401111c:	b480      	push	{r7}
2401111e:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP1Callback can be implemented in the user file
  */
}
24011120:	bf00      	nop
24011122:	46bd      	mov	sp, r7
24011124:	f85d 7b04 	ldr.w	r7, [sp], #4
24011128:	4770      	bx	lr

2401112a <HAL_PWREx_WKUP2_Callback>:
/**
  * @brief PWR WKUP2 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP2_Callback (void)
{
2401112a:	b480      	push	{r7}
2401112c:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP2Callback can be implemented in the user file
  */
}
2401112e:	bf00      	nop
24011130:	46bd      	mov	sp, r7
24011132:	f85d 7b04 	ldr.w	r7, [sp], #4
24011136:	4770      	bx	lr

24011138 <HAL_PWREx_WKUP3_Callback>:
/**
  * @brief PWR WKUP3 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP3_Callback (void)
{
24011138:	b480      	push	{r7}
2401113a:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP3Callback can be implemented in the user file
  */
}
2401113c:	bf00      	nop
2401113e:	46bd      	mov	sp, r7
24011140:	f85d 7b04 	ldr.w	r7, [sp], #4
24011144:	4770      	bx	lr

24011146 <HAL_PWREx_WKUP4_Callback>:
/**
  * @brief PWR WKUP4 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP4_Callback (void)
{
24011146:	b480      	push	{r7}
24011148:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP4Callback can be implemented in the user file
  */
}
2401114a:	bf00      	nop
2401114c:	46bd      	mov	sp, r7
2401114e:	f85d 7b04 	ldr.w	r7, [sp], #4
24011152:	4770      	bx	lr

24011154 <HAL_PWREx_WKUP5_Callback>:
/**
  * @brief PWR WKUP5 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP5_Callback (void)
{
24011154:	b480      	push	{r7}
24011156:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP5Callback can be implemented in the user file
  */
}
24011158:	bf00      	nop
2401115a:	46bd      	mov	sp, r7
2401115c:	f85d 7b04 	ldr.w	r7, [sp], #4
24011160:	4770      	bx	lr

24011162 <HAL_PWREx_WKUP6_Callback>:
/**
  * @brief PWR WKUP6 interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_WKUP6_Callback (void)
{
24011162:	b480      	push	{r7}
24011164:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWREx_WKUP6Callback can be implemented in the user file
  */
}
24011166:	bf00      	nop
24011168:	46bd      	mov	sp, r7
2401116a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401116e:	4770      	bx	lr

24011170 <HAL_PWREx_EnableBkUpReg>:
/**
  * @brief Enable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg (void)
{
24011170:	b580      	push	{r7, lr}
24011172:	b082      	sub	sp, #8
24011174:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the Backup regulator */
  SET_BIT (PWR->CR2, PWR_CR2_BREN);
24011176:	4b10      	ldr	r3, [pc, #64]	; (240111b8 <HAL_PWREx_EnableBkUpReg+0x48>)
24011178:	689b      	ldr	r3, [r3, #8]
2401117a:	4a0f      	ldr	r2, [pc, #60]	; (240111b8 <HAL_PWREx_EnableBkUpReg+0x48>)
2401117c:	f043 0301 	orr.w	r3, r3, #1
24011180:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
24011182:	f7f1 f8df 	bl	24002344 <HAL_GetTick>
24011186:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
24011188:	e009      	b.n	2401119e <HAL_PWREx_EnableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2401118a:	f7f1 f8db 	bl	24002344 <HAL_GetTick>
2401118e:	4602      	mov	r2, r0
24011190:	687b      	ldr	r3, [r7, #4]
24011192:	1ad3      	subs	r3, r2, r3
24011194:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24011198:	d901      	bls.n	2401119e <HAL_PWREx_EnableBkUpReg+0x2e>
    {
      return HAL_ERROR;
2401119a:	2301      	movs	r3, #1
2401119c:	e007      	b.n	240111ae <HAL_PWREx_EnableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) == 0U)
2401119e:	4b06      	ldr	r3, [pc, #24]	; (240111b8 <HAL_PWREx_EnableBkUpReg+0x48>)
240111a0:	689b      	ldr	r3, [r3, #8]
240111a2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240111a6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240111aa:	d1ee      	bne.n	2401118a <HAL_PWREx_EnableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
240111ac:	2300      	movs	r3, #0
}
240111ae:	4618      	mov	r0, r3
240111b0:	3708      	adds	r7, #8
240111b2:	46bd      	mov	sp, r7
240111b4:	bd80      	pop	{r7, pc}
240111b6:	bf00      	nop
240111b8:	58024800 	.word	0x58024800

240111bc <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disable the Backup Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg (void)
{
240111bc:	b580      	push	{r7, lr}
240111be:	b082      	sub	sp, #8
240111c0:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the Backup regulator */
  CLEAR_BIT (PWR->CR2, PWR_CR2_BREN);
240111c2:	4b10      	ldr	r3, [pc, #64]	; (24011204 <HAL_PWREx_DisableBkUpReg+0x48>)
240111c4:	689b      	ldr	r3, [r3, #8]
240111c6:	4a0f      	ldr	r2, [pc, #60]	; (24011204 <HAL_PWREx_DisableBkUpReg+0x48>)
240111c8:	f023 0301 	bic.w	r3, r3, #1
240111cc:	6093      	str	r3, [r2, #8]

  /* Get tick */
  tickstart = HAL_GetTick ();
240111ce:	f7f1 f8b9 	bl	24002344 <HAL_GetTick>
240111d2:	6078      	str	r0, [r7, #4]

  /* Wait till Backup regulator ready flag is reset */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
240111d4:	e009      	b.n	240111ea <HAL_PWREx_DisableBkUpReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
240111d6:	f7f1 f8b5 	bl	24002344 <HAL_GetTick>
240111da:	4602      	mov	r2, r0
240111dc:	687b      	ldr	r3, [r7, #4]
240111de:	1ad3      	subs	r3, r2, r3
240111e0:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
240111e4:	d901      	bls.n	240111ea <HAL_PWREx_DisableBkUpReg+0x2e>
    {
      return HAL_ERROR;
240111e6:	2301      	movs	r3, #1
240111e8:	e007      	b.n	240111fa <HAL_PWREx_DisableBkUpReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_BRR) != 0U)
240111ea:	4b06      	ldr	r3, [pc, #24]	; (24011204 <HAL_PWREx_DisableBkUpReg+0x48>)
240111ec:	689b      	ldr	r3, [r3, #8]
240111ee:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240111f2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240111f6:	d0ee      	beq.n	240111d6 <HAL_PWREx_DisableBkUpReg+0x1a>
    }
  }

  return HAL_OK;
240111f8:	2300      	movs	r3, #0
}
240111fa:	4618      	mov	r0, r3
240111fc:	3708      	adds	r7, #8
240111fe:	46bd      	mov	sp, r7
24011200:	bd80      	pop	{r7, pc}
24011202:	bf00      	nop
24011204:	58024800 	.word	0x58024800

24011208 <HAL_PWREx_EnableUSBReg>:
/**
  * @brief Enable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_EnableUSBReg (void)
{
24011208:	b580      	push	{r7, lr}
2401120a:	b082      	sub	sp, #8
2401120c:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Enable the USB regulator */
  SET_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2401120e:	4b10      	ldr	r3, [pc, #64]	; (24011250 <HAL_PWREx_EnableUSBReg+0x48>)
24011210:	68db      	ldr	r3, [r3, #12]
24011212:	4a0f      	ldr	r2, [pc, #60]	; (24011250 <HAL_PWREx_EnableUSBReg+0x48>)
24011214:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
24011218:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
2401121a:	f7f1 f893 	bl	24002344 <HAL_GetTick>
2401121e:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
24011220:	e009      	b.n	24011236 <HAL_PWREx_EnableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
24011222:	f7f1 f88f 	bl	24002344 <HAL_GetTick>
24011226:	4602      	mov	r2, r0
24011228:	687b      	ldr	r3, [r7, #4]
2401122a:	1ad3      	subs	r3, r2, r3
2401122c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
24011230:	d901      	bls.n	24011236 <HAL_PWREx_EnableUSBReg+0x2e>
    {
      return HAL_ERROR;
24011232:	2301      	movs	r3, #1
24011234:	e007      	b.n	24011246 <HAL_PWREx_EnableUSBReg+0x3e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) == 0U)
24011236:	4b06      	ldr	r3, [pc, #24]	; (24011250 <HAL_PWREx_EnableUSBReg+0x48>)
24011238:	68db      	ldr	r3, [r3, #12]
2401123a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2401123e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24011242:	d1ee      	bne.n	24011222 <HAL_PWREx_EnableUSBReg+0x1a>
    }
  }

  return HAL_OK;
24011244:	2300      	movs	r3, #0
}
24011246:	4618      	mov	r0, r3
24011248:	3708      	adds	r7, #8
2401124a:	46bd      	mov	sp, r7
2401124c:	bd80      	pop	{r7, pc}
2401124e:	bf00      	nop
24011250:	58024800 	.word	0x58024800

24011254 <HAL_PWREx_DisableUSBReg>:
/**
  * @brief Disable the USB Regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_DisableUSBReg (void)
{
24011254:	b580      	push	{r7, lr}
24011256:	b082      	sub	sp, #8
24011258:	af00      	add	r7, sp, #0
  uint32_t tickstart;

  /* Disable the USB regulator */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USBREGEN);
2401125a:	4b10      	ldr	r3, [pc, #64]	; (2401129c <HAL_PWREx_DisableUSBReg+0x48>)
2401125c:	68db      	ldr	r3, [r3, #12]
2401125e:	4a0f      	ldr	r2, [pc, #60]	; (2401129c <HAL_PWREx_DisableUSBReg+0x48>)
24011260:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
24011264:	60d3      	str	r3, [r2, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
24011266:	f7f1 f86d 	bl	24002344 <HAL_GetTick>
2401126a:	6078      	str	r0, [r7, #4]

  /* Wait till the USB regulator ready flag is reset */
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
2401126c:	e009      	b.n	24011282 <HAL_PWREx_DisableUSBReg+0x2e>
  {
    if ((HAL_GetTick() - tickstart ) > PWR_FLAG_SETTING_DELAY)
2401126e:	f7f1 f869 	bl	24002344 <HAL_GetTick>
24011272:	4602      	mov	r2, r0
24011274:	687b      	ldr	r3, [r7, #4]
24011276:	1ad3      	subs	r3, r2, r3
24011278:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
2401127c:	d901      	bls.n	24011282 <HAL_PWREx_DisableUSBReg+0x2e>
    {
      return HAL_ERROR;
2401127e:	2301      	movs	r3, #1
24011280:	e007      	b.n	24011292 <HAL_PWREx_DisableUSBReg+0x3e>
  while(__HAL_PWR_GET_FLAG (PWR_FLAG_USB33RDY) != 0U)
24011282:	4b06      	ldr	r3, [pc, #24]	; (2401129c <HAL_PWREx_DisableUSBReg+0x48>)
24011284:	68db      	ldr	r3, [r3, #12]
24011286:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
2401128a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
2401128e:	d0ee      	beq.n	2401126e <HAL_PWREx_DisableUSBReg+0x1a>
    }
  }

  return HAL_OK;
24011290:	2300      	movs	r3, #0
}
24011292:	4618      	mov	r0, r3
24011294:	3708      	adds	r7, #8
24011296:	46bd      	mov	sp, r7
24011298:	bd80      	pop	{r7, pc}
2401129a:	bf00      	nop
2401129c:	58024800 	.word	0x58024800

240112a0 <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
240112a0:	b480      	push	{r7}
240112a2:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
240112a4:	4b05      	ldr	r3, [pc, #20]	; (240112bc <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
240112a6:	68db      	ldr	r3, [r3, #12]
240112a8:	4a04      	ldr	r2, [pc, #16]	; (240112bc <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
240112aa:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
240112ae:	60d3      	str	r3, [r2, #12]
}
240112b0:	bf00      	nop
240112b2:	46bd      	mov	sp, r7
240112b4:	f85d 7b04 	ldr.w	r7, [sp], #4
240112b8:	4770      	bx	lr
240112ba:	bf00      	nop
240112bc:	58024800 	.word	0x58024800

240112c0 <HAL_PWREx_DisableUSBVoltageDetector>:
/**
  * @brief Disable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
240112c0:	b480      	push	{r7}
240112c2:	af00      	add	r7, sp, #0
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
240112c4:	4b05      	ldr	r3, [pc, #20]	; (240112dc <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
240112c6:	68db      	ldr	r3, [r3, #12]
240112c8:	4a04      	ldr	r2, [pc, #16]	; (240112dc <HAL_PWREx_DisableUSBVoltageDetector+0x1c>)
240112ca:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
240112ce:	60d3      	str	r3, [r2, #12]
}
240112d0:	bf00      	nop
240112d2:	46bd      	mov	sp, r7
240112d4:	f85d 7b04 	ldr.w	r7, [sp], #4
240112d8:	4770      	bx	lr
240112da:	bf00      	nop
240112dc:	58024800 	.word	0x58024800

240112e0 <HAL_PWREx_EnableBatteryCharging>:
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_5 : 5 KOhm resistor.
  *            @arg PWR_BATTERY_CHARGING_RESISTOR_1_5 : 1.5 KOhm resistor.
  * @retval None.
  */
void HAL_PWREx_EnableBatteryCharging (uint32_t ResistorValue)
{
240112e0:	b480      	push	{r7}
240112e2:	b083      	sub	sp, #12
240112e4:	af00      	add	r7, sp, #0
240112e6:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param (IS_PWR_BATTERY_RESISTOR_SELECT (ResistorValue));

  /* Specify the charging resistor */
  MODIFY_REG (PWR->CR3, PWR_CR3_VBRS, ResistorValue);
240112e8:	4b09      	ldr	r3, [pc, #36]	; (24011310 <HAL_PWREx_EnableBatteryCharging+0x30>)
240112ea:	68db      	ldr	r3, [r3, #12]
240112ec:	f423 7200 	bic.w	r2, r3, #512	; 0x200
240112f0:	4907      	ldr	r1, [pc, #28]	; (24011310 <HAL_PWREx_EnableBatteryCharging+0x30>)
240112f2:	687b      	ldr	r3, [r7, #4]
240112f4:	4313      	orrs	r3, r2
240112f6:	60cb      	str	r3, [r1, #12]

  /* Enable the Battery charging */
  SET_BIT (PWR->CR3, PWR_CR3_VBE);
240112f8:	4b05      	ldr	r3, [pc, #20]	; (24011310 <HAL_PWREx_EnableBatteryCharging+0x30>)
240112fa:	68db      	ldr	r3, [r3, #12]
240112fc:	4a04      	ldr	r2, [pc, #16]	; (24011310 <HAL_PWREx_EnableBatteryCharging+0x30>)
240112fe:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24011302:	60d3      	str	r3, [r2, #12]
}
24011304:	bf00      	nop
24011306:	370c      	adds	r7, #12
24011308:	46bd      	mov	sp, r7
2401130a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401130e:	4770      	bx	lr
24011310:	58024800 	.word	0x58024800

24011314 <HAL_PWREx_DisableBatteryCharging>:
/**
  * @brief Disable the Battery charging.
  * @retval None.
  */
void HAL_PWREx_DisableBatteryCharging (void)
{
24011314:	b480      	push	{r7}
24011316:	af00      	add	r7, sp, #0
  /* Disable the Battery charging */
  CLEAR_BIT (PWR->CR3, PWR_CR3_VBE);
24011318:	4b05      	ldr	r3, [pc, #20]	; (24011330 <HAL_PWREx_DisableBatteryCharging+0x1c>)
2401131a:	68db      	ldr	r3, [r3, #12]
2401131c:	4a04      	ldr	r2, [pc, #16]	; (24011330 <HAL_PWREx_DisableBatteryCharging+0x1c>)
2401131e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24011322:	60d3      	str	r3, [r2, #12]
}
24011324:	bf00      	nop
24011326:	46bd      	mov	sp, r7
24011328:	f85d 7b04 	ldr.w	r7, [sp], #4
2401132c:	4770      	bx	lr
2401132e:	bf00      	nop
24011330:	58024800 	.word	0x58024800

24011334 <HAL_PWREx_EnableMonitoring>:
/**
  * @brief Enable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_EnableMonitoring (void)
{
24011334:	b480      	push	{r7}
24011336:	af00      	add	r7, sp, #0
  /* Enable the VBAT and Temperature monitoring */
  SET_BIT (PWR->CR2, PWR_CR2_MONEN);
24011338:	4b05      	ldr	r3, [pc, #20]	; (24011350 <HAL_PWREx_EnableMonitoring+0x1c>)
2401133a:	689b      	ldr	r3, [r3, #8]
2401133c:	4a04      	ldr	r2, [pc, #16]	; (24011350 <HAL_PWREx_EnableMonitoring+0x1c>)
2401133e:	f043 0310 	orr.w	r3, r3, #16
24011342:	6093      	str	r3, [r2, #8]
}
24011344:	bf00      	nop
24011346:	46bd      	mov	sp, r7
24011348:	f85d 7b04 	ldr.w	r7, [sp], #4
2401134c:	4770      	bx	lr
2401134e:	bf00      	nop
24011350:	58024800 	.word	0x58024800

24011354 <HAL_PWREx_DisableMonitoring>:
/**
  * @brief Disable the VBAT and temperature monitoring.
  * @retval HAL status.
  */
void HAL_PWREx_DisableMonitoring (void)
{
24011354:	b480      	push	{r7}
24011356:	af00      	add	r7, sp, #0
  /* Disable the VBAT and Temperature monitoring */
  CLEAR_BIT (PWR->CR2, PWR_CR2_MONEN);
24011358:	4b05      	ldr	r3, [pc, #20]	; (24011370 <HAL_PWREx_DisableMonitoring+0x1c>)
2401135a:	689b      	ldr	r3, [r3, #8]
2401135c:	4a04      	ldr	r2, [pc, #16]	; (24011370 <HAL_PWREx_DisableMonitoring+0x1c>)
2401135e:	f023 0310 	bic.w	r3, r3, #16
24011362:	6093      	str	r3, [r2, #8]
}
24011364:	bf00      	nop
24011366:	46bd      	mov	sp, r7
24011368:	f85d 7b04 	ldr.w	r7, [sp], #4
2401136c:	4770      	bx	lr
2401136e:	bf00      	nop
24011370:	58024800 	.word	0x58024800

24011374 <HAL_PWREx_GetTemperatureLevel>:
  * @brief Indicate whether the junction temperature is between, above or below
  *        the thresholds.
  * @retval Temperature level.
  */
uint32_t HAL_PWREx_GetTemperatureLevel (void)
{
24011374:	b480      	push	{r7}
24011376:	b083      	sub	sp, #12
24011378:	af00      	add	r7, sp, #0
  uint32_t tempLevel, regValue;

  /* Read the temperature flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_TEMPH | PWR_CR2_TEMPL));
2401137a:	4b0f      	ldr	r3, [pc, #60]	; (240113b8 <HAL_PWREx_GetTemperatureLevel+0x44>)
2401137c:	689b      	ldr	r3, [r3, #8]
2401137e:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
24011382:	603b      	str	r3, [r7, #0]

  /* Check if the temperature is below the threshold */
  if (regValue == PWR_CR2_TEMPL)
24011384:	683b      	ldr	r3, [r7, #0]
24011386:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2401138a:	d103      	bne.n	24011394 <HAL_PWREx_GetTemperatureLevel+0x20>
  {
    tempLevel = PWR_TEMP_BELOW_LOW_THRESHOLD;
2401138c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
24011390:	607b      	str	r3, [r7, #4]
24011392:	e009      	b.n	240113a8 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* Check if the temperature is above the threshold */
  else if (regValue == PWR_CR2_TEMPH)
24011394:	683b      	ldr	r3, [r7, #0]
24011396:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2401139a:	d103      	bne.n	240113a4 <HAL_PWREx_GetTemperatureLevel+0x30>
  {
    tempLevel = PWR_TEMP_ABOVE_HIGH_THRESHOLD;
2401139c:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
240113a0:	607b      	str	r3, [r7, #4]
240113a2:	e001      	b.n	240113a8 <HAL_PWREx_GetTemperatureLevel+0x34>
  }
  /* The temperature is between the thresholds */
  else
  {
    tempLevel = PWR_TEMP_BETWEEN_HIGH_LOW_THRESHOLD;
240113a4:	2300      	movs	r3, #0
240113a6:	607b      	str	r3, [r7, #4]
  }

  return tempLevel;
240113a8:	687b      	ldr	r3, [r7, #4]
}
240113aa:	4618      	mov	r0, r3
240113ac:	370c      	adds	r7, #12
240113ae:	46bd      	mov	sp, r7
240113b0:	f85d 7b04 	ldr.w	r7, [sp], #4
240113b4:	4770      	bx	lr
240113b6:	bf00      	nop
240113b8:	58024800 	.word	0x58024800

240113bc <HAL_PWREx_GetVBATLevel>:
  * @brief Indicate whether the Battery voltage level is between, above or below
  *        the thresholds.
  * @retval VBAT level.
  */
uint32_t HAL_PWREx_GetVBATLevel (void)
{
240113bc:	b480      	push	{r7}
240113be:	b083      	sub	sp, #12
240113c0:	af00      	add	r7, sp, #0
  uint32_t VBATLevel, regValue;

  /* Read the VBAT flags */
  regValue = READ_BIT (PWR->CR2, (PWR_CR2_VBATH | PWR_CR2_VBATL));
240113c2:	4b0f      	ldr	r3, [pc, #60]	; (24011400 <HAL_PWREx_GetVBATLevel+0x44>)
240113c4:	689b      	ldr	r3, [r3, #8]
240113c6:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
240113ca:	603b      	str	r3, [r7, #0]

  /* Check if the VBAT is below the threshold */
  if (regValue == PWR_CR2_VBATL)
240113cc:	683b      	ldr	r3, [r7, #0]
240113ce:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
240113d2:	d103      	bne.n	240113dc <HAL_PWREx_GetVBATLevel+0x20>
  {
    VBATLevel = PWR_VBAT_BELOW_LOW_THRESHOLD;
240113d4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
240113d8:	607b      	str	r3, [r7, #4]
240113da:	e009      	b.n	240113f0 <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* Check if the VBAT is above the threshold */
  else if (regValue == PWR_CR2_VBATH)
240113dc:	683b      	ldr	r3, [r7, #0]
240113de:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
240113e2:	d103      	bne.n	240113ec <HAL_PWREx_GetVBATLevel+0x30>
  {
    VBATLevel = PWR_VBAT_ABOVE_HIGH_THRESHOLD;
240113e4:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
240113e8:	607b      	str	r3, [r7, #4]
240113ea:	e001      	b.n	240113f0 <HAL_PWREx_GetVBATLevel+0x34>
  }
  /* The VBAT is between the thresholds */
  else
  {
    VBATLevel = PWR_VBAT_BETWEEN_HIGH_LOW_THRESHOLD;
240113ec:	2300      	movs	r3, #0
240113ee:	607b      	str	r3, [r7, #4]
  }

  return VBATLevel;
240113f0:	687b      	ldr	r3, [r7, #4]
}
240113f2:	4618      	mov	r0, r3
240113f4:	370c      	adds	r7, #12
240113f6:	46bd      	mov	sp, r7
240113f8:	f85d 7b04 	ldr.w	r7, [sp], #4
240113fc:	4770      	bx	lr
240113fe:	bf00      	nop
24011400:	58024800 	.word	0x58024800

24011404 <HAL_PWREx_ConfigAVD>:
  *         driver. All combination are allowed: wake up only Cortex-M7, wake up
  *         only Cortex-M4 and wake up Cortex-M7 and Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ConfigAVD (PWREx_AVDTypeDef *sConfigAVD)
{
24011404:	b480      	push	{r7}
24011406:	b083      	sub	sp, #12
24011408:	af00      	add	r7, sp, #0
2401140a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_AVD_LEVEL (sConfigAVD->AVDLevel));
  assert_param (IS_PWR_AVD_MODE (sConfigAVD->Mode));

  /* Set the ALS[18:17] bits according to AVDLevel value */
  MODIFY_REG (PWR->CR1, PWR_CR1_ALS, sConfigAVD->AVDLevel);
2401140c:	4b37      	ldr	r3, [pc, #220]	; (240114ec <HAL_PWREx_ConfigAVD+0xe8>)
2401140e:	681b      	ldr	r3, [r3, #0]
24011410:	f423 22c0 	bic.w	r2, r3, #393216	; 0x60000
24011414:	687b      	ldr	r3, [r7, #4]
24011416:	681b      	ldr	r3, [r3, #0]
24011418:	4934      	ldr	r1, [pc, #208]	; (240114ec <HAL_PWREx_ConfigAVD+0xe8>)
2401141a:	4313      	orrs	r3, r2
2401141c:	600b      	str	r3, [r1, #0]

  /* Clear any previous config */
#if !defined (DUAL_CORE)
  __HAL_PWR_AVD_EXTI_DISABLE_EVENT ();
2401141e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011422:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24011426:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401142a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401142e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __HAL_PWR_AVD_EXTI_DISABLE_IT ();
24011432:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011436:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2401143a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401143e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011442:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* !defined (DUAL_CORE) */

  __HAL_PWR_AVD_EXTI_DISABLE_RISING_EDGE ();
24011446:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401144a:	681b      	ldr	r3, [r3, #0]
2401144c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24011450:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011454:	6013      	str	r3, [r2, #0]
  __HAL_PWR_AVD_EXTI_DISABLE_FALLING_EDGE ();
24011456:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401145a:	685b      	ldr	r3, [r3, #4]
2401145c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24011460:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24011464:	6053      	str	r3, [r2, #4]

#if !defined (DUAL_CORE)
  /* Configure the interrupt mode */
  if ((sConfigAVD->Mode & AVD_MODE_IT) == AVD_MODE_IT)
24011466:	687b      	ldr	r3, [r7, #4]
24011468:	685b      	ldr	r3, [r3, #4]
2401146a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401146e:	2b00      	cmp	r3, #0
24011470:	d009      	beq.n	24011486 <HAL_PWREx_ConfigAVD+0x82>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_IT ();
24011472:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011476:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
2401147a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401147e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011482:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  }

  /* Configure the event mode */
  if ((sConfigAVD->Mode & AVD_MODE_EVT) == AVD_MODE_EVT)
24011486:	687b      	ldr	r3, [r7, #4]
24011488:	685b      	ldr	r3, [r3, #4]
2401148a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401148e:	2b00      	cmp	r3, #0
24011490:	d009      	beq.n	240114a6 <HAL_PWREx_ConfigAVD+0xa2>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_EVENT ();
24011492:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011496:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
2401149a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401149e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240114a2:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  }
#endif /* !defined (DUAL_CORE) */

  /* Rising edge configuration */
  if ((sConfigAVD->Mode & AVD_RISING_EDGE) == AVD_RISING_EDGE)
240114a6:	687b      	ldr	r3, [r7, #4]
240114a8:	685b      	ldr	r3, [r3, #4]
240114aa:	f003 0301 	and.w	r3, r3, #1
240114ae:	2b00      	cmp	r3, #0
240114b0:	d007      	beq.n	240114c2 <HAL_PWREx_ConfigAVD+0xbe>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_RISING_EDGE ();
240114b2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240114b6:	681b      	ldr	r3, [r3, #0]
240114b8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240114bc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240114c0:	6013      	str	r3, [r2, #0]
  }

  /* Falling edge configuration */
  if ((sConfigAVD->Mode & AVD_FALLING_EDGE) == AVD_FALLING_EDGE)
240114c2:	687b      	ldr	r3, [r7, #4]
240114c4:	685b      	ldr	r3, [r3, #4]
240114c6:	f003 0302 	and.w	r3, r3, #2
240114ca:	2b00      	cmp	r3, #0
240114cc:	d007      	beq.n	240114de <HAL_PWREx_ConfigAVD+0xda>
  {
    __HAL_PWR_AVD_EXTI_ENABLE_FALLING_EDGE ();
240114ce:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
240114d2:	685b      	ldr	r3, [r3, #4]
240114d4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
240114d8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240114dc:	6053      	str	r3, [r2, #4]
  }
}
240114de:	bf00      	nop
240114e0:	370c      	adds	r7, #12
240114e2:	46bd      	mov	sp, r7
240114e4:	f85d 7b04 	ldr.w	r7, [sp], #4
240114e8:	4770      	bx	lr
240114ea:	bf00      	nop
240114ec:	58024800 	.word	0x58024800

240114f0 <HAL_PWREx_EnableAVD>:
/**
  * @brief Enable the Analog Voltage Detector (AVD).
  * @retval None.
  */
void HAL_PWREx_EnableAVD (void)
{
240114f0:	b480      	push	{r7}
240114f2:	af00      	add	r7, sp, #0
  /* Enable the Analog Voltage Detector */
  SET_BIT (PWR->CR1, PWR_CR1_AVDEN);
240114f4:	4b05      	ldr	r3, [pc, #20]	; (2401150c <HAL_PWREx_EnableAVD+0x1c>)
240114f6:	681b      	ldr	r3, [r3, #0]
240114f8:	4a04      	ldr	r2, [pc, #16]	; (2401150c <HAL_PWREx_EnableAVD+0x1c>)
240114fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240114fe:	6013      	str	r3, [r2, #0]
}
24011500:	bf00      	nop
24011502:	46bd      	mov	sp, r7
24011504:	f85d 7b04 	ldr.w	r7, [sp], #4
24011508:	4770      	bx	lr
2401150a:	bf00      	nop
2401150c:	58024800 	.word	0x58024800

24011510 <HAL_PWREx_DisableAVD>:
/**
  * @brief Disable the Analog Voltage Detector(AVD).
  * @retval None.
  */
void HAL_PWREx_DisableAVD (void)
{
24011510:	b480      	push	{r7}
24011512:	af00      	add	r7, sp, #0
  /* Disable the Analog Voltage Detector */
  CLEAR_BIT (PWR->CR1, PWR_CR1_AVDEN);
24011514:	4b05      	ldr	r3, [pc, #20]	; (2401152c <HAL_PWREx_DisableAVD+0x1c>)
24011516:	681b      	ldr	r3, [r3, #0]
24011518:	4a04      	ldr	r2, [pc, #16]	; (2401152c <HAL_PWREx_DisableAVD+0x1c>)
2401151a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401151e:	6013      	str	r3, [r2, #0]
}
24011520:	bf00      	nop
24011522:	46bd      	mov	sp, r7
24011524:	f85d 7b04 	ldr.w	r7, [sp], #4
24011528:	4770      	bx	lr
2401152a:	bf00      	nop
2401152c:	58024800 	.word	0x58024800

24011530 <HAL_PWREx_PVD_AVD_IRQHandler>:
  * @brief  This function handles the PWR PVD/AVD interrupt request.
  * @note   This API should be called under the PVD_AVD_IRQHandler().
  * @retval None
  */
void HAL_PWREx_PVD_AVD_IRQHandler (void)
{
24011530:	b580      	push	{r7, lr}
24011532:	af00      	add	r7, sp, #0
  /* Check if the Programmable Voltage Detector is enabled (PVD) */
  if (READ_BIT (PWR->CR1, PWR_CR1_PVDEN) != 0U)
24011534:	4b1b      	ldr	r3, [pc, #108]	; (240115a4 <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
24011536:	681b      	ldr	r3, [r3, #0]
24011538:	f003 0310 	and.w	r3, r3, #16
2401153c:	2b00      	cmp	r3, #0
2401153e:	d014      	beq.n	2401156a <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR D1/CD EXTI flag */
      if (__HAL_PWR_PVD_EXTI_GET_FLAG () != 0U)
24011540:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011544:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24011548:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
2401154c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24011550:	d10b      	bne.n	2401156a <HAL_PWREx_PVD_AVD_IRQHandler+0x3a>
      {
        /* PWR PVD interrupt user callback */
        HAL_PWR_PVDCallback ();
24011552:	f7ff faf4 	bl	24010b3e <HAL_PWR_PVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_PVD_EXTI_CLEAR_FLAG ();
24011556:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401155a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2401155e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24011562:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24011566:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    }
#endif /* defined (DUAL_CORE) */
  }

  /* Check if the Analog Voltage Detector is enabled (AVD) */
  if (READ_BIT (PWR->CR1, PWR_CR1_AVDEN) != 0U)
2401156a:	4b0e      	ldr	r3, [pc, #56]	; (240115a4 <HAL_PWREx_PVD_AVD_IRQHandler+0x74>)
2401156c:	681b      	ldr	r3, [r3, #0]
2401156e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24011572:	2b00      	cmp	r3, #0
24011574:	d014      	beq.n	240115a0 <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
#if defined (DUAL_CORE)
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
#endif /* defined (DUAL_CORE) */
    {
      /* Check PWR EXTI D1/CD flag */
      if (__HAL_PWR_AVD_EXTI_GET_FLAG () != 0U)
24011576:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
2401157a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
2401157e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24011582:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24011586:	d10b      	bne.n	240115a0 <HAL_PWREx_PVD_AVD_IRQHandler+0x70>
      {
        /* PWR AVD interrupt user callback */
        HAL_PWREx_AVDCallback ();
24011588:	f000 f80e 	bl	240115a8 <HAL_PWREx_AVDCallback>

        /* Clear PWR EXTI D1/CD pending bit */
        __HAL_PWR_AVD_EXTI_CLEAR_FLAG ();
2401158c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24011590:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24011594:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
24011598:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
2401159c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
        __HAL_PWR_AVD_EXTID2_CLEAR_FLAG ();
      }
    }
#endif /* defined (DUAL_CORE) */
  }
}
240115a0:	bf00      	nop
240115a2:	bd80      	pop	{r7, pc}
240115a4:	58024800 	.word	0x58024800

240115a8 <HAL_PWREx_AVDCallback>:
/**
  * @brief PWR AVD interrupt callback.
  * @retval None.
  */
__weak void HAL_PWREx_AVDCallback (void)
{
240115a8:	b480      	push	{r7}
240115aa:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PWR_AVDCallback can be implemented in the user file
  */
}
240115ac:	bf00      	nop
240115ae:	46bd      	mov	sp, r7
240115b0:	f85d 7b04 	ldr.w	r7, [sp], #4
240115b4:	4770      	bx	lr
	...

240115b8 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
240115b8:	b580      	push	{r7, lr}
240115ba:	b086      	sub	sp, #24
240115bc:	af02      	add	r7, sp, #8
240115be:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240115c0:	f7f0 fec0 	bl	24002344 <HAL_GetTick>
240115c4:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
240115c6:	687b      	ldr	r3, [r7, #4]
240115c8:	2b00      	cmp	r3, #0
240115ca:	d101      	bne.n	240115d0 <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
240115cc:	2301      	movs	r3, #1
240115ce:	e05f      	b.n	24011690 <HAL_QSPI_Init+0xd8>
  if (hqspi->Init.DualFlash != QSPI_DUALFLASH_ENABLE )
  {
    assert_param(IS_QSPI_FLASH_ID(hqspi->Init.FlashID));
  }

  if(hqspi->State == HAL_QSPI_STATE_RESET)
240115d0:	687b      	ldr	r3, [r7, #4]
240115d2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240115d6:	b2db      	uxtb	r3, r3
240115d8:	2b00      	cmp	r3, #0
240115da:	d107      	bne.n	240115ec <HAL_QSPI_Init+0x34>

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
240115dc:	6878      	ldr	r0, [r7, #4]
240115de:	f7ef fd23 	bl	24001028 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
240115e2:	f241 3188 	movw	r1, #5000	; 0x1388
240115e6:	6878      	ldr	r0, [r7, #4]
240115e8:	f001 f98e 	bl	24012908 <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
240115ec:	687b      	ldr	r3, [r7, #4]
240115ee:	681b      	ldr	r3, [r3, #0]
240115f0:	681b      	ldr	r3, [r3, #0]
240115f2:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
240115f6:	687b      	ldr	r3, [r7, #4]
240115f8:	689b      	ldr	r3, [r3, #8]
240115fa:	3b01      	subs	r3, #1
240115fc:	021a      	lsls	r2, r3, #8
240115fe:	687b      	ldr	r3, [r7, #4]
24011600:	681b      	ldr	r3, [r3, #0]
24011602:	430a      	orrs	r2, r1
24011604:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24011606:	687b      	ldr	r3, [r7, #4]
24011608:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2401160a:	9300      	str	r3, [sp, #0]
2401160c:	68fb      	ldr	r3, [r7, #12]
2401160e:	2200      	movs	r2, #0
24011610:	2120      	movs	r1, #32
24011612:	6878      	ldr	r0, [r7, #4]
24011614:	f001 fa87 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011618:	4603      	mov	r3, r0
2401161a:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
2401161c:	7afb      	ldrb	r3, [r7, #11]
2401161e:	2b00      	cmp	r3, #0
24011620:	d135      	bne.n	2401168e <HAL_QSPI_Init+0xd6>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
24011622:	687b      	ldr	r3, [r7, #4]
24011624:	681b      	ldr	r3, [r3, #0]
24011626:	681a      	ldr	r2, [r3, #0]
24011628:	4b1b      	ldr	r3, [pc, #108]	; (24011698 <HAL_QSPI_Init+0xe0>)
2401162a:	4013      	ands	r3, r2
2401162c:	687a      	ldr	r2, [r7, #4]
2401162e:	6852      	ldr	r2, [r2, #4]
24011630:	0611      	lsls	r1, r2, #24
24011632:	687a      	ldr	r2, [r7, #4]
24011634:	68d2      	ldr	r2, [r2, #12]
24011636:	4311      	orrs	r1, r2
24011638:	687a      	ldr	r2, [r7, #4]
2401163a:	69d2      	ldr	r2, [r2, #28]
2401163c:	4311      	orrs	r1, r2
2401163e:	687a      	ldr	r2, [r7, #4]
24011640:	6a12      	ldr	r2, [r2, #32]
24011642:	4311      	orrs	r1, r2
24011644:	687a      	ldr	r2, [r7, #4]
24011646:	6812      	ldr	r2, [r2, #0]
24011648:	430b      	orrs	r3, r1
2401164a:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting  | hqspi->Init.FlashID | hqspi->Init.DualFlash));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
2401164c:	687b      	ldr	r3, [r7, #4]
2401164e:	681b      	ldr	r3, [r3, #0]
24011650:	685a      	ldr	r2, [r3, #4]
24011652:	4b12      	ldr	r3, [pc, #72]	; (2401169c <HAL_QSPI_Init+0xe4>)
24011654:	4013      	ands	r3, r2
24011656:	687a      	ldr	r2, [r7, #4]
24011658:	6912      	ldr	r2, [r2, #16]
2401165a:	0411      	lsls	r1, r2, #16
2401165c:	687a      	ldr	r2, [r7, #4]
2401165e:	6952      	ldr	r2, [r2, #20]
24011660:	4311      	orrs	r1, r2
24011662:	687a      	ldr	r2, [r7, #4]
24011664:	6992      	ldr	r2, [r2, #24]
24011666:	4311      	orrs	r1, r2
24011668:	687a      	ldr	r2, [r7, #4]
2401166a:	6812      	ldr	r2, [r2, #0]
2401166c:	430b      	orrs	r3, r1
2401166e:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
24011670:	687b      	ldr	r3, [r7, #4]
24011672:	681b      	ldr	r3, [r3, #0]
24011674:	681a      	ldr	r2, [r3, #0]
24011676:	687b      	ldr	r3, [r7, #4]
24011678:	681b      	ldr	r3, [r3, #0]
2401167a:	f042 0201 	orr.w	r2, r2, #1
2401167e:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011680:	687b      	ldr	r3, [r7, #4]
24011682:	2200      	movs	r2, #0
24011684:	645a      	str	r2, [r3, #68]	; 0x44

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
24011686:	687b      	ldr	r3, [r7, #4]
24011688:	2201      	movs	r2, #1
2401168a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  }

  /* Return function status */
  return status;
2401168e:	7afb      	ldrb	r3, [r7, #11]
}
24011690:	4618      	mov	r0, r3
24011692:	3710      	adds	r7, #16
24011694:	46bd      	mov	sp, r7
24011696:	bd80      	pop	{r7, pc}
24011698:	00ffff2f 	.word	0x00ffff2f
2401169c:	ffe0f8fe 	.word	0xffe0f8fe

240116a0 <HAL_QSPI_DeInit>:
  * @brief De-Initialize the QSPI peripheral.
  * @param hqspi QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_DeInit(QSPI_HandleTypeDef *hqspi)
{
240116a0:	b580      	push	{r7, lr}
240116a2:	b082      	sub	sp, #8
240116a4:	af00      	add	r7, sp, #0
240116a6:	6078      	str	r0, [r7, #4]
  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
240116a8:	687b      	ldr	r3, [r7, #4]
240116aa:	2b00      	cmp	r3, #0
240116ac:	d101      	bne.n	240116b2 <HAL_QSPI_DeInit+0x12>
  {
    return HAL_ERROR;
240116ae:	2301      	movs	r3, #1
240116b0:	e012      	b.n	240116d8 <HAL_QSPI_DeInit+0x38>
  }

  /* Disable the QSPI Peripheral Clock */
  __HAL_QSPI_DISABLE(hqspi);
240116b2:	687b      	ldr	r3, [r7, #4]
240116b4:	681b      	ldr	r3, [r3, #0]
240116b6:	681a      	ldr	r2, [r3, #0]
240116b8:	687b      	ldr	r3, [r7, #4]
240116ba:	681b      	ldr	r3, [r3, #0]
240116bc:	f022 0201 	bic.w	r2, r2, #1
240116c0:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware */
  hqspi->MspDeInitCallback(hqspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_QSPI_MspDeInit(hqspi);
240116c2:	6878      	ldr	r0, [r7, #4]
240116c4:	f7ef fd6c 	bl	240011a0 <HAL_QSPI_MspDeInit>
#endif

  /* Set QSPI error code to none */
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240116c8:	687b      	ldr	r3, [r7, #4]
240116ca:	2200      	movs	r2, #0
240116cc:	645a      	str	r2, [r3, #68]	; 0x44

  /* Initialize the QSPI state */
  hqspi->State = HAL_QSPI_STATE_RESET;
240116ce:	687b      	ldr	r3, [r7, #4]
240116d0:	2200      	movs	r2, #0
240116d2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  return HAL_OK;
240116d6:	2300      	movs	r3, #0
}
240116d8:	4618      	mov	r0, r3
240116da:	3708      	adds	r7, #8
240116dc:	46bd      	mov	sp, r7
240116de:	bd80      	pop	{r7, pc}
  * @brief Initialize the QSPI MSP.
  * @param hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspInit(QSPI_HandleTypeDef *hqspi)
{
240116e0:	b480      	push	{r7}
240116e2:	b083      	sub	sp, #12
240116e4:	af00      	add	r7, sp, #0
240116e6:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspInit can be implemented in the user file
   */
}
240116e8:	bf00      	nop
240116ea:	370c      	adds	r7, #12
240116ec:	46bd      	mov	sp, r7
240116ee:	f85d 7b04 	ldr.w	r7, [sp], #4
240116f2:	4770      	bx	lr
  * @brief DeInitialize the QSPI MSP.
  * @param hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_MspDeInit(QSPI_HandleTypeDef *hqspi)
{
240116f4:	b480      	push	{r7}
240116f6:	b083      	sub	sp, #12
240116f8:	af00      	add	r7, sp, #0
240116fa:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_MspDeInit can be implemented in the user file
   */
}
240116fc:	bf00      	nop
240116fe:	370c      	adds	r7, #12
24011700:	46bd      	mov	sp, r7
24011702:	f85d 7b04 	ldr.w	r7, [sp], #4
24011706:	4770      	bx	lr

24011708 <HAL_QSPI_IRQHandler>:
  * @brief Handle QSPI interrupt request.
  * @param hqspi QSPI handle
  * @retval None
  */
void HAL_QSPI_IRQHandler(QSPI_HandleTypeDef *hqspi)
{
24011708:	b580      	push	{r7, lr}
2401170a:	b086      	sub	sp, #24
2401170c:	af00      	add	r7, sp, #0
2401170e:	6078      	str	r0, [r7, #4]
  __IO uint32_t *data_reg;
  uint32_t flag = READ_REG(hqspi->Instance->SR);
24011710:	687b      	ldr	r3, [r7, #4]
24011712:	681b      	ldr	r3, [r3, #0]
24011714:	689b      	ldr	r3, [r3, #8]
24011716:	617b      	str	r3, [r7, #20]
  uint32_t itsource = READ_REG(hqspi->Instance->CR);
24011718:	687b      	ldr	r3, [r7, #4]
2401171a:	681b      	ldr	r3, [r3, #0]
2401171c:	681b      	ldr	r3, [r3, #0]
2401171e:	613b      	str	r3, [r7, #16]

  /* QSPI Fifo Threshold interrupt occurred ----------------------------------*/
  if(((flag & QSPI_FLAG_FT) != 0U) && ((itsource & QSPI_IT_FT) != 0U))
24011720:	697b      	ldr	r3, [r7, #20]
24011722:	f003 0304 	and.w	r3, r3, #4
24011726:	2b00      	cmp	r3, #0
24011728:	d064      	beq.n	240117f4 <HAL_QSPI_IRQHandler+0xec>
2401172a:	693b      	ldr	r3, [r7, #16]
2401172c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24011730:	2b00      	cmp	r3, #0
24011732:	d05f      	beq.n	240117f4 <HAL_QSPI_IRQHandler+0xec>
  {
    data_reg = &hqspi->Instance->DR;
24011734:	687b      	ldr	r3, [r7, #4]
24011736:	681b      	ldr	r3, [r3, #0]
24011738:	3320      	adds	r3, #32
2401173a:	60fb      	str	r3, [r7, #12]

    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2401173c:	687b      	ldr	r3, [r7, #4]
2401173e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011742:	b2db      	uxtb	r3, r3
24011744:	2b12      	cmp	r3, #18
24011746:	d125      	bne.n	24011794 <HAL_QSPI_IRQHandler+0x8c>
    {
      /* Transmission process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24011748:	e01c      	b.n	24011784 <HAL_QSPI_IRQHandler+0x7c>
      {
        if (hqspi->TxXferCount > 0U)
2401174a:	687b      	ldr	r3, [r7, #4]
2401174c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401174e:	2b00      	cmp	r3, #0
24011750:	d00f      	beq.n	24011772 <HAL_QSPI_IRQHandler+0x6a>
        {
          /* Fill the FIFO until the threshold is reached */
          *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
24011752:	687b      	ldr	r3, [r7, #4]
24011754:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011756:	781a      	ldrb	r2, [r3, #0]
24011758:	68fb      	ldr	r3, [r7, #12]
2401175a:	701a      	strb	r2, [r3, #0]
          hqspi->pTxBuffPtr++;
2401175c:	687b      	ldr	r3, [r7, #4]
2401175e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011760:	1c5a      	adds	r2, r3, #1
24011762:	687b      	ldr	r3, [r7, #4]
24011764:	625a      	str	r2, [r3, #36]	; 0x24
          hqspi->TxXferCount--;
24011766:	687b      	ldr	r3, [r7, #4]
24011768:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401176a:	1e5a      	subs	r2, r3, #1
2401176c:	687b      	ldr	r3, [r7, #4]
2401176e:	62da      	str	r2, [r3, #44]	; 0x2c
24011770:	e008      	b.n	24011784 <HAL_QSPI_IRQHandler+0x7c>
        }
        else
        {
          /* No more data available for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
24011772:	687b      	ldr	r3, [r7, #4]
24011774:	681b      	ldr	r3, [r3, #0]
24011776:	681a      	ldr	r2, [r3, #0]
24011778:	687b      	ldr	r3, [r7, #4]
2401177a:	681b      	ldr	r3, [r3, #0]
2401177c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
24011780:	601a      	str	r2, [r3, #0]
          break;
24011782:	e033      	b.n	240117ec <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
24011784:	687b      	ldr	r3, [r7, #4]
24011786:	681b      	ldr	r3, [r3, #0]
24011788:	689b      	ldr	r3, [r3, #8]
2401178a:	f003 0304 	and.w	r3, r3, #4
2401178e:	2b00      	cmp	r3, #0
24011790:	d1db      	bne.n	2401174a <HAL_QSPI_IRQHandler+0x42>
24011792:	e02b      	b.n	240117ec <HAL_QSPI_IRQHandler+0xe4>
        }
      }
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
24011794:	687b      	ldr	r3, [r7, #4]
24011796:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401179a:	b2db      	uxtb	r3, r3
2401179c:	2b22      	cmp	r3, #34	; 0x22
2401179e:	d125      	bne.n	240117ec <HAL_QSPI_IRQHandler+0xe4>
    {
      /* Receiving Process */
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
240117a0:	e01d      	b.n	240117de <HAL_QSPI_IRQHandler+0xd6>
      {
        if (hqspi->RxXferCount > 0U)
240117a2:	687b      	ldr	r3, [r7, #4]
240117a4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240117a6:	2b00      	cmp	r3, #0
240117a8:	d010      	beq.n	240117cc <HAL_QSPI_IRQHandler+0xc4>
        {
          /* Read the FIFO until the threshold is reached */
          *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
240117aa:	687b      	ldr	r3, [r7, #4]
240117ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240117ae:	68fa      	ldr	r2, [r7, #12]
240117b0:	7812      	ldrb	r2, [r2, #0]
240117b2:	b2d2      	uxtb	r2, r2
240117b4:	701a      	strb	r2, [r3, #0]
          hqspi->pRxBuffPtr++;
240117b6:	687b      	ldr	r3, [r7, #4]
240117b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240117ba:	1c5a      	adds	r2, r3, #1
240117bc:	687b      	ldr	r3, [r7, #4]
240117be:	631a      	str	r2, [r3, #48]	; 0x30
          hqspi->RxXferCount--;
240117c0:	687b      	ldr	r3, [r7, #4]
240117c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240117c4:	1e5a      	subs	r2, r3, #1
240117c6:	687b      	ldr	r3, [r7, #4]
240117c8:	639a      	str	r2, [r3, #56]	; 0x38
240117ca:	e008      	b.n	240117de <HAL_QSPI_IRQHandler+0xd6>
        }
        else
        {
          /* All data have been received for the transfer */
          /* Disable the QSPI FIFO Threshold Interrupt */
          __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_FT);
240117cc:	687b      	ldr	r3, [r7, #4]
240117ce:	681b      	ldr	r3, [r3, #0]
240117d0:	681a      	ldr	r2, [r3, #0]
240117d2:	687b      	ldr	r3, [r7, #4]
240117d4:	681b      	ldr	r3, [r3, #0]
240117d6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
240117da:	601a      	str	r2, [r3, #0]
          break;
240117dc:	e006      	b.n	240117ec <HAL_QSPI_IRQHandler+0xe4>
      while(__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_FT) != RESET)
240117de:	687b      	ldr	r3, [r7, #4]
240117e0:	681b      	ldr	r3, [r3, #0]
240117e2:	689b      	ldr	r3, [r3, #8]
240117e4:	f003 0304 	and.w	r3, r3, #4
240117e8:	2b00      	cmp	r3, #0
240117ea:	d1da      	bne.n	240117a2 <HAL_QSPI_IRQHandler+0x9a>

    /* FIFO Threshold callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->FifoThresholdCallback(hqspi);
#else
    HAL_QSPI_FifoThresholdCallback(hqspi);
240117ec:	6878      	ldr	r0, [r7, #4]
240117ee:	f000 ff72 	bl	240126d6 <HAL_QSPI_FifoThresholdCallback>
240117f2:	e13c      	b.n	24011a6e <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Complete interrupt occurred -------------------------------*/
  else if(((flag & QSPI_FLAG_TC) != 0U) && ((itsource & QSPI_IT_TC) != 0U))
240117f4:	697b      	ldr	r3, [r7, #20]
240117f6:	f003 0302 	and.w	r3, r3, #2
240117fa:	2b00      	cmp	r3, #0
240117fc:	f000 80b0 	beq.w	24011960 <HAL_QSPI_IRQHandler+0x258>
24011800:	693b      	ldr	r3, [r7, #16]
24011802:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24011806:	2b00      	cmp	r3, #0
24011808:	f000 80aa 	beq.w	24011960 <HAL_QSPI_IRQHandler+0x258>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TC);
2401180c:	687b      	ldr	r3, [r7, #4]
2401180e:	681b      	ldr	r3, [r3, #0]
24011810:	2202      	movs	r2, #2
24011812:	60da      	str	r2, [r3, #12]

    /* Disable the QSPI FIFO Threshold, Transfer Error and Transfer complete Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
24011814:	687b      	ldr	r3, [r7, #4]
24011816:	681b      	ldr	r3, [r3, #0]
24011818:	681a      	ldr	r2, [r3, #0]
2401181a:	687b      	ldr	r3, [r7, #4]
2401181c:	681b      	ldr	r3, [r3, #0]
2401181e:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
24011822:	601a      	str	r2, [r3, #0]

    /* Transfer complete callback */
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011824:	687b      	ldr	r3, [r7, #4]
24011826:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401182a:	b2db      	uxtb	r3, r3
2401182c:	2b12      	cmp	r3, #18
2401182e:	d120      	bne.n	24011872 <HAL_QSPI_IRQHandler+0x16a>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011830:	687b      	ldr	r3, [r7, #4]
24011832:	681b      	ldr	r3, [r3, #0]
24011834:	681b      	ldr	r3, [r3, #0]
24011836:	f003 0304 	and.w	r3, r3, #4
2401183a:	2b00      	cmp	r3, #0
2401183c:	d011      	beq.n	24011862 <HAL_QSPI_IRQHandler+0x15a>
      {
        /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
           but no impact on H7 HW and it minimize the cost in the footprint */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401183e:	687b      	ldr	r3, [r7, #4]
24011840:	681b      	ldr	r3, [r3, #0]
24011842:	681a      	ldr	r2, [r3, #0]
24011844:	687b      	ldr	r3, [r7, #4]
24011846:	681b      	ldr	r3, [r3, #0]
24011848:	f022 0204 	bic.w	r2, r2, #4
2401184c:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
2401184e:	687b      	ldr	r3, [r7, #4]
24011850:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011852:	681b      	ldr	r3, [r3, #0]
24011854:	68da      	ldr	r2, [r3, #12]
24011856:	687b      	ldr	r3, [r7, #4]
24011858:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401185a:	681b      	ldr	r3, [r3, #0]
2401185c:	f022 0201 	bic.w	r2, r2, #1
24011860:	60da      	str	r2, [r3, #12]
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011862:	687b      	ldr	r3, [r7, #4]
24011864:	2201      	movs	r2, #1
24011866:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* TX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->TxCpltCallback(hqspi);
#else
      HAL_QSPI_TxCpltCallback(hqspi);
2401186a:	6878      	ldr	r0, [r7, #4]
2401186c:	f000 ff29 	bl	240126c2 <HAL_QSPI_TxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011870:	e0fa      	b.n	24011a68 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_RX)
24011872:	687b      	ldr	r3, [r7, #4]
24011874:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011878:	b2db      	uxtb	r3, r3
2401187a:	2b22      	cmp	r3, #34	; 0x22
2401187c:	d143      	bne.n	24011906 <HAL_QSPI_IRQHandler+0x1fe>
    {
      if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
2401187e:	687b      	ldr	r3, [r7, #4]
24011880:	681b      	ldr	r3, [r3, #0]
24011882:	681b      	ldr	r3, [r3, #0]
24011884:	f003 0304 	and.w	r3, r3, #4
24011888:	2b00      	cmp	r3, #0
2401188a:	d012      	beq.n	240118b2 <HAL_QSPI_IRQHandler+0x1aa>
      {
        /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
           but no impact on H7 HW and it minimize the cost in the footprint */
        CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401188c:	687b      	ldr	r3, [r7, #4]
2401188e:	681b      	ldr	r3, [r3, #0]
24011890:	681a      	ldr	r2, [r3, #0]
24011892:	687b      	ldr	r3, [r7, #4]
24011894:	681b      	ldr	r3, [r3, #0]
24011896:	f022 0204 	bic.w	r2, r2, #4
2401189a:	601a      	str	r2, [r3, #0]

        /* Disable the MDMA channel */
        __HAL_MDMA_DISABLE(hqspi->hmdma);
2401189c:	687b      	ldr	r3, [r7, #4]
2401189e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240118a0:	681b      	ldr	r3, [r3, #0]
240118a2:	68da      	ldr	r2, [r3, #12]
240118a4:	687b      	ldr	r3, [r7, #4]
240118a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240118a8:	681b      	ldr	r3, [r3, #0]
240118aa:	f022 0201 	bic.w	r2, r2, #1
240118ae:	60da      	str	r2, [r3, #12]
240118b0:	e021      	b.n	240118f6 <HAL_QSPI_IRQHandler+0x1ee>
      }
      else
      {
        data_reg = &hqspi->Instance->DR;
240118b2:	687b      	ldr	r3, [r7, #4]
240118b4:	681b      	ldr	r3, [r3, #0]
240118b6:	3320      	adds	r3, #32
240118b8:	60fb      	str	r3, [r7, #12]
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
240118ba:	e013      	b.n	240118e4 <HAL_QSPI_IRQHandler+0x1dc>
        {
          if (hqspi->RxXferCount > 0U)
240118bc:	687b      	ldr	r3, [r7, #4]
240118be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240118c0:	2b00      	cmp	r3, #0
240118c2:	d017      	beq.n	240118f4 <HAL_QSPI_IRQHandler+0x1ec>
          {
            /* Read the last data received in the FIFO until it is empty */
            *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
240118c4:	687b      	ldr	r3, [r7, #4]
240118c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240118c8:	68fa      	ldr	r2, [r7, #12]
240118ca:	7812      	ldrb	r2, [r2, #0]
240118cc:	b2d2      	uxtb	r2, r2
240118ce:	701a      	strb	r2, [r3, #0]
            hqspi->pRxBuffPtr++;
240118d0:	687b      	ldr	r3, [r7, #4]
240118d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240118d4:	1c5a      	adds	r2, r3, #1
240118d6:	687b      	ldr	r3, [r7, #4]
240118d8:	631a      	str	r2, [r3, #48]	; 0x30
            hqspi->RxXferCount--;
240118da:	687b      	ldr	r3, [r7, #4]
240118dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240118de:	1e5a      	subs	r2, r3, #1
240118e0:	687b      	ldr	r3, [r7, #4]
240118e2:	639a      	str	r2, [r3, #56]	; 0x38
        while(READ_BIT(hqspi->Instance->SR, QUADSPI_SR_FLEVEL) != 0U)
240118e4:	687b      	ldr	r3, [r7, #4]
240118e6:	681b      	ldr	r3, [r3, #0]
240118e8:	689b      	ldr	r3, [r3, #8]
240118ea:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
240118ee:	2b00      	cmp	r3, #0
240118f0:	d1e4      	bne.n	240118bc <HAL_QSPI_IRQHandler+0x1b4>
240118f2:	e000      	b.n	240118f6 <HAL_QSPI_IRQHandler+0x1ee>
          }
          else
          {
            /* All data have been received for the transfer */
            break;
240118f4:	bf00      	nop
        }
      }


      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
240118f6:	687b      	ldr	r3, [r7, #4]
240118f8:	2201      	movs	r2, #1
240118fa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* RX Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->RxCpltCallback(hqspi);
#else
      HAL_QSPI_RxCpltCallback(hqspi);
240118fe:	6878      	ldr	r0, [r7, #4]
24011900:	f000 fed5 	bl	240126ae <HAL_QSPI_RxCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011904:	e0b0      	b.n	24011a68 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_BUSY)
24011906:	687b      	ldr	r3, [r7, #4]
24011908:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401190c:	b2db      	uxtb	r3, r3
2401190e:	2b02      	cmp	r3, #2
24011910:	d107      	bne.n	24011922 <HAL_QSPI_IRQHandler+0x21a>
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011912:	687b      	ldr	r3, [r7, #4]
24011914:	2201      	movs	r2, #1
24011916:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Command Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->CmdCpltCallback(hqspi);
#else
      HAL_QSPI_CmdCpltCallback(hqspi);
2401191a:	6878      	ldr	r0, [r7, #4]
2401191c:	f000 febd 	bl	2401269a <HAL_QSPI_CmdCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011920:	e0a2      	b.n	24011a68 <HAL_QSPI_IRQHandler+0x360>
#endif
    }
    else if(hqspi->State == HAL_QSPI_STATE_ABORT)
24011922:	687b      	ldr	r3, [r7, #4]
24011924:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011928:	b2db      	uxtb	r3, r3
2401192a:	2b08      	cmp	r3, #8
2401192c:	f040 809c 	bne.w	24011a68 <HAL_QSPI_IRQHandler+0x360>
    {
      /* Reset functional mode configuration to indirect write mode by default */
      CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
24011930:	687b      	ldr	r3, [r7, #4]
24011932:	681b      	ldr	r3, [r3, #0]
24011934:	695a      	ldr	r2, [r3, #20]
24011936:	687b      	ldr	r3, [r7, #4]
24011938:	681b      	ldr	r3, [r3, #0]
2401193a:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2401193e:	615a      	str	r2, [r3, #20]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011940:	687b      	ldr	r3, [r7, #4]
24011942:	2201      	movs	r2, #1
24011944:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      if (hqspi->ErrorCode == HAL_QSPI_ERROR_NONE)
24011948:	687b      	ldr	r3, [r7, #4]
2401194a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401194c:	2b00      	cmp	r3, #0
2401194e:	d103      	bne.n	24011958 <HAL_QSPI_IRQHandler+0x250>

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
24011950:	6878      	ldr	r0, [r7, #4]
24011952:	f000 fe98 	bl	24012686 <HAL_QSPI_AbortCpltCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011956:	e087      	b.n	24011a68 <HAL_QSPI_IRQHandler+0x360>

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24011958:	6878      	ldr	r0, [r7, #4]
2401195a:	f000 fe8a 	bl	24012672 <HAL_QSPI_ErrorCallback>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
2401195e:	e083      	b.n	24011a68 <HAL_QSPI_IRQHandler+0x360>
     /* Nothing to do */
    }
  }

  /* QSPI Status Match interrupt occurred ------------------------------------*/
  else if(((flag & QSPI_FLAG_SM) != 0U) && ((itsource & QSPI_IT_SM) != 0U))
24011960:	697b      	ldr	r3, [r7, #20]
24011962:	f003 0308 	and.w	r3, r3, #8
24011966:	2b00      	cmp	r3, #0
24011968:	d01f      	beq.n	240119aa <HAL_QSPI_IRQHandler+0x2a2>
2401196a:	693b      	ldr	r3, [r7, #16]
2401196c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24011970:	2b00      	cmp	r3, #0
24011972:	d01a      	beq.n	240119aa <HAL_QSPI_IRQHandler+0x2a2>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_SM);
24011974:	687b      	ldr	r3, [r7, #4]
24011976:	681b      	ldr	r3, [r3, #0]
24011978:	2208      	movs	r2, #8
2401197a:	60da      	str	r2, [r3, #12]

    /* Check if the automatic poll mode stop is activated */
    if(READ_BIT(hqspi->Instance->CR, QUADSPI_CR_APMS) != 0U)
2401197c:	687b      	ldr	r3, [r7, #4]
2401197e:	681b      	ldr	r3, [r3, #0]
24011980:	681b      	ldr	r3, [r3, #0]
24011982:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
24011986:	2b00      	cmp	r3, #0
24011988:	d00b      	beq.n	240119a2 <HAL_QSPI_IRQHandler+0x29a>
    {
      /* Disable the QSPI Transfer Error and Status Match Interrupts */
      __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
2401198a:	687b      	ldr	r3, [r7, #4]
2401198c:	681b      	ldr	r3, [r3, #0]
2401198e:	681a      	ldr	r2, [r3, #0]
24011990:	687b      	ldr	r3, [r7, #4]
24011992:	681b      	ldr	r3, [r3, #0]
24011994:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
24011998:	601a      	str	r2, [r3, #0]

      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
2401199a:	687b      	ldr	r3, [r7, #4]
2401199c:	2201      	movs	r2, #1
2401199e:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Status match callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->StatusMatchCallback(hqspi);
#else
    HAL_QSPI_StatusMatchCallback(hqspi);
240119a2:	6878      	ldr	r0, [r7, #4]
240119a4:	f000 fea1 	bl	240126ea <HAL_QSPI_StatusMatchCallback>
240119a8:	e061      	b.n	24011a6e <HAL_QSPI_IRQHandler+0x366>
#endif
  }

  /* QSPI Transfer Error interrupt occurred ----------------------------------*/
  else if(((flag & QSPI_FLAG_TE) != 0U) && ((itsource & QSPI_IT_TE) != 0U))
240119aa:	697b      	ldr	r3, [r7, #20]
240119ac:	f003 0301 	and.w	r3, r3, #1
240119b0:	2b00      	cmp	r3, #0
240119b2:	d047      	beq.n	24011a44 <HAL_QSPI_IRQHandler+0x33c>
240119b4:	693b      	ldr	r3, [r7, #16]
240119b6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240119ba:	2b00      	cmp	r3, #0
240119bc:	d042      	beq.n	24011a44 <HAL_QSPI_IRQHandler+0x33c>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TE);
240119be:	687b      	ldr	r3, [r7, #4]
240119c0:	681b      	ldr	r3, [r3, #0]
240119c2:	2201      	movs	r2, #1
240119c4:	60da      	str	r2, [r3, #12]

    /* Disable all the QSPI Interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, QSPI_IT_SM | QSPI_IT_TC | QSPI_IT_TE | QSPI_IT_FT);
240119c6:	687b      	ldr	r3, [r7, #4]
240119c8:	681b      	ldr	r3, [r3, #0]
240119ca:	681a      	ldr	r2, [r3, #0]
240119cc:	687b      	ldr	r3, [r7, #4]
240119ce:	681b      	ldr	r3, [r3, #0]
240119d0:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
240119d4:	601a      	str	r2, [r3, #0]

    /* Set error code */
    hqspi->ErrorCode |= HAL_QSPI_ERROR_TRANSFER;
240119d6:	687b      	ldr	r3, [r7, #4]
240119d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240119da:	f043 0202 	orr.w	r2, r3, #2
240119de:	687b      	ldr	r3, [r7, #4]
240119e0:	645a      	str	r2, [r3, #68]	; 0x44

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
240119e2:	687b      	ldr	r3, [r7, #4]
240119e4:	681b      	ldr	r3, [r3, #0]
240119e6:	681b      	ldr	r3, [r3, #0]
240119e8:	f003 0304 	and.w	r3, r3, #4
240119ec:	2b00      	cmp	r3, #0
240119ee:	d021      	beq.n	24011a34 <HAL_QSPI_IRQHandler+0x32c>
    {
      /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
         but no impact on H7 HW and it minimize the cost in the footprint */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
240119f0:	687b      	ldr	r3, [r7, #4]
240119f2:	681b      	ldr	r3, [r3, #0]
240119f4:	681a      	ldr	r2, [r3, #0]
240119f6:	687b      	ldr	r3, [r7, #4]
240119f8:	681b      	ldr	r3, [r3, #0]
240119fa:	f022 0204 	bic.w	r2, r2, #4
240119fe:	601a      	str	r2, [r3, #0]

      /* Disable the MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
24011a00:	687b      	ldr	r3, [r7, #4]
24011a02:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011a04:	4a1c      	ldr	r2, [pc, #112]	; (24011a78 <HAL_QSPI_IRQHandler+0x370>)
24011a06:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
24011a08:	687b      	ldr	r3, [r7, #4]
24011a0a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24011a0c:	4618      	mov	r0, r3
24011a0e:	f7fe fb34 	bl	2401007a <HAL_MDMA_Abort_IT>
24011a12:	4603      	mov	r3, r0
24011a14:	2b00      	cmp	r3, #0
24011a16:	d029      	beq.n	24011a6c <HAL_QSPI_IRQHandler+0x364>
      {
        /* Set error code to DMA */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24011a18:	687b      	ldr	r3, [r7, #4]
24011a1a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011a1c:	f043 0204 	orr.w	r2, r3, #4
24011a20:	687b      	ldr	r3, [r7, #4]
24011a22:	645a      	str	r2, [r3, #68]	; 0x44

        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
24011a24:	687b      	ldr	r3, [r7, #4]
24011a26:	2201      	movs	r2, #1
24011a28:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->ErrorCallback(hqspi);
#else
        HAL_QSPI_ErrorCallback(hqspi);
24011a2c:	6878      	ldr	r0, [r7, #4]
24011a2e:	f000 fe20 	bl	24012672 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011a32:	e01b      	b.n	24011a6c <HAL_QSPI_IRQHandler+0x364>
      }
    }
    else
    {
      /* Change state of QSPI */
      hqspi->State = HAL_QSPI_STATE_READY;
24011a34:	687b      	ldr	r3, [r7, #4]
24011a36:	2201      	movs	r2, #1
24011a38:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Error callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
      hqspi->ErrorCallback(hqspi);
#else
      HAL_QSPI_ErrorCallback(hqspi);
24011a3c:	6878      	ldr	r0, [r7, #4]
24011a3e:	f000 fe18 	bl	24012672 <HAL_QSPI_ErrorCallback>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011a42:	e013      	b.n	24011a6c <HAL_QSPI_IRQHandler+0x364>
#endif
    }
  }

  /* QSPI Timeout interrupt occurred -----------------------------------------*/
  else if(((flag & QSPI_FLAG_TO) != 0U) && ((itsource & QSPI_IT_TO) != 0U))
24011a44:	697b      	ldr	r3, [r7, #20]
24011a46:	f003 0310 	and.w	r3, r3, #16
24011a4a:	2b00      	cmp	r3, #0
24011a4c:	d00f      	beq.n	24011a6e <HAL_QSPI_IRQHandler+0x366>
24011a4e:	693b      	ldr	r3, [r7, #16]
24011a50:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
24011a54:	2b00      	cmp	r3, #0
24011a56:	d00a      	beq.n	24011a6e <HAL_QSPI_IRQHandler+0x366>
  {
    /* Clear interrupt */
    WRITE_REG(hqspi->Instance->FCR, QSPI_FLAG_TO);
24011a58:	687b      	ldr	r3, [r7, #4]
24011a5a:	681b      	ldr	r3, [r3, #0]
24011a5c:	2210      	movs	r2, #16
24011a5e:	60da      	str	r2, [r3, #12]

    /* Timeout callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
    hqspi->TimeOutCallback(hqspi);
#else
    HAL_QSPI_TimeOutCallback(hqspi);
24011a60:	6878      	ldr	r0, [r7, #4]
24011a62:	f000 fe4c 	bl	240126fe <HAL_QSPI_TimeOutCallback>

   else
  {
   /* Nothing to do */
  }
}
24011a66:	e002      	b.n	24011a6e <HAL_QSPI_IRQHandler+0x366>
    if(hqspi->State == HAL_QSPI_STATE_BUSY_INDIRECT_TX)
24011a68:	bf00      	nop
24011a6a:	e000      	b.n	24011a6e <HAL_QSPI_IRQHandler+0x366>
    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24011a6c:	bf00      	nop
}
24011a6e:	bf00      	nop
24011a70:	3718      	adds	r7, #24
24011a72:	46bd      	mov	sp, r7
24011a74:	bd80      	pop	{r7, pc}
24011a76:	bf00      	nop
24011a78:	24012ac1 	.word	0x24012ac1

24011a7c <HAL_QSPI_Command>:
  * @param Timeout Timeout duration
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t Timeout)
{
24011a7c:	b580      	push	{r7, lr}
24011a7e:	b088      	sub	sp, #32
24011a80:	af02      	add	r7, sp, #8
24011a82:	60f8      	str	r0, [r7, #12]
24011a84:	60b9      	str	r1, [r7, #8]
24011a86:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
24011a88:	f7f0 fc5c 	bl	24002344 <HAL_GetTick>
24011a8c:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24011a8e:	68fb      	ldr	r3, [r7, #12]
24011a90:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011a94:	b2db      	uxtb	r3, r3
24011a96:	2b01      	cmp	r3, #1
24011a98:	d101      	bne.n	24011a9e <HAL_QSPI_Command+0x22>
24011a9a:	2302      	movs	r3, #2
24011a9c:	e048      	b.n	24011b30 <HAL_QSPI_Command+0xb4>
24011a9e:	68fb      	ldr	r3, [r7, #12]
24011aa0:	2201      	movs	r2, #1
24011aa2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011aa6:	68fb      	ldr	r3, [r7, #12]
24011aa8:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011aac:	b2db      	uxtb	r3, r3
24011aae:	2b01      	cmp	r3, #1
24011ab0:	d137      	bne.n	24011b22 <HAL_QSPI_Command+0xa6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011ab2:	68fb      	ldr	r3, [r7, #12]
24011ab4:	2200      	movs	r2, #0
24011ab6:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
24011ab8:	68fb      	ldr	r3, [r7, #12]
24011aba:	2202      	movs	r2, #2
24011abc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
24011ac0:	687b      	ldr	r3, [r7, #4]
24011ac2:	9300      	str	r3, [sp, #0]
24011ac4:	693b      	ldr	r3, [r7, #16]
24011ac6:	2200      	movs	r2, #0
24011ac8:	2120      	movs	r1, #32
24011aca:	68f8      	ldr	r0, [r7, #12]
24011acc:	f001 f82b 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011ad0:	4603      	mov	r3, r0
24011ad2:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24011ad4:	7dfb      	ldrb	r3, [r7, #23]
24011ad6:	2b00      	cmp	r3, #0
24011ad8:	d125      	bne.n	24011b26 <HAL_QSPI_Command+0xaa>
    {
      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24011ada:	2200      	movs	r2, #0
24011adc:	68b9      	ldr	r1, [r7, #8]
24011ade:	68f8      	ldr	r0, [r7, #12]
24011ae0:	f001 f858 	bl	24012b94 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
24011ae4:	68bb      	ldr	r3, [r7, #8]
24011ae6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011ae8:	2b00      	cmp	r3, #0
24011aea:	d115      	bne.n	24011b18 <HAL_QSPI_Command+0x9c>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24011aec:	687b      	ldr	r3, [r7, #4]
24011aee:	9300      	str	r3, [sp, #0]
24011af0:	693b      	ldr	r3, [r7, #16]
24011af2:	2201      	movs	r2, #1
24011af4:	2102      	movs	r1, #2
24011af6:	68f8      	ldr	r0, [r7, #12]
24011af8:	f001 f815 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011afc:	4603      	mov	r3, r0
24011afe:	75fb      	strb	r3, [r7, #23]

        if (status == HAL_OK)
24011b00:	7dfb      	ldrb	r3, [r7, #23]
24011b02:	2b00      	cmp	r3, #0
24011b04:	d10f      	bne.n	24011b26 <HAL_QSPI_Command+0xaa>
        {
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24011b06:	68fb      	ldr	r3, [r7, #12]
24011b08:	681b      	ldr	r3, [r3, #0]
24011b0a:	2202      	movs	r2, #2
24011b0c:	60da      	str	r2, [r3, #12]

          /* Update QSPI state */
          hqspi->State = HAL_QSPI_STATE_READY;
24011b0e:	68fb      	ldr	r3, [r7, #12]
24011b10:	2201      	movs	r2, #1
24011b12:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24011b16:	e006      	b.n	24011b26 <HAL_QSPI_Command+0xaa>
        }
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
24011b18:	68fb      	ldr	r3, [r7, #12]
24011b1a:	2201      	movs	r2, #1
24011b1c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24011b20:	e001      	b.n	24011b26 <HAL_QSPI_Command+0xaa>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
24011b22:	2302      	movs	r3, #2
24011b24:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24011b26:	68fb      	ldr	r3, [r7, #12]
24011b28:	2200      	movs	r2, #0
24011b2a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24011b2e:	7dfb      	ldrb	r3, [r7, #23]
}
24011b30:	4618      	mov	r0, r3
24011b32:	3718      	adds	r7, #24
24011b34:	46bd      	mov	sp, r7
24011b36:	bd80      	pop	{r7, pc}

24011b38 <HAL_QSPI_Command_IT>:
  * @param cmd structure that contains the command configuration information
  * @note   This function is used only in Indirect Read or Write Modes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Command_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd)
{
24011b38:	b580      	push	{r7, lr}
24011b3a:	b086      	sub	sp, #24
24011b3c:	af02      	add	r7, sp, #8
24011b3e:	6078      	str	r0, [r7, #4]
24011b40:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
24011b42:	f7f0 fbff 	bl	24002344 <HAL_GetTick>
24011b46:	60b8      	str	r0, [r7, #8]
  assert_param(IS_QSPI_DDR_MODE(cmd->DdrMode));
  assert_param(IS_QSPI_DDR_HHC(cmd->DdrHoldHalfCycle));
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
24011b48:	687b      	ldr	r3, [r7, #4]
24011b4a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011b4e:	b2db      	uxtb	r3, r3
24011b50:	2b01      	cmp	r3, #1
24011b52:	d101      	bne.n	24011b58 <HAL_QSPI_Command_IT+0x20>
24011b54:	2302      	movs	r3, #2
24011b56:	e051      	b.n	24011bfc <HAL_QSPI_Command_IT+0xc4>
24011b58:	687b      	ldr	r3, [r7, #4]
24011b5a:	2201      	movs	r2, #1
24011b5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011b60:	687b      	ldr	r3, [r7, #4]
24011b62:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011b66:	b2db      	uxtb	r3, r3
24011b68:	2b01      	cmp	r3, #1
24011b6a:	d140      	bne.n	24011bee <HAL_QSPI_Command_IT+0xb6>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011b6c:	687b      	ldr	r3, [r7, #4]
24011b6e:	2200      	movs	r2, #0
24011b70:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_BUSY;
24011b72:	687b      	ldr	r3, [r7, #4]
24011b74:	2202      	movs	r2, #2
24011b76:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24011b7a:	687b      	ldr	r3, [r7, #4]
24011b7c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24011b7e:	9300      	str	r3, [sp, #0]
24011b80:	68bb      	ldr	r3, [r7, #8]
24011b82:	2200      	movs	r2, #0
24011b84:	2120      	movs	r1, #32
24011b86:	6878      	ldr	r0, [r7, #4]
24011b88:	f000 ffcd 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011b8c:	4603      	mov	r3, r0
24011b8e:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
24011b90:	7bfb      	ldrb	r3, [r7, #15]
24011b92:	2b00      	cmp	r3, #0
24011b94:	d126      	bne.n	24011be4 <HAL_QSPI_Command_IT+0xac>
    {
      if (cmd->DataMode == QSPI_DATA_NONE)
24011b96:	683b      	ldr	r3, [r7, #0]
24011b98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011b9a:	2b00      	cmp	r3, #0
24011b9c:	d103      	bne.n	24011ba6 <HAL_QSPI_Command_IT+0x6e>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24011b9e:	687b      	ldr	r3, [r7, #4]
24011ba0:	681b      	ldr	r3, [r3, #0]
24011ba2:	2203      	movs	r2, #3
24011ba4:	60da      	str	r2, [r3, #12]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24011ba6:	2200      	movs	r2, #0
24011ba8:	6839      	ldr	r1, [r7, #0]
24011baa:	6878      	ldr	r0, [r7, #4]
24011bac:	f000 fff2 	bl	24012b94 <QSPI_Config>

      if (cmd->DataMode == QSPI_DATA_NONE)
24011bb0:	683b      	ldr	r3, [r7, #0]
24011bb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011bb4:	2b00      	cmp	r3, #0
24011bb6:	d10c      	bne.n	24011bd2 <HAL_QSPI_Command_IT+0x9a>
      {
        /* When there is no data phase, the transfer start as soon as the configuration is done
        so activate TC and TE interrupts */
        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
24011bb8:	687b      	ldr	r3, [r7, #4]
24011bba:	2200      	movs	r2, #0
24011bbc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        /* Enable the QSPI Transfer Error Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_TC);
24011bc0:	687b      	ldr	r3, [r7, #4]
24011bc2:	681b      	ldr	r3, [r3, #0]
24011bc4:	681a      	ldr	r2, [r3, #0]
24011bc6:	687b      	ldr	r3, [r7, #4]
24011bc8:	681b      	ldr	r3, [r3, #0]
24011bca:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
24011bce:	601a      	str	r2, [r3, #0]
24011bd0:	e013      	b.n	24011bfa <HAL_QSPI_Command_IT+0xc2>
      }
      else
      {
        /* Update QSPI state */
        hqspi->State = HAL_QSPI_STATE_READY;
24011bd2:	687b      	ldr	r3, [r7, #4]
24011bd4:	2201      	movs	r2, #1
24011bd6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Process unlocked */
        __HAL_UNLOCK(hqspi);
24011bda:	687b      	ldr	r3, [r7, #4]
24011bdc:	2200      	movs	r2, #0
24011bde:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011be2:	e00a      	b.n	24011bfa <HAL_QSPI_Command_IT+0xc2>
      }
    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011be4:	687b      	ldr	r3, [r7, #4]
24011be6:	2200      	movs	r2, #0
24011be8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011bec:	e005      	b.n	24011bfa <HAL_QSPI_Command_IT+0xc2>
    }
  }
  else
  {
    status = HAL_BUSY;
24011bee:	2302      	movs	r3, #2
24011bf0:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24011bf2:	687b      	ldr	r3, [r7, #4]
24011bf4:	2200      	movs	r2, #0
24011bf6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
24011bfa:	7bfb      	ldrb	r3, [r7, #15]
}
24011bfc:	4618      	mov	r0, r3
24011bfe:	3710      	adds	r7, #16
24011c00:	46bd      	mov	sp, r7
24011c02:	bd80      	pop	{r7, pc}

24011c04 <HAL_QSPI_Transmit>:
  * @param Timeout Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
24011c04:	b580      	push	{r7, lr}
24011c06:	b08a      	sub	sp, #40	; 0x28
24011c08:	af02      	add	r7, sp, #8
24011c0a:	60f8      	str	r0, [r7, #12]
24011c0c:	60b9      	str	r1, [r7, #8]
24011c0e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24011c10:	2300      	movs	r3, #0
24011c12:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
24011c14:	f7f0 fb96 	bl	24002344 <HAL_GetTick>
24011c18:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24011c1a:	68fb      	ldr	r3, [r7, #12]
24011c1c:	681b      	ldr	r3, [r3, #0]
24011c1e:	3320      	adds	r3, #32
24011c20:	617b      	str	r3, [r7, #20]

  /* Process locked */
  __HAL_LOCK(hqspi);
24011c22:	68fb      	ldr	r3, [r7, #12]
24011c24:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011c28:	b2db      	uxtb	r3, r3
24011c2a:	2b01      	cmp	r3, #1
24011c2c:	d101      	bne.n	24011c32 <HAL_QSPI_Transmit+0x2e>
24011c2e:	2302      	movs	r3, #2
24011c30:	e076      	b.n	24011d20 <HAL_QSPI_Transmit+0x11c>
24011c32:	68fb      	ldr	r3, [r7, #12]
24011c34:	2201      	movs	r2, #1
24011c36:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011c3a:	68fb      	ldr	r3, [r7, #12]
24011c3c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011c40:	b2db      	uxtb	r3, r3
24011c42:	2b01      	cmp	r3, #1
24011c44:	d165      	bne.n	24011d12 <HAL_QSPI_Transmit+0x10e>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011c46:	68fb      	ldr	r3, [r7, #12]
24011c48:	2200      	movs	r2, #0
24011c4a:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24011c4c:	68bb      	ldr	r3, [r7, #8]
24011c4e:	2b00      	cmp	r3, #0
24011c50:	d056      	beq.n	24011d00 <HAL_QSPI_Transmit+0xfc>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24011c52:	68fb      	ldr	r3, [r7, #12]
24011c54:	2212      	movs	r2, #18
24011c56:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24011c5a:	68fb      	ldr	r3, [r7, #12]
24011c5c:	681b      	ldr	r3, [r3, #0]
24011c5e:	691b      	ldr	r3, [r3, #16]
24011c60:	1c5a      	adds	r2, r3, #1
24011c62:	68fb      	ldr	r3, [r7, #12]
24011c64:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24011c66:	68fb      	ldr	r3, [r7, #12]
24011c68:	681b      	ldr	r3, [r3, #0]
24011c6a:	691b      	ldr	r3, [r3, #16]
24011c6c:	1c5a      	adds	r2, r3, #1
24011c6e:	68fb      	ldr	r3, [r7, #12]
24011c70:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
24011c72:	68fb      	ldr	r3, [r7, #12]
24011c74:	68ba      	ldr	r2, [r7, #8]
24011c76:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24011c78:	68fb      	ldr	r3, [r7, #12]
24011c7a:	681b      	ldr	r3, [r3, #0]
24011c7c:	695a      	ldr	r2, [r3, #20]
24011c7e:	68fb      	ldr	r3, [r7, #12]
24011c80:	681b      	ldr	r3, [r3, #0]
24011c82:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24011c86:	615a      	str	r2, [r3, #20]

      while(hqspi->TxXferCount > 0U)
24011c88:	e01b      	b.n	24011cc2 <HAL_QSPI_Transmit+0xbe>
      {
        /* Wait until FT flag is set to send data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
24011c8a:	687b      	ldr	r3, [r7, #4]
24011c8c:	9300      	str	r3, [sp, #0]
24011c8e:	69bb      	ldr	r3, [r7, #24]
24011c90:	2201      	movs	r2, #1
24011c92:	2104      	movs	r1, #4
24011c94:	68f8      	ldr	r0, [r7, #12]
24011c96:	f000 ff46 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011c9a:	4603      	mov	r3, r0
24011c9c:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
24011c9e:	7ffb      	ldrb	r3, [r7, #31]
24011ca0:	2b00      	cmp	r3, #0
24011ca2:	d113      	bne.n	24011ccc <HAL_QSPI_Transmit+0xc8>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
24011ca4:	68fb      	ldr	r3, [r7, #12]
24011ca6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011ca8:	781a      	ldrb	r2, [r3, #0]
24011caa:	697b      	ldr	r3, [r7, #20]
24011cac:	701a      	strb	r2, [r3, #0]
        hqspi->pTxBuffPtr++;
24011cae:	68fb      	ldr	r3, [r7, #12]
24011cb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24011cb2:	1c5a      	adds	r2, r3, #1
24011cb4:	68fb      	ldr	r3, [r7, #12]
24011cb6:	625a      	str	r2, [r3, #36]	; 0x24
        hqspi->TxXferCount--;
24011cb8:	68fb      	ldr	r3, [r7, #12]
24011cba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24011cbc:	1e5a      	subs	r2, r3, #1
24011cbe:	68fb      	ldr	r3, [r7, #12]
24011cc0:	62da      	str	r2, [r3, #44]	; 0x2c
      while(hqspi->TxXferCount > 0U)
24011cc2:	68fb      	ldr	r3, [r7, #12]
24011cc4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24011cc6:	2b00      	cmp	r3, #0
24011cc8:	d1df      	bne.n	24011c8a <HAL_QSPI_Transmit+0x86>
24011cca:	e000      	b.n	24011cce <HAL_QSPI_Transmit+0xca>
          break;
24011ccc:	bf00      	nop
      }

      if (status == HAL_OK)
24011cce:	7ffb      	ldrb	r3, [r7, #31]
24011cd0:	2b00      	cmp	r3, #0
24011cd2:	d110      	bne.n	24011cf6 <HAL_QSPI_Transmit+0xf2>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24011cd4:	687b      	ldr	r3, [r7, #4]
24011cd6:	9300      	str	r3, [sp, #0]
24011cd8:	69bb      	ldr	r3, [r7, #24]
24011cda:	2201      	movs	r2, #1
24011cdc:	2102      	movs	r1, #2
24011cde:	68f8      	ldr	r0, [r7, #12]
24011ce0:	f000 ff21 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011ce4:	4603      	mov	r3, r0
24011ce6:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
24011ce8:	7ffb      	ldrb	r3, [r7, #31]
24011cea:	2b00      	cmp	r3, #0
24011cec:	d103      	bne.n	24011cf6 <HAL_QSPI_Transmit+0xf2>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24011cee:	68fb      	ldr	r3, [r7, #12]
24011cf0:	681b      	ldr	r3, [r3, #0]
24011cf2:	2202      	movs	r2, #2
24011cf4:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
24011cf6:	68fb      	ldr	r3, [r7, #12]
24011cf8:	2201      	movs	r2, #1
24011cfa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24011cfe:	e00a      	b.n	24011d16 <HAL_QSPI_Transmit+0x112>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24011d00:	68fb      	ldr	r3, [r7, #12]
24011d02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011d04:	f043 0208 	orr.w	r2, r3, #8
24011d08:	68fb      	ldr	r3, [r7, #12]
24011d0a:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24011d0c:	2301      	movs	r3, #1
24011d0e:	77fb      	strb	r3, [r7, #31]
24011d10:	e001      	b.n	24011d16 <HAL_QSPI_Transmit+0x112>
    }
  }
  else
  {
    status = HAL_BUSY;
24011d12:	2302      	movs	r3, #2
24011d14:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24011d16:	68fb      	ldr	r3, [r7, #12]
24011d18:	2200      	movs	r2, #0
24011d1a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
24011d1e:	7ffb      	ldrb	r3, [r7, #31]
}
24011d20:	4618      	mov	r0, r3
24011d22:	3720      	adds	r7, #32
24011d24:	46bd      	mov	sp, r7
24011d26:	bd80      	pop	{r7, pc}

24011d28 <HAL_QSPI_Receive>:
  * @param Timeout Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive(QSPI_HandleTypeDef *hqspi, uint8_t *pData, uint32_t Timeout)
{
24011d28:	b580      	push	{r7, lr}
24011d2a:	b08a      	sub	sp, #40	; 0x28
24011d2c:	af02      	add	r7, sp, #8
24011d2e:	60f8      	str	r0, [r7, #12]
24011d30:	60b9      	str	r1, [r7, #8]
24011d32:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24011d34:	2300      	movs	r3, #0
24011d36:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart = HAL_GetTick();
24011d38:	f7f0 fb04 	bl	24002344 <HAL_GetTick>
24011d3c:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24011d3e:	68fb      	ldr	r3, [r7, #12]
24011d40:	681b      	ldr	r3, [r3, #0]
24011d42:	699b      	ldr	r3, [r3, #24]
24011d44:	617b      	str	r3, [r7, #20]
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
24011d46:	68fb      	ldr	r3, [r7, #12]
24011d48:	681b      	ldr	r3, [r3, #0]
24011d4a:	3320      	adds	r3, #32
24011d4c:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hqspi);
24011d4e:	68fb      	ldr	r3, [r7, #12]
24011d50:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011d54:	b2db      	uxtb	r3, r3
24011d56:	2b01      	cmp	r3, #1
24011d58:	d101      	bne.n	24011d5e <HAL_QSPI_Receive+0x36>
24011d5a:	2302      	movs	r3, #2
24011d5c:	e07d      	b.n	24011e5a <HAL_QSPI_Receive+0x132>
24011d5e:	68fb      	ldr	r3, [r7, #12]
24011d60:	2201      	movs	r2, #1
24011d62:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011d66:	68fb      	ldr	r3, [r7, #12]
24011d68:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011d6c:	b2db      	uxtb	r3, r3
24011d6e:	2b01      	cmp	r3, #1
24011d70:	d16c      	bne.n	24011e4c <HAL_QSPI_Receive+0x124>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011d72:	68fb      	ldr	r3, [r7, #12]
24011d74:	2200      	movs	r2, #0
24011d76:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24011d78:	68bb      	ldr	r3, [r7, #8]
24011d7a:	2b00      	cmp	r3, #0
24011d7c:	d05d      	beq.n	24011e3a <HAL_QSPI_Receive+0x112>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24011d7e:	68fb      	ldr	r3, [r7, #12]
24011d80:	2222      	movs	r2, #34	; 0x22
24011d82:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24011d86:	68fb      	ldr	r3, [r7, #12]
24011d88:	681b      	ldr	r3, [r3, #0]
24011d8a:	691b      	ldr	r3, [r3, #16]
24011d8c:	1c5a      	adds	r2, r3, #1
24011d8e:	68fb      	ldr	r3, [r7, #12]
24011d90:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24011d92:	68fb      	ldr	r3, [r7, #12]
24011d94:	681b      	ldr	r3, [r3, #0]
24011d96:	691b      	ldr	r3, [r3, #16]
24011d98:	1c5a      	adds	r2, r3, #1
24011d9a:	68fb      	ldr	r3, [r7, #12]
24011d9c:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
24011d9e:	68fb      	ldr	r3, [r7, #12]
24011da0:	68ba      	ldr	r2, [r7, #8]
24011da2:	631a      	str	r2, [r3, #48]	; 0x30

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24011da4:	68fb      	ldr	r3, [r7, #12]
24011da6:	681b      	ldr	r3, [r3, #0]
24011da8:	695b      	ldr	r3, [r3, #20]
24011daa:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24011dae:	68fb      	ldr	r3, [r7, #12]
24011db0:	681b      	ldr	r3, [r3, #0]
24011db2:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24011db6:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24011db8:	68fb      	ldr	r3, [r7, #12]
24011dba:	681b      	ldr	r3, [r3, #0]
24011dbc:	697a      	ldr	r2, [r7, #20]
24011dbe:	619a      	str	r2, [r3, #24]

      while(hqspi->RxXferCount > 0U)
24011dc0:	e01c      	b.n	24011dfc <HAL_QSPI_Receive+0xd4>
      {
        /* Wait until FT or TC flag is set to read received data */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
24011dc2:	687b      	ldr	r3, [r7, #4]
24011dc4:	9300      	str	r3, [sp, #0]
24011dc6:	69bb      	ldr	r3, [r7, #24]
24011dc8:	2201      	movs	r2, #1
24011dca:	2106      	movs	r1, #6
24011dcc:	68f8      	ldr	r0, [r7, #12]
24011dce:	f000 feaa 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011dd2:	4603      	mov	r3, r0
24011dd4:	77fb      	strb	r3, [r7, #31]

        if  (status != HAL_OK)
24011dd6:	7ffb      	ldrb	r3, [r7, #31]
24011dd8:	2b00      	cmp	r3, #0
24011dda:	d114      	bne.n	24011e06 <HAL_QSPI_Receive+0xde>
        {
          break;
        }

        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
24011ddc:	68fb      	ldr	r3, [r7, #12]
24011dde:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011de0:	693a      	ldr	r2, [r7, #16]
24011de2:	7812      	ldrb	r2, [r2, #0]
24011de4:	b2d2      	uxtb	r2, r2
24011de6:	701a      	strb	r2, [r3, #0]
        hqspi->pRxBuffPtr++;
24011de8:	68fb      	ldr	r3, [r7, #12]
24011dea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24011dec:	1c5a      	adds	r2, r3, #1
24011dee:	68fb      	ldr	r3, [r7, #12]
24011df0:	631a      	str	r2, [r3, #48]	; 0x30
        hqspi->RxXferCount--;
24011df2:	68fb      	ldr	r3, [r7, #12]
24011df4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24011df6:	1e5a      	subs	r2, r3, #1
24011df8:	68fb      	ldr	r3, [r7, #12]
24011dfa:	639a      	str	r2, [r3, #56]	; 0x38
      while(hqspi->RxXferCount > 0U)
24011dfc:	68fb      	ldr	r3, [r7, #12]
24011dfe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24011e00:	2b00      	cmp	r3, #0
24011e02:	d1de      	bne.n	24011dc2 <HAL_QSPI_Receive+0x9a>
24011e04:	e000      	b.n	24011e08 <HAL_QSPI_Receive+0xe0>
          break;
24011e06:	bf00      	nop
      }

      if (status == HAL_OK)
24011e08:	7ffb      	ldrb	r3, [r7, #31]
24011e0a:	2b00      	cmp	r3, #0
24011e0c:	d110      	bne.n	24011e30 <HAL_QSPI_Receive+0x108>
      {
        /* Wait until TC flag is set to go back in idle state */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
24011e0e:	687b      	ldr	r3, [r7, #4]
24011e10:	9300      	str	r3, [sp, #0]
24011e12:	69bb      	ldr	r3, [r7, #24]
24011e14:	2201      	movs	r2, #1
24011e16:	2102      	movs	r1, #2
24011e18:	68f8      	ldr	r0, [r7, #12]
24011e1a:	f000 fe84 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24011e1e:	4603      	mov	r3, r0
24011e20:	77fb      	strb	r3, [r7, #31]

        if  (status == HAL_OK)
24011e22:	7ffb      	ldrb	r3, [r7, #31]
24011e24:	2b00      	cmp	r3, #0
24011e26:	d103      	bne.n	24011e30 <HAL_QSPI_Receive+0x108>
        {
          /* Clear Transfer Complete bit */
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24011e28:	68fb      	ldr	r3, [r7, #12]
24011e2a:	681b      	ldr	r3, [r3, #0]
24011e2c:	2202      	movs	r2, #2
24011e2e:	60da      	str	r2, [r3, #12]

        }
      }

      /* Update QSPI state */
      hqspi->State = HAL_QSPI_STATE_READY;
24011e30:	68fb      	ldr	r3, [r7, #12]
24011e32:	2201      	movs	r2, #1
24011e34:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24011e38:	e00a      	b.n	24011e50 <HAL_QSPI_Receive+0x128>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24011e3a:	68fb      	ldr	r3, [r7, #12]
24011e3c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011e3e:	f043 0208 	orr.w	r2, r3, #8
24011e42:	68fb      	ldr	r3, [r7, #12]
24011e44:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24011e46:	2301      	movs	r3, #1
24011e48:	77fb      	strb	r3, [r7, #31]
24011e4a:	e001      	b.n	24011e50 <HAL_QSPI_Receive+0x128>
    }
  }
  else
  {
    status = HAL_BUSY;
24011e4c:	2302      	movs	r3, #2
24011e4e:	77fb      	strb	r3, [r7, #31]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24011e50:	68fb      	ldr	r3, [r7, #12]
24011e52:	2200      	movs	r2, #0
24011e54:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return status;
24011e58:	7ffb      	ldrb	r3, [r7, #31]
}
24011e5a:	4618      	mov	r0, r3
24011e5c:	3720      	adds	r7, #32
24011e5e:	46bd      	mov	sp, r7
24011e60:	bd80      	pop	{r7, pc}

24011e62 <HAL_QSPI_Transmit_IT>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24011e62:	b480      	push	{r7}
24011e64:	b085      	sub	sp, #20
24011e66:	af00      	add	r7, sp, #0
24011e68:	6078      	str	r0, [r7, #4]
24011e6a:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24011e6c:	2300      	movs	r3, #0
24011e6e:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
24011e70:	687b      	ldr	r3, [r7, #4]
24011e72:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011e76:	b2db      	uxtb	r3, r3
24011e78:	2b01      	cmp	r3, #1
24011e7a:	d101      	bne.n	24011e80 <HAL_QSPI_Transmit_IT+0x1e>
24011e7c:	2302      	movs	r3, #2
24011e7e:	e04f      	b.n	24011f20 <HAL_QSPI_Transmit_IT+0xbe>
24011e80:	687b      	ldr	r3, [r7, #4]
24011e82:	2201      	movs	r2, #1
24011e84:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011e88:	687b      	ldr	r3, [r7, #4]
24011e8a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011e8e:	b2db      	uxtb	r3, r3
24011e90:	2b01      	cmp	r3, #1
24011e92:	d13e      	bne.n	24011f12 <HAL_QSPI_Transmit_IT+0xb0>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011e94:	687b      	ldr	r3, [r7, #4]
24011e96:	2200      	movs	r2, #0
24011e98:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24011e9a:	683b      	ldr	r3, [r7, #0]
24011e9c:	2b00      	cmp	r3, #0
24011e9e:	d02b      	beq.n	24011ef8 <HAL_QSPI_Transmit_IT+0x96>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
24011ea0:	687b      	ldr	r3, [r7, #4]
24011ea2:	2212      	movs	r2, #18
24011ea4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24011ea8:	687b      	ldr	r3, [r7, #4]
24011eaa:	681b      	ldr	r3, [r3, #0]
24011eac:	691b      	ldr	r3, [r3, #16]
24011eae:	1c5a      	adds	r2, r3, #1
24011eb0:	687b      	ldr	r3, [r7, #4]
24011eb2:	62da      	str	r2, [r3, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24011eb4:	687b      	ldr	r3, [r7, #4]
24011eb6:	681b      	ldr	r3, [r3, #0]
24011eb8:	691b      	ldr	r3, [r3, #16]
24011eba:	1c5a      	adds	r2, r3, #1
24011ebc:	687b      	ldr	r3, [r7, #4]
24011ebe:	629a      	str	r2, [r3, #40]	; 0x28
      hqspi->pTxBuffPtr = pData;
24011ec0:	687b      	ldr	r3, [r7, #4]
24011ec2:	683a      	ldr	r2, [r7, #0]
24011ec4:	625a      	str	r2, [r3, #36]	; 0x24

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24011ec6:	687b      	ldr	r3, [r7, #4]
24011ec8:	681b      	ldr	r3, [r3, #0]
24011eca:	2203      	movs	r2, #3
24011ecc:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect write */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
24011ece:	687b      	ldr	r3, [r7, #4]
24011ed0:	681b      	ldr	r3, [r3, #0]
24011ed2:	695a      	ldr	r2, [r3, #20]
24011ed4:	687b      	ldr	r3, [r7, #4]
24011ed6:	681b      	ldr	r3, [r3, #0]
24011ed8:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
24011edc:	615a      	str	r2, [r3, #20]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011ede:	687b      	ldr	r3, [r7, #4]
24011ee0:	2200      	movs	r2, #0
24011ee2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24011ee6:	687b      	ldr	r3, [r7, #4]
24011ee8:	681b      	ldr	r3, [r3, #0]
24011eea:	681a      	ldr	r2, [r3, #0]
24011eec:	687b      	ldr	r3, [r7, #4]
24011eee:	681b      	ldr	r3, [r3, #0]
24011ef0:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
24011ef4:	601a      	str	r2, [r3, #0]
24011ef6:	e012      	b.n	24011f1e <HAL_QSPI_Transmit_IT+0xbc>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24011ef8:	687b      	ldr	r3, [r7, #4]
24011efa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011efc:	f043 0208 	orr.w	r2, r3, #8
24011f00:	687b      	ldr	r3, [r7, #4]
24011f02:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24011f04:	2301      	movs	r3, #1
24011f06:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011f08:	687b      	ldr	r3, [r7, #4]
24011f0a:	2200      	movs	r2, #0
24011f0c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011f10:	e005      	b.n	24011f1e <HAL_QSPI_Transmit_IT+0xbc>
    }
  }
  else
  {
    status = HAL_BUSY;
24011f12:	2302      	movs	r3, #2
24011f14:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24011f16:	687b      	ldr	r3, [r7, #4]
24011f18:	2200      	movs	r2, #0
24011f1a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24011f1e:	7bfb      	ldrb	r3, [r7, #15]
}
24011f20:	4618      	mov	r0, r3
24011f22:	3714      	adds	r7, #20
24011f24:	46bd      	mov	sp, r7
24011f26:	f85d 7b04 	ldr.w	r7, [sp], #4
24011f2a:	4770      	bx	lr

24011f2c <HAL_QSPI_Receive_IT>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_IT(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
24011f2c:	b480      	push	{r7}
24011f2e:	b085      	sub	sp, #20
24011f30:	af00      	add	r7, sp, #0
24011f32:	6078      	str	r0, [r7, #4]
24011f34:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24011f36:	2300      	movs	r3, #0
24011f38:	73fb      	strb	r3, [r7, #15]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
24011f3a:	687b      	ldr	r3, [r7, #4]
24011f3c:	681b      	ldr	r3, [r3, #0]
24011f3e:	699b      	ldr	r3, [r3, #24]
24011f40:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
24011f42:	687b      	ldr	r3, [r7, #4]
24011f44:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24011f48:	b2db      	uxtb	r3, r3
24011f4a:	2b01      	cmp	r3, #1
24011f4c:	d101      	bne.n	24011f52 <HAL_QSPI_Receive_IT+0x26>
24011f4e:	2302      	movs	r3, #2
24011f50:	e055      	b.n	24011ffe <HAL_QSPI_Receive_IT+0xd2>
24011f52:	687b      	ldr	r3, [r7, #4]
24011f54:	2201      	movs	r2, #1
24011f56:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
24011f5a:	687b      	ldr	r3, [r7, #4]
24011f5c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24011f60:	b2db      	uxtb	r3, r3
24011f62:	2b01      	cmp	r3, #1
24011f64:	d144      	bne.n	24011ff0 <HAL_QSPI_Receive_IT+0xc4>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24011f66:	687b      	ldr	r3, [r7, #4]
24011f68:	2200      	movs	r2, #0
24011f6a:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24011f6c:	683b      	ldr	r3, [r7, #0]
24011f6e:	2b00      	cmp	r3, #0
24011f70:	d031      	beq.n	24011fd6 <HAL_QSPI_Receive_IT+0xaa>
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
24011f72:	687b      	ldr	r3, [r7, #4]
24011f74:	2222      	movs	r2, #34	; 0x22
24011f76:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

      /* Configure counters and size of the handle */
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
24011f7a:	687b      	ldr	r3, [r7, #4]
24011f7c:	681b      	ldr	r3, [r3, #0]
24011f7e:	691b      	ldr	r3, [r3, #16]
24011f80:	1c5a      	adds	r2, r3, #1
24011f82:	687b      	ldr	r3, [r7, #4]
24011f84:	639a      	str	r2, [r3, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
24011f86:	687b      	ldr	r3, [r7, #4]
24011f88:	681b      	ldr	r3, [r3, #0]
24011f8a:	691b      	ldr	r3, [r3, #16]
24011f8c:	1c5a      	adds	r2, r3, #1
24011f8e:	687b      	ldr	r3, [r7, #4]
24011f90:	635a      	str	r2, [r3, #52]	; 0x34
      hqspi->pRxBuffPtr = pData;
24011f92:	687b      	ldr	r3, [r7, #4]
24011f94:	683a      	ldr	r2, [r7, #0]
24011f96:	631a      	str	r2, [r3, #48]	; 0x30

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_TC);
24011f98:	687b      	ldr	r3, [r7, #4]
24011f9a:	681b      	ldr	r3, [r3, #0]
24011f9c:	2203      	movs	r2, #3
24011f9e:	60da      	str	r2, [r3, #12]

      /* Configure QSPI: CCR register with functional as indirect read */
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24011fa0:	687b      	ldr	r3, [r7, #4]
24011fa2:	681b      	ldr	r3, [r3, #0]
24011fa4:	695b      	ldr	r3, [r3, #20]
24011fa6:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24011faa:	687b      	ldr	r3, [r7, #4]
24011fac:	681b      	ldr	r3, [r3, #0]
24011fae:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24011fb2:	615a      	str	r2, [r3, #20]

      /* Start the transfer by re-writing the address in AR register */
      WRITE_REG(hqspi->Instance->AR, addr_reg);
24011fb4:	687b      	ldr	r3, [r7, #4]
24011fb6:	681b      	ldr	r3, [r3, #0]
24011fb8:	68ba      	ldr	r2, [r7, #8]
24011fba:	619a      	str	r2, [r3, #24]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011fbc:	687b      	ldr	r3, [r7, #4]
24011fbe:	2200      	movs	r2, #0
24011fc0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI transfer error, FIFO threshold and transfer complete Interrupts */
      __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE | QSPI_IT_FT | QSPI_IT_TC);
24011fc4:	687b      	ldr	r3, [r7, #4]
24011fc6:	681b      	ldr	r3, [r3, #0]
24011fc8:	681a      	ldr	r2, [r3, #0]
24011fca:	687b      	ldr	r3, [r7, #4]
24011fcc:	681b      	ldr	r3, [r3, #0]
24011fce:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
24011fd2:	601a      	str	r2, [r3, #0]
24011fd4:	e012      	b.n	24011ffc <HAL_QSPI_Receive_IT+0xd0>
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24011fd6:	687b      	ldr	r3, [r7, #4]
24011fd8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24011fda:	f043 0208 	orr.w	r2, r3, #8
24011fde:	687b      	ldr	r3, [r7, #4]
24011fe0:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
24011fe2:	2301      	movs	r3, #1
24011fe4:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24011fe6:	687b      	ldr	r3, [r7, #4]
24011fe8:	2200      	movs	r2, #0
24011fea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24011fee:	e005      	b.n	24011ffc <HAL_QSPI_Receive_IT+0xd0>
    }
  }
  else
  {
    status = HAL_BUSY;
24011ff0:	2302      	movs	r3, #2
24011ff2:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24011ff4:	687b      	ldr	r3, [r7, #4]
24011ff6:	2200      	movs	r2, #0
24011ff8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
24011ffc:	7bfb      	ldrb	r3, [r7, #15]
}
24011ffe:	4618      	mov	r0, r3
24012000:	3714      	adds	r7, #20
24012002:	46bd      	mov	sp, r7
24012004:	f85d 7b04 	ldr.w	r7, [sp], #4
24012008:	4770      	bx	lr
	...

2401200c <HAL_QSPI_Transmit_DMA>:
  * @param  pData pointer to data buffer
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Transmit_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
2401200c:	b590      	push	{r4, r7, lr}
2401200e:	b087      	sub	sp, #28
24012010:	af02      	add	r7, sp, #8
24012012:	6078      	str	r0, [r7, #4]
24012014:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
24012016:	2300      	movs	r3, #0
24012018:	73fb      	strb	r3, [r7, #15]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
2401201a:	687b      	ldr	r3, [r7, #4]
2401201c:	681b      	ldr	r3, [r3, #0]
2401201e:	691b      	ldr	r3, [r3, #16]
24012020:	3301      	adds	r3, #1
24012022:	60bb      	str	r3, [r7, #8]

  /* Process locked */
  __HAL_LOCK(hqspi);
24012024:	687b      	ldr	r3, [r7, #4]
24012026:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401202a:	b2db      	uxtb	r3, r3
2401202c:	2b01      	cmp	r3, #1
2401202e:	d101      	bne.n	24012034 <HAL_QSPI_Transmit_DMA+0x28>
24012030:	2302      	movs	r3, #2
24012032:	e0cb      	b.n	240121cc <HAL_QSPI_Transmit_DMA+0x1c0>
24012034:	687b      	ldr	r3, [r7, #4]
24012036:	2201      	movs	r2, #1
24012038:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401203c:	687b      	ldr	r3, [r7, #4]
2401203e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012042:	b2db      	uxtb	r3, r3
24012044:	2b01      	cmp	r3, #1
24012046:	f040 80ba 	bne.w	240121be <HAL_QSPI_Transmit_DMA+0x1b2>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2401204a:	687b      	ldr	r3, [r7, #4]
2401204c:	2200      	movs	r2, #0
2401204e:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24012050:	683b      	ldr	r3, [r7, #0]
24012052:	2b00      	cmp	r3, #0
24012054:	f000 80a6 	beq.w	240121a4 <HAL_QSPI_Transmit_DMA+0x198>
    {
      /* Configure counters of the handle */
      hqspi->TxXferCount = data_size;
24012058:	687b      	ldr	r3, [r7, #4]
2401205a:	68ba      	ldr	r2, [r7, #8]
2401205c:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
2401205e:	687b      	ldr	r3, [r7, #4]
24012060:	2212      	movs	r2, #18
24012062:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24012066:	687b      	ldr	r3, [r7, #4]
24012068:	681b      	ldr	r3, [r3, #0]
2401206a:	2203      	movs	r2, #3
2401206c:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->TxXferSize = hqspi->TxXferCount;
2401206e:	687b      	ldr	r3, [r7, #4]
24012070:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012072:	687b      	ldr	r3, [r7, #4]
24012074:	629a      	str	r2, [r3, #40]	; 0x28
        hqspi->pTxBuffPtr = pData;
24012076:	687b      	ldr	r3, [r7, #4]
24012078:	683a      	ldr	r2, [r7, #0]
2401207a:	625a      	str	r2, [r3, #36]	; 0x24

        /* Configure QSPI: CCR register with functional mode as indirect write */
        MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
2401207c:	687b      	ldr	r3, [r7, #4]
2401207e:	681b      	ldr	r3, [r3, #0]
24012080:	695a      	ldr	r2, [r3, #20]
24012082:	687b      	ldr	r3, [r7, #4]
24012084:	681b      	ldr	r3, [r3, #0]
24012086:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2401208a:	615a      	str	r2, [r3, #20]

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMATxCplt;
2401208c:	687b      	ldr	r3, [r7, #4]
2401208e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012090:	4a50      	ldr	r2, [pc, #320]	; (240121d4 <HAL_QSPI_Transmit_DMA+0x1c8>)
24012092:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24012094:	687b      	ldr	r3, [r7, #4]
24012096:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012098:	4a4f      	ldr	r2, [pc, #316]	; (240121d8 <HAL_QSPI_Transmit_DMA+0x1cc>)
2401209a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
2401209c:	687b      	ldr	r3, [r7, #4]
2401209e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240120a0:	2200      	movs	r2, #0
240120a2:	659a      	str	r2, [r3, #88]	; 0x58

        /* In Transmit mode , the MDMA destination is the QSPI DR register : Force the MDMA Destination Increment to disable */
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) ,MDMA_DEST_INC_DISABLE);
240120a4:	687b      	ldr	r3, [r7, #4]
240120a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240120a8:	681b      	ldr	r3, [r3, #0]
240120aa:	6919      	ldr	r1, [r3, #16]
240120ac:	687b      	ldr	r3, [r7, #4]
240120ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240120b0:	681a      	ldr	r2, [r3, #0]
240120b2:	4b4a      	ldr	r3, [pc, #296]	; (240121dc <HAL_QSPI_Transmit_DMA+0x1d0>)
240120b4:	400b      	ands	r3, r1
240120b6:	6113      	str	r3, [r2, #16]

        /* Update MDMA configuration with the correct SourceInc field for Write operation */
        if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_BYTE)
240120b8:	687b      	ldr	r3, [r7, #4]
240120ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240120bc:	69db      	ldr	r3, [r3, #28]
240120be:	2b00      	cmp	r3, #0
240120c0:	d10c      	bne.n	240120dc <HAL_QSPI_Transmit_DMA+0xd0>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_BYTE);
240120c2:	687b      	ldr	r3, [r7, #4]
240120c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240120c6:	681b      	ldr	r3, [r3, #0]
240120c8:	691a      	ldr	r2, [r3, #16]
240120ca:	4b45      	ldr	r3, [pc, #276]	; (240121e0 <HAL_QSPI_Transmit_DMA+0x1d4>)
240120cc:	4013      	ands	r3, r2
240120ce:	687a      	ldr	r2, [r7, #4]
240120d0:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
240120d2:	6812      	ldr	r2, [r2, #0]
240120d4:	f043 0302 	orr.w	r3, r3, #2
240120d8:	6113      	str	r3, [r2, #16]
240120da:	e02c      	b.n	24012136 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_HALFWORD)
240120dc:	687b      	ldr	r3, [r7, #4]
240120de:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240120e0:	69db      	ldr	r3, [r3, #28]
240120e2:	2b10      	cmp	r3, #16
240120e4:	d10c      	bne.n	24012100 <HAL_QSPI_Transmit_DMA+0xf4>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_HALFWORD);
240120e6:	687b      	ldr	r3, [r7, #4]
240120e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240120ea:	681b      	ldr	r3, [r3, #0]
240120ec:	691a      	ldr	r2, [r3, #16]
240120ee:	4b3c      	ldr	r3, [pc, #240]	; (240121e0 <HAL_QSPI_Transmit_DMA+0x1d4>)
240120f0:	4013      	ands	r3, r2
240120f2:	687a      	ldr	r2, [r7, #4]
240120f4:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
240120f6:	6812      	ldr	r2, [r2, #0]
240120f8:	f443 7381 	orr.w	r3, r3, #258	; 0x102
240120fc:	6113      	str	r3, [r2, #16]
240120fe:	e01a      	b.n	24012136 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else if (hqspi->hmdma->Init.SourceDataSize == MDMA_SRC_DATASIZE_WORD)
24012100:	687b      	ldr	r3, [r7, #4]
24012102:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012104:	69db      	ldr	r3, [r3, #28]
24012106:	2b20      	cmp	r3, #32
24012108:	d10d      	bne.n	24012126 <HAL_QSPI_Transmit_DMA+0x11a>
        {
          MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_WORD);
2401210a:	687b      	ldr	r3, [r7, #4]
2401210c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401210e:	681b      	ldr	r3, [r3, #0]
24012110:	691b      	ldr	r3, [r3, #16]
24012112:	4a33      	ldr	r2, [pc, #204]	; (240121e0 <HAL_QSPI_Transmit_DMA+0x1d4>)
24012114:	401a      	ands	r2, r3
24012116:	687b      	ldr	r3, [r7, #4]
24012118:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401211a:	6819      	ldr	r1, [r3, #0]
2401211c:	f240 2302 	movw	r3, #514	; 0x202
24012120:	4313      	orrs	r3, r2
24012122:	610b      	str	r3, [r1, #16]
24012124:	e007      	b.n	24012136 <HAL_QSPI_Transmit_DMA+0x12a>
        }
        else
        {
          /* in case of incorrect source data size */
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24012126:	687b      	ldr	r3, [r7, #4]
24012128:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401212a:	f043 0204 	orr.w	r2, r3, #4
2401212e:	687b      	ldr	r3, [r7, #4]
24012130:	645a      	str	r2, [r3, #68]	; 0x44
          status = HAL_ERROR;
24012132:	2301      	movs	r3, #1
24012134:	73fb      	strb	r3, [r7, #15]
        }

        /* Enable the QSPI transmit MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)pData, (uint32_t)&hqspi->Instance->DR, hqspi->TxXferSize, 1) == HAL_OK)
24012136:	687b      	ldr	r3, [r7, #4]
24012138:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
2401213a:	6839      	ldr	r1, [r7, #0]
2401213c:	687b      	ldr	r3, [r7, #4]
2401213e:	681b      	ldr	r3, [r3, #0]
24012140:	3320      	adds	r3, #32
24012142:	461c      	mov	r4, r3
24012144:	687b      	ldr	r3, [r7, #4]
24012146:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24012148:	2201      	movs	r2, #1
2401214a:	9200      	str	r2, [sp, #0]
2401214c:	4622      	mov	r2, r4
2401214e:	f7fd feb8 	bl	2400fec2 <HAL_MDMA_Start_IT>
24012152:	4603      	mov	r3, r0
24012154:	2b00      	cmp	r3, #0
24012156:	d114      	bne.n	24012182 <HAL_QSPI_Transmit_DMA+0x176>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24012158:	687b      	ldr	r3, [r7, #4]
2401215a:	2200      	movs	r2, #0
2401215c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
24012160:	687b      	ldr	r3, [r7, #4]
24012162:	681b      	ldr	r3, [r3, #0]
24012164:	681a      	ldr	r2, [r3, #0]
24012166:	687b      	ldr	r3, [r7, #4]
24012168:	681b      	ldr	r3, [r3, #0]
2401216a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2401216e:	601a      	str	r2, [r3, #0]

          /* Enable using MDMA by setting DMAEN, note that DMAEN bit is "reserved"
             but no impact on H7 HW and it minimize the cost in the footprint */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24012170:	687b      	ldr	r3, [r7, #4]
24012172:	681b      	ldr	r3, [r3, #0]
24012174:	681a      	ldr	r2, [r3, #0]
24012176:	687b      	ldr	r3, [r7, #4]
24012178:	681b      	ldr	r3, [r3, #0]
2401217a:	f042 0204 	orr.w	r2, r2, #4
2401217e:	601a      	str	r2, [r3, #0]
24012180:	e023      	b.n	240121ca <HAL_QSPI_Transmit_DMA+0x1be>
        }
        else
        {
          status = HAL_ERROR;
24012182:	2301      	movs	r3, #1
24012184:	73fb      	strb	r3, [r7, #15]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24012186:	687b      	ldr	r3, [r7, #4]
24012188:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401218a:	f043 0204 	orr.w	r2, r3, #4
2401218e:	687b      	ldr	r3, [r7, #4]
24012190:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
24012192:	687b      	ldr	r3, [r7, #4]
24012194:	2201      	movs	r2, #1
24012196:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
2401219a:	687b      	ldr	r3, [r7, #4]
2401219c:	2200      	movs	r2, #0
2401219e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240121a2:	e012      	b.n	240121ca <HAL_QSPI_Transmit_DMA+0x1be>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
240121a4:	687b      	ldr	r3, [r7, #4]
240121a6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240121a8:	f043 0208 	orr.w	r2, r3, #8
240121ac:	687b      	ldr	r3, [r7, #4]
240121ae:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
240121b0:	2301      	movs	r3, #1
240121b2:	73fb      	strb	r3, [r7, #15]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240121b4:	687b      	ldr	r3, [r7, #4]
240121b6:	2200      	movs	r2, #0
240121b8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240121bc:	e005      	b.n	240121ca <HAL_QSPI_Transmit_DMA+0x1be>
    }
  }
  else
  {
    status = HAL_BUSY;
240121be:	2302      	movs	r3, #2
240121c0:	73fb      	strb	r3, [r7, #15]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240121c2:	687b      	ldr	r3, [r7, #4]
240121c4:	2200      	movs	r2, #0
240121c6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
240121ca:	7bfb      	ldrb	r3, [r7, #15]
}
240121cc:	4618      	mov	r0, r3
240121ce:	3714      	adds	r7, #20
240121d0:	46bd      	mov	sp, r7
240121d2:	bd90      	pop	{r4, r7, pc}
240121d4:	24012a4d 	.word	0x24012a4d
240121d8:	24012a7d 	.word	0x24012a7d
240121dc:	fffff3f3 	.word	0xfffff3f3
240121e0:	fffffcfc 	.word	0xfffffcfc

240121e4 <HAL_QSPI_Receive_DMA>:
  * @param  pData pointer to data buffer.
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Receive_DMA(QSPI_HandleTypeDef *hqspi, uint8_t *pData)
{
240121e4:	b590      	push	{r4, r7, lr}
240121e6:	b089      	sub	sp, #36	; 0x24
240121e8:	af02      	add	r7, sp, #8
240121ea:	6078      	str	r0, [r7, #4]
240121ec:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
240121ee:	2300      	movs	r3, #0
240121f0:	75fb      	strb	r3, [r7, #23]
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
240121f2:	687b      	ldr	r3, [r7, #4]
240121f4:	681b      	ldr	r3, [r3, #0]
240121f6:	699b      	ldr	r3, [r3, #24]
240121f8:	613b      	str	r3, [r7, #16]
  uint32_t data_size = (READ_REG(hqspi->Instance->DLR) + 1U);
240121fa:	687b      	ldr	r3, [r7, #4]
240121fc:	681b      	ldr	r3, [r3, #0]
240121fe:	691b      	ldr	r3, [r3, #16]
24012200:	3301      	adds	r3, #1
24012202:	60fb      	str	r3, [r7, #12]

  /* Process locked */
  __HAL_LOCK(hqspi);
24012204:	687b      	ldr	r3, [r7, #4]
24012206:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
2401220a:	b2db      	uxtb	r3, r3
2401220c:	2b01      	cmp	r3, #1
2401220e:	d101      	bne.n	24012214 <HAL_QSPI_Receive_DMA+0x30>
24012210:	2302      	movs	r3, #2
24012212:	e0d1      	b.n	240123b8 <HAL_QSPI_Receive_DMA+0x1d4>
24012214:	687b      	ldr	r3, [r7, #4]
24012216:	2201      	movs	r2, #1
24012218:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401221c:	687b      	ldr	r3, [r7, #4]
2401221e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012222:	b2db      	uxtb	r3, r3
24012224:	2b01      	cmp	r3, #1
24012226:	f040 80c0 	bne.w	240123aa <HAL_QSPI_Receive_DMA+0x1c6>
  {
    /* Clear the error code */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
2401222a:	687b      	ldr	r3, [r7, #4]
2401222c:	2200      	movs	r2, #0
2401222e:	645a      	str	r2, [r3, #68]	; 0x44

    if(pData != NULL )
24012230:	683b      	ldr	r3, [r7, #0]
24012232:	2b00      	cmp	r3, #0
24012234:	f000 80ac 	beq.w	24012390 <HAL_QSPI_Receive_DMA+0x1ac>
    {
      /* Configure counters of the handle */
      hqspi->RxXferCount = data_size;
24012238:	687b      	ldr	r3, [r7, #4]
2401223a:	68fa      	ldr	r2, [r7, #12]
2401223c:	639a      	str	r2, [r3, #56]	; 0x38
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
2401223e:	687b      	ldr	r3, [r7, #4]
24012240:	2222      	movs	r2, #34	; 0x22
24012242:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, (QSPI_FLAG_TE | QSPI_FLAG_TC));
24012246:	687b      	ldr	r3, [r7, #4]
24012248:	681b      	ldr	r3, [r3, #0]
2401224a:	2203      	movs	r2, #3
2401224c:	60da      	str	r2, [r3, #12]

        /* Configure size and pointer of the handle */
        hqspi->RxXferSize = hqspi->RxXferCount;
2401224e:	687b      	ldr	r3, [r7, #4]
24012250:	6b9a      	ldr	r2, [r3, #56]	; 0x38
24012252:	687b      	ldr	r3, [r7, #4]
24012254:	635a      	str	r2, [r3, #52]	; 0x34
        hqspi->pRxBuffPtr = pData;
24012256:	687b      	ldr	r3, [r7, #4]
24012258:	683a      	ldr	r2, [r7, #0]
2401225a:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the QSPI MDMA transfer complete callback */
        hqspi->hmdma->XferCpltCallback = QSPI_DMARxCplt;
2401225c:	687b      	ldr	r3, [r7, #4]
2401225e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012260:	4a57      	ldr	r2, [pc, #348]	; (240123c0 <HAL_QSPI_Receive_DMA+0x1dc>)
24012262:	645a      	str	r2, [r3, #68]	; 0x44

        /* Set the MDMA error callback */
        hqspi->hmdma->XferErrorCallback = QSPI_DMAError;
24012264:	687b      	ldr	r3, [r7, #4]
24012266:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012268:	4a56      	ldr	r2, [pc, #344]	; (240123c4 <HAL_QSPI_Receive_DMA+0x1e0>)
2401226a:	655a      	str	r2, [r3, #84]	; 0x54

        /* Clear the MDMA abort callback */
        hqspi->hmdma->XferAbortCallback = NULL;
2401226c:	687b      	ldr	r3, [r7, #4]
2401226e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012270:	2200      	movs	r2, #0
24012272:	659a      	str	r2, [r3, #88]	; 0x58

      /* In Receive mode , the MDMA source is the QSPI DR register : Force the MDMA Source Increment to disable */
      MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_SINC | MDMA_CTCR_SINCOS) , MDMA_SRC_INC_DISABLE);
24012274:	687b      	ldr	r3, [r7, #4]
24012276:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012278:	681b      	ldr	r3, [r3, #0]
2401227a:	6919      	ldr	r1, [r3, #16]
2401227c:	687b      	ldr	r3, [r7, #4]
2401227e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012280:	681a      	ldr	r2, [r3, #0]
24012282:	4b51      	ldr	r3, [pc, #324]	; (240123c8 <HAL_QSPI_Receive_DMA+0x1e4>)
24012284:	400b      	ands	r3, r1
24012286:	6113      	str	r3, [r2, #16]

      /* Update MDMA configuration with the correct DestinationInc field for read operation */
      if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_BYTE)
24012288:	687b      	ldr	r3, [r7, #4]
2401228a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401228c:	6a1b      	ldr	r3, [r3, #32]
2401228e:	2b00      	cmp	r3, #0
24012290:	d10c      	bne.n	240122ac <HAL_QSPI_Receive_DMA+0xc8>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_BYTE);
24012292:	687b      	ldr	r3, [r7, #4]
24012294:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012296:	681b      	ldr	r3, [r3, #0]
24012298:	691a      	ldr	r2, [r3, #16]
2401229a:	4b4c      	ldr	r3, [pc, #304]	; (240123cc <HAL_QSPI_Receive_DMA+0x1e8>)
2401229c:	4013      	ands	r3, r2
2401229e:	687a      	ldr	r2, [r7, #4]
240122a0:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
240122a2:	6812      	ldr	r2, [r2, #0]
240122a4:	f043 0308 	orr.w	r3, r3, #8
240122a8:	6113      	str	r3, [r2, #16]
240122aa:	e02c      	b.n	24012306 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_HALFWORD)
240122ac:	687b      	ldr	r3, [r7, #4]
240122ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240122b0:	6a1b      	ldr	r3, [r3, #32]
240122b2:	2b40      	cmp	r3, #64	; 0x40
240122b4:	d10c      	bne.n	240122d0 <HAL_QSPI_Receive_DMA+0xec>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_HALFWORD);
240122b6:	687b      	ldr	r3, [r7, #4]
240122b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240122ba:	681b      	ldr	r3, [r3, #0]
240122bc:	691a      	ldr	r2, [r3, #16]
240122be:	4b43      	ldr	r3, [pc, #268]	; (240123cc <HAL_QSPI_Receive_DMA+0x1e8>)
240122c0:	4013      	ands	r3, r2
240122c2:	687a      	ldr	r2, [r7, #4]
240122c4:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
240122c6:	6812      	ldr	r2, [r2, #0]
240122c8:	f443 6381 	orr.w	r3, r3, #1032	; 0x408
240122cc:	6113      	str	r3, [r2, #16]
240122ce:	e01a      	b.n	24012306 <HAL_QSPI_Receive_DMA+0x122>
      }
      else if (hqspi->hmdma->Init.DestDataSize == MDMA_DEST_DATASIZE_WORD)
240122d0:	687b      	ldr	r3, [r7, #4]
240122d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240122d4:	6a1b      	ldr	r3, [r3, #32]
240122d6:	2b80      	cmp	r3, #128	; 0x80
240122d8:	d10d      	bne.n	240122f6 <HAL_QSPI_Receive_DMA+0x112>
      {
        MODIFY_REG(hqspi->hmdma->Instance->CTCR, (MDMA_CTCR_DINC | MDMA_CTCR_DINCOS) , MDMA_DEST_INC_WORD);
240122da:	687b      	ldr	r3, [r7, #4]
240122dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240122de:	681b      	ldr	r3, [r3, #0]
240122e0:	691b      	ldr	r3, [r3, #16]
240122e2:	4a3a      	ldr	r2, [pc, #232]	; (240123cc <HAL_QSPI_Receive_DMA+0x1e8>)
240122e4:	401a      	ands	r2, r3
240122e6:	687b      	ldr	r3, [r7, #4]
240122e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240122ea:	6819      	ldr	r1, [r3, #0]
240122ec:	f640 0308 	movw	r3, #2056	; 0x808
240122f0:	4313      	orrs	r3, r2
240122f2:	610b      	str	r3, [r1, #16]
240122f4:	e007      	b.n	24012306 <HAL_QSPI_Receive_DMA+0x122>
      }
      else
      {
       /* in case of incorrect destination data size */
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
240122f6:	687b      	ldr	r3, [r7, #4]
240122f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240122fa:	f043 0204 	orr.w	r2, r3, #4
240122fe:	687b      	ldr	r3, [r7, #4]
24012300:	645a      	str	r2, [r3, #68]	; 0x44
        status = HAL_ERROR;
24012302:	2301      	movs	r3, #1
24012304:	75fb      	strb	r3, [r7, #23]
      }
          /* Configure QSPI: CCR register with functional as indirect read */
          MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
24012306:	687b      	ldr	r3, [r7, #4]
24012308:	681b      	ldr	r3, [r3, #0]
2401230a:	695b      	ldr	r3, [r3, #20]
2401230c:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
24012310:	687b      	ldr	r3, [r7, #4]
24012312:	681b      	ldr	r3, [r3, #0]
24012314:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
24012318:	615a      	str	r2, [r3, #20]

          /* Start the transfer by re-writing the address in AR register */
          WRITE_REG(hqspi->Instance->AR, addr_reg);
2401231a:	687b      	ldr	r3, [r7, #4]
2401231c:	681b      	ldr	r3, [r3, #0]
2401231e:	693a      	ldr	r2, [r7, #16]
24012320:	619a      	str	r2, [r3, #24]

        /* Enable the MDMA */
        if (HAL_MDMA_Start_IT(hqspi->hmdma, (uint32_t)&hqspi->Instance->DR, (uint32_t)pData, hqspi->RxXferSize, 1) == HAL_OK)
24012322:	687b      	ldr	r3, [r7, #4]
24012324:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
24012326:	687b      	ldr	r3, [r7, #4]
24012328:	681b      	ldr	r3, [r3, #0]
2401232a:	3320      	adds	r3, #32
2401232c:	461c      	mov	r4, r3
2401232e:	683a      	ldr	r2, [r7, #0]
24012330:	687b      	ldr	r3, [r7, #4]
24012332:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012334:	2101      	movs	r1, #1
24012336:	9100      	str	r1, [sp, #0]
24012338:	4621      	mov	r1, r4
2401233a:	f7fd fdc2 	bl	2400fec2 <HAL_MDMA_Start_IT>
2401233e:	4603      	mov	r3, r0
24012340:	2b00      	cmp	r3, #0
24012342:	d114      	bne.n	2401236e <HAL_QSPI_Receive_DMA+0x18a>
        {
          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24012344:	687b      	ldr	r3, [r7, #4]
24012346:	2200      	movs	r2, #0
24012348:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          /* Enable the QSPI transfer error Interrupt */
          __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TE);
2401234c:	687b      	ldr	r3, [r7, #4]
2401234e:	681b      	ldr	r3, [r3, #0]
24012350:	681a      	ldr	r2, [r3, #0]
24012352:	687b      	ldr	r3, [r7, #4]
24012354:	681b      	ldr	r3, [r3, #0]
24012356:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2401235a:	601a      	str	r2, [r3, #0]

          /* Enable using MDMA by setting DMAEN, note that DMAEN bit is "reserved"
             but no impact on H7 HW and it minimize the cost in the footprint */
          SET_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401235c:	687b      	ldr	r3, [r7, #4]
2401235e:	681b      	ldr	r3, [r3, #0]
24012360:	681a      	ldr	r2, [r3, #0]
24012362:	687b      	ldr	r3, [r7, #4]
24012364:	681b      	ldr	r3, [r3, #0]
24012366:	f042 0204 	orr.w	r2, r2, #4
2401236a:	601a      	str	r2, [r3, #0]
2401236c:	e023      	b.n	240123b6 <HAL_QSPI_Receive_DMA+0x1d2>
        }
        else
        {
          status = HAL_ERROR;
2401236e:	2301      	movs	r3, #1
24012370:	75fb      	strb	r3, [r7, #23]
          hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
24012372:	687b      	ldr	r3, [r7, #4]
24012374:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012376:	f043 0204 	orr.w	r2, r3, #4
2401237a:	687b      	ldr	r3, [r7, #4]
2401237c:	645a      	str	r2, [r3, #68]	; 0x44
          hqspi->State = HAL_QSPI_STATE_READY;
2401237e:	687b      	ldr	r3, [r7, #4]
24012380:	2201      	movs	r2, #1
24012382:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

          /* Process unlocked */
          __HAL_UNLOCK(hqspi);
24012386:	687b      	ldr	r3, [r7, #4]
24012388:	2200      	movs	r2, #0
2401238a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
2401238e:	e012      	b.n	240123b6 <HAL_QSPI_Receive_DMA+0x1d2>
        }
    }
    else
    {
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
24012390:	687b      	ldr	r3, [r7, #4]
24012392:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012394:	f043 0208 	orr.w	r2, r3, #8
24012398:	687b      	ldr	r3, [r7, #4]
2401239a:	645a      	str	r2, [r3, #68]	; 0x44
      status = HAL_ERROR;
2401239c:	2301      	movs	r3, #1
2401239e:	75fb      	strb	r3, [r7, #23]

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
240123a0:	687b      	ldr	r3, [r7, #4]
240123a2:	2200      	movs	r2, #0
240123a4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
240123a8:	e005      	b.n	240123b6 <HAL_QSPI_Receive_DMA+0x1d2>
    }
  }
  else
  {
    status = HAL_BUSY;
240123aa:	2302      	movs	r3, #2
240123ac:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
240123ae:	687b      	ldr	r3, [r7, #4]
240123b0:	2200      	movs	r2, #0
240123b2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
240123b6:	7dfb      	ldrb	r3, [r7, #23]
}
240123b8:	4618      	mov	r0, r3
240123ba:	371c      	adds	r7, #28
240123bc:	46bd      	mov	sp, r7
240123be:	bd90      	pop	{r4, r7, pc}
240123c0:	24012a1d 	.word	0x24012a1d
240123c4:	24012a7d 	.word	0x24012a7d
240123c8:	fffffcfc 	.word	0xfffffcfc
240123cc:	fffff3f3 	.word	0xfffff3f3

240123d0 <HAL_QSPI_AutoPolling>:
  * @param  Timeout Timeout duration
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg, uint32_t Timeout)
{
240123d0:	b580      	push	{r7, lr}
240123d2:	b088      	sub	sp, #32
240123d4:	af02      	add	r7, sp, #8
240123d6:	60f8      	str	r0, [r7, #12]
240123d8:	60b9      	str	r1, [r7, #8]
240123da:	607a      	str	r2, [r7, #4]
240123dc:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240123de:	f7ef ffb1 	bl	24002344 <HAL_GetTick>
240123e2:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_INTERVAL(cfg->Interval));
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));

  /* Process locked */
  __HAL_LOCK(hqspi);
240123e4:	68fb      	ldr	r3, [r7, #12]
240123e6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240123ea:	b2db      	uxtb	r3, r3
240123ec:	2b01      	cmp	r3, #1
240123ee:	d101      	bne.n	240123f4 <HAL_QSPI_AutoPolling+0x24>
240123f0:	2302      	movs	r3, #2
240123f2:	e060      	b.n	240124b6 <HAL_QSPI_AutoPolling+0xe6>
240123f4:	68fb      	ldr	r3, [r7, #12]
240123f6:	2201      	movs	r2, #1
240123f8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240123fc:	68fb      	ldr	r3, [r7, #12]
240123fe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012402:	b2db      	uxtb	r3, r3
24012404:	2b01      	cmp	r3, #1
24012406:	d14f      	bne.n	240124a8 <HAL_QSPI_AutoPolling+0xd8>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
24012408:	68fb      	ldr	r3, [r7, #12]
2401240a:	2200      	movs	r2, #0
2401240c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
2401240e:	68fb      	ldr	r3, [r7, #12]
24012410:	2242      	movs	r2, #66	; 0x42
24012412:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
24012416:	683b      	ldr	r3, [r7, #0]
24012418:	9300      	str	r3, [sp, #0]
2401241a:	693b      	ldr	r3, [r7, #16]
2401241c:	2200      	movs	r2, #0
2401241e:	2120      	movs	r1, #32
24012420:	68f8      	ldr	r0, [r7, #12]
24012422:	f000 fb80 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24012426:	4603      	mov	r3, r0
24012428:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
2401242a:	7dfb      	ldrb	r3, [r7, #23]
2401242c:	2b00      	cmp	r3, #0
2401242e:	d13d      	bne.n	240124ac <HAL_QSPI_AutoPolling+0xdc>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
24012430:	68fb      	ldr	r3, [r7, #12]
24012432:	681b      	ldr	r3, [r3, #0]
24012434:	687a      	ldr	r2, [r7, #4]
24012436:	6812      	ldr	r2, [r2, #0]
24012438:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
2401243a:	68fb      	ldr	r3, [r7, #12]
2401243c:	681b      	ldr	r3, [r3, #0]
2401243e:	687a      	ldr	r2, [r7, #4]
24012440:	6852      	ldr	r2, [r2, #4]
24012442:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24012444:	68fb      	ldr	r3, [r7, #12]
24012446:	681b      	ldr	r3, [r3, #0]
24012448:	687a      	ldr	r2, [r7, #4]
2401244a:	6892      	ldr	r2, [r2, #8]
2401244c:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop enabled
      (otherwise there will be an infinite loop in blocking mode) */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
2401244e:	68fb      	ldr	r3, [r7, #12]
24012450:	681b      	ldr	r3, [r3, #0]
24012452:	681b      	ldr	r3, [r3, #0]
24012454:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
24012458:	687b      	ldr	r3, [r7, #4]
2401245a:	691b      	ldr	r3, [r3, #16]
2401245c:	431a      	orrs	r2, r3
2401245e:	68fb      	ldr	r3, [r7, #12]
24012460:	681b      	ldr	r3, [r3, #0]
24012462:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
24012466:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | QSPI_AUTOMATIC_STOP_ENABLE));

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
24012468:	687b      	ldr	r3, [r7, #4]
2401246a:	68da      	ldr	r2, [r3, #12]
2401246c:	68bb      	ldr	r3, [r7, #8]
2401246e:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24012470:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
24012474:	68b9      	ldr	r1, [r7, #8]
24012476:	68f8      	ldr	r0, [r7, #12]
24012478:	f000 fb8c 	bl	24012b94 <QSPI_Config>

      /* Wait until SM flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
2401247c:	683b      	ldr	r3, [r7, #0]
2401247e:	9300      	str	r3, [sp, #0]
24012480:	693b      	ldr	r3, [r7, #16]
24012482:	2201      	movs	r2, #1
24012484:	2108      	movs	r1, #8
24012486:	68f8      	ldr	r0, [r7, #12]
24012488:	f000 fb4d 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
2401248c:	4603      	mov	r3, r0
2401248e:	75fb      	strb	r3, [r7, #23]

      if (status == HAL_OK)
24012490:	7dfb      	ldrb	r3, [r7, #23]
24012492:	2b00      	cmp	r3, #0
24012494:	d10a      	bne.n	240124ac <HAL_QSPI_AutoPolling+0xdc>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
24012496:	68fb      	ldr	r3, [r7, #12]
24012498:	681b      	ldr	r3, [r3, #0]
2401249a:	2208      	movs	r2, #8
2401249c:	60da      	str	r2, [r3, #12]

        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
2401249e:	68fb      	ldr	r3, [r7, #12]
240124a0:	2201      	movs	r2, #1
240124a2:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
240124a6:	e001      	b.n	240124ac <HAL_QSPI_AutoPolling+0xdc>
      }
    }
  }
  else
  {
    status = HAL_BUSY;
240124a8:	2302      	movs	r3, #2
240124aa:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
240124ac:	68fb      	ldr	r3, [r7, #12]
240124ae:	2200      	movs	r2, #0
240124b0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
240124b4:	7dfb      	ldrb	r3, [r7, #23]
}
240124b6:	4618      	mov	r0, r3
240124b8:	3718      	adds	r7, #24
240124ba:	46bd      	mov	sp, r7
240124bc:	bd80      	pop	{r7, pc}

240124be <HAL_QSPI_AutoPolling_IT>:
  * @param  cfg structure that contains the polling configuration information.
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_AutoPolling_IT(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_AutoPollingTypeDef *cfg)
{
240124be:	b580      	push	{r7, lr}
240124c0:	b088      	sub	sp, #32
240124c2:	af02      	add	r7, sp, #8
240124c4:	60f8      	str	r0, [r7, #12]
240124c6:	60b9      	str	r1, [r7, #8]
240124c8:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240124ca:	f7ef ff3b 	bl	24002344 <HAL_GetTick>
240124ce:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_STATUS_BYTES_SIZE(cfg->StatusBytesSize));
  assert_param(IS_QSPI_MATCH_MODE(cfg->MatchMode));
  assert_param(IS_QSPI_AUTOMATIC_STOP(cfg->AutomaticStop));

  /* Process locked */
  __HAL_LOCK(hqspi);
240124d0:	68fb      	ldr	r3, [r7, #12]
240124d2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240124d6:	b2db      	uxtb	r3, r3
240124d8:	2b01      	cmp	r3, #1
240124da:	d101      	bne.n	240124e0 <HAL_QSPI_AutoPolling_IT+0x22>
240124dc:	2302      	movs	r3, #2
240124de:	e062      	b.n	240125a6 <HAL_QSPI_AutoPolling_IT+0xe8>
240124e0:	68fb      	ldr	r3, [r7, #12]
240124e2:	2201      	movs	r2, #1
240124e4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240124e8:	68fb      	ldr	r3, [r7, #12]
240124ea:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240124ee:	b2db      	uxtb	r3, r3
240124f0:	2b01      	cmp	r3, #1
240124f2:	d151      	bne.n	24012598 <HAL_QSPI_AutoPolling_IT+0xda>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240124f4:	68fb      	ldr	r3, [r7, #12]
240124f6:	2200      	movs	r2, #0
240124f8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
240124fa:	68fb      	ldr	r3, [r7, #12]
240124fc:	2242      	movs	r2, #66	; 0x42
240124fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
24012502:	68fb      	ldr	r3, [r7, #12]
24012504:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24012506:	9300      	str	r3, [sp, #0]
24012508:	693b      	ldr	r3, [r7, #16]
2401250a:	2200      	movs	r2, #0
2401250c:	2120      	movs	r1, #32
2401250e:	68f8      	ldr	r0, [r7, #12]
24012510:	f000 fb09 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24012514:	4603      	mov	r3, r0
24012516:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24012518:	7dfb      	ldrb	r3, [r7, #23]
2401251a:	2b00      	cmp	r3, #0
2401251c:	d137      	bne.n	2401258e <HAL_QSPI_AutoPolling_IT+0xd0>
    {
      /* Configure QSPI: PSMAR register with the status match value */
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
2401251e:	68fb      	ldr	r3, [r7, #12]
24012520:	681b      	ldr	r3, [r3, #0]
24012522:	687a      	ldr	r2, [r7, #4]
24012524:	6812      	ldr	r2, [r2, #0]
24012526:	629a      	str	r2, [r3, #40]	; 0x28

      /* Configure QSPI: PSMKR register with the status mask value */
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
24012528:	68fb      	ldr	r3, [r7, #12]
2401252a:	681b      	ldr	r3, [r3, #0]
2401252c:	687a      	ldr	r2, [r7, #4]
2401252e:	6852      	ldr	r2, [r2, #4]
24012530:	625a      	str	r2, [r3, #36]	; 0x24

      /* Configure QSPI: PIR register with the interval value */
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
24012532:	68fb      	ldr	r3, [r7, #12]
24012534:	681b      	ldr	r3, [r3, #0]
24012536:	687a      	ldr	r2, [r7, #4]
24012538:	6892      	ldr	r2, [r2, #8]
2401253a:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Configure QSPI: CR register with Match mode and Automatic stop mode */
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
2401253c:	68fb      	ldr	r3, [r7, #12]
2401253e:	681b      	ldr	r3, [r3, #0]
24012540:	681b      	ldr	r3, [r3, #0]
24012542:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
24012546:	687b      	ldr	r3, [r7, #4]
24012548:	691a      	ldr	r2, [r3, #16]
2401254a:	687b      	ldr	r3, [r7, #4]
2401254c:	695b      	ldr	r3, [r3, #20]
2401254e:	431a      	orrs	r2, r3
24012550:	68fb      	ldr	r3, [r7, #12]
24012552:	681b      	ldr	r3, [r3, #0]
24012554:	430a      	orrs	r2, r1
24012556:	601a      	str	r2, [r3, #0]
               (cfg->MatchMode | cfg->AutomaticStop));

      /* Clear interrupt */
      __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TE | QSPI_FLAG_SM);
24012558:	68fb      	ldr	r3, [r7, #12]
2401255a:	681b      	ldr	r3, [r3, #0]
2401255c:	2209      	movs	r2, #9
2401255e:	60da      	str	r2, [r3, #12]

      /* Call the configuration function */
      cmd->NbData = cfg->StatusBytesSize;
24012560:	687b      	ldr	r3, [r7, #4]
24012562:	68da      	ldr	r2, [r3, #12]
24012564:	68bb      	ldr	r3, [r7, #8]
24012566:	629a      	str	r2, [r3, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
24012568:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
2401256c:	68b9      	ldr	r1, [r7, #8]
2401256e:	68f8      	ldr	r0, [r7, #12]
24012570:	f000 fb10 	bl	24012b94 <QSPI_Config>

      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
24012574:	68fb      	ldr	r3, [r7, #12]
24012576:	2200      	movs	r2, #0
24012578:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      /* Enable the QSPI Transfer Error and status match Interrupt */
      __HAL_QSPI_ENABLE_IT(hqspi, (QSPI_IT_SM | QSPI_IT_TE));
2401257c:	68fb      	ldr	r3, [r7, #12]
2401257e:	681b      	ldr	r3, [r3, #0]
24012580:	681a      	ldr	r2, [r3, #0]
24012582:	68fb      	ldr	r3, [r7, #12]
24012584:	681b      	ldr	r3, [r3, #0]
24012586:	f442 2210 	orr.w	r2, r2, #589824	; 0x90000
2401258a:	601a      	str	r2, [r3, #0]
2401258c:	e00a      	b.n	240125a4 <HAL_QSPI_AutoPolling_IT+0xe6>

    }
    else
    {
      /* Process unlocked */
      __HAL_UNLOCK(hqspi);
2401258e:	68fb      	ldr	r3, [r7, #12]
24012590:	2200      	movs	r2, #0
24012592:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
24012596:	e005      	b.n	240125a4 <HAL_QSPI_AutoPolling_IT+0xe6>
    }
  }
  else
  {
    status = HAL_BUSY;
24012598:	2302      	movs	r3, #2
2401259a:	75fb      	strb	r3, [r7, #23]

    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
2401259c:	68fb      	ldr	r3, [r7, #12]
2401259e:	2200      	movs	r2, #0
240125a0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  /* Return function status */
  return status;
240125a4:	7dfb      	ldrb	r3, [r7, #23]
}
240125a6:	4618      	mov	r0, r3
240125a8:	3718      	adds	r7, #24
240125aa:	46bd      	mov	sp, r7
240125ac:	bd80      	pop	{r7, pc}

240125ae <HAL_QSPI_MemoryMapped>:
  * @param  cfg structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_MemoryMapped(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, QSPI_MemoryMappedTypeDef *cfg)
{
240125ae:	b580      	push	{r7, lr}
240125b0:	b088      	sub	sp, #32
240125b2:	af02      	add	r7, sp, #8
240125b4:	60f8      	str	r0, [r7, #12]
240125b6:	60b9      	str	r1, [r7, #8]
240125b8:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
240125ba:	f7ef fec3 	bl	24002344 <HAL_GetTick>
240125be:	6138      	str	r0, [r7, #16]
  assert_param(IS_QSPI_SIOO_MODE(cmd->SIOOMode));

  assert_param(IS_QSPI_TIMEOUT_ACTIVATION(cfg->TimeOutActivation));

  /* Process locked */
  __HAL_LOCK(hqspi);
240125c0:	68fb      	ldr	r3, [r7, #12]
240125c2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240125c6:	b2db      	uxtb	r3, r3
240125c8:	2b01      	cmp	r3, #1
240125ca:	d101      	bne.n	240125d0 <HAL_QSPI_MemoryMapped+0x22>
240125cc:	2302      	movs	r3, #2
240125ce:	e04c      	b.n	2401266a <HAL_QSPI_MemoryMapped+0xbc>
240125d0:	68fb      	ldr	r3, [r7, #12]
240125d2:	2201      	movs	r2, #1
240125d4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240125d8:	68fb      	ldr	r3, [r7, #12]
240125da:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240125de:	b2db      	uxtb	r3, r3
240125e0:	2b01      	cmp	r3, #1
240125e2:	d13b      	bne.n	2401265c <HAL_QSPI_MemoryMapped+0xae>
  {
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
240125e4:	68fb      	ldr	r3, [r7, #12]
240125e6:	2200      	movs	r2, #0
240125e8:	645a      	str	r2, [r3, #68]	; 0x44

    /* Update state */
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
240125ea:	68fb      	ldr	r3, [r7, #12]
240125ec:	2282      	movs	r2, #130	; 0x82
240125ee:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Wait till BUSY flag reset */
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240125f2:	68fb      	ldr	r3, [r7, #12]
240125f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240125f6:	9300      	str	r3, [sp, #0]
240125f8:	693b      	ldr	r3, [r7, #16]
240125fa:	2200      	movs	r2, #0
240125fc:	2120      	movs	r1, #32
240125fe:	68f8      	ldr	r0, [r7, #12]
24012600:	f000 fa91 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24012604:	4603      	mov	r3, r0
24012606:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
24012608:	7dfb      	ldrb	r3, [r7, #23]
2401260a:	2b00      	cmp	r3, #0
2401260c:	d128      	bne.n	24012660 <HAL_QSPI_MemoryMapped+0xb2>
    {
      /* Configure QSPI: CR register with timeout counter enable */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
2401260e:	68fb      	ldr	r3, [r7, #12]
24012610:	681b      	ldr	r3, [r3, #0]
24012612:	681b      	ldr	r3, [r3, #0]
24012614:	f023 0108 	bic.w	r1, r3, #8
24012618:	687b      	ldr	r3, [r7, #4]
2401261a:	685a      	ldr	r2, [r3, #4]
2401261c:	68fb      	ldr	r3, [r7, #12]
2401261e:	681b      	ldr	r3, [r3, #0]
24012620:	430a      	orrs	r2, r1
24012622:	601a      	str	r2, [r3, #0]

    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
24012624:	687b      	ldr	r3, [r7, #4]
24012626:	685b      	ldr	r3, [r3, #4]
24012628:	2b08      	cmp	r3, #8
2401262a:	d110      	bne.n	2401264e <HAL_QSPI_MemoryMapped+0xa0>
      {
        assert_param(IS_QSPI_TIMEOUT_PERIOD(cfg->TimeOutPeriod));

        /* Configure QSPI: LPTR register with the low-power timeout value */
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
2401262c:	68fb      	ldr	r3, [r7, #12]
2401262e:	681b      	ldr	r3, [r3, #0]
24012630:	687a      	ldr	r2, [r7, #4]
24012632:	6812      	ldr	r2, [r2, #0]
24012634:	631a      	str	r2, [r3, #48]	; 0x30

        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
24012636:	68fb      	ldr	r3, [r7, #12]
24012638:	681b      	ldr	r3, [r3, #0]
2401263a:	2210      	movs	r2, #16
2401263c:	60da      	str	r2, [r3, #12]

        /* Enable the QSPI TimeOut Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
2401263e:	68fb      	ldr	r3, [r7, #12]
24012640:	681b      	ldr	r3, [r3, #0]
24012642:	681a      	ldr	r2, [r3, #0]
24012644:	68fb      	ldr	r3, [r7, #12]
24012646:	681b      	ldr	r3, [r3, #0]
24012648:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
2401264c:	601a      	str	r2, [r3, #0]
      }

      /* Call the configuration function */
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
2401264e:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
24012652:	68b9      	ldr	r1, [r7, #8]
24012654:	68f8      	ldr	r0, [r7, #12]
24012656:	f000 fa9d 	bl	24012b94 <QSPI_Config>
2401265a:	e001      	b.n	24012660 <HAL_QSPI_MemoryMapped+0xb2>
    }
  }
  else
  {
    status = HAL_BUSY;
2401265c:	2302      	movs	r3, #2
2401265e:	75fb      	strb	r3, [r7, #23]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24012660:	68fb      	ldr	r3, [r7, #12]
24012662:	2200      	movs	r2, #0
24012664:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24012668:	7dfb      	ldrb	r3, [r7, #23]
}
2401266a:	4618      	mov	r0, r3
2401266c:	3718      	adds	r7, #24
2401266e:	46bd      	mov	sp, r7
24012670:	bd80      	pop	{r7, pc}

24012672 <HAL_QSPI_ErrorCallback>:
  * @brief  Transfer Error callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_ErrorCallback(QSPI_HandleTypeDef *hqspi)
{
24012672:	b480      	push	{r7}
24012674:	b083      	sub	sp, #12
24012676:	af00      	add	r7, sp, #0
24012678:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_ErrorCallback could be implemented in the user file
   */
}
2401267a:	bf00      	nop
2401267c:	370c      	adds	r7, #12
2401267e:	46bd      	mov	sp, r7
24012680:	f85d 7b04 	ldr.w	r7, [sp], #4
24012684:	4770      	bx	lr

24012686 <HAL_QSPI_AbortCpltCallback>:
  * @brief  Abort completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_AbortCpltCallback(QSPI_HandleTypeDef *hqspi)
{
24012686:	b480      	push	{r7}
24012688:	b083      	sub	sp, #12
2401268a:	af00      	add	r7, sp, #0
2401268c:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_AbortCpltCallback could be implemented in the user file
   */
}
2401268e:	bf00      	nop
24012690:	370c      	adds	r7, #12
24012692:	46bd      	mov	sp, r7
24012694:	f85d 7b04 	ldr.w	r7, [sp], #4
24012698:	4770      	bx	lr

2401269a <HAL_QSPI_CmdCpltCallback>:
  * @brief  Command completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_CmdCpltCallback(QSPI_HandleTypeDef *hqspi)
{
2401269a:	b480      	push	{r7}
2401269c:	b083      	sub	sp, #12
2401269e:	af00      	add	r7, sp, #0
240126a0:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_CmdCpltCallback could be implemented in the user file
   */
}
240126a2:	bf00      	nop
240126a4:	370c      	adds	r7, #12
240126a6:	46bd      	mov	sp, r7
240126a8:	f85d 7b04 	ldr.w	r7, [sp], #4
240126ac:	4770      	bx	lr

240126ae <HAL_QSPI_RxCpltCallback>:
  * @brief  Rx Transfer completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_RxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240126ae:	b480      	push	{r7}
240126b0:	b083      	sub	sp, #12
240126b2:	af00      	add	r7, sp, #0
240126b4:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_RxCpltCallback could be implemented in the user file
   */
}
240126b6:	bf00      	nop
240126b8:	370c      	adds	r7, #12
240126ba:	46bd      	mov	sp, r7
240126bc:	f85d 7b04 	ldr.w	r7, [sp], #4
240126c0:	4770      	bx	lr

240126c2 <HAL_QSPI_TxCpltCallback>:
  * @brief  Tx Transfer completed callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TxCpltCallback(QSPI_HandleTypeDef *hqspi)
{
240126c2:	b480      	push	{r7}
240126c4:	b083      	sub	sp, #12
240126c6:	af00      	add	r7, sp, #0
240126c8:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_QSPI_TxCpltCallback could be implemented in the user file
   */
}
240126ca:	bf00      	nop
240126cc:	370c      	adds	r7, #12
240126ce:	46bd      	mov	sp, r7
240126d0:	f85d 7b04 	ldr.w	r7, [sp], #4
240126d4:	4770      	bx	lr

240126d6 <HAL_QSPI_FifoThresholdCallback>:
  * @brief  FIFO Threshold callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_FifoThresholdCallback(QSPI_HandleTypeDef *hqspi)
{
240126d6:	b480      	push	{r7}
240126d8:	b083      	sub	sp, #12
240126da:	af00      	add	r7, sp, #0
240126dc:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_FIFOThresholdCallback could be implemented in the user file
   */
}
240126de:	bf00      	nop
240126e0:	370c      	adds	r7, #12
240126e2:	46bd      	mov	sp, r7
240126e4:	f85d 7b04 	ldr.w	r7, [sp], #4
240126e8:	4770      	bx	lr

240126ea <HAL_QSPI_StatusMatchCallback>:
  * @brief  Status Match callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_StatusMatchCallback(QSPI_HandleTypeDef *hqspi)
{
240126ea:	b480      	push	{r7}
240126ec:	b083      	sub	sp, #12
240126ee:	af00      	add	r7, sp, #0
240126f0:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_StatusMatchCallback could be implemented in the user file
   */
}
240126f2:	bf00      	nop
240126f4:	370c      	adds	r7, #12
240126f6:	46bd      	mov	sp, r7
240126f8:	f85d 7b04 	ldr.w	r7, [sp], #4
240126fc:	4770      	bx	lr

240126fe <HAL_QSPI_TimeOutCallback>:
  * @brief  Timeout callback.
  * @param  hqspi QSPI handle
  * @retval None
  */
__weak void HAL_QSPI_TimeOutCallback(QSPI_HandleTypeDef *hqspi)
{
240126fe:	b480      	push	{r7}
24012700:	b083      	sub	sp, #12
24012702:	af00      	add	r7, sp, #0
24012704:	6078      	str	r0, [r7, #4]
  UNUSED(hqspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_QSPI_TimeOutCallback could be implemented in the user file
   */
}
24012706:	bf00      	nop
24012708:	370c      	adds	r7, #12
2401270a:	46bd      	mov	sp, r7
2401270c:	f85d 7b04 	ldr.w	r7, [sp], #4
24012710:	4770      	bx	lr

24012712 <HAL_QSPI_GetState>:
  * @brief  Return the QSPI handle state.
  * @param  hqspi QSPI handle
  * @retval HAL state
  */
HAL_QSPI_StateTypeDef HAL_QSPI_GetState(QSPI_HandleTypeDef *hqspi)
{
24012712:	b480      	push	{r7}
24012714:	b083      	sub	sp, #12
24012716:	af00      	add	r7, sp, #0
24012718:	6078      	str	r0, [r7, #4]
  /* Return QSPI handle state */
  return hqspi->State;
2401271a:	687b      	ldr	r3, [r7, #4]
2401271c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012720:	b2db      	uxtb	r3, r3
}
24012722:	4618      	mov	r0, r3
24012724:	370c      	adds	r7, #12
24012726:	46bd      	mov	sp, r7
24012728:	f85d 7b04 	ldr.w	r7, [sp], #4
2401272c:	4770      	bx	lr

2401272e <HAL_QSPI_GetError>:
* @brief  Return the QSPI error code.
* @param  hqspi QSPI handle
* @retval QSPI Error Code
*/
uint32_t HAL_QSPI_GetError(QSPI_HandleTypeDef *hqspi)
{
2401272e:	b480      	push	{r7}
24012730:	b083      	sub	sp, #12
24012732:	af00      	add	r7, sp, #0
24012734:	6078      	str	r0, [r7, #4]
  return hqspi->ErrorCode;
24012736:	687b      	ldr	r3, [r7, #4]
24012738:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
2401273a:	4618      	mov	r0, r3
2401273c:	370c      	adds	r7, #12
2401273e:	46bd      	mov	sp, r7
24012740:	f85d 7b04 	ldr.w	r7, [sp], #4
24012744:	4770      	bx	lr

24012746 <HAL_QSPI_Abort>:
* @brief  Abort the current transmission.
* @param  hqspi QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort(QSPI_HandleTypeDef *hqspi)
{
24012746:	b580      	push	{r7, lr}
24012748:	b086      	sub	sp, #24
2401274a:	af02      	add	r7, sp, #8
2401274c:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
2401274e:	2300      	movs	r3, #0
24012750:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
24012752:	f7ef fdf7 	bl	24002344 <HAL_GetTick>
24012756:	60b8      	str	r0, [r7, #8]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
24012758:	687b      	ldr	r3, [r7, #4]
2401275a:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401275e:	b2db      	uxtb	r3, r3
24012760:	f003 0302 	and.w	r3, r3, #2
24012764:	2b00      	cmp	r3, #0
24012766:	d062      	beq.n	2401282e <HAL_QSPI_Abort+0xe8>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24012768:	687b      	ldr	r3, [r7, #4]
2401276a:	2200      	movs	r2, #0
2401276c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24012770:	687b      	ldr	r3, [r7, #4]
24012772:	681b      	ldr	r3, [r3, #0]
24012774:	681b      	ldr	r3, [r3, #0]
24012776:	f003 0304 	and.w	r3, r3, #4
2401277a:	2b00      	cmp	r3, #0
2401277c:	d017      	beq.n	240127ae <HAL_QSPI_Abort+0x68>
    {
      /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
         but no impact on H7 HW and it minimize the cost in the footprint */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
2401277e:	687b      	ldr	r3, [r7, #4]
24012780:	681b      	ldr	r3, [r3, #0]
24012782:	681a      	ldr	r2, [r3, #0]
24012784:	687b      	ldr	r3, [r7, #4]
24012786:	681b      	ldr	r3, [r3, #0]
24012788:	f022 0204 	bic.w	r2, r2, #4
2401278c:	601a      	str	r2, [r3, #0]

      /* Abort MDMA */
      status = HAL_MDMA_Abort(hqspi->hmdma);
2401278e:	687b      	ldr	r3, [r7, #4]
24012790:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012792:	4618      	mov	r0, r3
24012794:	f7fd fc16 	bl	2400ffc4 <HAL_MDMA_Abort>
24012798:	4603      	mov	r3, r0
2401279a:	73fb      	strb	r3, [r7, #15]
      if(status != HAL_OK)
2401279c:	7bfb      	ldrb	r3, [r7, #15]
2401279e:	2b00      	cmp	r3, #0
240127a0:	d005      	beq.n	240127ae <HAL_QSPI_Abort+0x68>
      {
        hqspi->ErrorCode |= HAL_QSPI_ERROR_DMA;
240127a2:	687b      	ldr	r3, [r7, #4]
240127a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240127a6:	f043 0204 	orr.w	r2, r3, #4
240127aa:	687b      	ldr	r3, [r7, #4]
240127ac:	645a      	str	r2, [r3, #68]	; 0x44
      }
    }

    if (__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_BUSY) != RESET)
240127ae:	687b      	ldr	r3, [r7, #4]
240127b0:	681b      	ldr	r3, [r3, #0]
240127b2:	689b      	ldr	r3, [r3, #8]
240127b4:	f003 0320 	and.w	r3, r3, #32
240127b8:	2b00      	cmp	r3, #0
240127ba:	d034      	beq.n	24012826 <HAL_QSPI_Abort+0xe0>
    {
      /* Configure QSPI: CR register with Abort request */
      SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
240127bc:	687b      	ldr	r3, [r7, #4]
240127be:	681b      	ldr	r3, [r3, #0]
240127c0:	681a      	ldr	r2, [r3, #0]
240127c2:	687b      	ldr	r3, [r7, #4]
240127c4:	681b      	ldr	r3, [r3, #0]
240127c6:	f042 0202 	orr.w	r2, r2, #2
240127ca:	601a      	str	r2, [r3, #0]
      
      /* Wait until TC flag is set to go back in idle state */
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, hqspi->Timeout);
240127cc:	687b      	ldr	r3, [r7, #4]
240127ce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240127d0:	9300      	str	r3, [sp, #0]
240127d2:	68bb      	ldr	r3, [r7, #8]
240127d4:	2201      	movs	r2, #1
240127d6:	2102      	movs	r1, #2
240127d8:	6878      	ldr	r0, [r7, #4]
240127da:	f000 f9a4 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
240127de:	4603      	mov	r3, r0
240127e0:	73fb      	strb	r3, [r7, #15]
      
      if (status == HAL_OK)
240127e2:	7bfb      	ldrb	r3, [r7, #15]
240127e4:	2b00      	cmp	r3, #0
240127e6:	d10e      	bne.n	24012806 <HAL_QSPI_Abort+0xc0>
      {
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240127e8:	687b      	ldr	r3, [r7, #4]
240127ea:	681b      	ldr	r3, [r3, #0]
240127ec:	2202      	movs	r2, #2
240127ee:	60da      	str	r2, [r3, #12]
        
        /* Wait until BUSY flag is reset */
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
240127f0:	687b      	ldr	r3, [r7, #4]
240127f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
240127f4:	9300      	str	r3, [sp, #0]
240127f6:	68bb      	ldr	r3, [r7, #8]
240127f8:	2200      	movs	r2, #0
240127fa:	2120      	movs	r1, #32
240127fc:	6878      	ldr	r0, [r7, #4]
240127fe:	f000 f992 	bl	24012b26 <QSPI_WaitFlagStateUntilTimeout>
24012802:	4603      	mov	r3, r0
24012804:	73fb      	strb	r3, [r7, #15]
      }

      if (status == HAL_OK)
24012806:	7bfb      	ldrb	r3, [r7, #15]
24012808:	2b00      	cmp	r3, #0
2401280a:	d110      	bne.n	2401282e <HAL_QSPI_Abort+0xe8>
      {
        /* Reset functional mode configuration to indirect write mode by default */
        CLEAR_BIT(hqspi->Instance->CCR, QUADSPI_CCR_FMODE);
2401280c:	687b      	ldr	r3, [r7, #4]
2401280e:	681b      	ldr	r3, [r3, #0]
24012810:	695a      	ldr	r2, [r3, #20]
24012812:	687b      	ldr	r3, [r7, #4]
24012814:	681b      	ldr	r3, [r3, #0]
24012816:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
2401281a:	615a      	str	r2, [r3, #20]
        
        /* Update state */
        hqspi->State = HAL_QSPI_STATE_READY;
2401281c:	687b      	ldr	r3, [r7, #4]
2401281e:	2201      	movs	r2, #1
24012820:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
24012824:	e003      	b.n	2401282e <HAL_QSPI_Abort+0xe8>
      }
    }
    else
    {
      /* Update state */
      hqspi->State = HAL_QSPI_STATE_READY;
24012826:	687b      	ldr	r3, [r7, #4]
24012828:	2201      	movs	r2, #1
2401282a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    }
  }

  return status;
2401282e:	7bfb      	ldrb	r3, [r7, #15]
}
24012830:	4618      	mov	r0, r3
24012832:	3710      	adds	r7, #16
24012834:	46bd      	mov	sp, r7
24012836:	bd80      	pop	{r7, pc}

24012838 <HAL_QSPI_Abort_IT>:
* @brief  Abort the current transmission (non-blocking function)
* @param  hqspi QSPI handle
* @retval HAL status
*/
HAL_StatusTypeDef HAL_QSPI_Abort_IT(QSPI_HandleTypeDef *hqspi)
{
24012838:	b580      	push	{r7, lr}
2401283a:	b084      	sub	sp, #16
2401283c:	af00      	add	r7, sp, #0
2401283e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
24012840:	2300      	movs	r3, #0
24012842:	73fb      	strb	r3, [r7, #15]

  /* Check if the state is in one of the busy states */
  if (((uint32_t)hqspi->State & 0x2U) != 0U)
24012844:	687b      	ldr	r3, [r7, #4]
24012846:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
2401284a:	b2db      	uxtb	r3, r3
2401284c:	f003 0302 	and.w	r3, r3, #2
24012850:	2b00      	cmp	r3, #0
24012852:	d052      	beq.n	240128fa <HAL_QSPI_Abort_IT+0xc2>
  {
    /* Process unlocked */
    __HAL_UNLOCK(hqspi);
24012854:	687b      	ldr	r3, [r7, #4]
24012856:	2200      	movs	r2, #0
24012858:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Update QSPI state */
    hqspi->State = HAL_QSPI_STATE_ABORT;
2401285c:	687b      	ldr	r3, [r7, #4]
2401285e:	2208      	movs	r2, #8
24012860:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable all interrupts */
    __HAL_QSPI_DISABLE_IT(hqspi, (QSPI_IT_TO | QSPI_IT_SM | QSPI_IT_FT | QSPI_IT_TC | QSPI_IT_TE));
24012864:	687b      	ldr	r3, [r7, #4]
24012866:	681b      	ldr	r3, [r3, #0]
24012868:	681a      	ldr	r2, [r3, #0]
2401286a:	687b      	ldr	r3, [r7, #4]
2401286c:	681b      	ldr	r3, [r3, #0]
2401286e:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
24012872:	601a      	str	r2, [r3, #0]

    if ((hqspi->Instance->CR & QUADSPI_CR_DMAEN) != 0U)
24012874:	687b      	ldr	r3, [r7, #4]
24012876:	681b      	ldr	r3, [r3, #0]
24012878:	681b      	ldr	r3, [r3, #0]
2401287a:	f003 0304 	and.w	r3, r3, #4
2401287e:	2b00      	cmp	r3, #0
24012880:	d01b      	beq.n	240128ba <HAL_QSPI_Abort_IT+0x82>
    {
      /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
         but no impact on H7 HW and it minimize the cost in the footprint */
      CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24012882:	687b      	ldr	r3, [r7, #4]
24012884:	681b      	ldr	r3, [r3, #0]
24012886:	681a      	ldr	r2, [r3, #0]
24012888:	687b      	ldr	r3, [r7, #4]
2401288a:	681b      	ldr	r3, [r3, #0]
2401288c:	f022 0204 	bic.w	r2, r2, #4
24012890:	601a      	str	r2, [r3, #0]

      /* Abort MDMA channel */
      hqspi->hmdma->XferAbortCallback = QSPI_DMAAbortCplt;
24012892:	687b      	ldr	r3, [r7, #4]
24012894:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24012896:	4a1b      	ldr	r2, [pc, #108]	; (24012904 <HAL_QSPI_Abort_IT+0xcc>)
24012898:	659a      	str	r2, [r3, #88]	; 0x58
      if (HAL_MDMA_Abort_IT(hqspi->hmdma) != HAL_OK)
2401289a:	687b      	ldr	r3, [r7, #4]
2401289c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
2401289e:	4618      	mov	r0, r3
240128a0:	f7fd fbeb 	bl	2401007a <HAL_MDMA_Abort_IT>
240128a4:	4603      	mov	r3, r0
240128a6:	2b00      	cmp	r3, #0
240128a8:	d027      	beq.n	240128fa <HAL_QSPI_Abort_IT+0xc2>
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
240128aa:	687b      	ldr	r3, [r7, #4]
240128ac:	2201      	movs	r2, #1
240128ae:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

        /* Abort Complete callback */
#if (USE_HAL_QSPI_REGISTER_CALLBACKS == 1)
        hqspi->AbortCpltCallback(hqspi);
#else
        HAL_QSPI_AbortCpltCallback(hqspi);
240128b2:	6878      	ldr	r0, [r7, #4]
240128b4:	f7ff fee7 	bl	24012686 <HAL_QSPI_AbortCpltCallback>
240128b8:	e01f      	b.n	240128fa <HAL_QSPI_Abort_IT+0xc2>
#endif
      }
    }
    else
    {
      if (__HAL_QSPI_GET_FLAG(hqspi, QSPI_FLAG_BUSY) != RESET)
240128ba:	687b      	ldr	r3, [r7, #4]
240128bc:	681b      	ldr	r3, [r3, #0]
240128be:	689b      	ldr	r3, [r3, #8]
240128c0:	f003 0320 	and.w	r3, r3, #32
240128c4:	2b00      	cmp	r3, #0
240128c6:	d014      	beq.n	240128f2 <HAL_QSPI_Abort_IT+0xba>
      {
        /* Clear interrupt */
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
240128c8:	687b      	ldr	r3, [r7, #4]
240128ca:	681b      	ldr	r3, [r3, #0]
240128cc:	2202      	movs	r2, #2
240128ce:	60da      	str	r2, [r3, #12]
        
        /* Enable the QSPI Transfer Complete Interrupt */
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
240128d0:	687b      	ldr	r3, [r7, #4]
240128d2:	681b      	ldr	r3, [r3, #0]
240128d4:	681a      	ldr	r2, [r3, #0]
240128d6:	687b      	ldr	r3, [r7, #4]
240128d8:	681b      	ldr	r3, [r3, #0]
240128da:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
240128de:	601a      	str	r2, [r3, #0]
        
        /* Configure QSPI: CR register with Abort request */
        SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
240128e0:	687b      	ldr	r3, [r7, #4]
240128e2:	681b      	ldr	r3, [r3, #0]
240128e4:	681a      	ldr	r2, [r3, #0]
240128e6:	687b      	ldr	r3, [r7, #4]
240128e8:	681b      	ldr	r3, [r3, #0]
240128ea:	f042 0202 	orr.w	r2, r2, #2
240128ee:	601a      	str	r2, [r3, #0]
240128f0:	e003      	b.n	240128fa <HAL_QSPI_Abort_IT+0xc2>
      }    
      else
      {
        /* Change state of QSPI */
        hqspi->State = HAL_QSPI_STATE_READY;
240128f2:	687b      	ldr	r3, [r7, #4]
240128f4:	2201      	movs	r2, #1
240128f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      }
    }
  }
  return status;
240128fa:	7bfb      	ldrb	r3, [r7, #15]
}
240128fc:	4618      	mov	r0, r3
240128fe:	3710      	adds	r7, #16
24012900:	46bd      	mov	sp, r7
24012902:	bd80      	pop	{r7, pc}
24012904:	24012ac1 	.word	0x24012ac1

24012908 <HAL_QSPI_SetTimeout>:
  * @param  hqspi QSPI handle.
  * @param  Timeout Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
24012908:	b480      	push	{r7}
2401290a:	b083      	sub	sp, #12
2401290c:	af00      	add	r7, sp, #0
2401290e:	6078      	str	r0, [r7, #4]
24012910:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
24012912:	687b      	ldr	r3, [r7, #4]
24012914:	683a      	ldr	r2, [r7, #0]
24012916:	649a      	str	r2, [r3, #72]	; 0x48
}
24012918:	bf00      	nop
2401291a:	370c      	adds	r7, #12
2401291c:	46bd      	mov	sp, r7
2401291e:	f85d 7b04 	ldr.w	r7, [sp], #4
24012922:	4770      	bx	lr

24012924 <HAL_QSPI_SetFifoThreshold>:
  * @param  hqspi QSPI handle.
  * @param  Threshold Threshold of the Fifo (value between 1 and 16).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFifoThreshold(QSPI_HandleTypeDef *hqspi, uint32_t Threshold)
{
24012924:	b480      	push	{r7}
24012926:	b085      	sub	sp, #20
24012928:	af00      	add	r7, sp, #0
2401292a:	6078      	str	r0, [r7, #4]
2401292c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
2401292e:	2300      	movs	r3, #0
24012930:	73fb      	strb	r3, [r7, #15]

  /* Process locked */
  __HAL_LOCK(hqspi);
24012932:	687b      	ldr	r3, [r7, #4]
24012934:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
24012938:	b2db      	uxtb	r3, r3
2401293a:	2b01      	cmp	r3, #1
2401293c:	d101      	bne.n	24012942 <HAL_QSPI_SetFifoThreshold+0x1e>
2401293e:	2302      	movs	r3, #2
24012940:	e021      	b.n	24012986 <HAL_QSPI_SetFifoThreshold+0x62>
24012942:	687b      	ldr	r3, [r7, #4]
24012944:	2201      	movs	r2, #1
24012946:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
2401294a:	687b      	ldr	r3, [r7, #4]
2401294c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012950:	b2db      	uxtb	r3, r3
24012952:	2b01      	cmp	r3, #1
24012954:	d110      	bne.n	24012978 <HAL_QSPI_SetFifoThreshold+0x54>
  {
    /* Synchronize init structure with new FIFO threshold value */
    hqspi->Init.FifoThreshold = Threshold;
24012956:	687b      	ldr	r3, [r7, #4]
24012958:	683a      	ldr	r2, [r7, #0]
2401295a:	609a      	str	r2, [r3, #8]

    /* Configure QSPI FIFO Threshold */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
2401295c:	687b      	ldr	r3, [r7, #4]
2401295e:	681b      	ldr	r3, [r3, #0]
24012960:	681b      	ldr	r3, [r3, #0]
24012962:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
24012966:	687b      	ldr	r3, [r7, #4]
24012968:	689b      	ldr	r3, [r3, #8]
2401296a:	3b01      	subs	r3, #1
2401296c:	021a      	lsls	r2, r3, #8
2401296e:	687b      	ldr	r3, [r7, #4]
24012970:	681b      	ldr	r3, [r3, #0]
24012972:	430a      	orrs	r2, r1
24012974:	601a      	str	r2, [r3, #0]
24012976:	e001      	b.n	2401297c <HAL_QSPI_SetFifoThreshold+0x58>
               ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));
  }
  else
  {
    status = HAL_BUSY;
24012978:	2302      	movs	r3, #2
2401297a:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
2401297c:	687b      	ldr	r3, [r7, #4]
2401297e:	2200      	movs	r2, #0
24012980:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24012984:	7bfb      	ldrb	r3, [r7, #15]
}
24012986:	4618      	mov	r0, r3
24012988:	3714      	adds	r7, #20
2401298a:	46bd      	mov	sp, r7
2401298c:	f85d 7b04 	ldr.w	r7, [sp], #4
24012990:	4770      	bx	lr

24012992 <HAL_QSPI_GetFifoThreshold>:
/** @brief Get QSPI Fifo threshold.
  * @param  hqspi QSPI handle.
  * @retval Fifo threshold (value between 1 and 16)
  */
uint32_t HAL_QSPI_GetFifoThreshold(QSPI_HandleTypeDef *hqspi)
{
24012992:	b480      	push	{r7}
24012994:	b083      	sub	sp, #12
24012996:	af00      	add	r7, sp, #0
24012998:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(hqspi->Instance->CR, QUADSPI_CR_FTHRES) >> QUADSPI_CR_FTHRES_Pos) + 1U);
2401299a:	687b      	ldr	r3, [r7, #4]
2401299c:	681b      	ldr	r3, [r3, #0]
2401299e:	681b      	ldr	r3, [r3, #0]
240129a0:	0a1b      	lsrs	r3, r3, #8
240129a2:	f003 030f 	and.w	r3, r3, #15
240129a6:	3301      	adds	r3, #1
}
240129a8:	4618      	mov	r0, r3
240129aa:	370c      	adds	r7, #12
240129ac:	46bd      	mov	sp, r7
240129ae:	f85d 7b04 	ldr.w	r7, [sp], #4
240129b2:	4770      	bx	lr

240129b4 <HAL_QSPI_SetFlashID>:
  *                   This parameter can be a value of @ref QSPI_Flash_Select.
  * @note   The FlashID is ignored when dual flash mode is enabled.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_SetFlashID(QSPI_HandleTypeDef *hqspi, uint32_t FlashID)
{
240129b4:	b480      	push	{r7}
240129b6:	b085      	sub	sp, #20
240129b8:	af00      	add	r7, sp, #0
240129ba:	6078      	str	r0, [r7, #4]
240129bc:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
240129be:	2300      	movs	r3, #0
240129c0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameter */
  assert_param(IS_QSPI_FLASH_ID(FlashID));

  /* Process locked */
  __HAL_LOCK(hqspi);
240129c2:	687b      	ldr	r3, [r7, #4]
240129c4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
240129c8:	b2db      	uxtb	r3, r3
240129ca:	2b01      	cmp	r3, #1
240129cc:	d101      	bne.n	240129d2 <HAL_QSPI_SetFlashID+0x1e>
240129ce:	2302      	movs	r3, #2
240129d0:	e01e      	b.n	24012a10 <HAL_QSPI_SetFlashID+0x5c>
240129d2:	687b      	ldr	r3, [r7, #4]
240129d4:	2201      	movs	r2, #1
240129d6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  if(hqspi->State == HAL_QSPI_STATE_READY)
240129da:	687b      	ldr	r3, [r7, #4]
240129dc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
240129e0:	b2db      	uxtb	r3, r3
240129e2:	2b01      	cmp	r3, #1
240129e4:	d10d      	bne.n	24012a02 <HAL_QSPI_SetFlashID+0x4e>
  {
    /* Synchronize init structure with new FlashID value */
    hqspi->Init.FlashID = FlashID;
240129e6:	687b      	ldr	r3, [r7, #4]
240129e8:	683a      	ldr	r2, [r7, #0]
240129ea:	61da      	str	r2, [r3, #28]

    /* Configure QSPI FlashID */
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FSEL, FlashID);
240129ec:	687b      	ldr	r3, [r7, #4]
240129ee:	681b      	ldr	r3, [r3, #0]
240129f0:	681b      	ldr	r3, [r3, #0]
240129f2:	f023 0180 	bic.w	r1, r3, #128	; 0x80
240129f6:	687b      	ldr	r3, [r7, #4]
240129f8:	681b      	ldr	r3, [r3, #0]
240129fa:	683a      	ldr	r2, [r7, #0]
240129fc:	430a      	orrs	r2, r1
240129fe:	601a      	str	r2, [r3, #0]
24012a00:	e001      	b.n	24012a06 <HAL_QSPI_SetFlashID+0x52>
  }
  else
  {
    status = HAL_BUSY;
24012a02:	2302      	movs	r3, #2
24012a04:	73fb      	strb	r3, [r7, #15]
  }

  /* Process unlocked */
  __HAL_UNLOCK(hqspi);
24012a06:	687b      	ldr	r3, [r7, #4]
24012a08:	2200      	movs	r2, #0
24012a0a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  /* Return function status */
  return status;
24012a0e:	7bfb      	ldrb	r3, [r7, #15]
}
24012a10:	4618      	mov	r0, r3
24012a12:	3714      	adds	r7, #20
24012a14:	46bd      	mov	sp, r7
24012a16:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a1a:	4770      	bx	lr

24012a1c <QSPI_DMARxCplt>:
  * @brief  DMA QSPI receive process complete callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMARxCplt(MDMA_HandleTypeDef *hmdma)
{
24012a1c:	b480      	push	{r7}
24012a1e:	b085      	sub	sp, #20
24012a20:	af00      	add	r7, sp, #0
24012a22:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
24012a24:	687b      	ldr	r3, [r7, #4]
24012a26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012a28:	60fb      	str	r3, [r7, #12]
  hqspi->RxXferCount = 0U;
24012a2a:	68fb      	ldr	r3, [r7, #12]
24012a2c:	2200      	movs	r2, #0
24012a2e:	639a      	str	r2, [r3, #56]	; 0x38

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24012a30:	68fb      	ldr	r3, [r7, #12]
24012a32:	681b      	ldr	r3, [r3, #0]
24012a34:	681a      	ldr	r2, [r3, #0]
24012a36:	68fb      	ldr	r3, [r7, #12]
24012a38:	681b      	ldr	r3, [r3, #0]
24012a3a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24012a3e:	601a      	str	r2, [r3, #0]
}
24012a40:	bf00      	nop
24012a42:	3714      	adds	r7, #20
24012a44:	46bd      	mov	sp, r7
24012a46:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a4a:	4770      	bx	lr

24012a4c <QSPI_DMATxCplt>:
  * @brief  DMA QSPI transmit process complete callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMATxCplt(MDMA_HandleTypeDef *hmdma)
{
24012a4c:	b480      	push	{r7}
24012a4e:	b085      	sub	sp, #20
24012a50:	af00      	add	r7, sp, #0
24012a52:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = (QSPI_HandleTypeDef*)(hmdma->Parent);
24012a54:	687b      	ldr	r3, [r7, #4]
24012a56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012a58:	60fb      	str	r3, [r7, #12]
  hqspi->TxXferCount = 0U;
24012a5a:	68fb      	ldr	r3, [r7, #12]
24012a5c:	2200      	movs	r2, #0
24012a5e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the QSPI transfer complete Interrupt */
  __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24012a60:	68fb      	ldr	r3, [r7, #12]
24012a62:	681b      	ldr	r3, [r3, #0]
24012a64:	681a      	ldr	r2, [r3, #0]
24012a66:	68fb      	ldr	r3, [r7, #12]
24012a68:	681b      	ldr	r3, [r3, #0]
24012a6a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24012a6e:	601a      	str	r2, [r3, #0]
}
24012a70:	bf00      	nop
24012a72:	3714      	adds	r7, #20
24012a74:	46bd      	mov	sp, r7
24012a76:	f85d 7b04 	ldr.w	r7, [sp], #4
24012a7a:	4770      	bx	lr

24012a7c <QSPI_DMAError>:
  * @brief  DMA QSPI communication error callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMAError(MDMA_HandleTypeDef *hmdma)
{
24012a7c:	b580      	push	{r7, lr}
24012a7e:	b084      	sub	sp, #16
24012a80:	af00      	add	r7, sp, #0
24012a82:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24012a84:	687b      	ldr	r3, [r7, #4]
24012a86:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012a88:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
24012a8a:	68fb      	ldr	r3, [r7, #12]
24012a8c:	2200      	movs	r2, #0
24012a8e:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24012a90:	68fb      	ldr	r3, [r7, #12]
24012a92:	2200      	movs	r2, #0
24012a94:	62da      	str	r2, [r3, #44]	; 0x2c
  hqspi->ErrorCode   |= HAL_QSPI_ERROR_DMA;
24012a96:	68fb      	ldr	r3, [r7, #12]
24012a98:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012a9a:	f043 0204 	orr.w	r2, r3, #4
24012a9e:	68fb      	ldr	r3, [r7, #12]
24012aa0:	645a      	str	r2, [r3, #68]	; 0x44

  /* Disable using MDMA by clearing DMAEN, note that DMAEN bit is "reserved"
     but no impact on H7 HW and it minimize the cost in the footprint */
  CLEAR_BIT(hqspi->Instance->CR, QUADSPI_CR_DMAEN);
24012aa2:	68fb      	ldr	r3, [r7, #12]
24012aa4:	681b      	ldr	r3, [r3, #0]
24012aa6:	681a      	ldr	r2, [r3, #0]
24012aa8:	68fb      	ldr	r3, [r7, #12]
24012aaa:	681b      	ldr	r3, [r3, #0]
24012aac:	f022 0204 	bic.w	r2, r2, #4
24012ab0:	601a      	str	r2, [r3, #0]

  /* Abort the QSPI */
  (void)HAL_QSPI_Abort_IT(hqspi);
24012ab2:	68f8      	ldr	r0, [r7, #12]
24012ab4:	f7ff fec0 	bl	24012838 <HAL_QSPI_Abort_IT>

}
24012ab8:	bf00      	nop
24012aba:	3710      	adds	r7, #16
24012abc:	46bd      	mov	sp, r7
24012abe:	bd80      	pop	{r7, pc}

24012ac0 <QSPI_DMAAbortCplt>:
  * @brief  MDMA QSPI abort complete callback.
  * @param  hmdma MDMA handle
  * @retval None
  */
static void QSPI_DMAAbortCplt(MDMA_HandleTypeDef *hmdma)
{
24012ac0:	b580      	push	{r7, lr}
24012ac2:	b084      	sub	sp, #16
24012ac4:	af00      	add	r7, sp, #0
24012ac6:	6078      	str	r0, [r7, #4]
  QSPI_HandleTypeDef* hqspi = ( QSPI_HandleTypeDef* )(hmdma->Parent);
24012ac8:	687b      	ldr	r3, [r7, #4]
24012aca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24012acc:	60fb      	str	r3, [r7, #12]

  hqspi->RxXferCount = 0U;
24012ace:	68fb      	ldr	r3, [r7, #12]
24012ad0:	2200      	movs	r2, #0
24012ad2:	639a      	str	r2, [r3, #56]	; 0x38
  hqspi->TxXferCount = 0U;
24012ad4:	68fb      	ldr	r3, [r7, #12]
24012ad6:	2200      	movs	r2, #0
24012ad8:	62da      	str	r2, [r3, #44]	; 0x2c

  if(hqspi->State == HAL_QSPI_STATE_ABORT)
24012ada:	68fb      	ldr	r3, [r7, #12]
24012adc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
24012ae0:	b2db      	uxtb	r3, r3
24012ae2:	2b08      	cmp	r3, #8
24012ae4:	d114      	bne.n	24012b10 <QSPI_DMAAbortCplt+0x50>
  {
    /* MDMA Abort called by QSPI abort */
    /* Clear interrupt */
    __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
24012ae6:	68fb      	ldr	r3, [r7, #12]
24012ae8:	681b      	ldr	r3, [r3, #0]
24012aea:	2202      	movs	r2, #2
24012aec:	60da      	str	r2, [r3, #12]

    /* Enable the QSPI Transfer Complete Interrupt */
    __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TC);
24012aee:	68fb      	ldr	r3, [r7, #12]
24012af0:	681b      	ldr	r3, [r3, #0]
24012af2:	681a      	ldr	r2, [r3, #0]
24012af4:	68fb      	ldr	r3, [r7, #12]
24012af6:	681b      	ldr	r3, [r3, #0]
24012af8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
24012afc:	601a      	str	r2, [r3, #0]

    /* Configure QSPI: CR register with Abort request */
    SET_BIT(hqspi->Instance->CR, QUADSPI_CR_ABORT);
24012afe:	68fb      	ldr	r3, [r7, #12]
24012b00:	681b      	ldr	r3, [r3, #0]
24012b02:	681a      	ldr	r2, [r3, #0]
24012b04:	68fb      	ldr	r3, [r7, #12]
24012b06:	681b      	ldr	r3, [r3, #0]
24012b08:	f042 0202 	orr.w	r2, r2, #2
24012b0c:	601a      	str	r2, [r3, #0]
    hqspi->ErrorCallback(hqspi);
#else
    HAL_QSPI_ErrorCallback(hqspi);
#endif
  }
}
24012b0e:	e006      	b.n	24012b1e <QSPI_DMAAbortCplt+0x5e>
    hqspi->State = HAL_QSPI_STATE_READY;
24012b10:	68fb      	ldr	r3, [r7, #12]
24012b12:	2201      	movs	r2, #1
24012b14:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    HAL_QSPI_ErrorCallback(hqspi);
24012b18:	68f8      	ldr	r0, [r7, #12]
24012b1a:	f7ff fdaa 	bl	24012672 <HAL_QSPI_ErrorCallback>
}
24012b1e:	bf00      	nop
24012b20:	3710      	adds	r7, #16
24012b22:	46bd      	mov	sp, r7
24012b24:	bd80      	pop	{r7, pc}

24012b26 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
24012b26:	b580      	push	{r7, lr}
24012b28:	b084      	sub	sp, #16
24012b2a:	af00      	add	r7, sp, #0
24012b2c:	60f8      	str	r0, [r7, #12]
24012b2e:	60b9      	str	r1, [r7, #8]
24012b30:	603b      	str	r3, [r7, #0]
24012b32:	4613      	mov	r3, r2
24012b34:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
24012b36:	e01a      	b.n	24012b6e <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
24012b38:	69bb      	ldr	r3, [r7, #24]
24012b3a:	f1b3 3fff 	cmp.w	r3, #4294967295
24012b3e:	d016      	beq.n	24012b6e <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
24012b40:	f7ef fc00 	bl	24002344 <HAL_GetTick>
24012b44:	4602      	mov	r2, r0
24012b46:	683b      	ldr	r3, [r7, #0]
24012b48:	1ad3      	subs	r3, r2, r3
24012b4a:	69ba      	ldr	r2, [r7, #24]
24012b4c:	429a      	cmp	r2, r3
24012b4e:	d302      	bcc.n	24012b56 <QSPI_WaitFlagStateUntilTimeout+0x30>
24012b50:	69bb      	ldr	r3, [r7, #24]
24012b52:	2b00      	cmp	r3, #0
24012b54:	d10b      	bne.n	24012b6e <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
24012b56:	68fb      	ldr	r3, [r7, #12]
24012b58:	2204      	movs	r2, #4
24012b5a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
24012b5e:	68fb      	ldr	r3, [r7, #12]
24012b60:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24012b62:	f043 0201 	orr.w	r2, r3, #1
24012b66:	68fb      	ldr	r3, [r7, #12]
24012b68:	645a      	str	r2, [r3, #68]	; 0x44

        return HAL_ERROR;
24012b6a:	2301      	movs	r3, #1
24012b6c:	e00e      	b.n	24012b8c <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
24012b6e:	68fb      	ldr	r3, [r7, #12]
24012b70:	681b      	ldr	r3, [r3, #0]
24012b72:	689a      	ldr	r2, [r3, #8]
24012b74:	68bb      	ldr	r3, [r7, #8]
24012b76:	4013      	ands	r3, r2
24012b78:	2b00      	cmp	r3, #0
24012b7a:	bf14      	ite	ne
24012b7c:	2301      	movne	r3, #1
24012b7e:	2300      	moveq	r3, #0
24012b80:	b2db      	uxtb	r3, r3
24012b82:	461a      	mov	r2, r3
24012b84:	79fb      	ldrb	r3, [r7, #7]
24012b86:	429a      	cmp	r2, r3
24012b88:	d1d6      	bne.n	24012b38 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
24012b8a:	2300      	movs	r3, #0
}
24012b8c:	4618      	mov	r0, r3
24012b8e:	3710      	adds	r7, #16
24012b90:	46bd      	mov	sp, r7
24012b92:	bd80      	pop	{r7, pc}

24012b94 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
24012b94:	b480      	push	{r7}
24012b96:	b085      	sub	sp, #20
24012b98:	af00      	add	r7, sp, #0
24012b9a:	60f8      	str	r0, [r7, #12]
24012b9c:	60b9      	str	r1, [r7, #8]
24012b9e:	607a      	str	r2, [r7, #4]
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
24012ba0:	68bb      	ldr	r3, [r7, #8]
24012ba2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012ba4:	2b00      	cmp	r3, #0
24012ba6:	d009      	beq.n	24012bbc <QSPI_Config+0x28>
24012ba8:	687b      	ldr	r3, [r7, #4]
24012baa:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24012bae:	d005      	beq.n	24012bbc <QSPI_Config+0x28>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
24012bb0:	68bb      	ldr	r3, [r7, #8]
24012bb2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
24012bb4:	68fb      	ldr	r3, [r7, #12]
24012bb6:	681b      	ldr	r3, [r3, #0]
24012bb8:	3a01      	subs	r2, #1
24012bba:	611a      	str	r2, [r3, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
24012bbc:	68bb      	ldr	r3, [r7, #8]
24012bbe:	699b      	ldr	r3, [r3, #24]
24012bc0:	2b00      	cmp	r3, #0
24012bc2:	f000 80b9 	beq.w	24012d38 <QSPI_Config+0x1a4>
  {
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
24012bc6:	68bb      	ldr	r3, [r7, #8]
24012bc8:	6a1b      	ldr	r3, [r3, #32]
24012bca:	2b00      	cmp	r3, #0
24012bcc:	d05f      	beq.n	24012c8e <QSPI_Config+0xfa>
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24012bce:	68fb      	ldr	r3, [r7, #12]
24012bd0:	681b      	ldr	r3, [r3, #0]
24012bd2:	68ba      	ldr	r2, [r7, #8]
24012bd4:	6892      	ldr	r2, [r2, #8]
24012bd6:	61da      	str	r2, [r3, #28]

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24012bd8:	68bb      	ldr	r3, [r7, #8]
24012bda:	69db      	ldr	r3, [r3, #28]
24012bdc:	2b00      	cmp	r3, #0
24012bde:	d031      	beq.n	24012c44 <QSPI_Config+0xb0>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012be0:	68bb      	ldr	r3, [r7, #8]
24012be2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012be4:	68bb      	ldr	r3, [r7, #8]
24012be6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012be8:	431a      	orrs	r2, r3
24012bea:	68bb      	ldr	r3, [r7, #8]
24012bec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012bee:	431a      	orrs	r2, r3
24012bf0:	68bb      	ldr	r3, [r7, #8]
24012bf2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012bf4:	431a      	orrs	r2, r3
24012bf6:	68bb      	ldr	r3, [r7, #8]
24012bf8:	695b      	ldr	r3, [r3, #20]
24012bfa:	049b      	lsls	r3, r3, #18
24012bfc:	431a      	orrs	r2, r3
24012bfe:	68bb      	ldr	r3, [r7, #8]
24012c00:	691b      	ldr	r3, [r3, #16]
24012c02:	431a      	orrs	r2, r3
24012c04:	68bb      	ldr	r3, [r7, #8]
24012c06:	6a1b      	ldr	r3, [r3, #32]
24012c08:	431a      	orrs	r2, r3
24012c0a:	68bb      	ldr	r3, [r7, #8]
24012c0c:	68db      	ldr	r3, [r3, #12]
24012c0e:	431a      	orrs	r2, r3
24012c10:	68bb      	ldr	r3, [r7, #8]
24012c12:	69db      	ldr	r3, [r3, #28]
24012c14:	431a      	orrs	r2, r3
24012c16:	68bb      	ldr	r3, [r7, #8]
24012c18:	699b      	ldr	r3, [r3, #24]
24012c1a:	431a      	orrs	r2, r3
24012c1c:	68bb      	ldr	r3, [r7, #8]
24012c1e:	681b      	ldr	r3, [r3, #0]
24012c20:	ea42 0103 	orr.w	r1, r2, r3
24012c24:	68fb      	ldr	r3, [r7, #12]
24012c26:	681b      	ldr	r3, [r3, #0]
24012c28:	687a      	ldr	r2, [r7, #4]
24012c2a:	430a      	orrs	r2, r1
24012c2c:	615a      	str	r2, [r3, #20]
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateBytesSize | cmd->AlternateByteMode |
                                         cmd->AddressSize | cmd->AddressMode | cmd->InstructionMode |
                                         cmd->Instruction | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24012c2e:	687b      	ldr	r3, [r7, #4]
24012c30:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24012c34:	f000 812e 	beq.w	24012e94 <QSPI_Config+0x300>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24012c38:	68fb      	ldr	r3, [r7, #12]
24012c3a:	681b      	ldr	r3, [r3, #0]
24012c3c:	68ba      	ldr	r2, [r7, #8]
24012c3e:	6852      	ldr	r2, [r2, #4]
24012c40:	619a      	str	r2, [r3, #24]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
24012c42:	e127      	b.n	24012e94 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012c44:	68bb      	ldr	r3, [r7, #8]
24012c46:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012c48:	68bb      	ldr	r3, [r7, #8]
24012c4a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012c4c:	431a      	orrs	r2, r3
24012c4e:	68bb      	ldr	r3, [r7, #8]
24012c50:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012c52:	431a      	orrs	r2, r3
24012c54:	68bb      	ldr	r3, [r7, #8]
24012c56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012c58:	431a      	orrs	r2, r3
24012c5a:	68bb      	ldr	r3, [r7, #8]
24012c5c:	695b      	ldr	r3, [r3, #20]
24012c5e:	049b      	lsls	r3, r3, #18
24012c60:	431a      	orrs	r2, r3
24012c62:	68bb      	ldr	r3, [r7, #8]
24012c64:	691b      	ldr	r3, [r3, #16]
24012c66:	431a      	orrs	r2, r3
24012c68:	68bb      	ldr	r3, [r7, #8]
24012c6a:	6a1b      	ldr	r3, [r3, #32]
24012c6c:	431a      	orrs	r2, r3
24012c6e:	68bb      	ldr	r3, [r7, #8]
24012c70:	69db      	ldr	r3, [r3, #28]
24012c72:	431a      	orrs	r2, r3
24012c74:	68bb      	ldr	r3, [r7, #8]
24012c76:	699b      	ldr	r3, [r3, #24]
24012c78:	431a      	orrs	r2, r3
24012c7a:	68bb      	ldr	r3, [r7, #8]
24012c7c:	681b      	ldr	r3, [r3, #0]
24012c7e:	ea42 0103 	orr.w	r1, r2, r3
24012c82:	68fb      	ldr	r3, [r7, #12]
24012c84:	681b      	ldr	r3, [r3, #0]
24012c86:	687a      	ldr	r2, [r7, #4]
24012c88:	430a      	orrs	r2, r1
24012c8a:	615a      	str	r2, [r3, #20]
}
24012c8c:	e102      	b.n	24012e94 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24012c8e:	68bb      	ldr	r3, [r7, #8]
24012c90:	69db      	ldr	r3, [r3, #28]
24012c92:	2b00      	cmp	r3, #0
24012c94:	d02e      	beq.n	24012cf4 <QSPI_Config+0x160>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012c96:	68bb      	ldr	r3, [r7, #8]
24012c98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012c9a:	68bb      	ldr	r3, [r7, #8]
24012c9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012c9e:	431a      	orrs	r2, r3
24012ca0:	68bb      	ldr	r3, [r7, #8]
24012ca2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012ca4:	431a      	orrs	r2, r3
24012ca6:	68bb      	ldr	r3, [r7, #8]
24012ca8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012caa:	431a      	orrs	r2, r3
24012cac:	68bb      	ldr	r3, [r7, #8]
24012cae:	695b      	ldr	r3, [r3, #20]
24012cb0:	049b      	lsls	r3, r3, #18
24012cb2:	431a      	orrs	r2, r3
24012cb4:	68bb      	ldr	r3, [r7, #8]
24012cb6:	6a1b      	ldr	r3, [r3, #32]
24012cb8:	431a      	orrs	r2, r3
24012cba:	68bb      	ldr	r3, [r7, #8]
24012cbc:	68db      	ldr	r3, [r3, #12]
24012cbe:	431a      	orrs	r2, r3
24012cc0:	68bb      	ldr	r3, [r7, #8]
24012cc2:	69db      	ldr	r3, [r3, #28]
24012cc4:	431a      	orrs	r2, r3
24012cc6:	68bb      	ldr	r3, [r7, #8]
24012cc8:	699b      	ldr	r3, [r3, #24]
24012cca:	431a      	orrs	r2, r3
24012ccc:	68bb      	ldr	r3, [r7, #8]
24012cce:	681b      	ldr	r3, [r3, #0]
24012cd0:	ea42 0103 	orr.w	r1, r2, r3
24012cd4:	68fb      	ldr	r3, [r7, #12]
24012cd6:	681b      	ldr	r3, [r3, #0]
24012cd8:	687a      	ldr	r2, [r7, #4]
24012cda:	430a      	orrs	r2, r1
24012cdc:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24012cde:	687b      	ldr	r3, [r7, #4]
24012ce0:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24012ce4:	f000 80d6 	beq.w	24012e94 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24012ce8:	68fb      	ldr	r3, [r7, #12]
24012cea:	681b      	ldr	r3, [r3, #0]
24012cec:	68ba      	ldr	r2, [r7, #8]
24012cee:	6852      	ldr	r2, [r2, #4]
24012cf0:	619a      	str	r2, [r3, #24]
}
24012cf2:	e0cf      	b.n	24012e94 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012cf4:	68bb      	ldr	r3, [r7, #8]
24012cf6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012cf8:	68bb      	ldr	r3, [r7, #8]
24012cfa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012cfc:	431a      	orrs	r2, r3
24012cfe:	68bb      	ldr	r3, [r7, #8]
24012d00:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012d02:	431a      	orrs	r2, r3
24012d04:	68bb      	ldr	r3, [r7, #8]
24012d06:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012d08:	431a      	orrs	r2, r3
24012d0a:	68bb      	ldr	r3, [r7, #8]
24012d0c:	695b      	ldr	r3, [r3, #20]
24012d0e:	049b      	lsls	r3, r3, #18
24012d10:	431a      	orrs	r2, r3
24012d12:	68bb      	ldr	r3, [r7, #8]
24012d14:	6a1b      	ldr	r3, [r3, #32]
24012d16:	431a      	orrs	r2, r3
24012d18:	68bb      	ldr	r3, [r7, #8]
24012d1a:	69db      	ldr	r3, [r3, #28]
24012d1c:	431a      	orrs	r2, r3
24012d1e:	68bb      	ldr	r3, [r7, #8]
24012d20:	699b      	ldr	r3, [r3, #24]
24012d22:	431a      	orrs	r2, r3
24012d24:	68bb      	ldr	r3, [r7, #8]
24012d26:	681b      	ldr	r3, [r3, #0]
24012d28:	ea42 0103 	orr.w	r1, r2, r3
24012d2c:	68fb      	ldr	r3, [r7, #12]
24012d2e:	681b      	ldr	r3, [r3, #0]
24012d30:	687a      	ldr	r2, [r7, #4]
24012d32:	430a      	orrs	r2, r1
24012d34:	615a      	str	r2, [r3, #20]
}
24012d36:	e0ad      	b.n	24012e94 <QSPI_Config+0x300>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
24012d38:	68bb      	ldr	r3, [r7, #8]
24012d3a:	6a1b      	ldr	r3, [r3, #32]
24012d3c:	2b00      	cmp	r3, #0
24012d3e:	d058      	beq.n	24012df2 <QSPI_Config+0x25e>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
24012d40:	68fb      	ldr	r3, [r7, #12]
24012d42:	681b      	ldr	r3, [r3, #0]
24012d44:	68ba      	ldr	r2, [r7, #8]
24012d46:	6892      	ldr	r2, [r2, #8]
24012d48:	61da      	str	r2, [r3, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24012d4a:	68bb      	ldr	r3, [r7, #8]
24012d4c:	69db      	ldr	r3, [r3, #28]
24012d4e:	2b00      	cmp	r3, #0
24012d50:	d02d      	beq.n	24012dae <QSPI_Config+0x21a>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012d52:	68bb      	ldr	r3, [r7, #8]
24012d54:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012d56:	68bb      	ldr	r3, [r7, #8]
24012d58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012d5a:	431a      	orrs	r2, r3
24012d5c:	68bb      	ldr	r3, [r7, #8]
24012d5e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012d60:	431a      	orrs	r2, r3
24012d62:	68bb      	ldr	r3, [r7, #8]
24012d64:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012d66:	431a      	orrs	r2, r3
24012d68:	68bb      	ldr	r3, [r7, #8]
24012d6a:	695b      	ldr	r3, [r3, #20]
24012d6c:	049b      	lsls	r3, r3, #18
24012d6e:	431a      	orrs	r2, r3
24012d70:	68bb      	ldr	r3, [r7, #8]
24012d72:	691b      	ldr	r3, [r3, #16]
24012d74:	431a      	orrs	r2, r3
24012d76:	68bb      	ldr	r3, [r7, #8]
24012d78:	6a1b      	ldr	r3, [r3, #32]
24012d7a:	431a      	orrs	r2, r3
24012d7c:	68bb      	ldr	r3, [r7, #8]
24012d7e:	68db      	ldr	r3, [r3, #12]
24012d80:	431a      	orrs	r2, r3
24012d82:	68bb      	ldr	r3, [r7, #8]
24012d84:	69db      	ldr	r3, [r3, #28]
24012d86:	431a      	orrs	r2, r3
24012d88:	68bb      	ldr	r3, [r7, #8]
24012d8a:	699b      	ldr	r3, [r3, #24]
24012d8c:	ea42 0103 	orr.w	r1, r2, r3
24012d90:	68fb      	ldr	r3, [r7, #12]
24012d92:	681b      	ldr	r3, [r3, #0]
24012d94:	687a      	ldr	r2, [r7, #4]
24012d96:	430a      	orrs	r2, r1
24012d98:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24012d9a:	687b      	ldr	r3, [r7, #4]
24012d9c:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24012da0:	d078      	beq.n	24012e94 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24012da2:	68fb      	ldr	r3, [r7, #12]
24012da4:	681b      	ldr	r3, [r3, #0]
24012da6:	68ba      	ldr	r2, [r7, #8]
24012da8:	6852      	ldr	r2, [r2, #4]
24012daa:	619a      	str	r2, [r3, #24]
}
24012dac:	e072      	b.n	24012e94 <QSPI_Config+0x300>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012dae:	68bb      	ldr	r3, [r7, #8]
24012db0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012db2:	68bb      	ldr	r3, [r7, #8]
24012db4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012db6:	431a      	orrs	r2, r3
24012db8:	68bb      	ldr	r3, [r7, #8]
24012dba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012dbc:	431a      	orrs	r2, r3
24012dbe:	68bb      	ldr	r3, [r7, #8]
24012dc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012dc2:	431a      	orrs	r2, r3
24012dc4:	68bb      	ldr	r3, [r7, #8]
24012dc6:	695b      	ldr	r3, [r3, #20]
24012dc8:	049b      	lsls	r3, r3, #18
24012dca:	431a      	orrs	r2, r3
24012dcc:	68bb      	ldr	r3, [r7, #8]
24012dce:	691b      	ldr	r3, [r3, #16]
24012dd0:	431a      	orrs	r2, r3
24012dd2:	68bb      	ldr	r3, [r7, #8]
24012dd4:	6a1b      	ldr	r3, [r3, #32]
24012dd6:	431a      	orrs	r2, r3
24012dd8:	68bb      	ldr	r3, [r7, #8]
24012dda:	69db      	ldr	r3, [r3, #28]
24012ddc:	431a      	orrs	r2, r3
24012dde:	68bb      	ldr	r3, [r7, #8]
24012de0:	699b      	ldr	r3, [r3, #24]
24012de2:	ea42 0103 	orr.w	r1, r2, r3
24012de6:	68fb      	ldr	r3, [r7, #12]
24012de8:	681b      	ldr	r3, [r3, #0]
24012dea:	687a      	ldr	r2, [r7, #4]
24012dec:	430a      	orrs	r2, r1
24012dee:	615a      	str	r2, [r3, #20]
}
24012df0:	e050      	b.n	24012e94 <QSPI_Config+0x300>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
24012df2:	68bb      	ldr	r3, [r7, #8]
24012df4:	69db      	ldr	r3, [r3, #28]
24012df6:	2b00      	cmp	r3, #0
24012df8:	d02a      	beq.n	24012e50 <QSPI_Config+0x2bc>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012dfa:	68bb      	ldr	r3, [r7, #8]
24012dfc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012dfe:	68bb      	ldr	r3, [r7, #8]
24012e00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012e02:	431a      	orrs	r2, r3
24012e04:	68bb      	ldr	r3, [r7, #8]
24012e06:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012e08:	431a      	orrs	r2, r3
24012e0a:	68bb      	ldr	r3, [r7, #8]
24012e0c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012e0e:	431a      	orrs	r2, r3
24012e10:	68bb      	ldr	r3, [r7, #8]
24012e12:	695b      	ldr	r3, [r3, #20]
24012e14:	049b      	lsls	r3, r3, #18
24012e16:	431a      	orrs	r2, r3
24012e18:	68bb      	ldr	r3, [r7, #8]
24012e1a:	6a1b      	ldr	r3, [r3, #32]
24012e1c:	431a      	orrs	r2, r3
24012e1e:	68bb      	ldr	r3, [r7, #8]
24012e20:	68db      	ldr	r3, [r3, #12]
24012e22:	431a      	orrs	r2, r3
24012e24:	68bb      	ldr	r3, [r7, #8]
24012e26:	69db      	ldr	r3, [r3, #28]
24012e28:	431a      	orrs	r2, r3
24012e2a:	68bb      	ldr	r3, [r7, #8]
24012e2c:	699b      	ldr	r3, [r3, #24]
24012e2e:	ea42 0103 	orr.w	r1, r2, r3
24012e32:	68fb      	ldr	r3, [r7, #12]
24012e34:	681b      	ldr	r3, [r3, #0]
24012e36:	687a      	ldr	r2, [r7, #4]
24012e38:	430a      	orrs	r2, r1
24012e3a:	615a      	str	r2, [r3, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
24012e3c:	687b      	ldr	r3, [r7, #4]
24012e3e:	f1b3 6f40 	cmp.w	r3, #201326592	; 0xc000000
24012e42:	d027      	beq.n	24012e94 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
24012e44:	68fb      	ldr	r3, [r7, #12]
24012e46:	681b      	ldr	r3, [r3, #0]
24012e48:	68ba      	ldr	r2, [r7, #8]
24012e4a:	6852      	ldr	r2, [r2, #4]
24012e4c:	619a      	str	r2, [r3, #24]
}
24012e4e:	e021      	b.n	24012e94 <QSPI_Config+0x300>
        if (cmd->DataMode != QSPI_DATA_NONE)
24012e50:	68bb      	ldr	r3, [r7, #8]
24012e52:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012e54:	2b00      	cmp	r3, #0
24012e56:	d01d      	beq.n	24012e94 <QSPI_Config+0x300>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
24012e58:	68bb      	ldr	r3, [r7, #8]
24012e5a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
24012e5c:	68bb      	ldr	r3, [r7, #8]
24012e5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24012e60:	431a      	orrs	r2, r3
24012e62:	68bb      	ldr	r3, [r7, #8]
24012e64:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24012e66:	431a      	orrs	r2, r3
24012e68:	68bb      	ldr	r3, [r7, #8]
24012e6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24012e6c:	431a      	orrs	r2, r3
24012e6e:	68bb      	ldr	r3, [r7, #8]
24012e70:	695b      	ldr	r3, [r3, #20]
24012e72:	049b      	lsls	r3, r3, #18
24012e74:	431a      	orrs	r2, r3
24012e76:	68bb      	ldr	r3, [r7, #8]
24012e78:	6a1b      	ldr	r3, [r3, #32]
24012e7a:	431a      	orrs	r2, r3
24012e7c:	68bb      	ldr	r3, [r7, #8]
24012e7e:	69db      	ldr	r3, [r3, #28]
24012e80:	431a      	orrs	r2, r3
24012e82:	68bb      	ldr	r3, [r7, #8]
24012e84:	699b      	ldr	r3, [r3, #24]
24012e86:	ea42 0103 	orr.w	r1, r2, r3
24012e8a:	68fb      	ldr	r3, [r7, #12]
24012e8c:	681b      	ldr	r3, [r3, #0]
24012e8e:	687a      	ldr	r2, [r7, #4]
24012e90:	430a      	orrs	r2, r1
24012e92:	615a      	str	r2, [r3, #20]
}
24012e94:	bf00      	nop
24012e96:	3714      	adds	r7, #20
24012e98:	46bd      	mov	sp, r7
24012e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
24012e9e:	4770      	bx	lr

24012ea0 <HAL_RCC_DeInit>:
  *            - Peripheral clocks
  *            - LSI, LSE and RTC clocks
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_DeInit(void)
{
24012ea0:	b580      	push	{r7, lr}
24012ea2:	b082      	sub	sp, #8
24012ea4:	af00      	add	r7, sp, #0
  uint32_t tickstart;

        /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > __HAL_FLASH_GET_LATENCY())
24012ea6:	4b89      	ldr	r3, [pc, #548]	; (240130cc <HAL_RCC_DeInit+0x22c>)
24012ea8:	681b      	ldr	r3, [r3, #0]
24012eaa:	f003 030f 	and.w	r3, r3, #15
24012eae:	2b06      	cmp	r3, #6
24012eb0:	d80f      	bhi.n	24012ed2 <HAL_RCC_DeInit+0x32>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
24012eb2:	4b86      	ldr	r3, [pc, #536]	; (240130cc <HAL_RCC_DeInit+0x22c>)
24012eb4:	681b      	ldr	r3, [r3, #0]
24012eb6:	f023 030f 	bic.w	r3, r3, #15
24012eba:	4a84      	ldr	r2, [pc, #528]	; (240130cc <HAL_RCC_DeInit+0x22c>)
24012ebc:	f043 0307 	orr.w	r3, r3, #7
24012ec0:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
24012ec2:	4b82      	ldr	r3, [pc, #520]	; (240130cc <HAL_RCC_DeInit+0x22c>)
24012ec4:	681b      	ldr	r3, [r3, #0]
24012ec6:	f003 030f 	and.w	r3, r3, #15
24012eca:	2b07      	cmp	r3, #7
24012ecc:	d001      	beq.n	24012ed2 <HAL_RCC_DeInit+0x32>
    {
      return HAL_ERROR;
24012ece:	2301      	movs	r3, #1
24012ed0:	e0f7      	b.n	240130c2 <HAL_RCC_DeInit+0x222>

  }


  /* Get Start Tick */
  tickstart = HAL_GetTick();
24012ed2:	f7ef fa37 	bl	24002344 <HAL_GetTick>
24012ed6:	6078      	str	r0, [r7, #4]

  /* Set HSION bit */
  SET_BIT(RCC->CR, RCC_CR_HSION);
24012ed8:	4b7d      	ldr	r3, [pc, #500]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012eda:	681b      	ldr	r3, [r3, #0]
24012edc:	4a7c      	ldr	r2, [pc, #496]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012ede:	f043 0301 	orr.w	r3, r3, #1
24012ee2:	6013      	str	r3, [r2, #0]

  /* Wait till HSI is ready */
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24012ee4:	e008      	b.n	24012ef8 <HAL_RCC_DeInit+0x58>
  {
    if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
24012ee6:	f7ef fa2d 	bl	24002344 <HAL_GetTick>
24012eea:	4602      	mov	r2, r0
24012eec:	687b      	ldr	r3, [r7, #4]
24012eee:	1ad3      	subs	r3, r2, r3
24012ef0:	2b02      	cmp	r3, #2
24012ef2:	d901      	bls.n	24012ef8 <HAL_RCC_DeInit+0x58>
    {
      return HAL_TIMEOUT;
24012ef4:	2303      	movs	r3, #3
24012ef6:	e0e4      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
24012ef8:	4b75      	ldr	r3, [pc, #468]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012efa:	681b      	ldr	r3, [r3, #0]
24012efc:	f003 0304 	and.w	r3, r3, #4
24012f00:	2b00      	cmp	r3, #0
24012f02:	d0f0      	beq.n	24012ee6 <HAL_RCC_DeInit+0x46>
    }
  }

  /* Set HSITRIM[6:0] bits to the reset value */
  SET_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM_6);
24012f04:	4b72      	ldr	r3, [pc, #456]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f06:	685b      	ldr	r3, [r3, #4]
24012f08:	4a71      	ldr	r2, [pc, #452]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f0a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24012f0e:	6053      	str	r3, [r2, #4]

  /* Reset CFGR register */
  CLEAR_REG(RCC->CFGR);
24012f10:	4b6f      	ldr	r3, [pc, #444]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f12:	2200      	movs	r2, #0
24012f14:	611a      	str	r2, [r3, #16]

  /* Update the SystemCoreClock and SystemD2Clock global variables */
  SystemCoreClock = HSI_VALUE;
24012f16:	4b6f      	ldr	r3, [pc, #444]	; (240130d4 <HAL_RCC_DeInit+0x234>)
24012f18:	4a6f      	ldr	r2, [pc, #444]	; (240130d8 <HAL_RCC_DeInit+0x238>)
24012f1a:	601a      	str	r2, [r3, #0]
  SystemD2Clock = HSI_VALUE;
24012f1c:	4b6f      	ldr	r3, [pc, #444]	; (240130dc <HAL_RCC_DeInit+0x23c>)
24012f1e:	4a6e      	ldr	r2, [pc, #440]	; (240130d8 <HAL_RCC_DeInit+0x238>)
24012f20:	601a      	str	r2, [r3, #0]

  /* Adapt Systick interrupt period */
  if(HAL_InitTick(uwTickPrio) != HAL_OK)
24012f22:	4b6f      	ldr	r3, [pc, #444]	; (240130e0 <HAL_RCC_DeInit+0x240>)
24012f24:	681b      	ldr	r3, [r3, #0]
24012f26:	4618      	mov	r0, r3
24012f28:	f7ef f9c2 	bl	240022b0 <HAL_InitTick>
24012f2c:	4603      	mov	r3, r0
24012f2e:	2b00      	cmp	r3, #0
24012f30:	d001      	beq.n	24012f36 <HAL_RCC_DeInit+0x96>
  {
    return HAL_ERROR;
24012f32:	2301      	movs	r3, #1
24012f34:	e0c5      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24012f36:	f7ef fa05 	bl	24002344 <HAL_GetTick>
24012f3a:	6078      	str	r0, [r7, #4]

  /* Wait till clock switch is ready */
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24012f3c:	e00a      	b.n	24012f54 <HAL_RCC_DeInit+0xb4>
  {
    if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
24012f3e:	f7ef fa01 	bl	24002344 <HAL_GetTick>
24012f42:	4602      	mov	r2, r0
24012f44:	687b      	ldr	r3, [r7, #4]
24012f46:	1ad3      	subs	r3, r2, r3
24012f48:	f241 3288 	movw	r2, #5000	; 0x1388
24012f4c:	4293      	cmp	r3, r2
24012f4e:	d901      	bls.n	24012f54 <HAL_RCC_DeInit+0xb4>
    {
      return HAL_TIMEOUT;
24012f50:	2303      	movs	r3, #3
24012f52:	e0b6      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != 0U)
24012f54:	4b5e      	ldr	r3, [pc, #376]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f56:	691b      	ldr	r3, [r3, #16]
24012f58:	f003 0338 	and.w	r3, r3, #56	; 0x38
24012f5c:	2b00      	cmp	r3, #0
24012f5e:	d1ee      	bne.n	24012f3e <HAL_RCC_DeInit+0x9e>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24012f60:	f7ef f9f0 	bl	24002344 <HAL_GetTick>
24012f64:	6078      	str	r0, [r7, #4]

  /* Reset CSION, CSIKERON, HSEON, HSI48ON, HSECSSON, HSIDIV bits */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSIKERON| RCC_CR_HSIDIV| RCC_CR_HSIDIVF| RCC_CR_CSION | RCC_CR_CSIKERON  \
24012f66:	4b5a      	ldr	r3, [pc, #360]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f68:	681a      	ldr	r2, [r3, #0]
24012f6a:	4959      	ldr	r1, [pc, #356]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f6c:	4b5d      	ldr	r3, [pc, #372]	; (240130e4 <HAL_RCC_DeInit+0x244>)
24012f6e:	4013      	ands	r3, r2
24012f70:	600b      	str	r3, [r1, #0]
  | RCC_CR_HSI48ON | RCC_CR_CSSHSEON);

  /* Wait till HSE is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
24012f72:	e008      	b.n	24012f86 <HAL_RCC_DeInit+0xe6>
  {
    if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
24012f74:	f7ef f9e6 	bl	24002344 <HAL_GetTick>
24012f78:	4602      	mov	r2, r0
24012f7a:	687b      	ldr	r3, [r7, #4]
24012f7c:	1ad3      	subs	r3, r2, r3
24012f7e:	2b64      	cmp	r3, #100	; 0x64
24012f80:	d901      	bls.n	24012f86 <HAL_RCC_DeInit+0xe6>
    {
      return HAL_TIMEOUT;
24012f82:	2303      	movs	r3, #3
24012f84:	e09d      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
24012f86:	4b52      	ldr	r3, [pc, #328]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f88:	681b      	ldr	r3, [r3, #0]
24012f8a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24012f8e:	2b00      	cmp	r3, #0
24012f90:	d1f0      	bne.n	24012f74 <HAL_RCC_DeInit+0xd4>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24012f92:	f7ef f9d7 	bl	24002344 <HAL_GetTick>
24012f96:	6078      	str	r0, [r7, #4]

  /* Clear PLLON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL1ON);
24012f98:	4b4d      	ldr	r3, [pc, #308]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f9a:	681b      	ldr	r3, [r3, #0]
24012f9c:	4a4c      	ldr	r2, [pc, #304]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012f9e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
24012fa2:	6013      	str	r3, [r2, #0]

  /* Wait till PLL is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
24012fa4:	e008      	b.n	24012fb8 <HAL_RCC_DeInit+0x118>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24012fa6:	f7ef f9cd 	bl	24002344 <HAL_GetTick>
24012faa:	4602      	mov	r2, r0
24012fac:	687b      	ldr	r3, [r7, #4]
24012fae:	1ad3      	subs	r3, r2, r3
24012fb0:	2b02      	cmp	r3, #2
24012fb2:	d901      	bls.n	24012fb8 <HAL_RCC_DeInit+0x118>
    {
      return HAL_TIMEOUT;
24012fb4:	2303      	movs	r3, #3
24012fb6:	e084      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL1RDY) != 0U)
24012fb8:	4b45      	ldr	r3, [pc, #276]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012fba:	681b      	ldr	r3, [r3, #0]
24012fbc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24012fc0:	2b00      	cmp	r3, #0
24012fc2:	d1f0      	bne.n	24012fa6 <HAL_RCC_DeInit+0x106>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24012fc4:	f7ef f9be 	bl	24002344 <HAL_GetTick>
24012fc8:	6078      	str	r0, [r7, #4]

  /* Reset PLL2ON bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL2ON);
24012fca:	4b41      	ldr	r3, [pc, #260]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012fcc:	681b      	ldr	r3, [r3, #0]
24012fce:	4a40      	ldr	r2, [pc, #256]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012fd0:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
24012fd4:	6013      	str	r3, [r2, #0]

  /* Wait till PLL2 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24012fd6:	e008      	b.n	24012fea <HAL_RCC_DeInit+0x14a>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
24012fd8:	f7ef f9b4 	bl	24002344 <HAL_GetTick>
24012fdc:	4602      	mov	r2, r0
24012fde:	687b      	ldr	r3, [r7, #4]
24012fe0:	1ad3      	subs	r3, r2, r3
24012fe2:	2b02      	cmp	r3, #2
24012fe4:	d901      	bls.n	24012fea <HAL_RCC_DeInit+0x14a>
    {
      return HAL_TIMEOUT;
24012fe6:	2303      	movs	r3, #3
24012fe8:	e06b      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL2RDY) != 0U)
24012fea:	4b39      	ldr	r3, [pc, #228]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012fec:	681b      	ldr	r3, [r3, #0]
24012fee:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24012ff2:	2b00      	cmp	r3, #0
24012ff4:	d1f0      	bne.n	24012fd8 <HAL_RCC_DeInit+0x138>
    }
  }

  /* Get Start Tick */
  tickstart = HAL_GetTick();
24012ff6:	f7ef f9a5 	bl	24002344 <HAL_GetTick>
24012ffa:	6078      	str	r0, [r7, #4]

  /* Reset PLL3 bit */
  CLEAR_BIT(RCC->CR, RCC_CR_PLL3ON);
24012ffc:	4b34      	ldr	r3, [pc, #208]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24012ffe:	681b      	ldr	r3, [r3, #0]
24013000:	4a33      	ldr	r2, [pc, #204]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013002:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
24013006:	6013      	str	r3, [r2, #0]

  /* Wait till PLL3 is disabled */
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
24013008:	e008      	b.n	2401301c <HAL_RCC_DeInit+0x17c>
  {
    if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
2401300a:	f7ef f99b 	bl	24002344 <HAL_GetTick>
2401300e:	4602      	mov	r2, r0
24013010:	687b      	ldr	r3, [r7, #4]
24013012:	1ad3      	subs	r3, r2, r3
24013014:	2b02      	cmp	r3, #2
24013016:	d901      	bls.n	2401301c <HAL_RCC_DeInit+0x17c>
    {
      return HAL_TIMEOUT;
24013018:	2303      	movs	r3, #3
2401301a:	e052      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
  while (READ_BIT(RCC->CR, RCC_CR_PLL3RDY) != 0U)
2401301c:	4b2c      	ldr	r3, [pc, #176]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401301e:	681b      	ldr	r3, [r3, #0]
24013020:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24013024:	2b00      	cmp	r3, #0
24013026:	d1f0      	bne.n	2401300a <HAL_RCC_DeInit+0x16a>
    }
  }

#if defined(RCC_D1CFGR_HPRE)
  /* Reset D1CFGR register */
  CLEAR_REG(RCC->D1CFGR);
24013028:	4b29      	ldr	r3, [pc, #164]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401302a:	2200      	movs	r2, #0
2401302c:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  CLEAR_REG(RCC->D2CFGR);
2401302e:	4b28      	ldr	r3, [pc, #160]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013030:	2200      	movs	r2, #0
24013032:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  CLEAR_REG(RCC->D3CFGR);
24013034:	4b26      	ldr	r3, [pc, #152]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013036:	2200      	movs	r2, #0
24013038:	621a      	str	r2, [r3, #32]
  /* Reset SRDCFGR register */
  CLEAR_REG(RCC->SRDCFGR);
#endif

  /* Reset PLLCKSELR register to default value */
  RCC->PLLCKSELR= RCC_PLLCKSELR_DIVM1_5|RCC_PLLCKSELR_DIVM2_5|RCC_PLLCKSELR_DIVM3_5;
2401303a:	4b25      	ldr	r3, [pc, #148]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401303c:	4a2a      	ldr	r2, [pc, #168]	; (240130e8 <HAL_RCC_DeInit+0x248>)
2401303e:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register to default value */
  WRITE_REG(RCC->PLLCFGR, 0x01FF0000U);
24013040:	4b23      	ldr	r3, [pc, #140]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013042:	4a2a      	ldr	r2, [pc, #168]	; (240130ec <HAL_RCC_DeInit+0x24c>)
24013044:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset PLL1DIVR register to default value */
  WRITE_REG(RCC->PLL1DIVR,0x01010280U);
24013046:	4b22      	ldr	r3, [pc, #136]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013048:	4a29      	ldr	r2, [pc, #164]	; (240130f0 <HAL_RCC_DeInit+0x250>)
2401304a:	631a      	str	r2, [r3, #48]	; 0x30

  /* Reset PLL1FRACR register */
  CLEAR_REG(RCC->PLL1FRACR);
2401304c:	4b20      	ldr	r3, [pc, #128]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401304e:	2200      	movs	r2, #0
24013050:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register to default value */
  WRITE_REG(RCC->PLL2DIVR,0x01010280U);
24013052:	4b1f      	ldr	r3, [pc, #124]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013054:	4a26      	ldr	r2, [pc, #152]	; (240130f0 <HAL_RCC_DeInit+0x250>)
24013056:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */
  CLEAR_REG(RCC->PLL2FRACR);
24013058:	4b1d      	ldr	r3, [pc, #116]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401305a:	2200      	movs	r2, #0
2401305c:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Reset PLL3DIVR register to default value */
  WRITE_REG(RCC->PLL3DIVR,0x01010280U);
2401305e:	4b1c      	ldr	r3, [pc, #112]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013060:	4a23      	ldr	r2, [pc, #140]	; (240130f0 <HAL_RCC_DeInit+0x250>)
24013062:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  CLEAR_REG(RCC->PLL3FRACR);
24013064:	4b1a      	ldr	r3, [pc, #104]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013066:	2200      	movs	r2, #0
24013068:	645a      	str	r2, [r3, #68]	; 0x44
  /* Reset HSEEXT  */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEEXT);
#endif /* RCC_CR_HSEEXT */

  /* Reset HSEBYP bit */
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
2401306a:	4b19      	ldr	r3, [pc, #100]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401306c:	681b      	ldr	r3, [r3, #0]
2401306e:	4a18      	ldr	r2, [pc, #96]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013070:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
24013074:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  CLEAR_REG(RCC->CIER);
24013076:	4b16      	ldr	r3, [pc, #88]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013078:	2200      	movs	r2, #0
2401307a:	661a      	str	r2, [r3, #96]	; 0x60

  /* Clear all interrupts flags */
  WRITE_REG(RCC->CICR,0xFFFFFFFFU);
2401307c:	4b14      	ldr	r3, [pc, #80]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401307e:	f04f 32ff 	mov.w	r2, #4294967295
24013082:	669a      	str	r2, [r3, #104]	; 0x68

  /* Reset all RSR flags */
  SET_BIT(RCC->RSR, RCC_RSR_RMVF);
24013084:	4b12      	ldr	r3, [pc, #72]	; (240130d0 <HAL_RCC_DeInit+0x230>)
24013086:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
2401308a:	4a11      	ldr	r2, [pc, #68]	; (240130d0 <HAL_RCC_DeInit+0x230>)
2401308c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24013090:	f8c2 30d0 	str.w	r3, [r2, #208]	; 0xd0

      /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < __HAL_FLASH_GET_LATENCY())
24013094:	4b0d      	ldr	r3, [pc, #52]	; (240130cc <HAL_RCC_DeInit+0x22c>)
24013096:	681b      	ldr	r3, [r3, #0]
24013098:	f003 0308 	and.w	r3, r3, #8
2401309c:	2b00      	cmp	r3, #0
2401309e:	d00f      	beq.n	240130c0 <HAL_RCC_DeInit+0x220>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLASH_LATENCY_DEFAULT);
240130a0:	4b0a      	ldr	r3, [pc, #40]	; (240130cc <HAL_RCC_DeInit+0x22c>)
240130a2:	681b      	ldr	r3, [r3, #0]
240130a4:	f023 030f 	bic.w	r3, r3, #15
240130a8:	4a08      	ldr	r2, [pc, #32]	; (240130cc <HAL_RCC_DeInit+0x22c>)
240130aa:	f043 0307 	orr.w	r3, r3, #7
240130ae:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLASH_LATENCY_DEFAULT)
240130b0:	4b06      	ldr	r3, [pc, #24]	; (240130cc <HAL_RCC_DeInit+0x22c>)
240130b2:	681b      	ldr	r3, [r3, #0]
240130b4:	f003 030f 	and.w	r3, r3, #15
240130b8:	2b07      	cmp	r3, #7
240130ba:	d001      	beq.n	240130c0 <HAL_RCC_DeInit+0x220>
    {
      return HAL_ERROR;
240130bc:	2301      	movs	r3, #1
240130be:	e000      	b.n	240130c2 <HAL_RCC_DeInit+0x222>
    }

}

  return HAL_OK;
240130c0:	2300      	movs	r3, #0
}
240130c2:	4618      	mov	r0, r3
240130c4:	3708      	adds	r7, #8
240130c6:	46bd      	mov	sp, r7
240130c8:	bd80      	pop	{r7, pc}
240130ca:	bf00      	nop
240130cc:	52002000 	.word	0x52002000
240130d0:	58024400 	.word	0x58024400
240130d4:	240004b0 	.word	0x240004b0
240130d8:	03d09000 	.word	0x03d09000
240130dc:	240004b4 	.word	0x240004b4
240130e0:	240004b8 	.word	0x240004b8
240130e4:	fff6ed45 	.word	0xfff6ed45
240130e8:	02020200 	.word	0x02020200
240130ec:	01ff0000 	.word	0x01ff0000
240130f0:	01010280 	.word	0x01010280

240130f4 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
240130f4:	b580      	push	{r7, lr}
240130f6:	b08c      	sub	sp, #48	; 0x30
240130f8:	af00      	add	r7, sp, #0
240130fa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
240130fc:	687b      	ldr	r3, [r7, #4]
240130fe:	2b00      	cmp	r3, #0
24013100:	d102      	bne.n	24013108 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
24013102:	2301      	movs	r3, #1
24013104:	f000 bc1d 	b.w	24013942 <HAL_RCC_OscConfig+0x84e>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
24013108:	687b      	ldr	r3, [r7, #4]
2401310a:	681b      	ldr	r3, [r3, #0]
2401310c:	f003 0301 	and.w	r3, r3, #1
24013110:	2b00      	cmp	r3, #0
24013112:	f000 8087 	beq.w	24013224 <HAL_RCC_OscConfig+0x130>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24013116:	4b99      	ldr	r3, [pc, #612]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013118:	691b      	ldr	r3, [r3, #16]
2401311a:	f003 0338 	and.w	r3, r3, #56	; 0x38
2401311e:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
24013120:	4b96      	ldr	r3, [pc, #600]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013122:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013124:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
24013126:	6afb      	ldr	r3, [r7, #44]	; 0x2c
24013128:	2b10      	cmp	r3, #16
2401312a:	d007      	beq.n	2401313c <HAL_RCC_OscConfig+0x48>
2401312c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
2401312e:	2b18      	cmp	r3, #24
24013130:	d110      	bne.n	24013154 <HAL_RCC_OscConfig+0x60>
24013132:	6abb      	ldr	r3, [r7, #40]	; 0x28
24013134:	f003 0303 	and.w	r3, r3, #3
24013138:	2b02      	cmp	r3, #2
2401313a:	d10b      	bne.n	24013154 <HAL_RCC_OscConfig+0x60>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
2401313c:	4b8f      	ldr	r3, [pc, #572]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401313e:	681b      	ldr	r3, [r3, #0]
24013140:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24013144:	2b00      	cmp	r3, #0
24013146:	d06c      	beq.n	24013222 <HAL_RCC_OscConfig+0x12e>
24013148:	687b      	ldr	r3, [r7, #4]
2401314a:	685b      	ldr	r3, [r3, #4]
2401314c:	2b00      	cmp	r3, #0
2401314e:	d168      	bne.n	24013222 <HAL_RCC_OscConfig+0x12e>
      {
        return HAL_ERROR;
24013150:	2301      	movs	r3, #1
24013152:	e3f6      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
24013154:	687b      	ldr	r3, [r7, #4]
24013156:	685b      	ldr	r3, [r3, #4]
24013158:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401315c:	d106      	bne.n	2401316c <HAL_RCC_OscConfig+0x78>
2401315e:	4b87      	ldr	r3, [pc, #540]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013160:	681b      	ldr	r3, [r3, #0]
24013162:	4a86      	ldr	r2, [pc, #536]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013164:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24013168:	6013      	str	r3, [r2, #0]
2401316a:	e02e      	b.n	240131ca <HAL_RCC_OscConfig+0xd6>
2401316c:	687b      	ldr	r3, [r7, #4]
2401316e:	685b      	ldr	r3, [r3, #4]
24013170:	2b00      	cmp	r3, #0
24013172:	d10c      	bne.n	2401318e <HAL_RCC_OscConfig+0x9a>
24013174:	4b81      	ldr	r3, [pc, #516]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013176:	681b      	ldr	r3, [r3, #0]
24013178:	4a80      	ldr	r2, [pc, #512]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401317a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
2401317e:	6013      	str	r3, [r2, #0]
24013180:	4b7e      	ldr	r3, [pc, #504]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013182:	681b      	ldr	r3, [r3, #0]
24013184:	4a7d      	ldr	r2, [pc, #500]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013186:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
2401318a:	6013      	str	r3, [r2, #0]
2401318c:	e01d      	b.n	240131ca <HAL_RCC_OscConfig+0xd6>
2401318e:	687b      	ldr	r3, [r7, #4]
24013190:	685b      	ldr	r3, [r3, #4]
24013192:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24013196:	d10c      	bne.n	240131b2 <HAL_RCC_OscConfig+0xbe>
24013198:	4b78      	ldr	r3, [pc, #480]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401319a:	681b      	ldr	r3, [r3, #0]
2401319c:	4a77      	ldr	r2, [pc, #476]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401319e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
240131a2:	6013      	str	r3, [r2, #0]
240131a4:	4b75      	ldr	r3, [pc, #468]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240131a6:	681b      	ldr	r3, [r3, #0]
240131a8:	4a74      	ldr	r2, [pc, #464]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240131aa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
240131ae:	6013      	str	r3, [r2, #0]
240131b0:	e00b      	b.n	240131ca <HAL_RCC_OscConfig+0xd6>
240131b2:	4b72      	ldr	r3, [pc, #456]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240131b4:	681b      	ldr	r3, [r3, #0]
240131b6:	4a71      	ldr	r2, [pc, #452]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240131b8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
240131bc:	6013      	str	r3, [r2, #0]
240131be:	4b6f      	ldr	r3, [pc, #444]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240131c0:	681b      	ldr	r3, [r3, #0]
240131c2:	4a6e      	ldr	r2, [pc, #440]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240131c4:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
240131c8:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
240131ca:	687b      	ldr	r3, [r7, #4]
240131cc:	685b      	ldr	r3, [r3, #4]
240131ce:	2b00      	cmp	r3, #0
240131d0:	d013      	beq.n	240131fa <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240131d2:	f7ef f8b7 	bl	24002344 <HAL_GetTick>
240131d6:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
240131d8:	e008      	b.n	240131ec <HAL_RCC_OscConfig+0xf8>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
240131da:	f7ef f8b3 	bl	24002344 <HAL_GetTick>
240131de:	4602      	mov	r2, r0
240131e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240131e2:	1ad3      	subs	r3, r2, r3
240131e4:	2b64      	cmp	r3, #100	; 0x64
240131e6:	d901      	bls.n	240131ec <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
240131e8:	2303      	movs	r3, #3
240131ea:	e3aa      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
240131ec:	4b63      	ldr	r3, [pc, #396]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240131ee:	681b      	ldr	r3, [r3, #0]
240131f0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240131f4:	2b00      	cmp	r3, #0
240131f6:	d0f0      	beq.n	240131da <HAL_RCC_OscConfig+0xe6>
240131f8:	e014      	b.n	24013224 <HAL_RCC_OscConfig+0x130>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240131fa:	f7ef f8a3 	bl	24002344 <HAL_GetTick>
240131fe:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
24013200:	e008      	b.n	24013214 <HAL_RCC_OscConfig+0x120>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
24013202:	f7ef f89f 	bl	24002344 <HAL_GetTick>
24013206:	4602      	mov	r2, r0
24013208:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401320a:	1ad3      	subs	r3, r2, r3
2401320c:	2b64      	cmp	r3, #100	; 0x64
2401320e:	d901      	bls.n	24013214 <HAL_RCC_OscConfig+0x120>
          {
            return HAL_TIMEOUT;
24013210:	2303      	movs	r3, #3
24013212:	e396      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
24013214:	4b59      	ldr	r3, [pc, #356]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013216:	681b      	ldr	r3, [r3, #0]
24013218:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401321c:	2b00      	cmp	r3, #0
2401321e:	d1f0      	bne.n	24013202 <HAL_RCC_OscConfig+0x10e>
24013220:	e000      	b.n	24013224 <HAL_RCC_OscConfig+0x130>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
24013222:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
24013224:	687b      	ldr	r3, [r7, #4]
24013226:	681b      	ldr	r3, [r3, #0]
24013228:	f003 0302 	and.w	r3, r3, #2
2401322c:	2b00      	cmp	r3, #0
2401322e:	f000 80cb 	beq.w	240133c8 <HAL_RCC_OscConfig+0x2d4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
24013232:	4b52      	ldr	r3, [pc, #328]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013234:	691b      	ldr	r3, [r3, #16]
24013236:	f003 0338 	and.w	r3, r3, #56	; 0x38
2401323a:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
2401323c:	4b4f      	ldr	r3, [pc, #316]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401323e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013240:	61fb      	str	r3, [r7, #28]
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
24013242:	6a3b      	ldr	r3, [r7, #32]
24013244:	2b00      	cmp	r3, #0
24013246:	d007      	beq.n	24013258 <HAL_RCC_OscConfig+0x164>
24013248:	6a3b      	ldr	r3, [r7, #32]
2401324a:	2b18      	cmp	r3, #24
2401324c:	d156      	bne.n	240132fc <HAL_RCC_OscConfig+0x208>
2401324e:	69fb      	ldr	r3, [r7, #28]
24013250:	f003 0303 	and.w	r3, r3, #3
24013254:	2b00      	cmp	r3, #0
24013256:	d151      	bne.n	240132fc <HAL_RCC_OscConfig+0x208>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
24013258:	4b48      	ldr	r3, [pc, #288]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401325a:	681b      	ldr	r3, [r3, #0]
2401325c:	f003 0304 	and.w	r3, r3, #4
24013260:	2b00      	cmp	r3, #0
24013262:	d005      	beq.n	24013270 <HAL_RCC_OscConfig+0x17c>
24013264:	687b      	ldr	r3, [r7, #4]
24013266:	68db      	ldr	r3, [r3, #12]
24013268:	2b00      	cmp	r3, #0
2401326a:	d101      	bne.n	24013270 <HAL_RCC_OscConfig+0x17c>
      {
        return HAL_ERROR;
2401326c:	2301      	movs	r3, #1
2401326e:	e368      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      }
      /* Otherwise, only HSI division and calibration are allowed */
      else
      {
          /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
24013270:	4b42      	ldr	r3, [pc, #264]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013272:	681b      	ldr	r3, [r3, #0]
24013274:	f023 0219 	bic.w	r2, r3, #25
24013278:	687b      	ldr	r3, [r7, #4]
2401327a:	68db      	ldr	r3, [r3, #12]
2401327c:	493f      	ldr	r1, [pc, #252]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401327e:	4313      	orrs	r3, r2
24013280:	600b      	str	r3, [r1, #0]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
24013282:	f7ef f85f 	bl	24002344 <HAL_GetTick>
24013286:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till HSI is ready */
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24013288:	e008      	b.n	2401329c <HAL_RCC_OscConfig+0x1a8>
          {
            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
2401328a:	f7ef f85b 	bl	24002344 <HAL_GetTick>
2401328e:	4602      	mov	r2, r0
24013290:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013292:	1ad3      	subs	r3, r2, r3
24013294:	2b02      	cmp	r3, #2
24013296:	d901      	bls.n	2401329c <HAL_RCC_OscConfig+0x1a8>
            {
              return HAL_TIMEOUT;
24013298:	2303      	movs	r3, #3
2401329a:	e352      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
2401329c:	4b37      	ldr	r3, [pc, #220]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401329e:	681b      	ldr	r3, [r3, #0]
240132a0:	f003 0304 	and.w	r3, r3, #4
240132a4:	2b00      	cmp	r3, #0
240132a6:	d0f0      	beq.n	2401328a <HAL_RCC_OscConfig+0x196>
            }
          }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
240132a8:	f7ef f8e6 	bl	24002478 <HAL_GetREVID>
240132ac:	4603      	mov	r3, r0
240132ae:	f241 0203 	movw	r2, #4099	; 0x1003
240132b2:	4293      	cmp	r3, r2
240132b4:	d817      	bhi.n	240132e6 <HAL_RCC_OscConfig+0x1f2>
240132b6:	687b      	ldr	r3, [r7, #4]
240132b8:	691b      	ldr	r3, [r3, #16]
240132ba:	2b40      	cmp	r3, #64	; 0x40
240132bc:	d108      	bne.n	240132d0 <HAL_RCC_OscConfig+0x1dc>
240132be:	4b2f      	ldr	r3, [pc, #188]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240132c0:	685b      	ldr	r3, [r3, #4]
240132c2:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
240132c6:	4a2d      	ldr	r2, [pc, #180]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240132c8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240132cc:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
240132ce:	e07b      	b.n	240133c8 <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
240132d0:	4b2a      	ldr	r3, [pc, #168]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240132d2:	685b      	ldr	r3, [r3, #4]
240132d4:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
240132d8:	687b      	ldr	r3, [r7, #4]
240132da:	691b      	ldr	r3, [r3, #16]
240132dc:	031b      	lsls	r3, r3, #12
240132de:	4927      	ldr	r1, [pc, #156]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240132e0:	4313      	orrs	r3, r2
240132e2:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
240132e4:	e070      	b.n	240133c8 <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
240132e6:	4b25      	ldr	r3, [pc, #148]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240132e8:	685b      	ldr	r3, [r3, #4]
240132ea:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
240132ee:	687b      	ldr	r3, [r7, #4]
240132f0:	691b      	ldr	r3, [r3, #16]
240132f2:	061b      	lsls	r3, r3, #24
240132f4:	4921      	ldr	r1, [pc, #132]	; (2401337c <HAL_RCC_OscConfig+0x288>)
240132f6:	4313      	orrs	r3, r2
240132f8:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
240132fa:	e065      	b.n	240133c8 <HAL_RCC_OscConfig+0x2d4>
    }

    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
240132fc:	687b      	ldr	r3, [r7, #4]
240132fe:	68db      	ldr	r3, [r3, #12]
24013300:	2b00      	cmp	r3, #0
24013302:	d048      	beq.n	24013396 <HAL_RCC_OscConfig+0x2a2>
      {
     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
24013304:	4b1d      	ldr	r3, [pc, #116]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013306:	681b      	ldr	r3, [r3, #0]
24013308:	f023 0219 	bic.w	r2, r3, #25
2401330c:	687b      	ldr	r3, [r7, #4]
2401330e:	68db      	ldr	r3, [r3, #12]
24013310:	491a      	ldr	r1, [pc, #104]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013312:	4313      	orrs	r3, r2
24013314:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013316:	f7ef f815 	bl	24002344 <HAL_GetTick>
2401331a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
2401331c:	e008      	b.n	24013330 <HAL_RCC_OscConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
2401331e:	f7ef f811 	bl	24002344 <HAL_GetTick>
24013322:	4602      	mov	r2, r0
24013324:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013326:	1ad3      	subs	r3, r2, r3
24013328:	2b02      	cmp	r3, #2
2401332a:	d901      	bls.n	24013330 <HAL_RCC_OscConfig+0x23c>
          {
            return HAL_TIMEOUT;
2401332c:	2303      	movs	r3, #3
2401332e:	e308      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24013330:	4b12      	ldr	r3, [pc, #72]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013332:	681b      	ldr	r3, [r3, #0]
24013334:	f003 0304 	and.w	r3, r3, #4
24013338:	2b00      	cmp	r3, #0
2401333a:	d0f0      	beq.n	2401331e <HAL_RCC_OscConfig+0x22a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
2401333c:	f7ef f89c 	bl	24002478 <HAL_GetREVID>
24013340:	4603      	mov	r3, r0
24013342:	f241 0203 	movw	r2, #4099	; 0x1003
24013346:	4293      	cmp	r3, r2
24013348:	d81a      	bhi.n	24013380 <HAL_RCC_OscConfig+0x28c>
2401334a:	687b      	ldr	r3, [r7, #4]
2401334c:	691b      	ldr	r3, [r3, #16]
2401334e:	2b40      	cmp	r3, #64	; 0x40
24013350:	d108      	bne.n	24013364 <HAL_RCC_OscConfig+0x270>
24013352:	4b0a      	ldr	r3, [pc, #40]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013354:	685b      	ldr	r3, [r3, #4]
24013356:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
2401335a:	4a08      	ldr	r2, [pc, #32]	; (2401337c <HAL_RCC_OscConfig+0x288>)
2401335c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013360:	6053      	str	r3, [r2, #4]
24013362:	e031      	b.n	240133c8 <HAL_RCC_OscConfig+0x2d4>
24013364:	4b05      	ldr	r3, [pc, #20]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013366:	685b      	ldr	r3, [r3, #4]
24013368:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
2401336c:	687b      	ldr	r3, [r7, #4]
2401336e:	691b      	ldr	r3, [r3, #16]
24013370:	031b      	lsls	r3, r3, #12
24013372:	4902      	ldr	r1, [pc, #8]	; (2401337c <HAL_RCC_OscConfig+0x288>)
24013374:	4313      	orrs	r3, r2
24013376:	604b      	str	r3, [r1, #4]
24013378:	e026      	b.n	240133c8 <HAL_RCC_OscConfig+0x2d4>
2401337a:	bf00      	nop
2401337c:	58024400 	.word	0x58024400
24013380:	4b9a      	ldr	r3, [pc, #616]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013382:	685b      	ldr	r3, [r3, #4]
24013384:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
24013388:	687b      	ldr	r3, [r7, #4]
2401338a:	691b      	ldr	r3, [r3, #16]
2401338c:	061b      	lsls	r3, r3, #24
2401338e:	4997      	ldr	r1, [pc, #604]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013390:	4313      	orrs	r3, r2
24013392:	604b      	str	r3, [r1, #4]
24013394:	e018      	b.n	240133c8 <HAL_RCC_OscConfig+0x2d4>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
24013396:	4b95      	ldr	r3, [pc, #596]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013398:	681b      	ldr	r3, [r3, #0]
2401339a:	4a94      	ldr	r2, [pc, #592]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
2401339c:	f023 0301 	bic.w	r3, r3, #1
240133a0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
240133a2:	f7ee ffcf 	bl	24002344 <HAL_GetTick>
240133a6:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
240133a8:	e008      	b.n	240133bc <HAL_RCC_OscConfig+0x2c8>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
240133aa:	f7ee ffcb 	bl	24002344 <HAL_GetTick>
240133ae:	4602      	mov	r2, r0
240133b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240133b2:	1ad3      	subs	r3, r2, r3
240133b4:	2b02      	cmp	r3, #2
240133b6:	d901      	bls.n	240133bc <HAL_RCC_OscConfig+0x2c8>
          {
            return HAL_TIMEOUT;
240133b8:	2303      	movs	r3, #3
240133ba:	e2c2      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
240133bc:	4b8b      	ldr	r3, [pc, #556]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240133be:	681b      	ldr	r3, [r3, #0]
240133c0:	f003 0304 	and.w	r3, r3, #4
240133c4:	2b00      	cmp	r3, #0
240133c6:	d1f0      	bne.n	240133aa <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
240133c8:	687b      	ldr	r3, [r7, #4]
240133ca:	681b      	ldr	r3, [r3, #0]
240133cc:	f003 0310 	and.w	r3, r3, #16
240133d0:	2b00      	cmp	r3, #0
240133d2:	f000 80a9 	beq.w	24013528 <HAL_RCC_OscConfig+0x434>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
240133d6:	4b85      	ldr	r3, [pc, #532]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240133d8:	691b      	ldr	r3, [r3, #16]
240133da:	f003 0338 	and.w	r3, r3, #56	; 0x38
240133de:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
240133e0:	4b82      	ldr	r3, [pc, #520]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240133e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240133e4:	617b      	str	r3, [r7, #20]
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
240133e6:	69bb      	ldr	r3, [r7, #24]
240133e8:	2b08      	cmp	r3, #8
240133ea:	d007      	beq.n	240133fc <HAL_RCC_OscConfig+0x308>
240133ec:	69bb      	ldr	r3, [r7, #24]
240133ee:	2b18      	cmp	r3, #24
240133f0:	d13a      	bne.n	24013468 <HAL_RCC_OscConfig+0x374>
240133f2:	697b      	ldr	r3, [r7, #20]
240133f4:	f003 0303 	and.w	r3, r3, #3
240133f8:	2b01      	cmp	r3, #1
240133fa:	d135      	bne.n	24013468 <HAL_RCC_OscConfig+0x374>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
240133fc:	4b7b      	ldr	r3, [pc, #492]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240133fe:	681b      	ldr	r3, [r3, #0]
24013400:	f403 7380 	and.w	r3, r3, #256	; 0x100
24013404:	2b00      	cmp	r3, #0
24013406:	d005      	beq.n	24013414 <HAL_RCC_OscConfig+0x320>
24013408:	687b      	ldr	r3, [r7, #4]
2401340a:	69db      	ldr	r3, [r3, #28]
2401340c:	2b80      	cmp	r3, #128	; 0x80
2401340e:	d001      	beq.n	24013414 <HAL_RCC_OscConfig+0x320>
      {
        return HAL_ERROR;
24013410:	2301      	movs	r3, #1
24013412:	e296      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24013414:	f7ef f830 	bl	24002478 <HAL_GetREVID>
24013418:	4603      	mov	r3, r0
2401341a:	f241 0203 	movw	r2, #4099	; 0x1003
2401341e:	4293      	cmp	r3, r2
24013420:	d817      	bhi.n	24013452 <HAL_RCC_OscConfig+0x35e>
24013422:	687b      	ldr	r3, [r7, #4]
24013424:	6a1b      	ldr	r3, [r3, #32]
24013426:	2b20      	cmp	r3, #32
24013428:	d108      	bne.n	2401343c <HAL_RCC_OscConfig+0x348>
2401342a:	4b70      	ldr	r3, [pc, #448]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
2401342c:	685b      	ldr	r3, [r3, #4]
2401342e:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
24013432:	4a6e      	ldr	r2, [pc, #440]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013434:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
24013438:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
2401343a:	e075      	b.n	24013528 <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
2401343c:	4b6b      	ldr	r3, [pc, #428]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
2401343e:	685b      	ldr	r3, [r3, #4]
24013440:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
24013444:	687b      	ldr	r3, [r7, #4]
24013446:	6a1b      	ldr	r3, [r3, #32]
24013448:	069b      	lsls	r3, r3, #26
2401344a:	4968      	ldr	r1, [pc, #416]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
2401344c:	4313      	orrs	r3, r2
2401344e:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
24013450:	e06a      	b.n	24013528 <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
24013452:	4b66      	ldr	r3, [pc, #408]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013454:	68db      	ldr	r3, [r3, #12]
24013456:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
2401345a:	687b      	ldr	r3, [r7, #4]
2401345c:	6a1b      	ldr	r3, [r3, #32]
2401345e:	061b      	lsls	r3, r3, #24
24013460:	4962      	ldr	r1, [pc, #392]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013462:	4313      	orrs	r3, r2
24013464:	60cb      	str	r3, [r1, #12]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
24013466:	e05f      	b.n	24013528 <HAL_RCC_OscConfig+0x434>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
24013468:	687b      	ldr	r3, [r7, #4]
2401346a:	69db      	ldr	r3, [r3, #28]
2401346c:	2b00      	cmp	r3, #0
2401346e:	d042      	beq.n	240134f6 <HAL_RCC_OscConfig+0x402>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
24013470:	4b5e      	ldr	r3, [pc, #376]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013472:	681b      	ldr	r3, [r3, #0]
24013474:	4a5d      	ldr	r2, [pc, #372]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013476:	f043 0380 	orr.w	r3, r3, #128	; 0x80
2401347a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2401347c:	f7ee ff62 	bl	24002344 <HAL_GetTick>
24013480:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
24013482:	e008      	b.n	24013496 <HAL_RCC_OscConfig+0x3a2>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
24013484:	f7ee ff5e 	bl	24002344 <HAL_GetTick>
24013488:	4602      	mov	r2, r0
2401348a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401348c:	1ad3      	subs	r3, r2, r3
2401348e:	2b02      	cmp	r3, #2
24013490:	d901      	bls.n	24013496 <HAL_RCC_OscConfig+0x3a2>
          {
            return HAL_TIMEOUT;
24013492:	2303      	movs	r3, #3
24013494:	e255      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
24013496:	4b55      	ldr	r3, [pc, #340]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013498:	681b      	ldr	r3, [r3, #0]
2401349a:	f403 7380 	and.w	r3, r3, #256	; 0x100
2401349e:	2b00      	cmp	r3, #0
240134a0:	d0f0      	beq.n	24013484 <HAL_RCC_OscConfig+0x390>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
240134a2:	f7ee ffe9 	bl	24002478 <HAL_GetREVID>
240134a6:	4603      	mov	r3, r0
240134a8:	f241 0203 	movw	r2, #4099	; 0x1003
240134ac:	4293      	cmp	r3, r2
240134ae:	d817      	bhi.n	240134e0 <HAL_RCC_OscConfig+0x3ec>
240134b0:	687b      	ldr	r3, [r7, #4]
240134b2:	6a1b      	ldr	r3, [r3, #32]
240134b4:	2b20      	cmp	r3, #32
240134b6:	d108      	bne.n	240134ca <HAL_RCC_OscConfig+0x3d6>
240134b8:	4b4c      	ldr	r3, [pc, #304]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134ba:	685b      	ldr	r3, [r3, #4]
240134bc:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
240134c0:	4a4a      	ldr	r2, [pc, #296]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134c2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
240134c6:	6053      	str	r3, [r2, #4]
240134c8:	e02e      	b.n	24013528 <HAL_RCC_OscConfig+0x434>
240134ca:	4b48      	ldr	r3, [pc, #288]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134cc:	685b      	ldr	r3, [r3, #4]
240134ce:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
240134d2:	687b      	ldr	r3, [r7, #4]
240134d4:	6a1b      	ldr	r3, [r3, #32]
240134d6:	069b      	lsls	r3, r3, #26
240134d8:	4944      	ldr	r1, [pc, #272]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134da:	4313      	orrs	r3, r2
240134dc:	604b      	str	r3, [r1, #4]
240134de:	e023      	b.n	24013528 <HAL_RCC_OscConfig+0x434>
240134e0:	4b42      	ldr	r3, [pc, #264]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134e2:	68db      	ldr	r3, [r3, #12]
240134e4:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
240134e8:	687b      	ldr	r3, [r7, #4]
240134ea:	6a1b      	ldr	r3, [r3, #32]
240134ec:	061b      	lsls	r3, r3, #24
240134ee:	493f      	ldr	r1, [pc, #252]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134f0:	4313      	orrs	r3, r2
240134f2:	60cb      	str	r3, [r1, #12]
240134f4:	e018      	b.n	24013528 <HAL_RCC_OscConfig+0x434>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
240134f6:	4b3d      	ldr	r3, [pc, #244]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134f8:	681b      	ldr	r3, [r3, #0]
240134fa:	4a3c      	ldr	r2, [pc, #240]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240134fc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
24013500:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013502:	f7ee ff1f 	bl	24002344 <HAL_GetTick>
24013506:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
24013508:	e008      	b.n	2401351c <HAL_RCC_OscConfig+0x428>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
2401350a:	f7ee ff1b 	bl	24002344 <HAL_GetTick>
2401350e:	4602      	mov	r2, r0
24013510:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013512:	1ad3      	subs	r3, r2, r3
24013514:	2b02      	cmp	r3, #2
24013516:	d901      	bls.n	2401351c <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
24013518:	2303      	movs	r3, #3
2401351a:	e212      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
2401351c:	4b33      	ldr	r3, [pc, #204]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
2401351e:	681b      	ldr	r3, [r3, #0]
24013520:	f403 7380 	and.w	r3, r3, #256	; 0x100
24013524:	2b00      	cmp	r3, #0
24013526:	d1f0      	bne.n	2401350a <HAL_RCC_OscConfig+0x416>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
24013528:	687b      	ldr	r3, [r7, #4]
2401352a:	681b      	ldr	r3, [r3, #0]
2401352c:	f003 0308 	and.w	r3, r3, #8
24013530:	2b00      	cmp	r3, #0
24013532:	d036      	beq.n	240135a2 <HAL_RCC_OscConfig+0x4ae>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
24013534:	687b      	ldr	r3, [r7, #4]
24013536:	695b      	ldr	r3, [r3, #20]
24013538:	2b00      	cmp	r3, #0
2401353a:	d019      	beq.n	24013570 <HAL_RCC_OscConfig+0x47c>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
2401353c:	4b2b      	ldr	r3, [pc, #172]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
2401353e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013540:	4a2a      	ldr	r2, [pc, #168]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013542:	f043 0301 	orr.w	r3, r3, #1
24013546:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24013548:	f7ee fefc 	bl	24002344 <HAL_GetTick>
2401354c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
2401354e:	e008      	b.n	24013562 <HAL_RCC_OscConfig+0x46e>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
24013550:	f7ee fef8 	bl	24002344 <HAL_GetTick>
24013554:	4602      	mov	r2, r0
24013556:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013558:	1ad3      	subs	r3, r2, r3
2401355a:	2b02      	cmp	r3, #2
2401355c:	d901      	bls.n	24013562 <HAL_RCC_OscConfig+0x46e>
        {
          return HAL_TIMEOUT;
2401355e:	2303      	movs	r3, #3
24013560:	e1ef      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
24013562:	4b22      	ldr	r3, [pc, #136]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013564:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013566:	f003 0302 	and.w	r3, r3, #2
2401356a:	2b00      	cmp	r3, #0
2401356c:	d0f0      	beq.n	24013550 <HAL_RCC_OscConfig+0x45c>
2401356e:	e018      	b.n	240135a2 <HAL_RCC_OscConfig+0x4ae>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
24013570:	4b1e      	ldr	r3, [pc, #120]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013572:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24013574:	4a1d      	ldr	r2, [pc, #116]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013576:	f023 0301 	bic.w	r3, r3, #1
2401357a:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
2401357c:	f7ee fee2 	bl	24002344 <HAL_GetTick>
24013580:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
24013582:	e008      	b.n	24013596 <HAL_RCC_OscConfig+0x4a2>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
24013584:	f7ee fede 	bl	24002344 <HAL_GetTick>
24013588:	4602      	mov	r2, r0
2401358a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401358c:	1ad3      	subs	r3, r2, r3
2401358e:	2b02      	cmp	r3, #2
24013590:	d901      	bls.n	24013596 <HAL_RCC_OscConfig+0x4a2>
        {
          return HAL_TIMEOUT;
24013592:	2303      	movs	r3, #3
24013594:	e1d5      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
24013596:	4b15      	ldr	r3, [pc, #84]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
24013598:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2401359a:	f003 0302 	and.w	r3, r3, #2
2401359e:	2b00      	cmp	r3, #0
240135a0:	d1f0      	bne.n	24013584 <HAL_RCC_OscConfig+0x490>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
240135a2:	687b      	ldr	r3, [r7, #4]
240135a4:	681b      	ldr	r3, [r3, #0]
240135a6:	f003 0320 	and.w	r3, r3, #32
240135aa:	2b00      	cmp	r3, #0
240135ac:	d039      	beq.n	24013622 <HAL_RCC_OscConfig+0x52e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
240135ae:	687b      	ldr	r3, [r7, #4]
240135b0:	699b      	ldr	r3, [r3, #24]
240135b2:	2b00      	cmp	r3, #0
240135b4:	d01c      	beq.n	240135f0 <HAL_RCC_OscConfig+0x4fc>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
240135b6:	4b0d      	ldr	r3, [pc, #52]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240135b8:	681b      	ldr	r3, [r3, #0]
240135ba:	4a0c      	ldr	r2, [pc, #48]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240135bc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
240135c0:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
240135c2:	f7ee febf 	bl	24002344 <HAL_GetTick>
240135c6:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
240135c8:	e008      	b.n	240135dc <HAL_RCC_OscConfig+0x4e8>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
240135ca:	f7ee febb 	bl	24002344 <HAL_GetTick>
240135ce:	4602      	mov	r2, r0
240135d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240135d2:	1ad3      	subs	r3, r2, r3
240135d4:	2b02      	cmp	r3, #2
240135d6:	d901      	bls.n	240135dc <HAL_RCC_OscConfig+0x4e8>
        {
          return HAL_TIMEOUT;
240135d8:	2303      	movs	r3, #3
240135da:	e1b2      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
240135dc:	4b03      	ldr	r3, [pc, #12]	; (240135ec <HAL_RCC_OscConfig+0x4f8>)
240135de:	681b      	ldr	r3, [r3, #0]
240135e0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
240135e4:	2b00      	cmp	r3, #0
240135e6:	d0f0      	beq.n	240135ca <HAL_RCC_OscConfig+0x4d6>
240135e8:	e01b      	b.n	24013622 <HAL_RCC_OscConfig+0x52e>
240135ea:	bf00      	nop
240135ec:	58024400 	.word	0x58024400
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
240135f0:	4b9b      	ldr	r3, [pc, #620]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240135f2:	681b      	ldr	r3, [r3, #0]
240135f4:	4a9a      	ldr	r2, [pc, #616]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240135f6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
240135fa:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
240135fc:	f7ee fea2 	bl	24002344 <HAL_GetTick>
24013600:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
24013602:	e008      	b.n	24013616 <HAL_RCC_OscConfig+0x522>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
24013604:	f7ee fe9e 	bl	24002344 <HAL_GetTick>
24013608:	4602      	mov	r2, r0
2401360a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401360c:	1ad3      	subs	r3, r2, r3
2401360e:	2b02      	cmp	r3, #2
24013610:	d901      	bls.n	24013616 <HAL_RCC_OscConfig+0x522>
        {
          return HAL_TIMEOUT;
24013612:	2303      	movs	r3, #3
24013614:	e195      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
24013616:	4b92      	ldr	r3, [pc, #584]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013618:	681b      	ldr	r3, [r3, #0]
2401361a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
2401361e:	2b00      	cmp	r3, #0
24013620:	d1f0      	bne.n	24013604 <HAL_RCC_OscConfig+0x510>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
24013622:	687b      	ldr	r3, [r7, #4]
24013624:	681b      	ldr	r3, [r3, #0]
24013626:	f003 0304 	and.w	r3, r3, #4
2401362a:	2b00      	cmp	r3, #0
2401362c:	f000 8081 	beq.w	24013732 <HAL_RCC_OscConfig+0x63e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
24013630:	4b8c      	ldr	r3, [pc, #560]	; (24013864 <HAL_RCC_OscConfig+0x770>)
24013632:	681b      	ldr	r3, [r3, #0]
24013634:	4a8b      	ldr	r2, [pc, #556]	; (24013864 <HAL_RCC_OscConfig+0x770>)
24013636:	f443 7380 	orr.w	r3, r3, #256	; 0x100
2401363a:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
2401363c:	f7ee fe82 	bl	24002344 <HAL_GetTick>
24013640:	6278      	str	r0, [r7, #36]	; 0x24

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24013642:	e008      	b.n	24013656 <HAL_RCC_OscConfig+0x562>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
24013644:	f7ee fe7e 	bl	24002344 <HAL_GetTick>
24013648:	4602      	mov	r2, r0
2401364a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
2401364c:	1ad3      	subs	r3, r2, r3
2401364e:	2b64      	cmp	r3, #100	; 0x64
24013650:	d901      	bls.n	24013656 <HAL_RCC_OscConfig+0x562>
      {
        return HAL_TIMEOUT;
24013652:	2303      	movs	r3, #3
24013654:	e175      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24013656:	4b83      	ldr	r3, [pc, #524]	; (24013864 <HAL_RCC_OscConfig+0x770>)
24013658:	681b      	ldr	r3, [r3, #0]
2401365a:	f403 7380 	and.w	r3, r3, #256	; 0x100
2401365e:	2b00      	cmp	r3, #0
24013660:	d0f0      	beq.n	24013644 <HAL_RCC_OscConfig+0x550>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
24013662:	687b      	ldr	r3, [r7, #4]
24013664:	689b      	ldr	r3, [r3, #8]
24013666:	2b01      	cmp	r3, #1
24013668:	d106      	bne.n	24013678 <HAL_RCC_OscConfig+0x584>
2401366a:	4b7d      	ldr	r3, [pc, #500]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401366c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401366e:	4a7c      	ldr	r2, [pc, #496]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013670:	f043 0301 	orr.w	r3, r3, #1
24013674:	6713      	str	r3, [r2, #112]	; 0x70
24013676:	e02d      	b.n	240136d4 <HAL_RCC_OscConfig+0x5e0>
24013678:	687b      	ldr	r3, [r7, #4]
2401367a:	689b      	ldr	r3, [r3, #8]
2401367c:	2b00      	cmp	r3, #0
2401367e:	d10c      	bne.n	2401369a <HAL_RCC_OscConfig+0x5a6>
24013680:	4b77      	ldr	r3, [pc, #476]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013682:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013684:	4a76      	ldr	r2, [pc, #472]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013686:	f023 0301 	bic.w	r3, r3, #1
2401368a:	6713      	str	r3, [r2, #112]	; 0x70
2401368c:	4b74      	ldr	r3, [pc, #464]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401368e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24013690:	4a73      	ldr	r2, [pc, #460]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013692:	f023 0304 	bic.w	r3, r3, #4
24013696:	6713      	str	r3, [r2, #112]	; 0x70
24013698:	e01c      	b.n	240136d4 <HAL_RCC_OscConfig+0x5e0>
2401369a:	687b      	ldr	r3, [r7, #4]
2401369c:	689b      	ldr	r3, [r3, #8]
2401369e:	2b05      	cmp	r3, #5
240136a0:	d10c      	bne.n	240136bc <HAL_RCC_OscConfig+0x5c8>
240136a2:	4b6f      	ldr	r3, [pc, #444]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240136a6:	4a6e      	ldr	r2, [pc, #440]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136a8:	f043 0304 	orr.w	r3, r3, #4
240136ac:	6713      	str	r3, [r2, #112]	; 0x70
240136ae:	4b6c      	ldr	r3, [pc, #432]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136b0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240136b2:	4a6b      	ldr	r2, [pc, #428]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136b4:	f043 0301 	orr.w	r3, r3, #1
240136b8:	6713      	str	r3, [r2, #112]	; 0x70
240136ba:	e00b      	b.n	240136d4 <HAL_RCC_OscConfig+0x5e0>
240136bc:	4b68      	ldr	r3, [pc, #416]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136be:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240136c0:	4a67      	ldr	r2, [pc, #412]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136c2:	f023 0301 	bic.w	r3, r3, #1
240136c6:	6713      	str	r3, [r2, #112]	; 0x70
240136c8:	4b65      	ldr	r3, [pc, #404]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136ca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240136cc:	4a64      	ldr	r2, [pc, #400]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136ce:	f023 0304 	bic.w	r3, r3, #4
240136d2:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
240136d4:	687b      	ldr	r3, [r7, #4]
240136d6:	689b      	ldr	r3, [r3, #8]
240136d8:	2b00      	cmp	r3, #0
240136da:	d015      	beq.n	24013708 <HAL_RCC_OscConfig+0x614>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
240136dc:	f7ee fe32 	bl	24002344 <HAL_GetTick>
240136e0:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
240136e2:	e00a      	b.n	240136fa <HAL_RCC_OscConfig+0x606>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
240136e4:	f7ee fe2e 	bl	24002344 <HAL_GetTick>
240136e8:	4602      	mov	r2, r0
240136ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240136ec:	1ad3      	subs	r3, r2, r3
240136ee:	f241 3288 	movw	r2, #5000	; 0x1388
240136f2:	4293      	cmp	r3, r2
240136f4:	d901      	bls.n	240136fa <HAL_RCC_OscConfig+0x606>
        {
          return HAL_TIMEOUT;
240136f6:	2303      	movs	r3, #3
240136f8:	e123      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
240136fa:	4b59      	ldr	r3, [pc, #356]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240136fc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240136fe:	f003 0302 	and.w	r3, r3, #2
24013702:	2b00      	cmp	r3, #0
24013704:	d0ee      	beq.n	240136e4 <HAL_RCC_OscConfig+0x5f0>
24013706:	e014      	b.n	24013732 <HAL_RCC_OscConfig+0x63e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24013708:	f7ee fe1c 	bl	24002344 <HAL_GetTick>
2401370c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
2401370e:	e00a      	b.n	24013726 <HAL_RCC_OscConfig+0x632>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
24013710:	f7ee fe18 	bl	24002344 <HAL_GetTick>
24013714:	4602      	mov	r2, r0
24013716:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013718:	1ad3      	subs	r3, r2, r3
2401371a:	f241 3288 	movw	r2, #5000	; 0x1388
2401371e:	4293      	cmp	r3, r2
24013720:	d901      	bls.n	24013726 <HAL_RCC_OscConfig+0x632>
        {
          return HAL_TIMEOUT;
24013722:	2303      	movs	r3, #3
24013724:	e10d      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
24013726:	4b4e      	ldr	r3, [pc, #312]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013728:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401372a:	f003 0302 	and.w	r3, r3, #2
2401372e:	2b00      	cmp	r3, #0
24013730:	d1ee      	bne.n	24013710 <HAL_RCC_OscConfig+0x61c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
24013732:	687b      	ldr	r3, [r7, #4]
24013734:	6a5b      	ldr	r3, [r3, #36]	; 0x24
24013736:	2b00      	cmp	r3, #0
24013738:	f000 8102 	beq.w	24013940 <HAL_RCC_OscConfig+0x84c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
2401373c:	4b48      	ldr	r3, [pc, #288]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401373e:	691b      	ldr	r3, [r3, #16]
24013740:	f003 0338 	and.w	r3, r3, #56	; 0x38
24013744:	2b18      	cmp	r3, #24
24013746:	f000 80bd 	beq.w	240138c4 <HAL_RCC_OscConfig+0x7d0>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
2401374a:	687b      	ldr	r3, [r7, #4]
2401374c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
2401374e:	2b02      	cmp	r3, #2
24013750:	f040 809e 	bne.w	24013890 <HAL_RCC_OscConfig+0x79c>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
24013754:	4b42      	ldr	r3, [pc, #264]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013756:	681b      	ldr	r3, [r3, #0]
24013758:	4a41      	ldr	r2, [pc, #260]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401375a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2401375e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013760:	f7ee fdf0 	bl	24002344 <HAL_GetTick>
24013764:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
24013766:	e008      	b.n	2401377a <HAL_RCC_OscConfig+0x686>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
24013768:	f7ee fdec 	bl	24002344 <HAL_GetTick>
2401376c:	4602      	mov	r2, r0
2401376e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013770:	1ad3      	subs	r3, r2, r3
24013772:	2b02      	cmp	r3, #2
24013774:	d901      	bls.n	2401377a <HAL_RCC_OscConfig+0x686>
          {
            return HAL_TIMEOUT;
24013776:	2303      	movs	r3, #3
24013778:	e0e3      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
2401377a:	4b39      	ldr	r3, [pc, #228]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401377c:	681b      	ldr	r3, [r3, #0]
2401377e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24013782:	2b00      	cmp	r3, #0
24013784:	d1f0      	bne.n	24013768 <HAL_RCC_OscConfig+0x674>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
24013786:	4b36      	ldr	r3, [pc, #216]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013788:	6a9a      	ldr	r2, [r3, #40]	; 0x28
2401378a:	4b37      	ldr	r3, [pc, #220]	; (24013868 <HAL_RCC_OscConfig+0x774>)
2401378c:	4013      	ands	r3, r2
2401378e:	687a      	ldr	r2, [r7, #4]
24013790:	6a91      	ldr	r1, [r2, #40]	; 0x28
24013792:	687a      	ldr	r2, [r7, #4]
24013794:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
24013796:	0112      	lsls	r2, r2, #4
24013798:	430a      	orrs	r2, r1
2401379a:	4931      	ldr	r1, [pc, #196]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401379c:	4313      	orrs	r3, r2
2401379e:	628b      	str	r3, [r1, #40]	; 0x28
240137a0:	687b      	ldr	r3, [r7, #4]
240137a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240137a4:	3b01      	subs	r3, #1
240137a6:	f3c3 0208 	ubfx	r2, r3, #0, #9
240137aa:	687b      	ldr	r3, [r7, #4]
240137ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240137ae:	3b01      	subs	r3, #1
240137b0:	025b      	lsls	r3, r3, #9
240137b2:	b29b      	uxth	r3, r3
240137b4:	431a      	orrs	r2, r3
240137b6:	687b      	ldr	r3, [r7, #4]
240137b8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240137ba:	3b01      	subs	r3, #1
240137bc:	041b      	lsls	r3, r3, #16
240137be:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
240137c2:	431a      	orrs	r2, r3
240137c4:	687b      	ldr	r3, [r7, #4]
240137c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
240137c8:	3b01      	subs	r3, #1
240137ca:	061b      	lsls	r3, r3, #24
240137cc:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
240137d0:	4923      	ldr	r1, [pc, #140]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240137d2:	4313      	orrs	r3, r2
240137d4:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();
240137d6:	4b22      	ldr	r3, [pc, #136]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240137d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240137da:	4a21      	ldr	r2, [pc, #132]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240137dc:	f023 0301 	bic.w	r3, r3, #1
240137e0:	62d3      	str	r3, [r2, #44]	; 0x2c

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
240137e2:	4b1f      	ldr	r3, [pc, #124]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240137e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
240137e6:	4b21      	ldr	r3, [pc, #132]	; (2401386c <HAL_RCC_OscConfig+0x778>)
240137e8:	4013      	ands	r3, r2
240137ea:	687a      	ldr	r2, [r7, #4]
240137ec:	6c92      	ldr	r2, [r2, #72]	; 0x48
240137ee:	00d2      	lsls	r2, r2, #3
240137f0:	491b      	ldr	r1, [pc, #108]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240137f2:	4313      	orrs	r3, r2
240137f4:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
240137f6:	4b1a      	ldr	r3, [pc, #104]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
240137f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240137fa:	f023 020c 	bic.w	r2, r3, #12
240137fe:	687b      	ldr	r3, [r7, #4]
24013800:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24013802:	4917      	ldr	r1, [pc, #92]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013804:	4313      	orrs	r3, r2
24013806:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
24013808:	4b15      	ldr	r3, [pc, #84]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401380a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401380c:	f023 0202 	bic.w	r2, r3, #2
24013810:	687b      	ldr	r3, [r7, #4]
24013812:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24013814:	4912      	ldr	r1, [pc, #72]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013816:	4313      	orrs	r3, r2
24013818:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
2401381a:	4b11      	ldr	r3, [pc, #68]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401381c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401381e:	4a10      	ldr	r2, [pc, #64]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013820:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24013824:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24013826:	4b0e      	ldr	r3, [pc, #56]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013828:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401382a:	4a0d      	ldr	r2, [pc, #52]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401382c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24013830:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
24013832:	4b0b      	ldr	r3, [pc, #44]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013834:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013836:	4a0a      	ldr	r2, [pc, #40]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013838:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
2401383c:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
         __HAL_RCC_PLLFRACN_ENABLE();
2401383e:	4b08      	ldr	r3, [pc, #32]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013840:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013842:	4a07      	ldr	r2, [pc, #28]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013844:	f043 0301 	orr.w	r3, r3, #1
24013848:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
2401384a:	4b05      	ldr	r3, [pc, #20]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
2401384c:	681b      	ldr	r3, [r3, #0]
2401384e:	4a04      	ldr	r2, [pc, #16]	; (24013860 <HAL_RCC_OscConfig+0x76c>)
24013850:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
24013854:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24013856:	f7ee fd75 	bl	24002344 <HAL_GetTick>
2401385a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
2401385c:	e011      	b.n	24013882 <HAL_RCC_OscConfig+0x78e>
2401385e:	bf00      	nop
24013860:	58024400 	.word	0x58024400
24013864:	58024800 	.word	0x58024800
24013868:	fffffc0c 	.word	0xfffffc0c
2401386c:	ffff0007 	.word	0xffff0007
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
24013870:	f7ee fd68 	bl	24002344 <HAL_GetTick>
24013874:	4602      	mov	r2, r0
24013876:	6a7b      	ldr	r3, [r7, #36]	; 0x24
24013878:	1ad3      	subs	r3, r2, r3
2401387a:	2b02      	cmp	r3, #2
2401387c:	d901      	bls.n	24013882 <HAL_RCC_OscConfig+0x78e>
          {
            return HAL_TIMEOUT;
2401387e:	2303      	movs	r3, #3
24013880:	e05f      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24013882:	4b32      	ldr	r3, [pc, #200]	; (2401394c <HAL_RCC_OscConfig+0x858>)
24013884:	681b      	ldr	r3, [r3, #0]
24013886:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2401388a:	2b00      	cmp	r3, #0
2401388c:	d0f0      	beq.n	24013870 <HAL_RCC_OscConfig+0x77c>
2401388e:	e057      	b.n	24013940 <HAL_RCC_OscConfig+0x84c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
24013890:	4b2e      	ldr	r3, [pc, #184]	; (2401394c <HAL_RCC_OscConfig+0x858>)
24013892:	681b      	ldr	r3, [r3, #0]
24013894:	4a2d      	ldr	r2, [pc, #180]	; (2401394c <HAL_RCC_OscConfig+0x858>)
24013896:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
2401389a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
2401389c:	f7ee fd52 	bl	24002344 <HAL_GetTick>
240138a0:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
240138a2:	e008      	b.n	240138b6 <HAL_RCC_OscConfig+0x7c2>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
240138a4:	f7ee fd4e 	bl	24002344 <HAL_GetTick>
240138a8:	4602      	mov	r2, r0
240138aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
240138ac:	1ad3      	subs	r3, r2, r3
240138ae:	2b02      	cmp	r3, #2
240138b0:	d901      	bls.n	240138b6 <HAL_RCC_OscConfig+0x7c2>
          {
            return HAL_TIMEOUT;
240138b2:	2303      	movs	r3, #3
240138b4:	e045      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
240138b6:	4b25      	ldr	r3, [pc, #148]	; (2401394c <HAL_RCC_OscConfig+0x858>)
240138b8:	681b      	ldr	r3, [r3, #0]
240138ba:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240138be:	2b00      	cmp	r3, #0
240138c0:	d1f0      	bne.n	240138a4 <HAL_RCC_OscConfig+0x7b0>
240138c2:	e03d      	b.n	24013940 <HAL_RCC_OscConfig+0x84c>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
240138c4:	4b21      	ldr	r3, [pc, #132]	; (2401394c <HAL_RCC_OscConfig+0x858>)
240138c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240138c8:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
240138ca:	4b20      	ldr	r3, [pc, #128]	; (2401394c <HAL_RCC_OscConfig+0x858>)
240138cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240138ce:	60fb      	str	r3, [r7, #12]
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
240138d0:	687b      	ldr	r3, [r7, #4]
240138d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
240138d4:	2b01      	cmp	r3, #1
240138d6:	d031      	beq.n	2401393c <HAL_RCC_OscConfig+0x848>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
240138d8:	693b      	ldr	r3, [r7, #16]
240138da:	f003 0203 	and.w	r2, r3, #3
240138de:	687b      	ldr	r3, [r7, #4]
240138e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
240138e2:	429a      	cmp	r2, r3
240138e4:	d12a      	bne.n	2401393c <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
240138e6:	693b      	ldr	r3, [r7, #16]
240138e8:	091b      	lsrs	r3, r3, #4
240138ea:	f003 023f 	and.w	r2, r3, #63	; 0x3f
240138ee:	687b      	ldr	r3, [r7, #4]
240138f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
240138f2:	429a      	cmp	r2, r3
240138f4:	d122      	bne.n	2401393c <HAL_RCC_OscConfig+0x848>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
240138f6:	68fb      	ldr	r3, [r7, #12]
240138f8:	f3c3 0208 	ubfx	r2, r3, #0, #9
240138fc:	687b      	ldr	r3, [r7, #4]
240138fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013900:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
24013902:	429a      	cmp	r2, r3
24013904:	d11a      	bne.n	2401393c <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24013906:	68fb      	ldr	r3, [r7, #12]
24013908:	0a5b      	lsrs	r3, r3, #9
2401390a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
2401390e:	687b      	ldr	r3, [r7, #4]
24013910:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24013912:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
24013914:	429a      	cmp	r2, r3
24013916:	d111      	bne.n	2401393c <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24013918:	68fb      	ldr	r3, [r7, #12]
2401391a:	0c1b      	lsrs	r3, r3, #16
2401391c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24013920:	687b      	ldr	r3, [r7, #4]
24013922:	6b9b      	ldr	r3, [r3, #56]	; 0x38
24013924:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
24013926:	429a      	cmp	r2, r3
24013928:	d108      	bne.n	2401393c <HAL_RCC_OscConfig+0x848>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
2401392a:	68fb      	ldr	r3, [r7, #12]
2401392c:	0e1b      	lsrs	r3, r3, #24
2401392e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24013932:	687b      	ldr	r3, [r7, #4]
24013934:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24013936:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
24013938:	429a      	cmp	r2, r3
2401393a:	d001      	beq.n	24013940 <HAL_RCC_OscConfig+0x84c>
      {
        return HAL_ERROR;
2401393c:	2301      	movs	r3, #1
2401393e:	e000      	b.n	24013942 <HAL_RCC_OscConfig+0x84e>
      }
    }
  }
  return HAL_OK;
24013940:	2300      	movs	r3, #0
}
24013942:	4618      	mov	r0, r3
24013944:	3730      	adds	r7, #48	; 0x30
24013946:	46bd      	mov	sp, r7
24013948:	bd80      	pop	{r7, pc}
2401394a:	bf00      	nop
2401394c:	58024400 	.word	0x58024400

24013950 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
24013950:	b580      	push	{r7, lr}
24013952:	b086      	sub	sp, #24
24013954:	af00      	add	r7, sp, #0
24013956:	6078      	str	r0, [r7, #4]
24013958:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

   /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
2401395a:	687b      	ldr	r3, [r7, #4]
2401395c:	2b00      	cmp	r3, #0
2401395e:	d101      	bne.n	24013964 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
24013960:	2301      	movs	r3, #1
24013962:	e19c      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
24013964:	4b8a      	ldr	r3, [pc, #552]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
24013966:	681b      	ldr	r3, [r3, #0]
24013968:	f003 030f 	and.w	r3, r3, #15
2401396c:	683a      	ldr	r2, [r7, #0]
2401396e:	429a      	cmp	r2, r3
24013970:	d910      	bls.n	24013994 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
24013972:	4b87      	ldr	r3, [pc, #540]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
24013974:	681b      	ldr	r3, [r3, #0]
24013976:	f023 020f 	bic.w	r2, r3, #15
2401397a:	4985      	ldr	r1, [pc, #532]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
2401397c:	683b      	ldr	r3, [r7, #0]
2401397e:	4313      	orrs	r3, r2
24013980:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
24013982:	4b83      	ldr	r3, [pc, #524]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
24013984:	681b      	ldr	r3, [r3, #0]
24013986:	f003 030f 	and.w	r3, r3, #15
2401398a:	683a      	ldr	r2, [r7, #0]
2401398c:	429a      	cmp	r2, r3
2401398e:	d001      	beq.n	24013994 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
24013990:	2301      	movs	r3, #1
24013992:	e184      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
24013994:	687b      	ldr	r3, [r7, #4]
24013996:	681b      	ldr	r3, [r3, #0]
24013998:	f003 0304 	and.w	r3, r3, #4
2401399c:	2b00      	cmp	r3, #0
2401399e:	d010      	beq.n	240139c2 <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
240139a0:	687b      	ldr	r3, [r7, #4]
240139a2:	691a      	ldr	r2, [r3, #16]
240139a4:	4b7b      	ldr	r3, [pc, #492]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
240139a6:	699b      	ldr	r3, [r3, #24]
240139a8:	f003 0370 	and.w	r3, r3, #112	; 0x70
240139ac:	429a      	cmp	r2, r3
240139ae:	d908      	bls.n	240139c2 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
240139b0:	4b78      	ldr	r3, [pc, #480]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
240139b2:	699b      	ldr	r3, [r3, #24]
240139b4:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240139b8:	687b      	ldr	r3, [r7, #4]
240139ba:	691b      	ldr	r3, [r3, #16]
240139bc:	4975      	ldr	r1, [pc, #468]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
240139be:	4313      	orrs	r3, r2
240139c0:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
240139c2:	687b      	ldr	r3, [r7, #4]
240139c4:	681b      	ldr	r3, [r3, #0]
240139c6:	f003 0308 	and.w	r3, r3, #8
240139ca:	2b00      	cmp	r3, #0
240139cc:	d010      	beq.n	240139f0 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
240139ce:	687b      	ldr	r3, [r7, #4]
240139d0:	695a      	ldr	r2, [r3, #20]
240139d2:	4b70      	ldr	r3, [pc, #448]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
240139d4:	69db      	ldr	r3, [r3, #28]
240139d6:	f003 0370 	and.w	r3, r3, #112	; 0x70
240139da:	429a      	cmp	r2, r3
240139dc:	d908      	bls.n	240139f0 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
240139de:	4b6d      	ldr	r3, [pc, #436]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
240139e0:	69db      	ldr	r3, [r3, #28]
240139e2:	f023 0270 	bic.w	r2, r3, #112	; 0x70
240139e6:	687b      	ldr	r3, [r7, #4]
240139e8:	695b      	ldr	r3, [r3, #20]
240139ea:	496a      	ldr	r1, [pc, #424]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
240139ec:	4313      	orrs	r3, r2
240139ee:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
  }
#endif
    }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
240139f0:	687b      	ldr	r3, [r7, #4]
240139f2:	681b      	ldr	r3, [r3, #0]
240139f4:	f003 0310 	and.w	r3, r3, #16
240139f8:	2b00      	cmp	r3, #0
240139fa:	d010      	beq.n	24013a1e <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
240139fc:	687b      	ldr	r3, [r7, #4]
240139fe:	699a      	ldr	r2, [r3, #24]
24013a00:	4b64      	ldr	r3, [pc, #400]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a02:	69db      	ldr	r3, [r3, #28]
24013a04:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
24013a08:	429a      	cmp	r2, r3
24013a0a:	d908      	bls.n	24013a1e <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24013a0c:	4b61      	ldr	r3, [pc, #388]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a0e:	69db      	ldr	r3, [r3, #28]
24013a10:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
24013a14:	687b      	ldr	r3, [r7, #4]
24013a16:	699b      	ldr	r3, [r3, #24]
24013a18:	495e      	ldr	r1, [pc, #376]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a1a:	4313      	orrs	r3, r2
24013a1c:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24013a1e:	687b      	ldr	r3, [r7, #4]
24013a20:	681b      	ldr	r3, [r3, #0]
24013a22:	f003 0320 	and.w	r3, r3, #32
24013a26:	2b00      	cmp	r3, #0
24013a28:	d010      	beq.n	24013a4c <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24013a2a:	687b      	ldr	r3, [r7, #4]
24013a2c:	69da      	ldr	r2, [r3, #28]
24013a2e:	4b59      	ldr	r3, [pc, #356]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a30:	6a1b      	ldr	r3, [r3, #32]
24013a32:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013a36:	429a      	cmp	r2, r3
24013a38:	d908      	bls.n	24013a4c <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
24013a3a:	4b56      	ldr	r3, [pc, #344]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a3c:	6a1b      	ldr	r3, [r3, #32]
24013a3e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013a42:	687b      	ldr	r3, [r7, #4]
24013a44:	69db      	ldr	r3, [r3, #28]
24013a46:	4953      	ldr	r1, [pc, #332]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a48:	4313      	orrs	r3, r2
24013a4a:	620b      	str	r3, [r1, #32]
    }
#endif
  }

   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24013a4c:	687b      	ldr	r3, [r7, #4]
24013a4e:	681b      	ldr	r3, [r3, #0]
24013a50:	f003 0302 	and.w	r3, r3, #2
24013a54:	2b00      	cmp	r3, #0
24013a56:	d010      	beq.n	24013a7a <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24013a58:	687b      	ldr	r3, [r7, #4]
24013a5a:	68da      	ldr	r2, [r3, #12]
24013a5c:	4b4d      	ldr	r3, [pc, #308]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a5e:	699b      	ldr	r3, [r3, #24]
24013a60:	f003 030f 	and.w	r3, r3, #15
24013a64:	429a      	cmp	r2, r3
24013a66:	d908      	bls.n	24013a7a <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24013a68:	4b4a      	ldr	r3, [pc, #296]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a6a:	699b      	ldr	r3, [r3, #24]
24013a6c:	f023 020f 	bic.w	r2, r3, #15
24013a70:	687b      	ldr	r3, [r7, #4]
24013a72:	68db      	ldr	r3, [r3, #12]
24013a74:	4947      	ldr	r1, [pc, #284]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a76:	4313      	orrs	r3, r2
24013a78:	618b      	str	r3, [r1, #24]
    }
#endif
  }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
24013a7a:	687b      	ldr	r3, [r7, #4]
24013a7c:	681b      	ldr	r3, [r3, #0]
24013a7e:	f003 0301 	and.w	r3, r3, #1
24013a82:	2b00      	cmp	r3, #0
24013a84:	d055      	beq.n	24013b32 <HAL_RCC_ClockConfig+0x1e2>
    {
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
24013a86:	4b43      	ldr	r3, [pc, #268]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a88:	699b      	ldr	r3, [r3, #24]
24013a8a:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
24013a8e:	687b      	ldr	r3, [r7, #4]
24013a90:	689b      	ldr	r3, [r3, #8]
24013a92:	4940      	ldr	r1, [pc, #256]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013a94:	4313      	orrs	r3, r2
24013a96:	618b      	str	r3, [r1, #24]
#else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
24013a98:	687b      	ldr	r3, [r7, #4]
24013a9a:	685b      	ldr	r3, [r3, #4]
24013a9c:	2b02      	cmp	r3, #2
24013a9e:	d107      	bne.n	24013ab0 <HAL_RCC_ClockConfig+0x160>
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
24013aa0:	4b3c      	ldr	r3, [pc, #240]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013aa2:	681b      	ldr	r3, [r3, #0]
24013aa4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24013aa8:	2b00      	cmp	r3, #0
24013aaa:	d121      	bne.n	24013af0 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
24013aac:	2301      	movs	r3, #1
24013aae:	e0f6      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
24013ab0:	687b      	ldr	r3, [r7, #4]
24013ab2:	685b      	ldr	r3, [r3, #4]
24013ab4:	2b03      	cmp	r3, #3
24013ab6:	d107      	bne.n	24013ac8 <HAL_RCC_ClockConfig+0x178>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
24013ab8:	4b36      	ldr	r3, [pc, #216]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013aba:	681b      	ldr	r3, [r3, #0]
24013abc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24013ac0:	2b00      	cmp	r3, #0
24013ac2:	d115      	bne.n	24013af0 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
24013ac4:	2301      	movs	r3, #1
24013ac6:	e0ea      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* CSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
24013ac8:	687b      	ldr	r3, [r7, #4]
24013aca:	685b      	ldr	r3, [r3, #4]
24013acc:	2b01      	cmp	r3, #1
24013ace:	d107      	bne.n	24013ae0 <HAL_RCC_ClockConfig+0x190>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
24013ad0:	4b30      	ldr	r3, [pc, #192]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013ad2:	681b      	ldr	r3, [r3, #0]
24013ad4:	f403 7380 	and.w	r3, r3, #256	; 0x100
24013ad8:	2b00      	cmp	r3, #0
24013ada:	d109      	bne.n	24013af0 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
24013adc:	2301      	movs	r3, #1
24013ade:	e0de      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
24013ae0:	4b2c      	ldr	r3, [pc, #176]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013ae2:	681b      	ldr	r3, [r3, #0]
24013ae4:	f003 0304 	and.w	r3, r3, #4
24013ae8:	2b00      	cmp	r3, #0
24013aea:	d101      	bne.n	24013af0 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
24013aec:	2301      	movs	r3, #1
24013aee:	e0d6      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
24013af0:	4b28      	ldr	r3, [pc, #160]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013af2:	691b      	ldr	r3, [r3, #16]
24013af4:	f023 0207 	bic.w	r2, r3, #7
24013af8:	687b      	ldr	r3, [r7, #4]
24013afa:	685b      	ldr	r3, [r3, #4]
24013afc:	4925      	ldr	r1, [pc, #148]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013afe:	4313      	orrs	r3, r2
24013b00:	610b      	str	r3, [r1, #16]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
24013b02:	f7ee fc1f 	bl	24002344 <HAL_GetTick>
24013b06:	6178      	str	r0, [r7, #20]

        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24013b08:	e00a      	b.n	24013b20 <HAL_RCC_ClockConfig+0x1d0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
24013b0a:	f7ee fc1b 	bl	24002344 <HAL_GetTick>
24013b0e:	4602      	mov	r2, r0
24013b10:	697b      	ldr	r3, [r7, #20]
24013b12:	1ad3      	subs	r3, r2, r3
24013b14:	f241 3288 	movw	r2, #5000	; 0x1388
24013b18:	4293      	cmp	r3, r2
24013b1a:	d901      	bls.n	24013b20 <HAL_RCC_ClockConfig+0x1d0>
          {
            return HAL_TIMEOUT;
24013b1c:	2303      	movs	r3, #3
24013b1e:	e0be      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
24013b20:	4b1c      	ldr	r3, [pc, #112]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013b22:	691b      	ldr	r3, [r3, #16]
24013b24:	f003 0238 	and.w	r2, r3, #56	; 0x38
24013b28:	687b      	ldr	r3, [r7, #4]
24013b2a:	685b      	ldr	r3, [r3, #4]
24013b2c:	00db      	lsls	r3, r3, #3
24013b2e:	429a      	cmp	r2, r3
24013b30:	d1eb      	bne.n	24013b0a <HAL_RCC_ClockConfig+0x1ba>

    }

    /* Decreasing the BUS frequency divider */
   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
24013b32:	687b      	ldr	r3, [r7, #4]
24013b34:	681b      	ldr	r3, [r3, #0]
24013b36:	f003 0302 	and.w	r3, r3, #2
24013b3a:	2b00      	cmp	r3, #0
24013b3c:	d010      	beq.n	24013b60 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
24013b3e:	687b      	ldr	r3, [r7, #4]
24013b40:	68da      	ldr	r2, [r3, #12]
24013b42:	4b14      	ldr	r3, [pc, #80]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013b44:	699b      	ldr	r3, [r3, #24]
24013b46:	f003 030f 	and.w	r3, r3, #15
24013b4a:	429a      	cmp	r2, r3
24013b4c:	d208      	bcs.n	24013b60 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
24013b4e:	4b11      	ldr	r3, [pc, #68]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013b50:	699b      	ldr	r3, [r3, #24]
24013b52:	f023 020f 	bic.w	r2, r3, #15
24013b56:	687b      	ldr	r3, [r7, #4]
24013b58:	68db      	ldr	r3, [r3, #12]
24013b5a:	490e      	ldr	r1, [pc, #56]	; (24013b94 <HAL_RCC_ClockConfig+0x244>)
24013b5c:	4313      	orrs	r3, r2
24013b5e:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
24013b60:	4b0b      	ldr	r3, [pc, #44]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
24013b62:	681b      	ldr	r3, [r3, #0]
24013b64:	f003 030f 	and.w	r3, r3, #15
24013b68:	683a      	ldr	r2, [r7, #0]
24013b6a:	429a      	cmp	r2, r3
24013b6c:	d214      	bcs.n	24013b98 <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
24013b6e:	4b08      	ldr	r3, [pc, #32]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
24013b70:	681b      	ldr	r3, [r3, #0]
24013b72:	f023 020f 	bic.w	r2, r3, #15
24013b76:	4906      	ldr	r1, [pc, #24]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
24013b78:	683b      	ldr	r3, [r7, #0]
24013b7a:	4313      	orrs	r3, r2
24013b7c:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
24013b7e:	4b04      	ldr	r3, [pc, #16]	; (24013b90 <HAL_RCC_ClockConfig+0x240>)
24013b80:	681b      	ldr	r3, [r3, #0]
24013b82:	f003 030f 	and.w	r3, r3, #15
24013b86:	683a      	ldr	r2, [r7, #0]
24013b88:	429a      	cmp	r2, r3
24013b8a:	d005      	beq.n	24013b98 <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
24013b8c:	2301      	movs	r3, #1
24013b8e:	e086      	b.n	24013c9e <HAL_RCC_ClockConfig+0x34e>
24013b90:	52002000 	.word	0x52002000
24013b94:	58024400 	.word	0x58024400
    }
 }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
24013b98:	687b      	ldr	r3, [r7, #4]
24013b9a:	681b      	ldr	r3, [r3, #0]
24013b9c:	f003 0304 	and.w	r3, r3, #4
24013ba0:	2b00      	cmp	r3, #0
24013ba2:	d010      	beq.n	24013bc6 <HAL_RCC_ClockConfig+0x276>
 {
#if defined(RCC_D1CFGR_D1PPRE)
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
24013ba4:	687b      	ldr	r3, [r7, #4]
24013ba6:	691a      	ldr	r2, [r3, #16]
24013ba8:	4b3f      	ldr	r3, [pc, #252]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013baa:	699b      	ldr	r3, [r3, #24]
24013bac:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013bb0:	429a      	cmp	r2, r3
24013bb2:	d208      	bcs.n	24013bc6 <HAL_RCC_ClockConfig+0x276>
   {
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
24013bb4:	4b3c      	ldr	r3, [pc, #240]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013bb6:	699b      	ldr	r3, [r3, #24]
24013bb8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013bbc:	687b      	ldr	r3, [r7, #4]
24013bbe:	691b      	ldr	r3, [r3, #16]
24013bc0:	4939      	ldr	r1, [pc, #228]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013bc2:	4313      	orrs	r3, r2
24013bc4:	618b      	str	r3, [r1, #24]
   }
#endif
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
24013bc6:	687b      	ldr	r3, [r7, #4]
24013bc8:	681b      	ldr	r3, [r3, #0]
24013bca:	f003 0308 	and.w	r3, r3, #8
24013bce:	2b00      	cmp	r3, #0
24013bd0:	d010      	beq.n	24013bf4 <HAL_RCC_ClockConfig+0x2a4>
 {
#if defined(RCC_D2CFGR_D2PPRE1)
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
24013bd2:	687b      	ldr	r3, [r7, #4]
24013bd4:	695a      	ldr	r2, [r3, #20]
24013bd6:	4b34      	ldr	r3, [pc, #208]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013bd8:	69db      	ldr	r3, [r3, #28]
24013bda:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013bde:	429a      	cmp	r2, r3
24013be0:	d208      	bcs.n	24013bf4 <HAL_RCC_ClockConfig+0x2a4>
   {
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
24013be2:	4b31      	ldr	r3, [pc, #196]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013be4:	69db      	ldr	r3, [r3, #28]
24013be6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013bea:	687b      	ldr	r3, [r7, #4]
24013bec:	695b      	ldr	r3, [r3, #20]
24013bee:	492e      	ldr	r1, [pc, #184]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013bf0:	4313      	orrs	r3, r2
24013bf2:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
24013bf4:	687b      	ldr	r3, [r7, #4]
24013bf6:	681b      	ldr	r3, [r3, #0]
24013bf8:	f003 0310 	and.w	r3, r3, #16
24013bfc:	2b00      	cmp	r3, #0
24013bfe:	d010      	beq.n	24013c22 <HAL_RCC_ClockConfig+0x2d2>
 {
#if defined (RCC_D2CFGR_D2PPRE2)
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
24013c00:	687b      	ldr	r3, [r7, #4]
24013c02:	699a      	ldr	r2, [r3, #24]
24013c04:	4b28      	ldr	r3, [pc, #160]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c06:	69db      	ldr	r3, [r3, #28]
24013c08:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
24013c0c:	429a      	cmp	r2, r3
24013c0e:	d208      	bcs.n	24013c22 <HAL_RCC_ClockConfig+0x2d2>
   {
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
24013c10:	4b25      	ldr	r3, [pc, #148]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c12:	69db      	ldr	r3, [r3, #28]
24013c14:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
24013c18:	687b      	ldr	r3, [r7, #4]
24013c1a:	699b      	ldr	r3, [r3, #24]
24013c1c:	4922      	ldr	r1, [pc, #136]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c1e:	4313      	orrs	r3, r2
24013c20:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
24013c22:	687b      	ldr	r3, [r7, #4]
24013c24:	681b      	ldr	r3, [r3, #0]
24013c26:	f003 0320 	and.w	r3, r3, #32
24013c2a:	2b00      	cmp	r3, #0
24013c2c:	d010      	beq.n	24013c50 <HAL_RCC_ClockConfig+0x300>
 {
#if defined(RCC_D3CFGR_D3PPRE)
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
24013c2e:	687b      	ldr	r3, [r7, #4]
24013c30:	69da      	ldr	r2, [r3, #28]
24013c32:	4b1d      	ldr	r3, [pc, #116]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c34:	6a1b      	ldr	r3, [r3, #32]
24013c36:	f003 0370 	and.w	r3, r3, #112	; 0x70
24013c3a:	429a      	cmp	r2, r3
24013c3c:	d208      	bcs.n	24013c50 <HAL_RCC_ClockConfig+0x300>
   {
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
24013c3e:	4b1a      	ldr	r3, [pc, #104]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c40:	6a1b      	ldr	r3, [r3, #32]
24013c42:	f023 0270 	bic.w	r2, r3, #112	; 0x70
24013c46:	687b      	ldr	r3, [r7, #4]
24013c48:	69db      	ldr	r3, [r3, #28]
24013c4a:	4917      	ldr	r1, [pc, #92]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c4c:	4313      	orrs	r3, r2
24013c4e:	620b      	str	r3, [r1, #32]
#endif
 }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
24013c50:	f000 f8be 	bl	24013dd0 <HAL_RCC_GetSysClockFreq>
24013c54:	4602      	mov	r2, r0
24013c56:	4b14      	ldr	r3, [pc, #80]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c58:	699b      	ldr	r3, [r3, #24]
24013c5a:	0a1b      	lsrs	r3, r3, #8
24013c5c:	f003 030f 	and.w	r3, r3, #15
24013c60:	4912      	ldr	r1, [pc, #72]	; (24013cac <HAL_RCC_ClockConfig+0x35c>)
24013c62:	5ccb      	ldrb	r3, [r1, r3]
24013c64:	f003 031f 	and.w	r3, r3, #31
24013c68:	fa22 f303 	lsr.w	r3, r2, r3
24013c6c:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
24013c6e:	4b0e      	ldr	r3, [pc, #56]	; (24013ca8 <HAL_RCC_ClockConfig+0x358>)
24013c70:	699b      	ldr	r3, [r3, #24]
24013c72:	f003 030f 	and.w	r3, r3, #15
24013c76:	4a0d      	ldr	r2, [pc, #52]	; (24013cac <HAL_RCC_ClockConfig+0x35c>)
24013c78:	5cd3      	ldrb	r3, [r2, r3]
24013c7a:	f003 031f 	and.w	r3, r3, #31
24013c7e:	693a      	ldr	r2, [r7, #16]
24013c80:	fa22 f303 	lsr.w	r3, r2, r3
24013c84:	4a0a      	ldr	r2, [pc, #40]	; (24013cb0 <HAL_RCC_ClockConfig+0x360>)
24013c86:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24013c88:	4a0a      	ldr	r2, [pc, #40]	; (24013cb4 <HAL_RCC_ClockConfig+0x364>)
24013c8a:	693b      	ldr	r3, [r7, #16]
24013c8c:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick (uwTickPrio);
24013c8e:	4b0a      	ldr	r3, [pc, #40]	; (24013cb8 <HAL_RCC_ClockConfig+0x368>)
24013c90:	681b      	ldr	r3, [r3, #0]
24013c92:	4618      	mov	r0, r3
24013c94:	f7ee fb0c 	bl	240022b0 <HAL_InitTick>
24013c98:	4603      	mov	r3, r0
24013c9a:	73fb      	strb	r3, [r7, #15]

  return halstatus;
24013c9c:	7bfb      	ldrb	r3, [r7, #15]
}
24013c9e:	4618      	mov	r0, r3
24013ca0:	3718      	adds	r7, #24
24013ca2:	46bd      	mov	sp, r7
24013ca4:	bd80      	pop	{r7, pc}
24013ca6:	bf00      	nop
24013ca8:	58024400 	.word	0x58024400
24013cac:	240178a4 	.word	0x240178a4
24013cb0:	240004b4 	.word	0x240004b4
24013cb4:	240004b0 	.word	0x240004b0
24013cb8:	240004b8 	.word	0x240004b8

24013cbc <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
24013cbc:	b580      	push	{r7, lr}
24013cbe:	b08c      	sub	sp, #48	; 0x30
24013cc0:	af00      	add	r7, sp, #0
24013cc2:	60f8      	str	r0, [r7, #12]
24013cc4:	60b9      	str	r1, [r7, #8]
24013cc6:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
24013cc8:	68fb      	ldr	r3, [r7, #12]
24013cca:	2b00      	cmp	r3, #0
24013ccc:	d12a      	bne.n	24013d24 <HAL_RCC_MCOConfig+0x68>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
24013cce:	4b2d      	ldr	r3, [pc, #180]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013cd0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24013cd4:	4a2b      	ldr	r2, [pc, #172]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013cd6:	f043 0301 	orr.w	r3, r3, #1
24013cda:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24013cde:	4b29      	ldr	r3, [pc, #164]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013ce0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24013ce4:	f003 0301 	and.w	r3, r3, #1
24013ce8:	61bb      	str	r3, [r7, #24]
24013cea:	69bb      	ldr	r3, [r7, #24]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
24013cec:	f44f 7380 	mov.w	r3, #256	; 0x100
24013cf0:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24013cf2:	2302      	movs	r3, #2
24013cf4:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24013cf6:	2303      	movs	r3, #3
24013cf8:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24013cfa:	2300      	movs	r3, #0
24013cfc:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24013cfe:	2300      	movs	r3, #0
24013d00:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
24013d02:	f107 031c 	add.w	r3, r7, #28
24013d06:	4619      	mov	r1, r3
24013d08:	481f      	ldr	r0, [pc, #124]	; (24013d88 <HAL_RCC_MCOConfig+0xcc>)
24013d0a:	f7f5 fd1f 	bl	2400974c <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
24013d0e:	4b1d      	ldr	r3, [pc, #116]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013d10:	691b      	ldr	r3, [r3, #16]
24013d12:	f023 72fe 	bic.w	r2, r3, #33292288	; 0x1fc0000
24013d16:	68b9      	ldr	r1, [r7, #8]
24013d18:	687b      	ldr	r3, [r7, #4]
24013d1a:	430b      	orrs	r3, r1
24013d1c:	4919      	ldr	r1, [pc, #100]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013d1e:	4313      	orrs	r3, r2
24013d20:	610b      	str	r3, [r1, #16]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
  }
}
24013d22:	e02a      	b.n	24013d7a <HAL_RCC_MCOConfig+0xbe>
    MCO2_CLK_ENABLE();
24013d24:	4b17      	ldr	r3, [pc, #92]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013d26:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24013d2a:	4a16      	ldr	r2, [pc, #88]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013d2c:	f043 0304 	orr.w	r3, r3, #4
24013d30:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
24013d34:	4b13      	ldr	r3, [pc, #76]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013d36:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
24013d3a:	f003 0304 	and.w	r3, r3, #4
24013d3e:	617b      	str	r3, [r7, #20]
24013d40:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
24013d42:	f44f 7300 	mov.w	r3, #512	; 0x200
24013d46:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
24013d48:	2302      	movs	r3, #2
24013d4a:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
24013d4c:	2303      	movs	r3, #3
24013d4e:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
24013d50:	2300      	movs	r3, #0
24013d52:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
24013d54:	2300      	movs	r3, #0
24013d56:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
24013d58:	f107 031c 	add.w	r3, r7, #28
24013d5c:	4619      	mov	r1, r3
24013d5e:	480b      	ldr	r0, [pc, #44]	; (24013d8c <HAL_RCC_MCOConfig+0xd0>)
24013d60:	f7f5 fcf4 	bl	2400974c <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
24013d64:	4b07      	ldr	r3, [pc, #28]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013d66:	691b      	ldr	r3, [r3, #16]
24013d68:	f023 427e 	bic.w	r2, r3, #4261412864	; 0xfe000000
24013d6c:	687b      	ldr	r3, [r7, #4]
24013d6e:	01d9      	lsls	r1, r3, #7
24013d70:	68bb      	ldr	r3, [r7, #8]
24013d72:	430b      	orrs	r3, r1
24013d74:	4903      	ldr	r1, [pc, #12]	; (24013d84 <HAL_RCC_MCOConfig+0xc8>)
24013d76:	4313      	orrs	r3, r2
24013d78:	610b      	str	r3, [r1, #16]
}
24013d7a:	bf00      	nop
24013d7c:	3730      	adds	r7, #48	; 0x30
24013d7e:	46bd      	mov	sp, r7
24013d80:	bd80      	pop	{r7, pc}
24013d82:	bf00      	nop
24013d84:	58024400 	.word	0x58024400
24013d88:	58020000 	.word	0x58020000
24013d8c:	58020800 	.word	0x58020800

24013d90 <HAL_RCC_EnableCSS>:
  *         allowing the MCU to perform rescue operations. The CSSI is linked to
  *         the Cortex-M NMI (Non-Mask-able Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
24013d90:	b480      	push	{r7}
24013d92:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_CSSHSEON) ;
24013d94:	4b05      	ldr	r3, [pc, #20]	; (24013dac <HAL_RCC_EnableCSS+0x1c>)
24013d96:	681b      	ldr	r3, [r3, #0]
24013d98:	4a04      	ldr	r2, [pc, #16]	; (24013dac <HAL_RCC_EnableCSS+0x1c>)
24013d9a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
24013d9e:	6013      	str	r3, [r2, #0]
}
24013da0:	bf00      	nop
24013da2:	46bd      	mov	sp, r7
24013da4:	f85d 7b04 	ldr.w	r7, [sp], #4
24013da8:	4770      	bx	lr
24013daa:	bf00      	nop
24013dac:	58024400 	.word	0x58024400

24013db0 <HAL_RCC_DisableCSS>:
/**
  * @brief  Disables the Clock Security System.
  * @retval None
  */
void HAL_RCC_DisableCSS(void)
{
24013db0:	b480      	push	{r7}
24013db2:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_CSSHSEON);
24013db4:	4b05      	ldr	r3, [pc, #20]	; (24013dcc <HAL_RCC_DisableCSS+0x1c>)
24013db6:	681b      	ldr	r3, [r3, #0]
24013db8:	4a04      	ldr	r2, [pc, #16]	; (24013dcc <HAL_RCC_DisableCSS+0x1c>)
24013dba:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
24013dbe:	6013      	str	r3, [r2, #0]
}
24013dc0:	bf00      	nop
24013dc2:	46bd      	mov	sp, r7
24013dc4:	f85d 7b04 	ldr.w	r7, [sp], #4
24013dc8:	4770      	bx	lr
24013dca:	bf00      	nop
24013dcc:	58024400 	.word	0x58024400

24013dd0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
24013dd0:	b480      	push	{r7}
24013dd2:	b089      	sub	sp, #36	; 0x24
24013dd4:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
24013dd6:	4bb3      	ldr	r3, [pc, #716]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013dd8:	691b      	ldr	r3, [r3, #16]
24013dda:	f003 0338 	and.w	r3, r3, #56	; 0x38
24013dde:	2b18      	cmp	r3, #24
24013de0:	f200 8155 	bhi.w	2401408e <HAL_RCC_GetSysClockFreq+0x2be>
24013de4:	a201      	add	r2, pc, #4	; (adr r2, 24013dec <HAL_RCC_GetSysClockFreq+0x1c>)
24013de6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24013dea:	bf00      	nop
24013dec:	24013e51 	.word	0x24013e51
24013df0:	2401408f 	.word	0x2401408f
24013df4:	2401408f 	.word	0x2401408f
24013df8:	2401408f 	.word	0x2401408f
24013dfc:	2401408f 	.word	0x2401408f
24013e00:	2401408f 	.word	0x2401408f
24013e04:	2401408f 	.word	0x2401408f
24013e08:	2401408f 	.word	0x2401408f
24013e0c:	24013e77 	.word	0x24013e77
24013e10:	2401408f 	.word	0x2401408f
24013e14:	2401408f 	.word	0x2401408f
24013e18:	2401408f 	.word	0x2401408f
24013e1c:	2401408f 	.word	0x2401408f
24013e20:	2401408f 	.word	0x2401408f
24013e24:	2401408f 	.word	0x2401408f
24013e28:	2401408f 	.word	0x2401408f
24013e2c:	24013e7d 	.word	0x24013e7d
24013e30:	2401408f 	.word	0x2401408f
24013e34:	2401408f 	.word	0x2401408f
24013e38:	2401408f 	.word	0x2401408f
24013e3c:	2401408f 	.word	0x2401408f
24013e40:	2401408f 	.word	0x2401408f
24013e44:	2401408f 	.word	0x2401408f
24013e48:	2401408f 	.word	0x2401408f
24013e4c:	24013e83 	.word	0x24013e83
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24013e50:	4b94      	ldr	r3, [pc, #592]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013e52:	681b      	ldr	r3, [r3, #0]
24013e54:	f003 0320 	and.w	r3, r3, #32
24013e58:	2b00      	cmp	r3, #0
24013e5a:	d009      	beq.n	24013e70 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24013e5c:	4b91      	ldr	r3, [pc, #580]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013e5e:	681b      	ldr	r3, [r3, #0]
24013e60:	08db      	lsrs	r3, r3, #3
24013e62:	f003 0303 	and.w	r3, r3, #3
24013e66:	4a90      	ldr	r2, [pc, #576]	; (240140a8 <HAL_RCC_GetSysClockFreq+0x2d8>)
24013e68:	fa22 f303 	lsr.w	r3, r2, r3
24013e6c:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
24013e6e:	e111      	b.n	24014094 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
24013e70:	4b8d      	ldr	r3, [pc, #564]	; (240140a8 <HAL_RCC_GetSysClockFreq+0x2d8>)
24013e72:	61bb      	str	r3, [r7, #24]
    break;
24013e74:	e10e      	b.n	24014094 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
24013e76:	4b8d      	ldr	r3, [pc, #564]	; (240140ac <HAL_RCC_GetSysClockFreq+0x2dc>)
24013e78:	61bb      	str	r3, [r7, #24]
    break;
24013e7a:	e10b      	b.n	24014094 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
24013e7c:	4b8c      	ldr	r3, [pc, #560]	; (240140b0 <HAL_RCC_GetSysClockFreq+0x2e0>)
24013e7e:	61bb      	str	r3, [r7, #24]
    break;
24013e80:	e108      	b.n	24014094 <HAL_RCC_GetSysClockFreq+0x2c4>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24013e82:	4b88      	ldr	r3, [pc, #544]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013e84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013e86:	f003 0303 	and.w	r3, r3, #3
24013e8a:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
24013e8c:	4b85      	ldr	r3, [pc, #532]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013e8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24013e90:	091b      	lsrs	r3, r3, #4
24013e92:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24013e96:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
24013e98:	4b82      	ldr	r3, [pc, #520]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013e9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24013e9c:	f003 0301 	and.w	r3, r3, #1
24013ea0:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
24013ea2:	4b80      	ldr	r3, [pc, #512]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013ea4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24013ea6:	08db      	lsrs	r3, r3, #3
24013ea8:	f3c3 030c 	ubfx	r3, r3, #0, #13
24013eac:	68fa      	ldr	r2, [r7, #12]
24013eae:	fb02 f303 	mul.w	r3, r2, r3
24013eb2:	ee07 3a90 	vmov	s15, r3
24013eb6:	eef8 7a67 	vcvt.f32.u32	s15, s15
24013eba:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
24013ebe:	693b      	ldr	r3, [r7, #16]
24013ec0:	2b00      	cmp	r3, #0
24013ec2:	f000 80e1 	beq.w	24014088 <HAL_RCC_GetSysClockFreq+0x2b8>
24013ec6:	697b      	ldr	r3, [r7, #20]
24013ec8:	2b02      	cmp	r3, #2
24013eca:	f000 8083 	beq.w	24013fd4 <HAL_RCC_GetSysClockFreq+0x204>
24013ece:	697b      	ldr	r3, [r7, #20]
24013ed0:	2b02      	cmp	r3, #2
24013ed2:	f200 80a1 	bhi.w	24014018 <HAL_RCC_GetSysClockFreq+0x248>
24013ed6:	697b      	ldr	r3, [r7, #20]
24013ed8:	2b00      	cmp	r3, #0
24013eda:	d003      	beq.n	24013ee4 <HAL_RCC_GetSysClockFreq+0x114>
24013edc:	697b      	ldr	r3, [r7, #20]
24013ede:	2b01      	cmp	r3, #1
24013ee0:	d056      	beq.n	24013f90 <HAL_RCC_GetSysClockFreq+0x1c0>
24013ee2:	e099      	b.n	24014018 <HAL_RCC_GetSysClockFreq+0x248>
    {
      switch (pllsource)
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24013ee4:	4b6f      	ldr	r3, [pc, #444]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013ee6:	681b      	ldr	r3, [r3, #0]
24013ee8:	f003 0320 	and.w	r3, r3, #32
24013eec:	2b00      	cmp	r3, #0
24013eee:	d02d      	beq.n	24013f4c <HAL_RCC_GetSysClockFreq+0x17c>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24013ef0:	4b6c      	ldr	r3, [pc, #432]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013ef2:	681b      	ldr	r3, [r3, #0]
24013ef4:	08db      	lsrs	r3, r3, #3
24013ef6:	f003 0303 	and.w	r3, r3, #3
24013efa:	4a6b      	ldr	r2, [pc, #428]	; (240140a8 <HAL_RCC_GetSysClockFreq+0x2d8>)
24013efc:	fa22 f303 	lsr.w	r3, r2, r3
24013f00:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24013f02:	687b      	ldr	r3, [r7, #4]
24013f04:	ee07 3a90 	vmov	s15, r3
24013f08:	eef8 6a67 	vcvt.f32.u32	s13, s15
24013f0c:	693b      	ldr	r3, [r7, #16]
24013f0e:	ee07 3a90 	vmov	s15, r3
24013f12:	eef8 7a67 	vcvt.f32.u32	s15, s15
24013f16:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24013f1a:	4b62      	ldr	r3, [pc, #392]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013f1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013f1e:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013f22:	ee07 3a90 	vmov	s15, r3
24013f26:	eef8 6a67 	vcvt.f32.u32	s13, s15
24013f2a:	ed97 6a02 	vldr	s12, [r7, #8]
24013f2e:	eddf 5a61 	vldr	s11, [pc, #388]	; 240140b4 <HAL_RCC_GetSysClockFreq+0x2e4>
24013f32:	eec6 7a25 	vdiv.f32	s15, s12, s11
24013f36:	ee76 7aa7 	vadd.f32	s15, s13, s15
24013f3a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24013f3e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24013f42:	ee67 7a27 	vmul.f32	s15, s14, s15
24013f46:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
24013f4a:	e087      	b.n	2401405c <HAL_RCC_GetSysClockFreq+0x28c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24013f4c:	693b      	ldr	r3, [r7, #16]
24013f4e:	ee07 3a90 	vmov	s15, r3
24013f52:	eef8 7a67 	vcvt.f32.u32	s15, s15
24013f56:	eddf 6a58 	vldr	s13, [pc, #352]	; 240140b8 <HAL_RCC_GetSysClockFreq+0x2e8>
24013f5a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24013f5e:	4b51      	ldr	r3, [pc, #324]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013f60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013f62:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013f66:	ee07 3a90 	vmov	s15, r3
24013f6a:	eef8 6a67 	vcvt.f32.u32	s13, s15
24013f6e:	ed97 6a02 	vldr	s12, [r7, #8]
24013f72:	eddf 5a50 	vldr	s11, [pc, #320]	; 240140b4 <HAL_RCC_GetSysClockFreq+0x2e4>
24013f76:	eec6 7a25 	vdiv.f32	s15, s12, s11
24013f7a:	ee76 7aa7 	vadd.f32	s15, s13, s15
24013f7e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24013f82:	ee77 7aa6 	vadd.f32	s15, s15, s13
24013f86:	ee67 7a27 	vmul.f32	s15, s14, s15
24013f8a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24013f8e:	e065      	b.n	2401405c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24013f90:	693b      	ldr	r3, [r7, #16]
24013f92:	ee07 3a90 	vmov	s15, r3
24013f96:	eef8 7a67 	vcvt.f32.u32	s15, s15
24013f9a:	eddf 6a48 	vldr	s13, [pc, #288]	; 240140bc <HAL_RCC_GetSysClockFreq+0x2ec>
24013f9e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24013fa2:	4b40      	ldr	r3, [pc, #256]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013fa4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013fa6:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013faa:	ee07 3a90 	vmov	s15, r3
24013fae:	eef8 6a67 	vcvt.f32.u32	s13, s15
24013fb2:	ed97 6a02 	vldr	s12, [r7, #8]
24013fb6:	eddf 5a3f 	vldr	s11, [pc, #252]	; 240140b4 <HAL_RCC_GetSysClockFreq+0x2e4>
24013fba:	eec6 7a25 	vdiv.f32	s15, s12, s11
24013fbe:	ee76 7aa7 	vadd.f32	s15, s13, s15
24013fc2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24013fc6:	ee77 7aa6 	vadd.f32	s15, s15, s13
24013fca:	ee67 7a27 	vmul.f32	s15, s14, s15
24013fce:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24013fd2:	e043      	b.n	2401405c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24013fd4:	693b      	ldr	r3, [r7, #16]
24013fd6:	ee07 3a90 	vmov	s15, r3
24013fda:	eef8 7a67 	vcvt.f32.u32	s15, s15
24013fde:	eddf 6a38 	vldr	s13, [pc, #224]	; 240140c0 <HAL_RCC_GetSysClockFreq+0x2f0>
24013fe2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24013fe6:	4b2f      	ldr	r3, [pc, #188]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
24013fe8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24013fea:	f3c3 0308 	ubfx	r3, r3, #0, #9
24013fee:	ee07 3a90 	vmov	s15, r3
24013ff2:	eef8 6a67 	vcvt.f32.u32	s13, s15
24013ff6:	ed97 6a02 	vldr	s12, [r7, #8]
24013ffa:	eddf 5a2e 	vldr	s11, [pc, #184]	; 240140b4 <HAL_RCC_GetSysClockFreq+0x2e4>
24013ffe:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014002:	ee76 7aa7 	vadd.f32	s15, s13, s15
24014006:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401400a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401400e:	ee67 7a27 	vmul.f32	s15, s14, s15
24014012:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
24014016:	e021      	b.n	2401405c <HAL_RCC_GetSysClockFreq+0x28c>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24014018:	693b      	ldr	r3, [r7, #16]
2401401a:	ee07 3a90 	vmov	s15, r3
2401401e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24014022:	eddf 6a26 	vldr	s13, [pc, #152]	; 240140bc <HAL_RCC_GetSysClockFreq+0x2ec>
24014026:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401402a:	4b1e      	ldr	r3, [pc, #120]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
2401402c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
2401402e:	f3c3 0308 	ubfx	r3, r3, #0, #9
24014032:	ee07 3a90 	vmov	s15, r3
24014036:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401403a:	ed97 6a02 	vldr	s12, [r7, #8]
2401403e:	eddf 5a1d 	vldr	s11, [pc, #116]	; 240140b4 <HAL_RCC_GetSysClockFreq+0x2e4>
24014042:	eec6 7a25 	vdiv.f32	s15, s12, s11
24014046:	ee76 7aa7 	vadd.f32	s15, s13, s15
2401404a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401404e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24014052:	ee67 7a27 	vmul.f32	s15, s14, s15
24014056:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
2401405a:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
2401405c:	4b11      	ldr	r3, [pc, #68]	; (240140a4 <HAL_RCC_GetSysClockFreq+0x2d4>)
2401405e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014060:	0a5b      	lsrs	r3, r3, #9
24014062:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24014066:	3301      	adds	r3, #1
24014068:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
2401406a:	683b      	ldr	r3, [r7, #0]
2401406c:	ee07 3a90 	vmov	s15, r3
24014070:	eeb8 7a67 	vcvt.f32.u32	s14, s15
24014074:	edd7 6a07 	vldr	s13, [r7, #28]
24014078:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401407c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24014080:	ee17 3a90 	vmov	r3, s15
24014084:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
24014086:	e005      	b.n	24014094 <HAL_RCC_GetSysClockFreq+0x2c4>
      sysclockfreq = 0U;
24014088:	2300      	movs	r3, #0
2401408a:	61bb      	str	r3, [r7, #24]
    break;
2401408c:	e002      	b.n	24014094 <HAL_RCC_GetSysClockFreq+0x2c4>

  default:
    sysclockfreq = CSI_VALUE;
2401408e:	4b07      	ldr	r3, [pc, #28]	; (240140ac <HAL_RCC_GetSysClockFreq+0x2dc>)
24014090:	61bb      	str	r3, [r7, #24]
    break;
24014092:	bf00      	nop
  }

  return sysclockfreq;
24014094:	69bb      	ldr	r3, [r7, #24]
}
24014096:	4618      	mov	r0, r3
24014098:	3724      	adds	r7, #36	; 0x24
2401409a:	46bd      	mov	sp, r7
2401409c:	f85d 7b04 	ldr.w	r7, [sp], #4
240140a0:	4770      	bx	lr
240140a2:	bf00      	nop
240140a4:	58024400 	.word	0x58024400
240140a8:	03d09000 	.word	0x03d09000
240140ac:	003d0900 	.word	0x003d0900
240140b0:	02dc6c00 	.word	0x02dc6c00
240140b4:	46000000 	.word	0x46000000
240140b8:	4c742400 	.word	0x4c742400
240140bc:	4a742400 	.word	0x4a742400
240140c0:	4c371b00 	.word	0x4c371b00

240140c4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
240140c4:	b580      	push	{r7, lr}
240140c6:	b082      	sub	sp, #8
240140c8:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
240140ca:	f7ff fe81 	bl	24013dd0 <HAL_RCC_GetSysClockFreq>
240140ce:	4602      	mov	r2, r0
240140d0:	4b10      	ldr	r3, [pc, #64]	; (24014114 <HAL_RCC_GetHCLKFreq+0x50>)
240140d2:	699b      	ldr	r3, [r3, #24]
240140d4:	0a1b      	lsrs	r3, r3, #8
240140d6:	f003 030f 	and.w	r3, r3, #15
240140da:	490f      	ldr	r1, [pc, #60]	; (24014118 <HAL_RCC_GetHCLKFreq+0x54>)
240140dc:	5ccb      	ldrb	r3, [r1, r3]
240140de:	f003 031f 	and.w	r3, r3, #31
240140e2:	fa22 f303 	lsr.w	r3, r2, r3
240140e6:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
240140e8:	4b0a      	ldr	r3, [pc, #40]	; (24014114 <HAL_RCC_GetHCLKFreq+0x50>)
240140ea:	699b      	ldr	r3, [r3, #24]
240140ec:	f003 030f 	and.w	r3, r3, #15
240140f0:	4a09      	ldr	r2, [pc, #36]	; (24014118 <HAL_RCC_GetHCLKFreq+0x54>)
240140f2:	5cd3      	ldrb	r3, [r2, r3]
240140f4:	f003 031f 	and.w	r3, r3, #31
240140f8:	687a      	ldr	r2, [r7, #4]
240140fa:	fa22 f303 	lsr.w	r3, r2, r3
240140fe:	4a07      	ldr	r2, [pc, #28]	; (2401411c <HAL_RCC_GetHCLKFreq+0x58>)
24014100:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
24014102:	4a07      	ldr	r2, [pc, #28]	; (24014120 <HAL_RCC_GetHCLKFreq+0x5c>)
24014104:	687b      	ldr	r3, [r7, #4]
24014106:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
24014108:	4b04      	ldr	r3, [pc, #16]	; (2401411c <HAL_RCC_GetHCLKFreq+0x58>)
2401410a:	681b      	ldr	r3, [r3, #0]
}
2401410c:	4618      	mov	r0, r3
2401410e:	3708      	adds	r7, #8
24014110:	46bd      	mov	sp, r7
24014112:	bd80      	pop	{r7, pc}
24014114:	58024400 	.word	0x58024400
24014118:	240178a4 	.word	0x240178a4
2401411c:	240004b4 	.word	0x240004b4
24014120:	240004b0 	.word	0x240004b0

24014124 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
24014124:	b580      	push	{r7, lr}
24014126:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
24014128:	f7ff ffcc 	bl	240140c4 <HAL_RCC_GetHCLKFreq>
2401412c:	4602      	mov	r2, r0
2401412e:	4b06      	ldr	r3, [pc, #24]	; (24014148 <HAL_RCC_GetPCLK1Freq+0x24>)
24014130:	69db      	ldr	r3, [r3, #28]
24014132:	091b      	lsrs	r3, r3, #4
24014134:	f003 0307 	and.w	r3, r3, #7
24014138:	4904      	ldr	r1, [pc, #16]	; (2401414c <HAL_RCC_GetPCLK1Freq+0x28>)
2401413a:	5ccb      	ldrb	r3, [r1, r3]
2401413c:	f003 031f 	and.w	r3, r3, #31
24014140:	fa22 f303 	lsr.w	r3, r2, r3
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
24014144:	4618      	mov	r0, r3
24014146:	bd80      	pop	{r7, pc}
24014148:	58024400 	.word	0x58024400
2401414c:	240178a4 	.word	0x240178a4

24014150 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
24014150:	b580      	push	{r7, lr}
24014152:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
24014154:	f7ff ffb6 	bl	240140c4 <HAL_RCC_GetHCLKFreq>
24014158:	4602      	mov	r2, r0
2401415a:	4b06      	ldr	r3, [pc, #24]	; (24014174 <HAL_RCC_GetPCLK2Freq+0x24>)
2401415c:	69db      	ldr	r3, [r3, #28]
2401415e:	0a1b      	lsrs	r3, r3, #8
24014160:	f003 0307 	and.w	r3, r3, #7
24014164:	4904      	ldr	r1, [pc, #16]	; (24014178 <HAL_RCC_GetPCLK2Freq+0x28>)
24014166:	5ccb      	ldrb	r3, [r1, r3]
24014168:	f003 031f 	and.w	r3, r3, #31
2401416c:	fa22 f303 	lsr.w	r3, r2, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
24014170:	4618      	mov	r0, r3
24014172:	bd80      	pop	{r7, pc}
24014174:	58024400 	.word	0x58024400
24014178:	240178a4 	.word	0x240178a4

2401417c <HAL_RCC_GetOscConfig>:
  * @param  RCC_OscInitStruct: pointer to an RCC_OscInitTypeDef structure that
  * will be configured.
  * @retval None
  */
void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
2401417c:	b580      	push	{r7, lr}
2401417e:	b082      	sub	sp, #8
24014180:	af00      	add	r7, sp, #0
24014182:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the Oscillator type parameter ---------------*/
  RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_CSI | \
24014184:	687b      	ldr	r3, [r7, #4]
24014186:	223f      	movs	r2, #63	; 0x3f
24014188:	601a      	str	r2, [r3, #0]
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
  }
#else
  if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
2401418a:	4b72      	ldr	r3, [pc, #456]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
2401418c:	681b      	ldr	r3, [r3, #0]
2401418e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24014192:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24014196:	d104      	bne.n	240141a2 <HAL_RCC_GetOscConfig+0x26>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
24014198:	687b      	ldr	r3, [r7, #4]
2401419a:	f44f 22a0 	mov.w	r2, #327680	; 0x50000
2401419e:	605a      	str	r2, [r3, #4]
240141a0:	e00e      	b.n	240141c0 <HAL_RCC_GetOscConfig+0x44>
  }
  else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
240141a2:	4b6c      	ldr	r3, [pc, #432]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240141a4:	681b      	ldr	r3, [r3, #0]
240141a6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240141aa:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240141ae:	d104      	bne.n	240141ba <HAL_RCC_GetOscConfig+0x3e>
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_ON;
240141b0:	687b      	ldr	r3, [r7, #4]
240141b2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
240141b6:	605a      	str	r2, [r3, #4]
240141b8:	e002      	b.n	240141c0 <HAL_RCC_GetOscConfig+0x44>
  }
  else
  {
    RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
240141ba:	687b      	ldr	r3, [r7, #4]
240141bc:	2200      	movs	r2, #0
240141be:	605a      	str	r2, [r3, #4]
  }
#endif /* RCC_CR_HSEEXT */

   /* Get the CSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_CSION) == RCC_CR_CSION)
240141c0:	4b64      	ldr	r3, [pc, #400]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240141c2:	681b      	ldr	r3, [r3, #0]
240141c4:	f003 0380 	and.w	r3, r3, #128	; 0x80
240141c8:	2b80      	cmp	r3, #128	; 0x80
240141ca:	d103      	bne.n	240141d4 <HAL_RCC_GetOscConfig+0x58>
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_ON;
240141cc:	687b      	ldr	r3, [r7, #4]
240141ce:	2280      	movs	r2, #128	; 0x80
240141d0:	61da      	str	r2, [r3, #28]
240141d2:	e002      	b.n	240141da <HAL_RCC_GetOscConfig+0x5e>
  }
  else
  {
    RCC_OscInitStruct->CSIState = RCC_CSI_OFF;
240141d4:	687b      	ldr	r3, [r7, #4]
240141d6:	2200      	movs	r2, #0
240141d8:	61da      	str	r2, [r3, #28]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
240141da:	f7ee f94d 	bl	24002478 <HAL_GetREVID>
240141de:	4603      	mov	r3, r0
240141e0:	f241 0203 	movw	r2, #4099	; 0x1003
240141e4:	4293      	cmp	r3, r2
240141e6:	d807      	bhi.n	240141f8 <HAL_RCC_GetOscConfig+0x7c>
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_CSITRIM_Msk) >> HAL_RCC_REV_Y_CSITRIM_Pos);
240141e8:	4b5a      	ldr	r3, [pc, #360]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240141ea:	685b      	ldr	r3, [r3, #4]
240141ec:	0e9b      	lsrs	r3, r3, #26
240141ee:	f003 021f 	and.w	r2, r3, #31
240141f2:	687b      	ldr	r3, [r7, #4]
240141f4:	621a      	str	r2, [r3, #32]
240141f6:	e006      	b.n	24014206 <HAL_RCC_GetOscConfig+0x8a>
  }
  else
  {
    RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
240141f8:	4b56      	ldr	r3, [pc, #344]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240141fa:	68db      	ldr	r3, [r3, #12]
240141fc:	0e1b      	lsrs	r3, r3, #24
240141fe:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24014202:	687b      	ldr	r3, [r7, #4]
24014204:	621a      	str	r2, [r3, #32]
#else
 RCC_OscInitStruct->CSICalibrationValue = (uint32_t)(READ_BIT(RCC->CSICFGR, RCC_CSICFGR_CSITRIM) >> RCC_CSICFGR_CSITRIM_Pos);
#endif /*RCC_VER_X*/

  /* Get the HSI configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
24014206:	4b53      	ldr	r3, [pc, #332]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014208:	681b      	ldr	r3, [r3, #0]
2401420a:	f003 0301 	and.w	r3, r3, #1
2401420e:	2b01      	cmp	r3, #1
24014210:	d103      	bne.n	2401421a <HAL_RCC_GetOscConfig+0x9e>
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_ON;
24014212:	687b      	ldr	r3, [r7, #4]
24014214:	2201      	movs	r2, #1
24014216:	60da      	str	r2, [r3, #12]
24014218:	e002      	b.n	24014220 <HAL_RCC_GetOscConfig+0xa4>
  }
  else
  {
    RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
2401421a:	687b      	ldr	r3, [r7, #4]
2401421c:	2200      	movs	r2, #0
2401421e:	60da      	str	r2, [r3, #12]
  }

#if defined(RCC_VER_X)
  if(HAL_GetREVID() <= REV_ID_Y)
24014220:	f7ee f92a 	bl	24002478 <HAL_GetREVID>
24014224:	4603      	mov	r3, r0
24014226:	f241 0203 	movw	r2, #4099	; 0x1003
2401422a:	4293      	cmp	r3, r2
2401422c:	d807      	bhi.n	2401423e <HAL_RCC_GetOscConfig+0xc2>
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, HAL_RCC_REV_Y_HSITRIM_Msk) >> HAL_RCC_REV_Y_HSITRIM_Pos);
2401422e:	4b49      	ldr	r3, [pc, #292]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014230:	685b      	ldr	r3, [r3, #4]
24014232:	0b1b      	lsrs	r3, r3, #12
24014234:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24014238:	687b      	ldr	r3, [r7, #4]
2401423a:	611a      	str	r2, [r3, #16]
2401423c:	e006      	b.n	2401424c <HAL_RCC_GetOscConfig+0xd0>
  }
  else
  {
    RCC_OscInitStruct->HSICalibrationValue = (uint32_t)(READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSITRIM) >> RCC_HSICFGR_HSITRIM_Pos);
2401423e:	4b45      	ldr	r3, [pc, #276]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014240:	685b      	ldr	r3, [r3, #4]
24014242:	0e1b      	lsrs	r3, r3, #24
24014244:	f003 027f 	and.w	r2, r3, #127	; 0x7f
24014248:	687b      	ldr	r3, [r7, #4]
2401424a:	611a      	str	r2, [r3, #16]
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
  }
#else
  if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
2401424c:	4b41      	ldr	r3, [pc, #260]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
2401424e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014250:	f003 0304 	and.w	r3, r3, #4
24014254:	2b04      	cmp	r3, #4
24014256:	d103      	bne.n	24014260 <HAL_RCC_GetOscConfig+0xe4>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
24014258:	687b      	ldr	r3, [r7, #4]
2401425a:	2205      	movs	r2, #5
2401425c:	609a      	str	r2, [r3, #8]
2401425e:	e00c      	b.n	2401427a <HAL_RCC_GetOscConfig+0xfe>
  }
  else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
24014260:	4b3c      	ldr	r3, [pc, #240]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014262:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014264:	f003 0301 	and.w	r3, r3, #1
24014268:	2b01      	cmp	r3, #1
2401426a:	d103      	bne.n	24014274 <HAL_RCC_GetOscConfig+0xf8>
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_ON;
2401426c:	687b      	ldr	r3, [r7, #4]
2401426e:	2201      	movs	r2, #1
24014270:	609a      	str	r2, [r3, #8]
24014272:	e002      	b.n	2401427a <HAL_RCC_GetOscConfig+0xfe>
  }
  else
  {
    RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
24014274:	687b      	ldr	r3, [r7, #4]
24014276:	2200      	movs	r2, #0
24014278:	609a      	str	r2, [r3, #8]
  }
#endif /* RCC_BDCR_LSEEXT */

  /* Get the LSI configuration -----------------------------------------------*/
  if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
2401427a:	4b36      	ldr	r3, [pc, #216]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
2401427c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
2401427e:	f003 0301 	and.w	r3, r3, #1
24014282:	2b01      	cmp	r3, #1
24014284:	d103      	bne.n	2401428e <HAL_RCC_GetOscConfig+0x112>
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_ON;
24014286:	687b      	ldr	r3, [r7, #4]
24014288:	2201      	movs	r2, #1
2401428a:	615a      	str	r2, [r3, #20]
2401428c:	e002      	b.n	24014294 <HAL_RCC_GetOscConfig+0x118>
  }
  else
  {
    RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
2401428e:	687b      	ldr	r3, [r7, #4]
24014290:	2200      	movs	r2, #0
24014292:	615a      	str	r2, [r3, #20]
  }

  /* Get the HSI48 configuration ---------------------------------------------*/
  if((RCC->CR & RCC_CR_HSI48ON) == RCC_CR_HSI48ON)
24014294:	4b2f      	ldr	r3, [pc, #188]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014296:	681b      	ldr	r3, [r3, #0]
24014298:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
2401429c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
240142a0:	d103      	bne.n	240142aa <HAL_RCC_GetOscConfig+0x12e>
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_ON;
240142a2:	687b      	ldr	r3, [r7, #4]
240142a4:	2201      	movs	r2, #1
240142a6:	619a      	str	r2, [r3, #24]
240142a8:	e002      	b.n	240142b0 <HAL_RCC_GetOscConfig+0x134>
  }
  else
  {
    RCC_OscInitStruct->HSI48State = RCC_HSI48_OFF;
240142aa:	687b      	ldr	r3, [r7, #4]
240142ac:	2200      	movs	r2, #0
240142ae:	619a      	str	r2, [r3, #24]
  }

  /* Get the PLL configuration -----------------------------------------------*/
  if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
240142b0:	4b28      	ldr	r3, [pc, #160]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240142b2:	681b      	ldr	r3, [r3, #0]
240142b4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
240142b8:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
240142bc:	d103      	bne.n	240142c6 <HAL_RCC_GetOscConfig+0x14a>
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
240142be:	687b      	ldr	r3, [r7, #4]
240142c0:	2202      	movs	r2, #2
240142c2:	625a      	str	r2, [r3, #36]	; 0x24
240142c4:	e002      	b.n	240142cc <HAL_RCC_GetOscConfig+0x150>
  }
  else
  {
    RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
240142c6:	687b      	ldr	r3, [r7, #4]
240142c8:	2201      	movs	r2, #1
240142ca:	625a      	str	r2, [r3, #36]	; 0x24
  }
  RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
240142cc:	4b21      	ldr	r3, [pc, #132]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240142ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240142d0:	f003 0203 	and.w	r2, r3, #3
240142d4:	687b      	ldr	r3, [r7, #4]
240142d6:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct->PLL.PLLM = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> RCC_PLLCKSELR_DIVM1_Pos);
240142d8:	4b1e      	ldr	r3, [pc, #120]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240142da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240142dc:	091b      	lsrs	r3, r3, #4
240142de:	f003 023f 	and.w	r2, r3, #63	; 0x3f
240142e2:	687b      	ldr	r3, [r7, #4]
240142e4:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_N1) >> RCC_PLL1DIVR_N1_Pos)+ 1U;
240142e6:	4b1b      	ldr	r3, [pc, #108]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240142e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240142ea:	f3c3 0308 	ubfx	r3, r3, #0, #9
240142ee:	1c5a      	adds	r2, r3, #1
240142f0:	687b      	ldr	r3, [r7, #4]
240142f2:	631a      	str	r2, [r3, #48]	; 0x30
  RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos)+ 1U;
240142f4:	4b17      	ldr	r3, [pc, #92]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
240142f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240142f8:	0e1b      	lsrs	r3, r3, #24
240142fa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240142fe:	1c5a      	adds	r2, r3, #1
24014300:	687b      	ldr	r3, [r7, #4]
24014302:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC_OscInitStruct->PLL.PLLP = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos)+ 1U;
24014304:	4b13      	ldr	r3, [pc, #76]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014306:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014308:	0a5b      	lsrs	r3, r3, #9
2401430a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2401430e:	1c5a      	adds	r2, r3, #1
24014310:	687b      	ldr	r3, [r7, #4]
24014312:	635a      	str	r2, [r3, #52]	; 0x34
  RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos)+ 1U;
24014314:	4b0f      	ldr	r3, [pc, #60]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014316:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24014318:	0c1b      	lsrs	r3, r3, #16
2401431a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2401431e:	1c5a      	adds	r2, r3, #1
24014320:	687b      	ldr	r3, [r7, #4]
24014322:	639a      	str	r2, [r3, #56]	; 0x38
  RCC_OscInitStruct->PLL.PLLRGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1RGE));
24014324:	4b0b      	ldr	r3, [pc, #44]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014326:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014328:	f003 020c 	and.w	r2, r3, #12
2401432c:	687b      	ldr	r3, [r7, #4]
2401432e:	641a      	str	r2, [r3, #64]	; 0x40
  RCC_OscInitStruct->PLL.PLLVCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL1VCOSEL) >> RCC_PLLCFGR_PLL1VCOSEL_Pos);
24014330:	4b08      	ldr	r3, [pc, #32]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014332:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014334:	085b      	lsrs	r3, r3, #1
24014336:	f003 0201 	and.w	r2, r3, #1
2401433a:	687b      	ldr	r3, [r7, #4]
2401433c:	645a      	str	r2, [r3, #68]	; 0x44
  RCC_OscInitStruct->PLL.PLLFRACN = (uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos));
2401433e:	4b05      	ldr	r3, [pc, #20]	; (24014354 <HAL_RCC_GetOscConfig+0x1d8>)
24014340:	6b5b      	ldr	r3, [r3, #52]	; 0x34
24014342:	08db      	lsrs	r3, r3, #3
24014344:	f3c3 020c 	ubfx	r2, r3, #0, #13
24014348:	687b      	ldr	r3, [r7, #4]
2401434a:	649a      	str	r2, [r3, #72]	; 0x48
}
2401434c:	bf00      	nop
2401434e:	3708      	adds	r7, #8
24014350:	46bd      	mov	sp, r7
24014352:	bd80      	pop	{r7, pc}
24014354:	58024400 	.word	0x58024400

24014358 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
24014358:	b480      	push	{r7}
2401435a:	b083      	sub	sp, #12
2401435c:	af00      	add	r7, sp, #0
2401435e:	6078      	str	r0, [r7, #4]
24014360:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
24014362:	687b      	ldr	r3, [r7, #4]
24014364:	223f      	movs	r2, #63	; 0x3f
24014366:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
24014368:	4b1a      	ldr	r3, [pc, #104]	; (240143d4 <HAL_RCC_GetClockConfig+0x7c>)
2401436a:	691b      	ldr	r3, [r3, #16]
2401436c:	f003 0207 	and.w	r2, r3, #7
24014370:	687b      	ldr	r3, [r7, #4]
24014372:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
24014374:	4b17      	ldr	r3, [pc, #92]	; (240143d4 <HAL_RCC_GetClockConfig+0x7c>)
24014376:	699b      	ldr	r3, [r3, #24]
24014378:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
2401437c:	687b      	ldr	r3, [r7, #4]
2401437e:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
24014380:	4b14      	ldr	r3, [pc, #80]	; (240143d4 <HAL_RCC_GetClockConfig+0x7c>)
24014382:	699b      	ldr	r3, [r3, #24]
24014384:	f003 020f 	and.w	r2, r3, #15
24014388:	687b      	ldr	r3, [r7, #4]
2401438a:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
2401438c:	4b11      	ldr	r3, [pc, #68]	; (240143d4 <HAL_RCC_GetClockConfig+0x7c>)
2401438e:	699b      	ldr	r3, [r3, #24]
24014390:	f003 0270 	and.w	r2, r3, #112	; 0x70
24014394:	687b      	ldr	r3, [r7, #4]
24014396:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
24014398:	4b0e      	ldr	r3, [pc, #56]	; (240143d4 <HAL_RCC_GetClockConfig+0x7c>)
2401439a:	69db      	ldr	r3, [r3, #28]
2401439c:	f003 0270 	and.w	r2, r3, #112	; 0x70
240143a0:	687b      	ldr	r3, [r7, #4]
240143a2:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
240143a4:	4b0b      	ldr	r3, [pc, #44]	; (240143d4 <HAL_RCC_GetClockConfig+0x7c>)
240143a6:	69db      	ldr	r3, [r3, #28]
240143a8:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
240143ac:	687b      	ldr	r3, [r7, #4]
240143ae:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
240143b0:	4b08      	ldr	r3, [pc, #32]	; (240143d4 <HAL_RCC_GetClockConfig+0x7c>)
240143b2:	6a1b      	ldr	r3, [r3, #32]
240143b4:	f003 0270 	and.w	r2, r3, #112	; 0x70
240143b8:	687b      	ldr	r3, [r7, #4]
240143ba:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
240143bc:	4b06      	ldr	r3, [pc, #24]	; (240143d8 <HAL_RCC_GetClockConfig+0x80>)
240143be:	681b      	ldr	r3, [r3, #0]
240143c0:	f003 020f 	and.w	r2, r3, #15
240143c4:	683b      	ldr	r3, [r7, #0]
240143c6:	601a      	str	r2, [r3, #0]
}
240143c8:	bf00      	nop
240143ca:	370c      	adds	r7, #12
240143cc:	46bd      	mov	sp, r7
240143ce:	f85d 7b04 	ldr.w	r7, [sp], #4
240143d2:	4770      	bx	lr
240143d4:	58024400 	.word	0x58024400
240143d8:	52002000 	.word	0x52002000

240143dc <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
240143dc:	b580      	push	{r7, lr}
240143de:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
240143e0:	4b07      	ldr	r3, [pc, #28]	; (24014400 <HAL_RCC_NMI_IRQHandler+0x24>)
240143e2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240143e4:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240143e8:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
240143ec:	d105      	bne.n	240143fa <HAL_RCC_NMI_IRQHandler+0x1e>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CCSCallback();
240143ee:	f000 f809 	bl	24014404 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
240143f2:	4b03      	ldr	r3, [pc, #12]	; (24014400 <HAL_RCC_NMI_IRQHandler+0x24>)
240143f4:	f44f 6280 	mov.w	r2, #1024	; 0x400
240143f8:	669a      	str	r2, [r3, #104]	; 0x68
  }
}
240143fa:	bf00      	nop
240143fc:	bd80      	pop	{r7, pc}
240143fe:	bf00      	nop
24014400:	58024400 	.word	0x58024400

24014404 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval none
  */
__weak void HAL_RCC_CCSCallback(void)
{
24014404:	b480      	push	{r7}
24014406:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CCSCallback could be implemented in the user file
   */
}
24014408:	bf00      	nop
2401440a:	46bd      	mov	sp, r7
2401440c:	f85d 7b04 	ldr.w	r7, [sp], #4
24014410:	4770      	bx	lr
	...

24014414 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
24014414:	b580      	push	{r7, lr}
24014416:	b086      	sub	sp, #24
24014418:	af00      	add	r7, sp, #0
2401441a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
2401441c:	2300      	movs	r3, #0
2401441e:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
24014420:	2300      	movs	r3, #0
24014422:	75bb      	strb	r3, [r7, #22]

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
24014424:	687b      	ldr	r3, [r7, #4]
24014426:	681b      	ldr	r3, [r3, #0]
24014428:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2401442c:	2b00      	cmp	r3, #0
2401442e:	d03f      	beq.n	240144b0 <HAL_RCCEx_PeriphCLKConfig+0x9c>
  {

    switch(PeriphClkInit->SpdifrxClockSelection)
24014430:	687b      	ldr	r3, [r7, #4]
24014432:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24014434:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24014438:	d02a      	beq.n	24014490 <HAL_RCCEx_PeriphCLKConfig+0x7c>
2401443a:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2401443e:	d824      	bhi.n	2401448a <HAL_RCCEx_PeriphCLKConfig+0x76>
24014440:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24014444:	d018      	beq.n	24014478 <HAL_RCCEx_PeriphCLKConfig+0x64>
24014446:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
2401444a:	d81e      	bhi.n	2401448a <HAL_RCCEx_PeriphCLKConfig+0x76>
2401444c:	2b00      	cmp	r3, #0
2401444e:	d003      	beq.n	24014458 <HAL_RCCEx_PeriphCLKConfig+0x44>
24014450:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24014454:	d007      	beq.n	24014466 <HAL_RCCEx_PeriphCLKConfig+0x52>
24014456:	e018      	b.n	2401448a <HAL_RCCEx_PeriphCLKConfig+0x76>
    {
    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
      /* Enable PLL1Q Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014458:	4ba3      	ldr	r3, [pc, #652]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
2401445a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401445c:	4aa2      	ldr	r2, [pc, #648]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
2401445e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014462:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
24014464:	e015      	b.n	24014492 <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
24014466:	687b      	ldr	r3, [r7, #4]
24014468:	3304      	adds	r3, #4
2401446a:	2102      	movs	r1, #2
2401446c:	4618      	mov	r0, r3
2401446e:	f002 fbbf 	bl	24016bf0 <RCCEx_PLL2_Config>
24014472:	4603      	mov	r3, r0
24014474:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
24014476:	e00c      	b.n	24014492 <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24014478:	687b      	ldr	r3, [r7, #4]
2401447a:	3324      	adds	r3, #36	; 0x24
2401447c:	2102      	movs	r1, #2
2401447e:	4618      	mov	r0, r3
24014480:	f002 fc68 	bl	24016d54 <RCCEx_PLL3_Config>
24014484:	4603      	mov	r3, r0
24014486:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
24014488:	e003      	b.n	24014492 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      /* Internal OSC clock is used as source of SPDIFRX clock*/
      /* SPDIFRX clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401448a:	2301      	movs	r3, #1
2401448c:	75fb      	strb	r3, [r7, #23]
      break;
2401448e:	e000      	b.n	24014492 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      break;
24014490:	bf00      	nop
    }

    if(ret == HAL_OK)
24014492:	7dfb      	ldrb	r3, [r7, #23]
24014494:	2b00      	cmp	r3, #0
24014496:	d109      	bne.n	240144ac <HAL_RCCEx_PeriphCLKConfig+0x98>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
24014498:	4b93      	ldr	r3, [pc, #588]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
2401449a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401449c:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
240144a0:	687b      	ldr	r3, [r7, #4]
240144a2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
240144a4:	4990      	ldr	r1, [pc, #576]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
240144a6:	4313      	orrs	r3, r2
240144a8:	650b      	str	r3, [r1, #80]	; 0x50
240144aa:	e001      	b.n	240144b0 <HAL_RCCEx_PeriphCLKConfig+0x9c>
    }
    else
    {
      /* set overall return value */
      status = ret;
240144ac:	7dfb      	ldrb	r3, [r7, #23]
240144ae:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
240144b0:	687b      	ldr	r3, [r7, #4]
240144b2:	681b      	ldr	r3, [r3, #0]
240144b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
240144b8:	2b00      	cmp	r3, #0
240144ba:	d03d      	beq.n	24014538 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
240144bc:	687b      	ldr	r3, [r7, #4]
240144be:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240144c0:	2b04      	cmp	r3, #4
240144c2:	d826      	bhi.n	24014512 <HAL_RCCEx_PeriphCLKConfig+0xfe>
240144c4:	a201      	add	r2, pc, #4	; (adr r2, 240144cc <HAL_RCCEx_PeriphCLKConfig+0xb8>)
240144c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240144ca:	bf00      	nop
240144cc:	240144e1 	.word	0x240144e1
240144d0:	240144ef 	.word	0x240144ef
240144d4:	24014501 	.word	0x24014501
240144d8:	24014519 	.word	0x24014519
240144dc:	24014519 	.word	0x24014519
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240144e0:	4b81      	ldr	r3, [pc, #516]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
240144e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240144e4:	4a80      	ldr	r2, [pc, #512]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
240144e6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240144ea:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240144ec:	e015      	b.n	2401451a <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240144ee:	687b      	ldr	r3, [r7, #4]
240144f0:	3304      	adds	r3, #4
240144f2:	2100      	movs	r1, #0
240144f4:	4618      	mov	r0, r3
240144f6:	f002 fb7b 	bl	24016bf0 <RCCEx_PLL2_Config>
240144fa:	4603      	mov	r3, r0
240144fc:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240144fe:	e00c      	b.n	2401451a <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
24014500:	687b      	ldr	r3, [r7, #4]
24014502:	3324      	adds	r3, #36	; 0x24
24014504:	2100      	movs	r1, #0
24014506:	4618      	mov	r0, r3
24014508:	f002 fc24 	bl	24016d54 <RCCEx_PLL3_Config>
2401450c:	4603      	mov	r3, r0
2401450e:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
24014510:	e003      	b.n	2401451a <HAL_RCCEx_PeriphCLKConfig+0x106>
      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24014512:	2301      	movs	r3, #1
24014514:	75fb      	strb	r3, [r7, #23]
      break;
24014516:	e000      	b.n	2401451a <HAL_RCCEx_PeriphCLKConfig+0x106>
      break;
24014518:	bf00      	nop
    }

    if(ret == HAL_OK)
2401451a:	7dfb      	ldrb	r3, [r7, #23]
2401451c:	2b00      	cmp	r3, #0
2401451e:	d109      	bne.n	24014534 <HAL_RCCEx_PeriphCLKConfig+0x120>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
24014520:	4b71      	ldr	r3, [pc, #452]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
24014522:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014524:	f023 0207 	bic.w	r2, r3, #7
24014528:	687b      	ldr	r3, [r7, #4]
2401452a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401452c:	496e      	ldr	r1, [pc, #440]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
2401452e:	4313      	orrs	r3, r2
24014530:	650b      	str	r3, [r1, #80]	; 0x50
24014532:	e001      	b.n	24014538 <HAL_RCCEx_PeriphCLKConfig+0x124>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014534:	7dfb      	ldrb	r3, [r7, #23]
24014536:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
24014538:	687b      	ldr	r3, [r7, #4]
2401453a:	681b      	ldr	r3, [r3, #0]
2401453c:	f403 7300 	and.w	r3, r3, #512	; 0x200
24014540:	2b00      	cmp	r3, #0
24014542:	d042      	beq.n	240145ca <HAL_RCCEx_PeriphCLKConfig+0x1b6>
  {
    switch(PeriphClkInit->Sai23ClockSelection)
24014544:	687b      	ldr	r3, [r7, #4]
24014546:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014548:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401454c:	d02b      	beq.n	240145a6 <HAL_RCCEx_PeriphCLKConfig+0x192>
2401454e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24014552:	d825      	bhi.n	240145a0 <HAL_RCCEx_PeriphCLKConfig+0x18c>
24014554:	2bc0      	cmp	r3, #192	; 0xc0
24014556:	d028      	beq.n	240145aa <HAL_RCCEx_PeriphCLKConfig+0x196>
24014558:	2bc0      	cmp	r3, #192	; 0xc0
2401455a:	d821      	bhi.n	240145a0 <HAL_RCCEx_PeriphCLKConfig+0x18c>
2401455c:	2b80      	cmp	r3, #128	; 0x80
2401455e:	d016      	beq.n	2401458e <HAL_RCCEx_PeriphCLKConfig+0x17a>
24014560:	2b80      	cmp	r3, #128	; 0x80
24014562:	d81d      	bhi.n	240145a0 <HAL_RCCEx_PeriphCLKConfig+0x18c>
24014564:	2b00      	cmp	r3, #0
24014566:	d002      	beq.n	2401456e <HAL_RCCEx_PeriphCLKConfig+0x15a>
24014568:	2b40      	cmp	r3, #64	; 0x40
2401456a:	d007      	beq.n	2401457c <HAL_RCCEx_PeriphCLKConfig+0x168>
2401456c:	e018      	b.n	240145a0 <HAL_RCCEx_PeriphCLKConfig+0x18c>
    {
    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401456e:	4b5e      	ldr	r3, [pc, #376]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
24014570:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014572:	4a5d      	ldr	r2, [pc, #372]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
24014574:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014578:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
2401457a:	e017      	b.n	240145ac <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2401457c:	687b      	ldr	r3, [r7, #4]
2401457e:	3304      	adds	r3, #4
24014580:	2100      	movs	r1, #0
24014582:	4618      	mov	r0, r3
24014584:	f002 fb34 	bl	24016bf0 <RCCEx_PLL2_Config>
24014588:	4603      	mov	r3, r0
2401458a:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
2401458c:	e00e      	b.n	240145ac <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2401458e:	687b      	ldr	r3, [r7, #4]
24014590:	3324      	adds	r3, #36	; 0x24
24014592:	2100      	movs	r1, #0
24014594:	4618      	mov	r0, r3
24014596:	f002 fbdd 	bl	24016d54 <RCCEx_PLL3_Config>
2401459a:	4603      	mov	r3, r0
2401459c:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
2401459e:	e005      	b.n	240145ac <HAL_RCCEx_PeriphCLKConfig+0x198>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
      /* SAI2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240145a0:	2301      	movs	r3, #1
240145a2:	75fb      	strb	r3, [r7, #23]
      break;
240145a4:	e002      	b.n	240145ac <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
240145a6:	bf00      	nop
240145a8:	e000      	b.n	240145ac <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
240145aa:	bf00      	nop
    }

    if(ret == HAL_OK)
240145ac:	7dfb      	ldrb	r3, [r7, #23]
240145ae:	2b00      	cmp	r3, #0
240145b0:	d109      	bne.n	240145c6 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
240145b2:	4b4d      	ldr	r3, [pc, #308]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
240145b4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240145b6:	f423 72e0 	bic.w	r2, r3, #448	; 0x1c0
240145ba:	687b      	ldr	r3, [r7, #4]
240145bc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240145be:	494a      	ldr	r1, [pc, #296]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
240145c0:	4313      	orrs	r3, r2
240145c2:	650b      	str	r3, [r1, #80]	; 0x50
240145c4:	e001      	b.n	240145ca <HAL_RCCEx_PeriphCLKConfig+0x1b6>
    }
    else
    {
      /* set overall return value */
      status = ret;
240145c6:	7dfb      	ldrb	r3, [r7, #23]
240145c8:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
240145ca:	687b      	ldr	r3, [r7, #4]
240145cc:	681b      	ldr	r3, [r3, #0]
240145ce:	f403 6380 	and.w	r3, r3, #1024	; 0x400
240145d2:	2b00      	cmp	r3, #0
240145d4:	d049      	beq.n	2401466a <HAL_RCCEx_PeriphCLKConfig+0x256>
  {
    switch(PeriphClkInit->Sai4AClockSelection)
240145d6:	687b      	ldr	r3, [r7, #4]
240145d8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
240145dc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
240145e0:	d030      	beq.n	24014644 <HAL_RCCEx_PeriphCLKConfig+0x230>
240145e2:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
240145e6:	d82a      	bhi.n	2401463e <HAL_RCCEx_PeriphCLKConfig+0x22a>
240145e8:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240145ec:	d02c      	beq.n	24014648 <HAL_RCCEx_PeriphCLKConfig+0x234>
240145ee:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
240145f2:	d824      	bhi.n	2401463e <HAL_RCCEx_PeriphCLKConfig+0x22a>
240145f4:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240145f8:	d018      	beq.n	2401462c <HAL_RCCEx_PeriphCLKConfig+0x218>
240145fa:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
240145fe:	d81e      	bhi.n	2401463e <HAL_RCCEx_PeriphCLKConfig+0x22a>
24014600:	2b00      	cmp	r3, #0
24014602:	d003      	beq.n	2401460c <HAL_RCCEx_PeriphCLKConfig+0x1f8>
24014604:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24014608:	d007      	beq.n	2401461a <HAL_RCCEx_PeriphCLKConfig+0x206>
2401460a:	e018      	b.n	2401463e <HAL_RCCEx_PeriphCLKConfig+0x22a>
    {
    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401460c:	4b36      	ldr	r3, [pc, #216]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
2401460e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014610:	4a35      	ldr	r2, [pc, #212]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
24014612:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014616:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
24014618:	e017      	b.n	2401464a <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
2401461a:	687b      	ldr	r3, [r7, #4]
2401461c:	3304      	adds	r3, #4
2401461e:	2100      	movs	r1, #0
24014620:	4618      	mov	r0, r3
24014622:	f002 fae5 	bl	24016bf0 <RCCEx_PLL2_Config>
24014626:	4603      	mov	r3, r0
24014628:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
2401462a:	e00e      	b.n	2401464a <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
2401462c:	687b      	ldr	r3, [r7, #4]
2401462e:	3324      	adds	r3, #36	; 0x24
24014630:	2100      	movs	r1, #0
24014632:	4618      	mov	r0, r3
24014634:	f002 fb8e 	bl	24016d54 <RCCEx_PLL3_Config>
24014638:	4603      	mov	r3, r0
2401463a:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
2401463c:	e005      	b.n	2401464a <HAL_RCCEx_PeriphCLKConfig+0x236>
      /* SAI4A clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
2401463e:	2301      	movs	r3, #1
24014640:	75fb      	strb	r3, [r7, #23]
      break;
24014642:	e002      	b.n	2401464a <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
24014644:	bf00      	nop
24014646:	e000      	b.n	2401464a <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
24014648:	bf00      	nop
    }

    if(ret == HAL_OK)
2401464a:	7dfb      	ldrb	r3, [r7, #23]
2401464c:	2b00      	cmp	r3, #0
2401464e:	d10a      	bne.n	24014666 <HAL_RCCEx_PeriphCLKConfig+0x252>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
24014650:	4b25      	ldr	r3, [pc, #148]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
24014652:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014654:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
24014658:	687b      	ldr	r3, [r7, #4]
2401465a:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
2401465e:	4922      	ldr	r1, [pc, #136]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
24014660:	4313      	orrs	r3, r2
24014662:	658b      	str	r3, [r1, #88]	; 0x58
24014664:	e001      	b.n	2401466a <HAL_RCCEx_PeriphCLKConfig+0x256>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014666:	7dfb      	ldrb	r3, [r7, #23]
24014668:	75bb      	strb	r3, [r7, #22]
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
2401466a:	687b      	ldr	r3, [r7, #4]
2401466c:	681b      	ldr	r3, [r3, #0]
2401466e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
24014672:	2b00      	cmp	r3, #0
24014674:	d04b      	beq.n	2401470e <HAL_RCCEx_PeriphCLKConfig+0x2fa>
  {
    switch(PeriphClkInit->Sai4BClockSelection)
24014676:	687b      	ldr	r3, [r7, #4]
24014678:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
2401467c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24014680:	d030      	beq.n	240146e4 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
24014682:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24014686:	d82a      	bhi.n	240146de <HAL_RCCEx_PeriphCLKConfig+0x2ca>
24014688:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2401468c:	d02e      	beq.n	240146ec <HAL_RCCEx_PeriphCLKConfig+0x2d8>
2401468e:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
24014692:	d824      	bhi.n	240146de <HAL_RCCEx_PeriphCLKConfig+0x2ca>
24014694:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24014698:	d018      	beq.n	240146cc <HAL_RCCEx_PeriphCLKConfig+0x2b8>
2401469a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2401469e:	d81e      	bhi.n	240146de <HAL_RCCEx_PeriphCLKConfig+0x2ca>
240146a0:	2b00      	cmp	r3, #0
240146a2:	d003      	beq.n	240146ac <HAL_RCCEx_PeriphCLKConfig+0x298>
240146a4:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
240146a8:	d007      	beq.n	240146ba <HAL_RCCEx_PeriphCLKConfig+0x2a6>
240146aa:	e018      	b.n	240146de <HAL_RCCEx_PeriphCLKConfig+0x2ca>
    {
    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240146ac:	4b0e      	ldr	r3, [pc, #56]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
240146ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240146b0:	4a0d      	ldr	r2, [pc, #52]	; (240146e8 <HAL_RCCEx_PeriphCLKConfig+0x2d4>)
240146b2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240146b6:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240146b8:	e019      	b.n	240146ee <HAL_RCCEx_PeriphCLKConfig+0x2da>

    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240146ba:	687b      	ldr	r3, [r7, #4]
240146bc:	3304      	adds	r3, #4
240146be:	2100      	movs	r1, #0
240146c0:	4618      	mov	r0, r3
240146c2:	f002 fa95 	bl	24016bf0 <RCCEx_PLL2_Config>
240146c6:	4603      	mov	r3, r0
240146c8:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
240146ca:	e010      	b.n	240146ee <HAL_RCCEx_PeriphCLKConfig+0x2da>

    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
240146cc:	687b      	ldr	r3, [r7, #4]
240146ce:	3324      	adds	r3, #36	; 0x24
240146d0:	2100      	movs	r1, #0
240146d2:	4618      	mov	r0, r3
240146d4:	f002 fb3e 	bl	24016d54 <RCCEx_PLL3_Config>
240146d8:	4603      	mov	r3, r0
240146da:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
240146dc:	e007      	b.n	240146ee <HAL_RCCEx_PeriphCLKConfig+0x2da>
      /* SAI4B clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
240146de:	2301      	movs	r3, #1
240146e0:	75fb      	strb	r3, [r7, #23]
      break;
240146e2:	e004      	b.n	240146ee <HAL_RCCEx_PeriphCLKConfig+0x2da>
      break;
240146e4:	bf00      	nop
240146e6:	e002      	b.n	240146ee <HAL_RCCEx_PeriphCLKConfig+0x2da>
240146e8:	58024400 	.word	0x58024400
      break;
240146ec:	bf00      	nop
    }

    if(ret == HAL_OK)
240146ee:	7dfb      	ldrb	r3, [r7, #23]
240146f0:	2b00      	cmp	r3, #0
240146f2:	d10a      	bne.n	2401470a <HAL_RCCEx_PeriphCLKConfig+0x2f6>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
240146f4:	4b99      	ldr	r3, [pc, #612]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
240146f6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240146f8:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
240146fc:	687b      	ldr	r3, [r7, #4]
240146fe:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
24014702:	4996      	ldr	r1, [pc, #600]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
24014704:	4313      	orrs	r3, r2
24014706:	658b      	str	r3, [r1, #88]	; 0x58
24014708:	e001      	b.n	2401470e <HAL_RCCEx_PeriphCLKConfig+0x2fa>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401470a:	7dfb      	ldrb	r3, [r7, #23]
2401470c:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
2401470e:	687b      	ldr	r3, [r7, #4]
24014710:	681b      	ldr	r3, [r3, #0]
24014712:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24014716:	2b00      	cmp	r3, #0
24014718:	d032      	beq.n	24014780 <HAL_RCCEx_PeriphCLKConfig+0x36c>
  {
    switch(PeriphClkInit->QspiClockSelection)
2401471a:	687b      	ldr	r3, [r7, #4]
2401471c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
2401471e:	2b30      	cmp	r3, #48	; 0x30
24014720:	d01c      	beq.n	2401475c <HAL_RCCEx_PeriphCLKConfig+0x348>
24014722:	2b30      	cmp	r3, #48	; 0x30
24014724:	d817      	bhi.n	24014756 <HAL_RCCEx_PeriphCLKConfig+0x342>
24014726:	2b20      	cmp	r3, #32
24014728:	d00c      	beq.n	24014744 <HAL_RCCEx_PeriphCLKConfig+0x330>
2401472a:	2b20      	cmp	r3, #32
2401472c:	d813      	bhi.n	24014756 <HAL_RCCEx_PeriphCLKConfig+0x342>
2401472e:	2b00      	cmp	r3, #0
24014730:	d016      	beq.n	24014760 <HAL_RCCEx_PeriphCLKConfig+0x34c>
24014732:	2b10      	cmp	r3, #16
24014734:	d10f      	bne.n	24014756 <HAL_RCCEx_PeriphCLKConfig+0x342>
    {
    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
      /* Enable QSPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24014736:	4b89      	ldr	r3, [pc, #548]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
24014738:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401473a:	4a88      	ldr	r2, [pc, #544]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
2401473c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014740:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* QSPI clock source configuration done later after clock selection check */
      break;
24014742:	e00e      	b.n	24014762 <HAL_RCCEx_PeriphCLKConfig+0x34e>

    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
24014744:	687b      	ldr	r3, [r7, #4]
24014746:	3304      	adds	r3, #4
24014748:	2102      	movs	r1, #2
2401474a:	4618      	mov	r0, r3
2401474c:	f002 fa50 	bl	24016bf0 <RCCEx_PLL2_Config>
24014750:	4603      	mov	r3, r0
24014752:	75fb      	strb	r3, [r7, #23]

      /* QSPI clock source configuration done later after clock selection check */
      break;
24014754:	e005      	b.n	24014762 <HAL_RCCEx_PeriphCLKConfig+0x34e>
    case RCC_QSPICLKSOURCE_D1HCLK:
      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
24014756:	2301      	movs	r3, #1
24014758:	75fb      	strb	r3, [r7, #23]
      break;
2401475a:	e002      	b.n	24014762 <HAL_RCCEx_PeriphCLKConfig+0x34e>
      break;
2401475c:	bf00      	nop
2401475e:	e000      	b.n	24014762 <HAL_RCCEx_PeriphCLKConfig+0x34e>
      break;
24014760:	bf00      	nop
    }

    if(ret == HAL_OK)
24014762:	7dfb      	ldrb	r3, [r7, #23]
24014764:	2b00      	cmp	r3, #0
24014766:	d109      	bne.n	2401477c <HAL_RCCEx_PeriphCLKConfig+0x368>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
24014768:	4b7c      	ldr	r3, [pc, #496]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
2401476a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401476c:	f023 0230 	bic.w	r2, r3, #48	; 0x30
24014770:	687b      	ldr	r3, [r7, #4]
24014772:	6c9b      	ldr	r3, [r3, #72]	; 0x48
24014774:	4979      	ldr	r1, [pc, #484]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
24014776:	4313      	orrs	r3, r2
24014778:	64cb      	str	r3, [r1, #76]	; 0x4c
2401477a:	e001      	b.n	24014780 <HAL_RCCEx_PeriphCLKConfig+0x36c>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401477c:	7dfb      	ldrb	r3, [r7, #23]
2401477e:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
24014780:	687b      	ldr	r3, [r7, #4]
24014782:	681b      	ldr	r3, [r3, #0]
24014784:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
24014788:	2b00      	cmp	r3, #0
2401478a:	d047      	beq.n	2401481c <HAL_RCCEx_PeriphCLKConfig+0x408>
  {
    switch(PeriphClkInit->Spi123ClockSelection)
2401478c:	687b      	ldr	r3, [r7, #4]
2401478e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24014790:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24014794:	d030      	beq.n	240147f8 <HAL_RCCEx_PeriphCLKConfig+0x3e4>
24014796:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
2401479a:	d82a      	bhi.n	240147f2 <HAL_RCCEx_PeriphCLKConfig+0x3de>
2401479c:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
240147a0:	d02c      	beq.n	240147fc <HAL_RCCEx_PeriphCLKConfig+0x3e8>
240147a2:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
240147a6:	d824      	bhi.n	240147f2 <HAL_RCCEx_PeriphCLKConfig+0x3de>
240147a8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
240147ac:	d018      	beq.n	240147e0 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
240147ae:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
240147b2:	d81e      	bhi.n	240147f2 <HAL_RCCEx_PeriphCLKConfig+0x3de>
240147b4:	2b00      	cmp	r3, #0
240147b6:	d003      	beq.n	240147c0 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
240147b8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
240147bc:	d007      	beq.n	240147ce <HAL_RCCEx_PeriphCLKConfig+0x3ba>
240147be:	e018      	b.n	240147f2 <HAL_RCCEx_PeriphCLKConfig+0x3de>
    {
    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
      /* Enable SPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240147c0:	4b66      	ldr	r3, [pc, #408]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
240147c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240147c4:	4a65      	ldr	r2, [pc, #404]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
240147c6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240147ca:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240147cc:	e017      	b.n	240147fe <HAL_RCCEx_PeriphCLKConfig+0x3ea>

    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
240147ce:	687b      	ldr	r3, [r7, #4]
240147d0:	3304      	adds	r3, #4
240147d2:	2100      	movs	r1, #0
240147d4:	4618      	mov	r0, r3
240147d6:	f002 fa0b 	bl	24016bf0 <RCCEx_PLL2_Config>
240147da:	4603      	mov	r3, r0
240147dc:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240147de:	e00e      	b.n	240147fe <HAL_RCCEx_PeriphCLKConfig+0x3ea>

    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
240147e0:	687b      	ldr	r3, [r7, #4]
240147e2:	3324      	adds	r3, #36	; 0x24
240147e4:	2100      	movs	r1, #0
240147e6:	4618      	mov	r0, r3
240147e8:	f002 fab4 	bl	24016d54 <RCCEx_PLL3_Config>
240147ec:	4603      	mov	r3, r0
240147ee:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
240147f0:	e005      	b.n	240147fe <HAL_RCCEx_PeriphCLKConfig+0x3ea>
      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240147f2:	2301      	movs	r3, #1
240147f4:	75fb      	strb	r3, [r7, #23]
      break;
240147f6:	e002      	b.n	240147fe <HAL_RCCEx_PeriphCLKConfig+0x3ea>
      break;
240147f8:	bf00      	nop
240147fa:	e000      	b.n	240147fe <HAL_RCCEx_PeriphCLKConfig+0x3ea>
      break;
240147fc:	bf00      	nop
    }

    if(ret == HAL_OK)
240147fe:	7dfb      	ldrb	r3, [r7, #23]
24014800:	2b00      	cmp	r3, #0
24014802:	d109      	bne.n	24014818 <HAL_RCCEx_PeriphCLKConfig+0x404>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
24014804:	4b55      	ldr	r3, [pc, #340]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
24014806:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24014808:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
2401480c:	687b      	ldr	r3, [r7, #4]
2401480e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
24014810:	4952      	ldr	r1, [pc, #328]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
24014812:	4313      	orrs	r3, r2
24014814:	650b      	str	r3, [r1, #80]	; 0x50
24014816:	e001      	b.n	2401481c <HAL_RCCEx_PeriphCLKConfig+0x408>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014818:	7dfb      	ldrb	r3, [r7, #23]
2401481a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
2401481c:	687b      	ldr	r3, [r7, #4]
2401481e:	681b      	ldr	r3, [r3, #0]
24014820:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
24014824:	2b00      	cmp	r3, #0
24014826:	d049      	beq.n	240148bc <HAL_RCCEx_PeriphCLKConfig+0x4a8>
  {
    switch(PeriphClkInit->Spi45ClockSelection)
24014828:	687b      	ldr	r3, [r7, #4]
2401482a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2401482c:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24014830:	d02e      	beq.n	24014890 <HAL_RCCEx_PeriphCLKConfig+0x47c>
24014832:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
24014836:	d828      	bhi.n	2401488a <HAL_RCCEx_PeriphCLKConfig+0x476>
24014838:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2401483c:	d02a      	beq.n	24014894 <HAL_RCCEx_PeriphCLKConfig+0x480>
2401483e:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
24014842:	d822      	bhi.n	2401488a <HAL_RCCEx_PeriphCLKConfig+0x476>
24014844:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
24014848:	d026      	beq.n	24014898 <HAL_RCCEx_PeriphCLKConfig+0x484>
2401484a:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
2401484e:	d81c      	bhi.n	2401488a <HAL_RCCEx_PeriphCLKConfig+0x476>
24014850:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24014854:	d010      	beq.n	24014878 <HAL_RCCEx_PeriphCLKConfig+0x464>
24014856:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2401485a:	d816      	bhi.n	2401488a <HAL_RCCEx_PeriphCLKConfig+0x476>
2401485c:	2b00      	cmp	r3, #0
2401485e:	d01d      	beq.n	2401489c <HAL_RCCEx_PeriphCLKConfig+0x488>
24014860:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24014864:	d111      	bne.n	2401488a <HAL_RCCEx_PeriphCLKConfig+0x476>
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24014866:	687b      	ldr	r3, [r7, #4]
24014868:	3304      	adds	r3, #4
2401486a:	2101      	movs	r1, #1
2401486c:	4618      	mov	r0, r3
2401486e:	f002 f9bf 	bl	24016bf0 <RCCEx_PLL2_Config>
24014872:	4603      	mov	r3, r0
24014874:	75fb      	strb	r3, [r7, #23]

      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
24014876:	e012      	b.n	2401489e <HAL_RCCEx_PeriphCLKConfig+0x48a>
    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24014878:	687b      	ldr	r3, [r7, #4]
2401487a:	3324      	adds	r3, #36	; 0x24
2401487c:	2101      	movs	r1, #1
2401487e:	4618      	mov	r0, r3
24014880:	f002 fa68 	bl	24016d54 <RCCEx_PLL3_Config>
24014884:	4603      	mov	r3, r0
24014886:	75fb      	strb	r3, [r7, #23]
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
24014888:	e009      	b.n	2401489e <HAL_RCCEx_PeriphCLKConfig+0x48a>
      /* HSE,  oscillator is used as source of SPI4/5 clock */
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
2401488a:	2301      	movs	r3, #1
2401488c:	75fb      	strb	r3, [r7, #23]
      break;
2401488e:	e006      	b.n	2401489e <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
24014890:	bf00      	nop
24014892:	e004      	b.n	2401489e <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
24014894:	bf00      	nop
24014896:	e002      	b.n	2401489e <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
24014898:	bf00      	nop
2401489a:	e000      	b.n	2401489e <HAL_RCCEx_PeriphCLKConfig+0x48a>
      break;
2401489c:	bf00      	nop
    }

    if(ret == HAL_OK)
2401489e:	7dfb      	ldrb	r3, [r7, #23]
240148a0:	2b00      	cmp	r3, #0
240148a2:	d109      	bne.n	240148b8 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
240148a4:	4b2d      	ldr	r3, [pc, #180]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
240148a6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240148a8:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
240148ac:	687b      	ldr	r3, [r7, #4]
240148ae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240148b0:	492a      	ldr	r1, [pc, #168]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
240148b2:	4313      	orrs	r3, r2
240148b4:	650b      	str	r3, [r1, #80]	; 0x50
240148b6:	e001      	b.n	240148bc <HAL_RCCEx_PeriphCLKConfig+0x4a8>
    }
    else
    {
      /* set overall return value */
      status = ret;
240148b8:	7dfb      	ldrb	r3, [r7, #23]
240148ba:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
240148bc:	687b      	ldr	r3, [r7, #4]
240148be:	681b      	ldr	r3, [r3, #0]
240148c0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
240148c4:	2b00      	cmp	r3, #0
240148c6:	d04d      	beq.n	24014964 <HAL_RCCEx_PeriphCLKConfig+0x550>
  {
    switch(PeriphClkInit->Spi6ClockSelection)
240148c8:	687b      	ldr	r3, [r7, #4]
240148ca:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
240148ce:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
240148d2:	d02e      	beq.n	24014932 <HAL_RCCEx_PeriphCLKConfig+0x51e>
240148d4:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
240148d8:	d828      	bhi.n	2401492c <HAL_RCCEx_PeriphCLKConfig+0x518>
240148da:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240148de:	d02a      	beq.n	24014936 <HAL_RCCEx_PeriphCLKConfig+0x522>
240148e0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
240148e4:	d822      	bhi.n	2401492c <HAL_RCCEx_PeriphCLKConfig+0x518>
240148e6:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
240148ea:	d026      	beq.n	2401493a <HAL_RCCEx_PeriphCLKConfig+0x526>
240148ec:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
240148f0:	d81c      	bhi.n	2401492c <HAL_RCCEx_PeriphCLKConfig+0x518>
240148f2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240148f6:	d010      	beq.n	2401491a <HAL_RCCEx_PeriphCLKConfig+0x506>
240148f8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240148fc:	d816      	bhi.n	2401492c <HAL_RCCEx_PeriphCLKConfig+0x518>
240148fe:	2b00      	cmp	r3, #0
24014900:	d01d      	beq.n	2401493e <HAL_RCCEx_PeriphCLKConfig+0x52a>
24014902:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014906:	d111      	bne.n	2401492c <HAL_RCCEx_PeriphCLKConfig+0x518>
      /* SPI6 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24014908:	687b      	ldr	r3, [r7, #4]
2401490a:	3304      	adds	r3, #4
2401490c:	2101      	movs	r1, #1
2401490e:	4618      	mov	r0, r3
24014910:	f002 f96e 	bl	24016bf0 <RCCEx_PLL2_Config>
24014914:	4603      	mov	r3, r0
24014916:	75fb      	strb	r3, [r7, #23]

      /* SPI6 clock source configuration done later after clock selection check */
      break;
24014918:	e012      	b.n	24014940 <HAL_RCCEx_PeriphCLKConfig+0x52c>
    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
2401491a:	687b      	ldr	r3, [r7, #4]
2401491c:	3324      	adds	r3, #36	; 0x24
2401491e:	2101      	movs	r1, #1
24014920:	4618      	mov	r0, r3
24014922:	f002 fa17 	bl	24016d54 <RCCEx_PLL3_Config>
24014926:	4603      	mov	r3, r0
24014928:	75fb      	strb	r3, [r7, #23]
      /* SPI6 clock source configuration done later after clock selection check */
      break;
2401492a:	e009      	b.n	24014940 <HAL_RCCEx_PeriphCLKConfig+0x52c>
      /* SPI6 clock source configuration done later after clock selection check */
      break;
#endif

    default:
      ret = HAL_ERROR;
2401492c:	2301      	movs	r3, #1
2401492e:	75fb      	strb	r3, [r7, #23]
      break;
24014930:	e006      	b.n	24014940 <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
24014932:	bf00      	nop
24014934:	e004      	b.n	24014940 <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
24014936:	bf00      	nop
24014938:	e002      	b.n	24014940 <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
2401493a:	bf00      	nop
2401493c:	e000      	b.n	24014940 <HAL_RCCEx_PeriphCLKConfig+0x52c>
      break;
2401493e:	bf00      	nop
    }

    if(ret == HAL_OK)
24014940:	7dfb      	ldrb	r3, [r7, #23]
24014942:	2b00      	cmp	r3, #0
24014944:	d10c      	bne.n	24014960 <HAL_RCCEx_PeriphCLKConfig+0x54c>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
24014946:	4b05      	ldr	r3, [pc, #20]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
24014948:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401494a:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
2401494e:	687b      	ldr	r3, [r7, #4]
24014950:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
24014954:	4901      	ldr	r1, [pc, #4]	; (2401495c <HAL_RCCEx_PeriphCLKConfig+0x548>)
24014956:	4313      	orrs	r3, r2
24014958:	658b      	str	r3, [r1, #88]	; 0x58
2401495a:	e003      	b.n	24014964 <HAL_RCCEx_PeriphCLKConfig+0x550>
2401495c:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
24014960:	7dfb      	ldrb	r3, [r7, #23]
24014962:	75bb      	strb	r3, [r7, #22]
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
24014964:	687b      	ldr	r3, [r7, #4]
24014966:	681b      	ldr	r3, [r3, #0]
24014968:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
2401496c:	2b00      	cmp	r3, #0
2401496e:	d02f      	beq.n	240149d0 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
  {
    switch(PeriphClkInit->FdcanClockSelection)
24014970:	687b      	ldr	r3, [r7, #4]
24014972:	6edb      	ldr	r3, [r3, #108]	; 0x6c
24014974:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014978:	d00e      	beq.n	24014998 <HAL_RCCEx_PeriphCLKConfig+0x584>
2401497a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
2401497e:	d814      	bhi.n	240149aa <HAL_RCCEx_PeriphCLKConfig+0x596>
24014980:	2b00      	cmp	r3, #0
24014982:	d015      	beq.n	240149b0 <HAL_RCCEx_PeriphCLKConfig+0x59c>
24014984:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014988:	d10f      	bne.n	240149aa <HAL_RCCEx_PeriphCLKConfig+0x596>
    {
    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
      /* Enable FDCAN Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401498a:	4baf      	ldr	r3, [pc, #700]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
2401498c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401498e:	4aae      	ldr	r2, [pc, #696]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014990:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014994:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FDCAN clock source configuration done later after clock selection check */
      break;
24014996:	e00c      	b.n	240149b2 <HAL_RCCEx_PeriphCLKConfig+0x59e>

    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24014998:	687b      	ldr	r3, [r7, #4]
2401499a:	3304      	adds	r3, #4
2401499c:	2101      	movs	r1, #1
2401499e:	4618      	mov	r0, r3
240149a0:	f002 f926 	bl	24016bf0 <RCCEx_PLL2_Config>
240149a4:	4603      	mov	r3, r0
240149a6:	75fb      	strb	r3, [r7, #23]

      /* FDCAN clock source configuration done later after clock selection check */
      break;
240149a8:	e003      	b.n	240149b2 <HAL_RCCEx_PeriphCLKConfig+0x59e>
      /* HSE is used as clock source for FDCAN*/
      /* FDCAN clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240149aa:	2301      	movs	r3, #1
240149ac:	75fb      	strb	r3, [r7, #23]
      break;
240149ae:	e000      	b.n	240149b2 <HAL_RCCEx_PeriphCLKConfig+0x59e>
      break;
240149b0:	bf00      	nop
    }

    if(ret == HAL_OK)
240149b2:	7dfb      	ldrb	r3, [r7, #23]
240149b4:	2b00      	cmp	r3, #0
240149b6:	d109      	bne.n	240149cc <HAL_RCCEx_PeriphCLKConfig+0x5b8>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
240149b8:	4ba3      	ldr	r3, [pc, #652]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
240149ba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240149bc:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
240149c0:	687b      	ldr	r3, [r7, #4]
240149c2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
240149c4:	49a0      	ldr	r1, [pc, #640]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
240149c6:	4313      	orrs	r3, r2
240149c8:	650b      	str	r3, [r1, #80]	; 0x50
240149ca:	e001      	b.n	240149d0 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
    }
    else
    {
      /* set overall return value */
      status = ret;
240149cc:	7dfb      	ldrb	r3, [r7, #23]
240149ce:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
240149d0:	687b      	ldr	r3, [r7, #4]
240149d2:	681b      	ldr	r3, [r3, #0]
240149d4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
240149d8:	2b00      	cmp	r3, #0
240149da:	d032      	beq.n	24014a42 <HAL_RCCEx_PeriphCLKConfig+0x62e>
  {
    switch(PeriphClkInit->FmcClockSelection)
240149dc:	687b      	ldr	r3, [r7, #4]
240149de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
240149e0:	2b03      	cmp	r3, #3
240149e2:	d81b      	bhi.n	24014a1c <HAL_RCCEx_PeriphCLKConfig+0x608>
240149e4:	a201      	add	r2, pc, #4	; (adr r2, 240149ec <HAL_RCCEx_PeriphCLKConfig+0x5d8>)
240149e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240149ea:	bf00      	nop
240149ec:	24014a23 	.word	0x24014a23
240149f0:	240149fd 	.word	0x240149fd
240149f4:	24014a0b 	.word	0x24014a0b
240149f8:	24014a23 	.word	0x24014a23
    {
    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
      /* Enable FMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240149fc:	4b92      	ldr	r3, [pc, #584]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
240149fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24014a00:	4a91      	ldr	r2, [pc, #580]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014a02:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24014a06:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FMC clock source configuration done later after clock selection check */
      break;
24014a08:	e00c      	b.n	24014a24 <HAL_RCCEx_PeriphCLKConfig+0x610>

    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
24014a0a:	687b      	ldr	r3, [r7, #4]
24014a0c:	3304      	adds	r3, #4
24014a0e:	2102      	movs	r1, #2
24014a10:	4618      	mov	r0, r3
24014a12:	f002 f8ed 	bl	24016bf0 <RCCEx_PLL2_Config>
24014a16:	4603      	mov	r3, r0
24014a18:	75fb      	strb	r3, [r7, #23]

      /* FMC clock source configuration done later after clock selection check */
      break;
24014a1a:	e003      	b.n	24014a24 <HAL_RCCEx_PeriphCLKConfig+0x610>
    case RCC_FMCCLKSOURCE_HCLK:
      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
24014a1c:	2301      	movs	r3, #1
24014a1e:	75fb      	strb	r3, [r7, #23]
      break;
24014a20:	e000      	b.n	24014a24 <HAL_RCCEx_PeriphCLKConfig+0x610>
      break;
24014a22:	bf00      	nop
    }

    if(ret == HAL_OK)
24014a24:	7dfb      	ldrb	r3, [r7, #23]
24014a26:	2b00      	cmp	r3, #0
24014a28:	d109      	bne.n	24014a3e <HAL_RCCEx_PeriphCLKConfig+0x62a>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
24014a2a:	4b87      	ldr	r3, [pc, #540]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014a2c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24014a2e:	f023 0203 	bic.w	r2, r3, #3
24014a32:	687b      	ldr	r3, [r7, #4]
24014a34:	6c5b      	ldr	r3, [r3, #68]	; 0x44
24014a36:	4984      	ldr	r1, [pc, #528]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014a38:	4313      	orrs	r3, r2
24014a3a:	64cb      	str	r3, [r1, #76]	; 0x4c
24014a3c:	e001      	b.n	24014a42 <HAL_RCCEx_PeriphCLKConfig+0x62e>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014a3e:	7dfb      	ldrb	r3, [r7, #23]
24014a40:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
24014a42:	687b      	ldr	r3, [r7, #4]
24014a44:	681b      	ldr	r3, [r3, #0]
24014a46:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
24014a4a:	2b00      	cmp	r3, #0
24014a4c:	f000 8086 	beq.w	24014b5c <HAL_RCCEx_PeriphCLKConfig+0x748>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
24014a50:	4b7e      	ldr	r3, [pc, #504]	; (24014c4c <HAL_RCCEx_PeriphCLKConfig+0x838>)
24014a52:	681b      	ldr	r3, [r3, #0]
24014a54:	4a7d      	ldr	r2, [pc, #500]	; (24014c4c <HAL_RCCEx_PeriphCLKConfig+0x838>)
24014a56:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24014a5a:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
24014a5c:	f7ed fc72 	bl	24002344 <HAL_GetTick>
24014a60:	6138      	str	r0, [r7, #16]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24014a62:	e009      	b.n	24014a78 <HAL_RCCEx_PeriphCLKConfig+0x664>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
24014a64:	f7ed fc6e 	bl	24002344 <HAL_GetTick>
24014a68:	4602      	mov	r2, r0
24014a6a:	693b      	ldr	r3, [r7, #16]
24014a6c:	1ad3      	subs	r3, r2, r3
24014a6e:	2b64      	cmp	r3, #100	; 0x64
24014a70:	d902      	bls.n	24014a78 <HAL_RCCEx_PeriphCLKConfig+0x664>
      {
        ret = HAL_TIMEOUT;
24014a72:	2303      	movs	r3, #3
24014a74:	75fb      	strb	r3, [r7, #23]
        break;
24014a76:	e005      	b.n	24014a84 <HAL_RCCEx_PeriphCLKConfig+0x670>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
24014a78:	4b74      	ldr	r3, [pc, #464]	; (24014c4c <HAL_RCCEx_PeriphCLKConfig+0x838>)
24014a7a:	681b      	ldr	r3, [r3, #0]
24014a7c:	f403 7380 	and.w	r3, r3, #256	; 0x100
24014a80:	2b00      	cmp	r3, #0
24014a82:	d0ef      	beq.n	24014a64 <HAL_RCCEx_PeriphCLKConfig+0x650>
      }
    }

    if(ret == HAL_OK)
24014a84:	7dfb      	ldrb	r3, [r7, #23]
24014a86:	2b00      	cmp	r3, #0
24014a88:	d166      	bne.n	24014b58 <HAL_RCCEx_PeriphCLKConfig+0x744>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
24014a8a:	4b6f      	ldr	r3, [pc, #444]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014a8c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
24014a8e:	687b      	ldr	r3, [r7, #4]
24014a90:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24014a94:	4053      	eors	r3, r2
24014a96:	f403 7340 	and.w	r3, r3, #768	; 0x300
24014a9a:	2b00      	cmp	r3, #0
24014a9c:	d013      	beq.n	24014ac6 <HAL_RCCEx_PeriphCLKConfig+0x6b2>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
24014a9e:	4b6a      	ldr	r3, [pc, #424]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014aa0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014aa2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
24014aa6:	60fb      	str	r3, [r7, #12]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
24014aa8:	4b67      	ldr	r3, [pc, #412]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014aaa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014aac:	4a66      	ldr	r2, [pc, #408]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014aae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
24014ab2:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
24014ab4:	4b64      	ldr	r3, [pc, #400]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014ab6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014ab8:	4a63      	ldr	r2, [pc, #396]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014aba:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
24014abe:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
24014ac0:	4a61      	ldr	r2, [pc, #388]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014ac2:	68fb      	ldr	r3, [r7, #12]
24014ac4:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
24014ac6:	687b      	ldr	r3, [r7, #4]
24014ac8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24014acc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24014ad0:	d115      	bne.n	24014afe <HAL_RCCEx_PeriphCLKConfig+0x6ea>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
24014ad2:	f7ed fc37 	bl	24002344 <HAL_GetTick>
24014ad6:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24014ad8:	e00b      	b.n	24014af2 <HAL_RCCEx_PeriphCLKConfig+0x6de>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
24014ada:	f7ed fc33 	bl	24002344 <HAL_GetTick>
24014ade:	4602      	mov	r2, r0
24014ae0:	693b      	ldr	r3, [r7, #16]
24014ae2:	1ad3      	subs	r3, r2, r3
24014ae4:	f241 3288 	movw	r2, #5000	; 0x1388
24014ae8:	4293      	cmp	r3, r2
24014aea:	d902      	bls.n	24014af2 <HAL_RCCEx_PeriphCLKConfig+0x6de>
          {
            ret = HAL_TIMEOUT;
24014aec:	2303      	movs	r3, #3
24014aee:	75fb      	strb	r3, [r7, #23]
            break;
24014af0:	e005      	b.n	24014afe <HAL_RCCEx_PeriphCLKConfig+0x6ea>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
24014af2:	4b55      	ldr	r3, [pc, #340]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014af4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24014af6:	f003 0302 	and.w	r3, r3, #2
24014afa:	2b00      	cmp	r3, #0
24014afc:	d0ed      	beq.n	24014ada <HAL_RCCEx_PeriphCLKConfig+0x6c6>
          }
        }
      }

      if(ret == HAL_OK)
24014afe:	7dfb      	ldrb	r3, [r7, #23]
24014b00:	2b00      	cmp	r3, #0
24014b02:	d126      	bne.n	24014b52 <HAL_RCCEx_PeriphCLKConfig+0x73e>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
24014b04:	687b      	ldr	r3, [r7, #4]
24014b06:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24014b0a:	f403 7340 	and.w	r3, r3, #768	; 0x300
24014b0e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
24014b12:	d10d      	bne.n	24014b30 <HAL_RCCEx_PeriphCLKConfig+0x71c>
24014b14:	4b4c      	ldr	r3, [pc, #304]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014b16:	691b      	ldr	r3, [r3, #16]
24014b18:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
24014b1c:	687b      	ldr	r3, [r7, #4]
24014b1e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24014b22:	0919      	lsrs	r1, r3, #4
24014b24:	4b4a      	ldr	r3, [pc, #296]	; (24014c50 <HAL_RCCEx_PeriphCLKConfig+0x83c>)
24014b26:	400b      	ands	r3, r1
24014b28:	4947      	ldr	r1, [pc, #284]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014b2a:	4313      	orrs	r3, r2
24014b2c:	610b      	str	r3, [r1, #16]
24014b2e:	e005      	b.n	24014b3c <HAL_RCCEx_PeriphCLKConfig+0x728>
24014b30:	4b45      	ldr	r3, [pc, #276]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014b32:	691b      	ldr	r3, [r3, #16]
24014b34:	4a44      	ldr	r2, [pc, #272]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014b36:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
24014b3a:	6113      	str	r3, [r2, #16]
24014b3c:	4b42      	ldr	r3, [pc, #264]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014b3e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
24014b40:	687b      	ldr	r3, [r7, #4]
24014b42:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
24014b46:	f3c3 030b 	ubfx	r3, r3, #0, #12
24014b4a:	493f      	ldr	r1, [pc, #252]	; (24014c48 <HAL_RCCEx_PeriphCLKConfig+0x834>)
24014b4c:	4313      	orrs	r3, r2
24014b4e:	670b      	str	r3, [r1, #112]	; 0x70
24014b50:	e004      	b.n	24014b5c <HAL_RCCEx_PeriphCLKConfig+0x748>
      }
      else
      {
        /* set overall return value */
        status = ret;
24014b52:	7dfb      	ldrb	r3, [r7, #23]
24014b54:	75bb      	strb	r3, [r7, #22]
24014b56:	e001      	b.n	24014b5c <HAL_RCCEx_PeriphCLKConfig+0x748>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
24014b58:	7dfb      	ldrb	r3, [r7, #23]
24014b5a:	75bb      	strb	r3, [r7, #22]
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
24014b5c:	687b      	ldr	r3, [r7, #4]
24014b5e:	681b      	ldr	r3, [r3, #0]
24014b60:	f003 0301 	and.w	r3, r3, #1
24014b64:	2b00      	cmp	r3, #0
24014b66:	f000 8085 	beq.w	24014c74 <HAL_RCCEx_PeriphCLKConfig+0x860>
  {
    switch(PeriphClkInit->Usart16ClockSelection)
24014b6a:	687b      	ldr	r3, [r7, #4]
24014b6c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
24014b6e:	2b28      	cmp	r3, #40	; 0x28
24014b70:	d866      	bhi.n	24014c40 <HAL_RCCEx_PeriphCLKConfig+0x82c>
24014b72:	a201      	add	r2, pc, #4	; (adr r2, 24014b78 <HAL_RCCEx_PeriphCLKConfig+0x764>)
24014b74:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24014b78:	24014c55 	.word	0x24014c55
24014b7c:	24014c41 	.word	0x24014c41
24014b80:	24014c41 	.word	0x24014c41
24014b84:	24014c41 	.word	0x24014c41
24014b88:	24014c41 	.word	0x24014c41
24014b8c:	24014c41 	.word	0x24014c41
24014b90:	24014c41 	.word	0x24014c41
24014b94:	24014c41 	.word	0x24014c41
24014b98:	24014c1d 	.word	0x24014c1d
24014b9c:	24014c41 	.word	0x24014c41
24014ba0:	24014c41 	.word	0x24014c41
24014ba4:	24014c41 	.word	0x24014c41
24014ba8:	24014c41 	.word	0x24014c41
24014bac:	24014c41 	.word	0x24014c41
24014bb0:	24014c41 	.word	0x24014c41
24014bb4:	24014c41 	.word	0x24014c41
24014bb8:	24014c2f 	.word	0x24014c2f
24014bbc:	24014c41 	.word	0x24014c41
24014bc0:	24014c41 	.word	0x24014c41
24014bc4:	24014c41 	.word	0x24014c41
24014bc8:	24014c41 	.word	0x24014c41
24014bcc:	24014c41 	.word	0x24014c41
24014bd0:	24014c41 	.word	0x24014c41
24014bd4:	24014c41 	.word	0x24014c41
24014bd8:	24014c55 	.word	0x24014c55
24014bdc:	24014c41 	.word	0x24014c41
24014be0:	24014c41 	.word	0x24014c41
24014be4:	24014c41 	.word	0x24014c41
24014be8:	24014c41 	.word	0x24014c41
24014bec:	24014c41 	.word	0x24014c41
24014bf0:	24014c41 	.word	0x24014c41
24014bf4:	24014c41 	.word	0x24014c41
24014bf8:	24014c55 	.word	0x24014c55
24014bfc:	24014c41 	.word	0x24014c41
24014c00:	24014c41 	.word	0x24014c41
24014c04:	24014c41 	.word	0x24014c41
24014c08:	24014c41 	.word	0x24014c41
24014c0c:	24014c41 	.word	0x24014c41
24014c10:	24014c41 	.word	0x24014c41
24014c14:	24014c41 	.word	0x24014c41
24014c18:	24014c55 	.word	0x24014c55
    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24014c1c:	687b      	ldr	r3, [r7, #4]
24014c1e:	3304      	adds	r3, #4
24014c20:	2101      	movs	r1, #1
24014c22:	4618      	mov	r0, r3
24014c24:	f001 ffe4 	bl	24016bf0 <RCCEx_PLL2_Config>
24014c28:	4603      	mov	r3, r0
24014c2a:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
24014c2c:	e013      	b.n	24014c56 <HAL_RCCEx_PeriphCLKConfig+0x842>

    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24014c2e:	687b      	ldr	r3, [r7, #4]
24014c30:	3324      	adds	r3, #36	; 0x24
24014c32:	2101      	movs	r1, #1
24014c34:	4618      	mov	r0, r3
24014c36:	f002 f88d 	bl	24016d54 <RCCEx_PLL3_Config>
24014c3a:	4603      	mov	r3, r0
24014c3c:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
24014c3e:	e00a      	b.n	24014c56 <HAL_RCCEx_PeriphCLKConfig+0x842>
      /* LSE,  oscillator is used as source of USART1/6 clock */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24014c40:	2301      	movs	r3, #1
24014c42:	75fb      	strb	r3, [r7, #23]
      break;
24014c44:	e007      	b.n	24014c56 <HAL_RCCEx_PeriphCLKConfig+0x842>
24014c46:	bf00      	nop
24014c48:	58024400 	.word	0x58024400
24014c4c:	58024800 	.word	0x58024800
24014c50:	00ffffcf 	.word	0x00ffffcf
      break;
24014c54:	bf00      	nop
    }

    if(ret == HAL_OK)
24014c56:	7dfb      	ldrb	r3, [r7, #23]
24014c58:	2b00      	cmp	r3, #0
24014c5a:	d109      	bne.n	24014c70 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
24014c5c:	4b96      	ldr	r3, [pc, #600]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014c5e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24014c60:	f023 0238 	bic.w	r2, r3, #56	; 0x38
24014c64:	687b      	ldr	r3, [r7, #4]
24014c66:	6f9b      	ldr	r3, [r3, #120]	; 0x78
24014c68:	4993      	ldr	r1, [pc, #588]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014c6a:	4313      	orrs	r3, r2
24014c6c:	654b      	str	r3, [r1, #84]	; 0x54
24014c6e:	e001      	b.n	24014c74 <HAL_RCCEx_PeriphCLKConfig+0x860>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014c70:	7dfb      	ldrb	r3, [r7, #23]
24014c72:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
24014c74:	687b      	ldr	r3, [r7, #4]
24014c76:	681b      	ldr	r3, [r3, #0]
24014c78:	f003 0302 	and.w	r3, r3, #2
24014c7c:	2b00      	cmp	r3, #0
24014c7e:	d038      	beq.n	24014cf2 <HAL_RCCEx_PeriphCLKConfig+0x8de>
  {
    switch(PeriphClkInit->Usart234578ClockSelection)
24014c80:	687b      	ldr	r3, [r7, #4]
24014c82:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24014c84:	2b05      	cmp	r3, #5
24014c86:	d821      	bhi.n	24014ccc <HAL_RCCEx_PeriphCLKConfig+0x8b8>
24014c88:	a201      	add	r2, pc, #4	; (adr r2, 24014c90 <HAL_RCCEx_PeriphCLKConfig+0x87c>)
24014c8a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24014c8e:	bf00      	nop
24014c90:	24014cd3 	.word	0x24014cd3
24014c94:	24014ca9 	.word	0x24014ca9
24014c98:	24014cbb 	.word	0x24014cbb
24014c9c:	24014cd3 	.word	0x24014cd3
24014ca0:	24014cd3 	.word	0x24014cd3
24014ca4:	24014cd3 	.word	0x24014cd3
    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24014ca8:	687b      	ldr	r3, [r7, #4]
24014caa:	3304      	adds	r3, #4
24014cac:	2101      	movs	r1, #1
24014cae:	4618      	mov	r0, r3
24014cb0:	f001 ff9e 	bl	24016bf0 <RCCEx_PLL2_Config>
24014cb4:	4603      	mov	r3, r0
24014cb6:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
24014cb8:	e00c      	b.n	24014cd4 <HAL_RCCEx_PeriphCLKConfig+0x8c0>

    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24014cba:	687b      	ldr	r3, [r7, #4]
24014cbc:	3324      	adds	r3, #36	; 0x24
24014cbe:	2101      	movs	r1, #1
24014cc0:	4618      	mov	r0, r3
24014cc2:	f002 f847 	bl	24016d54 <RCCEx_PLL3_Config>
24014cc6:	4603      	mov	r3, r0
24014cc8:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
24014cca:	e003      	b.n	24014cd4 <HAL_RCCEx_PeriphCLKConfig+0x8c0>
      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24014ccc:	2301      	movs	r3, #1
24014cce:	75fb      	strb	r3, [r7, #23]
      break;
24014cd0:	e000      	b.n	24014cd4 <HAL_RCCEx_PeriphCLKConfig+0x8c0>
      break;
24014cd2:	bf00      	nop
    }

    if(ret == HAL_OK)
24014cd4:	7dfb      	ldrb	r3, [r7, #23]
24014cd6:	2b00      	cmp	r3, #0
24014cd8:	d109      	bne.n	24014cee <HAL_RCCEx_PeriphCLKConfig+0x8da>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
24014cda:	4b77      	ldr	r3, [pc, #476]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014cdc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24014cde:	f023 0207 	bic.w	r2, r3, #7
24014ce2:	687b      	ldr	r3, [r7, #4]
24014ce4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
24014ce6:	4974      	ldr	r1, [pc, #464]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014ce8:	4313      	orrs	r3, r2
24014cea:	654b      	str	r3, [r1, #84]	; 0x54
24014cec:	e001      	b.n	24014cf2 <HAL_RCCEx_PeriphCLKConfig+0x8de>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014cee:	7dfb      	ldrb	r3, [r7, #23]
24014cf0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
24014cf2:	687b      	ldr	r3, [r7, #4]
24014cf4:	681b      	ldr	r3, [r3, #0]
24014cf6:	f003 0304 	and.w	r3, r3, #4
24014cfa:	2b00      	cmp	r3, #0
24014cfc:	d03a      	beq.n	24014d74 <HAL_RCCEx_PeriphCLKConfig+0x960>
  {
    switch(PeriphClkInit->Lpuart1ClockSelection)
24014cfe:	687b      	ldr	r3, [r7, #4]
24014d00:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
24014d04:	2b05      	cmp	r3, #5
24014d06:	d821      	bhi.n	24014d4c <HAL_RCCEx_PeriphCLKConfig+0x938>
24014d08:	a201      	add	r2, pc, #4	; (adr r2, 24014d10 <HAL_RCCEx_PeriphCLKConfig+0x8fc>)
24014d0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
24014d0e:	bf00      	nop
24014d10:	24014d53 	.word	0x24014d53
24014d14:	24014d29 	.word	0x24014d29
24014d18:	24014d3b 	.word	0x24014d3b
24014d1c:	24014d53 	.word	0x24014d53
24014d20:	24014d53 	.word	0x24014d53
24014d24:	24014d53 	.word	0x24014d53
    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
24014d28:	687b      	ldr	r3, [r7, #4]
24014d2a:	3304      	adds	r3, #4
24014d2c:	2101      	movs	r1, #1
24014d2e:	4618      	mov	r0, r3
24014d30:	f001 ff5e 	bl	24016bf0 <RCCEx_PLL2_Config>
24014d34:	4603      	mov	r3, r0
24014d36:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
24014d38:	e00c      	b.n	24014d54 <HAL_RCCEx_PeriphCLKConfig+0x940>

    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24014d3a:	687b      	ldr	r3, [r7, #4]
24014d3c:	3324      	adds	r3, #36	; 0x24
24014d3e:	2101      	movs	r1, #1
24014d40:	4618      	mov	r0, r3
24014d42:	f002 f807 	bl	24016d54 <RCCEx_PLL3_Config>
24014d46:	4603      	mov	r3, r0
24014d48:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
24014d4a:	e003      	b.n	24014d54 <HAL_RCCEx_PeriphCLKConfig+0x940>
      /* LSE,  oscillator is used as source of LPUART1 clock */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24014d4c:	2301      	movs	r3, #1
24014d4e:	75fb      	strb	r3, [r7, #23]
      break;
24014d50:	e000      	b.n	24014d54 <HAL_RCCEx_PeriphCLKConfig+0x940>
      break;
24014d52:	bf00      	nop
    }

    if(ret == HAL_OK)
24014d54:	7dfb      	ldrb	r3, [r7, #23]
24014d56:	2b00      	cmp	r3, #0
24014d58:	d10a      	bne.n	24014d70 <HAL_RCCEx_PeriphCLKConfig+0x95c>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
24014d5a:	4b57      	ldr	r3, [pc, #348]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014d5c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014d5e:	f023 0207 	bic.w	r2, r3, #7
24014d62:	687b      	ldr	r3, [r7, #4]
24014d64:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
24014d68:	4953      	ldr	r1, [pc, #332]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014d6a:	4313      	orrs	r3, r2
24014d6c:	658b      	str	r3, [r1, #88]	; 0x58
24014d6e:	e001      	b.n	24014d74 <HAL_RCCEx_PeriphCLKConfig+0x960>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014d70:	7dfb      	ldrb	r3, [r7, #23]
24014d72:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
24014d74:	687b      	ldr	r3, [r7, #4]
24014d76:	681b      	ldr	r3, [r3, #0]
24014d78:	f003 0320 	and.w	r3, r3, #32
24014d7c:	2b00      	cmp	r3, #0
24014d7e:	d04b      	beq.n	24014e18 <HAL_RCCEx_PeriphCLKConfig+0xa04>
  {
    switch(PeriphClkInit->Lptim1ClockSelection)
24014d80:	687b      	ldr	r3, [r7, #4]
24014d82:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
24014d86:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24014d8a:	d02e      	beq.n	24014dea <HAL_RCCEx_PeriphCLKConfig+0x9d6>
24014d8c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24014d90:	d828      	bhi.n	24014de4 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
24014d92:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24014d96:	d02a      	beq.n	24014dee <HAL_RCCEx_PeriphCLKConfig+0x9da>
24014d98:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24014d9c:	d822      	bhi.n	24014de4 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
24014d9e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014da2:	d026      	beq.n	24014df2 <HAL_RCCEx_PeriphCLKConfig+0x9de>
24014da4:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24014da8:	d81c      	bhi.n	24014de4 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
24014daa:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014dae:	d010      	beq.n	24014dd2 <HAL_RCCEx_PeriphCLKConfig+0x9be>
24014db0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24014db4:	d816      	bhi.n	24014de4 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
24014db6:	2b00      	cmp	r3, #0
24014db8:	d01d      	beq.n	24014df6 <HAL_RCCEx_PeriphCLKConfig+0x9e2>
24014dba:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24014dbe:	d111      	bne.n	24014de4 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24014dc0:	687b      	ldr	r3, [r7, #4]
24014dc2:	3304      	adds	r3, #4
24014dc4:	2100      	movs	r1, #0
24014dc6:	4618      	mov	r0, r3
24014dc8:	f001 ff12 	bl	24016bf0 <RCCEx_PLL2_Config>
24014dcc:	4603      	mov	r3, r0
24014dce:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
24014dd0:	e012      	b.n	24014df8 <HAL_RCCEx_PeriphCLKConfig+0x9e4>

    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24014dd2:	687b      	ldr	r3, [r7, #4]
24014dd4:	3324      	adds	r3, #36	; 0x24
24014dd6:	2102      	movs	r1, #2
24014dd8:	4618      	mov	r0, r3
24014dda:	f001 ffbb 	bl	24016d54 <RCCEx_PLL3_Config>
24014dde:	4603      	mov	r3, r0
24014de0:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
24014de2:	e009      	b.n	24014df8 <HAL_RCCEx_PeriphCLKConfig+0x9e4>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24014de4:	2301      	movs	r3, #1
24014de6:	75fb      	strb	r3, [r7, #23]
      break;
24014de8:	e006      	b.n	24014df8 <HAL_RCCEx_PeriphCLKConfig+0x9e4>
      break;
24014dea:	bf00      	nop
24014dec:	e004      	b.n	24014df8 <HAL_RCCEx_PeriphCLKConfig+0x9e4>
      break;
24014dee:	bf00      	nop
24014df0:	e002      	b.n	24014df8 <HAL_RCCEx_PeriphCLKConfig+0x9e4>
      break;
24014df2:	bf00      	nop
24014df4:	e000      	b.n	24014df8 <HAL_RCCEx_PeriphCLKConfig+0x9e4>
      break;
24014df6:	bf00      	nop
    }

    if(ret == HAL_OK)
24014df8:	7dfb      	ldrb	r3, [r7, #23]
24014dfa:	2b00      	cmp	r3, #0
24014dfc:	d10a      	bne.n	24014e14 <HAL_RCCEx_PeriphCLKConfig+0xa00>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
24014dfe:	4b2e      	ldr	r3, [pc, #184]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014e00:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24014e02:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
24014e06:	687b      	ldr	r3, [r7, #4]
24014e08:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
24014e0c:	492a      	ldr	r1, [pc, #168]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014e0e:	4313      	orrs	r3, r2
24014e10:	654b      	str	r3, [r1, #84]	; 0x54
24014e12:	e001      	b.n	24014e18 <HAL_RCCEx_PeriphCLKConfig+0xa04>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014e14:	7dfb      	ldrb	r3, [r7, #23]
24014e16:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
24014e18:	687b      	ldr	r3, [r7, #4]
24014e1a:	681b      	ldr	r3, [r3, #0]
24014e1c:	f003 0340 	and.w	r3, r3, #64	; 0x40
24014e20:	2b00      	cmp	r3, #0
24014e22:	d04d      	beq.n	24014ec0 <HAL_RCCEx_PeriphCLKConfig+0xaac>
  {
    switch(PeriphClkInit->Lptim2ClockSelection)
24014e24:	687b      	ldr	r3, [r7, #4]
24014e26:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
24014e2a:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
24014e2e:	d02e      	beq.n	24014e8e <HAL_RCCEx_PeriphCLKConfig+0xa7a>
24014e30:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
24014e34:	d828      	bhi.n	24014e88 <HAL_RCCEx_PeriphCLKConfig+0xa74>
24014e36:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014e3a:	d02a      	beq.n	24014e92 <HAL_RCCEx_PeriphCLKConfig+0xa7e>
24014e3c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014e40:	d822      	bhi.n	24014e88 <HAL_RCCEx_PeriphCLKConfig+0xa74>
24014e42:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
24014e46:	d026      	beq.n	24014e96 <HAL_RCCEx_PeriphCLKConfig+0xa82>
24014e48:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
24014e4c:	d81c      	bhi.n	24014e88 <HAL_RCCEx_PeriphCLKConfig+0xa74>
24014e4e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
24014e52:	d010      	beq.n	24014e76 <HAL_RCCEx_PeriphCLKConfig+0xa62>
24014e54:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
24014e58:	d816      	bhi.n	24014e88 <HAL_RCCEx_PeriphCLKConfig+0xa74>
24014e5a:	2b00      	cmp	r3, #0
24014e5c:	d01d      	beq.n	24014e9a <HAL_RCCEx_PeriphCLKConfig+0xa86>
24014e5e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24014e62:	d111      	bne.n	24014e88 <HAL_RCCEx_PeriphCLKConfig+0xa74>
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24014e64:	687b      	ldr	r3, [r7, #4]
24014e66:	3304      	adds	r3, #4
24014e68:	2100      	movs	r1, #0
24014e6a:	4618      	mov	r0, r3
24014e6c:	f001 fec0 	bl	24016bf0 <RCCEx_PLL2_Config>
24014e70:	4603      	mov	r3, r0
24014e72:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
24014e74:	e012      	b.n	24014e9c <HAL_RCCEx_PeriphCLKConfig+0xa88>

    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24014e76:	687b      	ldr	r3, [r7, #4]
24014e78:	3324      	adds	r3, #36	; 0x24
24014e7a:	2102      	movs	r1, #2
24014e7c:	4618      	mov	r0, r3
24014e7e:	f001 ff69 	bl	24016d54 <RCCEx_PLL3_Config>
24014e82:	4603      	mov	r3, r0
24014e84:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
24014e86:	e009      	b.n	24014e9c <HAL_RCCEx_PeriphCLKConfig+0xa88>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24014e88:	2301      	movs	r3, #1
24014e8a:	75fb      	strb	r3, [r7, #23]
      break;
24014e8c:	e006      	b.n	24014e9c <HAL_RCCEx_PeriphCLKConfig+0xa88>
      break;
24014e8e:	bf00      	nop
24014e90:	e004      	b.n	24014e9c <HAL_RCCEx_PeriphCLKConfig+0xa88>
      break;
24014e92:	bf00      	nop
24014e94:	e002      	b.n	24014e9c <HAL_RCCEx_PeriphCLKConfig+0xa88>
      break;
24014e96:	bf00      	nop
24014e98:	e000      	b.n	24014e9c <HAL_RCCEx_PeriphCLKConfig+0xa88>
      break;
24014e9a:	bf00      	nop
    }

    if(ret == HAL_OK)
24014e9c:	7dfb      	ldrb	r3, [r7, #23]
24014e9e:	2b00      	cmp	r3, #0
24014ea0:	d10c      	bne.n	24014ebc <HAL_RCCEx_PeriphCLKConfig+0xaa8>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
24014ea2:	4b05      	ldr	r3, [pc, #20]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014ea4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014ea6:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
24014eaa:	687b      	ldr	r3, [r7, #4]
24014eac:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
24014eb0:	4901      	ldr	r1, [pc, #4]	; (24014eb8 <HAL_RCCEx_PeriphCLKConfig+0xaa4>)
24014eb2:	4313      	orrs	r3, r2
24014eb4:	658b      	str	r3, [r1, #88]	; 0x58
24014eb6:	e003      	b.n	24014ec0 <HAL_RCCEx_PeriphCLKConfig+0xaac>
24014eb8:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
24014ebc:	7dfb      	ldrb	r3, [r7, #23]
24014ebe:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
24014ec0:	687b      	ldr	r3, [r7, #4]
24014ec2:	681b      	ldr	r3, [r3, #0]
24014ec4:	f003 0380 	and.w	r3, r3, #128	; 0x80
24014ec8:	2b00      	cmp	r3, #0
24014eca:	d04b      	beq.n	24014f64 <HAL_RCCEx_PeriphCLKConfig+0xb50>
  {
    switch(PeriphClkInit->Lptim345ClockSelection)
24014ecc:	687b      	ldr	r3, [r7, #4]
24014ece:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
24014ed2:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
24014ed6:	d02e      	beq.n	24014f36 <HAL_RCCEx_PeriphCLKConfig+0xb22>
24014ed8:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
24014edc:	d828      	bhi.n	24014f30 <HAL_RCCEx_PeriphCLKConfig+0xb1c>
24014ede:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24014ee2:	d02a      	beq.n	24014f3a <HAL_RCCEx_PeriphCLKConfig+0xb26>
24014ee4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24014ee8:	d822      	bhi.n	24014f30 <HAL_RCCEx_PeriphCLKConfig+0xb1c>
24014eea:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
24014eee:	d026      	beq.n	24014f3e <HAL_RCCEx_PeriphCLKConfig+0xb2a>
24014ef0:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
24014ef4:	d81c      	bhi.n	24014f30 <HAL_RCCEx_PeriphCLKConfig+0xb1c>
24014ef6:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24014efa:	d010      	beq.n	24014f1e <HAL_RCCEx_PeriphCLKConfig+0xb0a>
24014efc:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24014f00:	d816      	bhi.n	24014f30 <HAL_RCCEx_PeriphCLKConfig+0xb1c>
24014f02:	2b00      	cmp	r3, #0
24014f04:	d01d      	beq.n	24014f42 <HAL_RCCEx_PeriphCLKConfig+0xb2e>
24014f06:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24014f0a:	d111      	bne.n	24014f30 <HAL_RCCEx_PeriphCLKConfig+0xb1c>
    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24014f0c:	687b      	ldr	r3, [r7, #4]
24014f0e:	3304      	adds	r3, #4
24014f10:	2100      	movs	r1, #0
24014f12:	4618      	mov	r0, r3
24014f14:	f001 fe6c 	bl	24016bf0 <RCCEx_PLL2_Config>
24014f18:	4603      	mov	r3, r0
24014f1a:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
24014f1c:	e012      	b.n	24014f44 <HAL_RCCEx_PeriphCLKConfig+0xb30>

    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24014f1e:	687b      	ldr	r3, [r7, #4]
24014f20:	3324      	adds	r3, #36	; 0x24
24014f22:	2102      	movs	r1, #2
24014f24:	4618      	mov	r0, r3
24014f26:	f001 ff15 	bl	24016d54 <RCCEx_PLL3_Config>
24014f2a:	4603      	mov	r3, r0
24014f2c:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
24014f2e:	e009      	b.n	24014f44 <HAL_RCCEx_PeriphCLKConfig+0xb30>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24014f30:	2301      	movs	r3, #1
24014f32:	75fb      	strb	r3, [r7, #23]
      break;
24014f34:	e006      	b.n	24014f44 <HAL_RCCEx_PeriphCLKConfig+0xb30>
      break;
24014f36:	bf00      	nop
24014f38:	e004      	b.n	24014f44 <HAL_RCCEx_PeriphCLKConfig+0xb30>
      break;
24014f3a:	bf00      	nop
24014f3c:	e002      	b.n	24014f44 <HAL_RCCEx_PeriphCLKConfig+0xb30>
      break;
24014f3e:	bf00      	nop
24014f40:	e000      	b.n	24014f44 <HAL_RCCEx_PeriphCLKConfig+0xb30>
      break;
24014f42:	bf00      	nop
    }

    if(ret == HAL_OK)
24014f44:	7dfb      	ldrb	r3, [r7, #23]
24014f46:	2b00      	cmp	r3, #0
24014f48:	d10a      	bne.n	24014f60 <HAL_RCCEx_PeriphCLKConfig+0xb4c>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
24014f4a:	4b9d      	ldr	r3, [pc, #628]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24014f4c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014f4e:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
24014f52:	687b      	ldr	r3, [r7, #4]
24014f54:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
24014f58:	4999      	ldr	r1, [pc, #612]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24014f5a:	4313      	orrs	r3, r2
24014f5c:	658b      	str	r3, [r1, #88]	; 0x58
24014f5e:	e001      	b.n	24014f64 <HAL_RCCEx_PeriphCLKConfig+0xb50>
    }
    else
    {
      /* set overall return value */
      status = ret;
24014f60:	7dfb      	ldrb	r3, [r7, #23]
24014f62:	75bb      	strb	r3, [r7, #22]

      __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
24014f64:	687b      	ldr	r3, [r7, #4]
24014f66:	681b      	ldr	r3, [r3, #0]
24014f68:	f003 0308 	and.w	r3, r3, #8
24014f6c:	2b00      	cmp	r3, #0
24014f6e:	d01a      	beq.n	24014fa6 <HAL_RCCEx_PeriphCLKConfig+0xb92>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
24014f70:	687b      	ldr	r3, [r7, #4]
24014f72:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24014f76:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24014f7a:	d10a      	bne.n	24014f92 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
    {
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
24014f7c:	687b      	ldr	r3, [r7, #4]
24014f7e:	3324      	adds	r3, #36	; 0x24
24014f80:	2102      	movs	r1, #2
24014f82:	4618      	mov	r0, r3
24014f84:	f001 fee6 	bl	24016d54 <RCCEx_PLL3_Config>
24014f88:	4603      	mov	r3, r0
24014f8a:	2b00      	cmp	r3, #0
24014f8c:	d001      	beq.n	24014f92 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        {
          status = HAL_ERROR;
24014f8e:	2301      	movs	r3, #1
24014f90:	75bb      	strb	r3, [r7, #22]
        }
    }

      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
24014f92:	4b8b      	ldr	r3, [pc, #556]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24014f94:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24014f96:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
24014f9a:	687b      	ldr	r3, [r7, #4]
24014f9c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24014fa0:	4987      	ldr	r1, [pc, #540]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24014fa2:	4313      	orrs	r3, r2
24014fa4:	654b      	str	r3, [r1, #84]	; 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
24014fa6:	687b      	ldr	r3, [r7, #4]
24014fa8:	681b      	ldr	r3, [r3, #0]
24014faa:	f003 0310 	and.w	r3, r3, #16
24014fae:	2b00      	cmp	r3, #0
24014fb0:	d01a      	beq.n	24014fe8 <HAL_RCCEx_PeriphCLKConfig+0xbd4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
24014fb2:	687b      	ldr	r3, [r7, #4]
24014fb4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24014fb8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24014fbc:	d10a      	bne.n	24014fd4 <HAL_RCCEx_PeriphCLKConfig+0xbc0>
    {
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
24014fbe:	687b      	ldr	r3, [r7, #4]
24014fc0:	3324      	adds	r3, #36	; 0x24
24014fc2:	2102      	movs	r1, #2
24014fc4:	4618      	mov	r0, r3
24014fc6:	f001 fec5 	bl	24016d54 <RCCEx_PLL3_Config>
24014fca:	4603      	mov	r3, r0
24014fcc:	2b00      	cmp	r3, #0
24014fce:	d001      	beq.n	24014fd4 <HAL_RCCEx_PeriphCLKConfig+0xbc0>
      {
        status = HAL_ERROR;
24014fd0:	2301      	movs	r3, #1
24014fd2:	75bb      	strb	r3, [r7, #22]
      }
    }

      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
24014fd4:	4b7a      	ldr	r3, [pc, #488]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24014fd6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24014fd8:	f423 7240 	bic.w	r2, r3, #768	; 0x300
24014fdc:	687b      	ldr	r3, [r7, #4]
24014fde:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
24014fe2:	4977      	ldr	r1, [pc, #476]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24014fe4:	4313      	orrs	r3, r2
24014fe6:	658b      	str	r3, [r1, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
24014fe8:	687b      	ldr	r3, [r7, #4]
24014fea:	681b      	ldr	r3, [r3, #0]
24014fec:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
24014ff0:	2b00      	cmp	r3, #0
24014ff2:	d034      	beq.n	2401505e <HAL_RCCEx_PeriphCLKConfig+0xc4a>
  {
    switch(PeriphClkInit->AdcClockSelection)
24014ff4:	687b      	ldr	r3, [r7, #4]
24014ff6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24014ffa:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24014ffe:	d01d      	beq.n	2401503c <HAL_RCCEx_PeriphCLKConfig+0xc28>
24015000:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015004:	d817      	bhi.n	24015036 <HAL_RCCEx_PeriphCLKConfig+0xc22>
24015006:	2b00      	cmp	r3, #0
24015008:	d003      	beq.n	24015012 <HAL_RCCEx_PeriphCLKConfig+0xbfe>
2401500a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
2401500e:	d009      	beq.n	24015024 <HAL_RCCEx_PeriphCLKConfig+0xc10>
24015010:	e011      	b.n	24015036 <HAL_RCCEx_PeriphCLKConfig+0xc22>
    {

    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
24015012:	687b      	ldr	r3, [r7, #4]
24015014:	3304      	adds	r3, #4
24015016:	2100      	movs	r1, #0
24015018:	4618      	mov	r0, r3
2401501a:	f001 fde9 	bl	24016bf0 <RCCEx_PLL2_Config>
2401501e:	4603      	mov	r3, r0
24015020:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
24015022:	e00c      	b.n	2401503e <HAL_RCCEx_PeriphCLKConfig+0xc2a>

    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
24015024:	687b      	ldr	r3, [r7, #4]
24015026:	3324      	adds	r3, #36	; 0x24
24015028:	2102      	movs	r1, #2
2401502a:	4618      	mov	r0, r3
2401502c:	f001 fe92 	bl	24016d54 <RCCEx_PLL3_Config>
24015030:	4603      	mov	r3, r0
24015032:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
24015034:	e003      	b.n	2401503e <HAL_RCCEx_PeriphCLKConfig+0xc2a>
      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
      /* ADC clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24015036:	2301      	movs	r3, #1
24015038:	75fb      	strb	r3, [r7, #23]
      break;
2401503a:	e000      	b.n	2401503e <HAL_RCCEx_PeriphCLKConfig+0xc2a>
      break;
2401503c:	bf00      	nop
    }

    if(ret == HAL_OK)
2401503e:	7dfb      	ldrb	r3, [r7, #23]
24015040:	2b00      	cmp	r3, #0
24015042:	d10a      	bne.n	2401505a <HAL_RCCEx_PeriphCLKConfig+0xc46>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
24015044:	4b5e      	ldr	r3, [pc, #376]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24015046:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015048:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
2401504c:	687b      	ldr	r3, [r7, #4]
2401504e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
24015052:	495b      	ldr	r1, [pc, #364]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24015054:	4313      	orrs	r3, r2
24015056:	658b      	str	r3, [r1, #88]	; 0x58
24015058:	e001      	b.n	2401505e <HAL_RCCEx_PeriphCLKConfig+0xc4a>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401505a:	7dfb      	ldrb	r3, [r7, #23]
2401505c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
2401505e:	687b      	ldr	r3, [r7, #4]
24015060:	681b      	ldr	r3, [r3, #0]
24015062:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
24015066:	2b00      	cmp	r3, #0
24015068:	d033      	beq.n	240150d2 <HAL_RCCEx_PeriphCLKConfig+0xcbe>
  {

    switch(PeriphClkInit->UsbClockSelection)
2401506a:	687b      	ldr	r3, [r7, #4]
2401506c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
24015070:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
24015074:	d01c      	beq.n	240150b0 <HAL_RCCEx_PeriphCLKConfig+0xc9c>
24015076:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
2401507a:	d816      	bhi.n	240150aa <HAL_RCCEx_PeriphCLKConfig+0xc96>
2401507c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
24015080:	d003      	beq.n	2401508a <HAL_RCCEx_PeriphCLKConfig+0xc76>
24015082:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24015086:	d007      	beq.n	24015098 <HAL_RCCEx_PeriphCLKConfig+0xc84>
24015088:	e00f      	b.n	240150aa <HAL_RCCEx_PeriphCLKConfig+0xc96>
    {
    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
      /* Enable USB Clock output generated form System USB . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
2401508a:	4b4d      	ldr	r3, [pc, #308]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
2401508c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401508e:	4a4c      	ldr	r2, [pc, #304]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24015090:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24015094:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* USB clock source configuration done later after clock selection check */
      break;
24015096:	e00c      	b.n	240150b2 <HAL_RCCEx_PeriphCLKConfig+0xc9e>

    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
24015098:	687b      	ldr	r3, [r7, #4]
2401509a:	3324      	adds	r3, #36	; 0x24
2401509c:	2101      	movs	r1, #1
2401509e:	4618      	mov	r0, r3
240150a0:	f001 fe58 	bl	24016d54 <RCCEx_PLL3_Config>
240150a4:	4603      	mov	r3, r0
240150a6:	75fb      	strb	r3, [r7, #23]

      /* USB clock source configuration done later after clock selection check */
      break;
240150a8:	e003      	b.n	240150b2 <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      /* HSI48 oscillator is used as source of USB clock */
      /* USB clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
240150aa:	2301      	movs	r3, #1
240150ac:	75fb      	strb	r3, [r7, #23]
      break;
240150ae:	e000      	b.n	240150b2 <HAL_RCCEx_PeriphCLKConfig+0xc9e>
      break;
240150b0:	bf00      	nop
    }

    if(ret == HAL_OK)
240150b2:	7dfb      	ldrb	r3, [r7, #23]
240150b4:	2b00      	cmp	r3, #0
240150b6:	d10a      	bne.n	240150ce <HAL_RCCEx_PeriphCLKConfig+0xcba>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
240150b8:	4b41      	ldr	r3, [pc, #260]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
240150ba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240150bc:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
240150c0:	687b      	ldr	r3, [r7, #4]
240150c2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
240150c6:	493e      	ldr	r1, [pc, #248]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
240150c8:	4313      	orrs	r3, r2
240150ca:	654b      	str	r3, [r1, #84]	; 0x54
240150cc:	e001      	b.n	240150d2 <HAL_RCCEx_PeriphCLKConfig+0xcbe>
    }
    else
    {
      /* set overall return value */
      status = ret;
240150ce:	7dfb      	ldrb	r3, [r7, #23]
240150d0:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
240150d2:	687b      	ldr	r3, [r7, #4]
240150d4:	681b      	ldr	r3, [r3, #0]
240150d6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
240150da:	2b00      	cmp	r3, #0
240150dc:	d029      	beq.n	24015132 <HAL_RCCEx_PeriphCLKConfig+0xd1e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch(PeriphClkInit->SdmmcClockSelection)
240150de:	687b      	ldr	r3, [r7, #4]
240150e0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240150e2:	2b00      	cmp	r3, #0
240150e4:	d003      	beq.n	240150ee <HAL_RCCEx_PeriphCLKConfig+0xcda>
240150e6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
240150ea:	d007      	beq.n	240150fc <HAL_RCCEx_PeriphCLKConfig+0xce8>
240150ec:	e00f      	b.n	2401510e <HAL_RCCEx_PeriphCLKConfig+0xcfa>
    {
    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
      /* Enable SDMMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
240150ee:	4b34      	ldr	r3, [pc, #208]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
240150f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240150f2:	4a33      	ldr	r2, [pc, #204]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
240150f4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
240150f8:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SDMMC clock source configuration done later after clock selection check */
      break;
240150fa:	e00b      	b.n	24015114 <HAL_RCCEx_PeriphCLKConfig+0xd00>

    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
240150fc:	687b      	ldr	r3, [r7, #4]
240150fe:	3304      	adds	r3, #4
24015100:	2102      	movs	r1, #2
24015102:	4618      	mov	r0, r3
24015104:	f001 fd74 	bl	24016bf0 <RCCEx_PLL2_Config>
24015108:	4603      	mov	r3, r0
2401510a:	75fb      	strb	r3, [r7, #23]

      /* SDMMC clock source configuration done later after clock selection check */
      break;
2401510c:	e002      	b.n	24015114 <HAL_RCCEx_PeriphCLKConfig+0xd00>

    default:
      ret = HAL_ERROR;
2401510e:	2301      	movs	r3, #1
24015110:	75fb      	strb	r3, [r7, #23]
      break;
24015112:	bf00      	nop
    }

    if(ret == HAL_OK)
24015114:	7dfb      	ldrb	r3, [r7, #23]
24015116:	2b00      	cmp	r3, #0
24015118:	d109      	bne.n	2401512e <HAL_RCCEx_PeriphCLKConfig+0xd1a>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
2401511a:	4b29      	ldr	r3, [pc, #164]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
2401511c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401511e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
24015122:	687b      	ldr	r3, [r7, #4]
24015124:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015126:	4926      	ldr	r1, [pc, #152]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24015128:	4313      	orrs	r3, r2
2401512a:	64cb      	str	r3, [r1, #76]	; 0x4c
2401512c:	e001      	b.n	24015132 <HAL_RCCEx_PeriphCLKConfig+0xd1e>
    }
    else
    {
      /* set overall return value */
      status = ret;
2401512e:	7dfb      	ldrb	r3, [r7, #23]
24015130:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
24015132:	687b      	ldr	r3, [r7, #4]
24015134:	681b      	ldr	r3, [r3, #0]
24015136:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
2401513a:	2b00      	cmp	r3, #0
2401513c:	d00a      	beq.n	24015154 <HAL_RCCEx_PeriphCLKConfig+0xd40>
  {
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
2401513e:	687b      	ldr	r3, [r7, #4]
24015140:	3324      	adds	r3, #36	; 0x24
24015142:	2102      	movs	r1, #2
24015144:	4618      	mov	r0, r3
24015146:	f001 fe05 	bl	24016d54 <RCCEx_PLL3_Config>
2401514a:	4603      	mov	r3, r0
2401514c:	2b00      	cmp	r3, #0
2401514e:	d001      	beq.n	24015154 <HAL_RCCEx_PeriphCLKConfig+0xd40>
    {
      status=HAL_ERROR;
24015150:	2301      	movs	r3, #1
24015152:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
24015154:	687b      	ldr	r3, [r7, #4]
24015156:	681b      	ldr	r3, [r3, #0]
24015158:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
2401515c:	2b00      	cmp	r3, #0
2401515e:	d033      	beq.n	240151c8 <HAL_RCCEx_PeriphCLKConfig+0xdb4>
  {

    switch(PeriphClkInit->RngClockSelection)
24015160:	687b      	ldr	r3, [r7, #4]
24015162:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
24015164:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
24015168:	d017      	beq.n	2401519a <HAL_RCCEx_PeriphCLKConfig+0xd86>
2401516a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
2401516e:	d811      	bhi.n	24015194 <HAL_RCCEx_PeriphCLKConfig+0xd80>
24015170:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24015174:	d013      	beq.n	2401519e <HAL_RCCEx_PeriphCLKConfig+0xd8a>
24015176:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
2401517a:	d80b      	bhi.n	24015194 <HAL_RCCEx_PeriphCLKConfig+0xd80>
2401517c:	2b00      	cmp	r3, #0
2401517e:	d010      	beq.n	240151a2 <HAL_RCCEx_PeriphCLKConfig+0xd8e>
24015180:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015184:	d106      	bne.n	24015194 <HAL_RCCEx_PeriphCLKConfig+0xd80>
    {
    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
      /* Enable RNG Clock output generated form System RNG . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
24015186:	4b0e      	ldr	r3, [pc, #56]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
24015188:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401518a:	4a0d      	ldr	r2, [pc, #52]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
2401518c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
24015190:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* RNG clock source configuration done later after clock selection check */
      break;
24015192:	e007      	b.n	240151a4 <HAL_RCCEx_PeriphCLKConfig+0xd90>
      /* HSI48 oscillator is used as source of RNG clock */
      /* RNG clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
24015194:	2301      	movs	r3, #1
24015196:	75fb      	strb	r3, [r7, #23]
      break;
24015198:	e004      	b.n	240151a4 <HAL_RCCEx_PeriphCLKConfig+0xd90>
      break;
2401519a:	bf00      	nop
2401519c:	e002      	b.n	240151a4 <HAL_RCCEx_PeriphCLKConfig+0xd90>
      break;
2401519e:	bf00      	nop
240151a0:	e000      	b.n	240151a4 <HAL_RCCEx_PeriphCLKConfig+0xd90>
      break;
240151a2:	bf00      	nop
    }

    if(ret == HAL_OK)
240151a4:	7dfb      	ldrb	r3, [r7, #23]
240151a6:	2b00      	cmp	r3, #0
240151a8:	d10c      	bne.n	240151c4 <HAL_RCCEx_PeriphCLKConfig+0xdb0>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
240151aa:	4b05      	ldr	r3, [pc, #20]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
240151ac:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240151ae:	f423 7240 	bic.w	r2, r3, #768	; 0x300
240151b2:	687b      	ldr	r3, [r7, #4]
240151b4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
240151b6:	4902      	ldr	r1, [pc, #8]	; (240151c0 <HAL_RCCEx_PeriphCLKConfig+0xdac>)
240151b8:	4313      	orrs	r3, r2
240151ba:	654b      	str	r3, [r1, #84]	; 0x54
240151bc:	e004      	b.n	240151c8 <HAL_RCCEx_PeriphCLKConfig+0xdb4>
240151be:	bf00      	nop
240151c0:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
240151c4:	7dfb      	ldrb	r3, [r7, #23]
240151c6:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
240151c8:	687b      	ldr	r3, [r7, #4]
240151ca:	681b      	ldr	r3, [r3, #0]
240151cc:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
240151d0:	2b00      	cmp	r3, #0
240151d2:	d008      	beq.n	240151e6 <HAL_RCCEx_PeriphCLKConfig+0xdd2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
240151d4:	4b31      	ldr	r3, [pc, #196]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
240151d6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240151d8:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
240151dc:	687b      	ldr	r3, [r7, #4]
240151de:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240151e0:	492e      	ldr	r1, [pc, #184]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
240151e2:	4313      	orrs	r3, r2
240151e4:	650b      	str	r3, [r1, #80]	; 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
240151e6:	687b      	ldr	r3, [r7, #4]
240151e8:	681b      	ldr	r3, [r3, #0]
240151ea:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
240151ee:	2b00      	cmp	r3, #0
240151f0:	d009      	beq.n	24015206 <HAL_RCCEx_PeriphCLKConfig+0xdf2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
240151f2:	4b2a      	ldr	r3, [pc, #168]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
240151f4:	691b      	ldr	r3, [r3, #16]
240151f6:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
240151fa:	687b      	ldr	r3, [r7, #4]
240151fc:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
24015200:	4926      	ldr	r1, [pc, #152]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015202:	4313      	orrs	r3, r2
24015204:	610b      	str	r3, [r1, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
24015206:	687b      	ldr	r3, [r7, #4]
24015208:	681b      	ldr	r3, [r3, #0]
2401520a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
2401520e:	2b00      	cmp	r3, #0
24015210:	d008      	beq.n	24015224 <HAL_RCCEx_PeriphCLKConfig+0xe10>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
24015212:	4b22      	ldr	r3, [pc, #136]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015214:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015216:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
2401521a:	687b      	ldr	r3, [r7, #4]
2401521c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
2401521e:	491f      	ldr	r1, [pc, #124]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015220:	4313      	orrs	r3, r2
24015222:	650b      	str	r3, [r1, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
24015224:	687b      	ldr	r3, [r7, #4]
24015226:	681b      	ldr	r3, [r3, #0]
24015228:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
2401522c:	2b00      	cmp	r3, #0
2401522e:	d00d      	beq.n	2401524c <HAL_RCCEx_PeriphCLKConfig+0xe38>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
24015230:	4b1a      	ldr	r3, [pc, #104]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015232:	691b      	ldr	r3, [r3, #16]
24015234:	4a19      	ldr	r2, [pc, #100]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015236:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
2401523a:	6113      	str	r3, [r2, #16]
2401523c:	4b17      	ldr	r3, [pc, #92]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
2401523e:	691a      	ldr	r2, [r3, #16]
24015240:	687b      	ldr	r3, [r7, #4]
24015242:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
24015246:	4915      	ldr	r1, [pc, #84]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015248:	4313      	orrs	r3, r2
2401524a:	610b      	str	r3, [r1, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
2401524c:	687b      	ldr	r3, [r7, #4]
2401524e:	681b      	ldr	r3, [r3, #0]
24015250:	2b00      	cmp	r3, #0
24015252:	da08      	bge.n	24015266 <HAL_RCCEx_PeriphCLKConfig+0xe52>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
24015254:	4b11      	ldr	r3, [pc, #68]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015256:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015258:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
2401525c:	687b      	ldr	r3, [r7, #4]
2401525e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015260:	490e      	ldr	r1, [pc, #56]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015262:	4313      	orrs	r3, r2
24015264:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
24015266:	687b      	ldr	r3, [r7, #4]
24015268:	681b      	ldr	r3, [r3, #0]
2401526a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
2401526e:	2b00      	cmp	r3, #0
24015270:	d009      	beq.n	24015286 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
24015272:	4b0a      	ldr	r3, [pc, #40]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015274:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015276:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
2401527a:	687b      	ldr	r3, [r7, #4]
2401527c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
24015280:	4906      	ldr	r1, [pc, #24]	; (2401529c <HAL_RCCEx_PeriphCLKConfig+0xe88>)
24015282:	4313      	orrs	r3, r2
24015284:	654b      	str	r3, [r1, #84]	; 0x54
  }

  if (status == HAL_OK)
24015286:	7dbb      	ldrb	r3, [r7, #22]
24015288:	2b00      	cmp	r3, #0
2401528a:	d101      	bne.n	24015290 <HAL_RCCEx_PeriphCLKConfig+0xe7c>
  {
    return HAL_OK;
2401528c:	2300      	movs	r3, #0
2401528e:	e000      	b.n	24015292 <HAL_RCCEx_PeriphCLKConfig+0xe7e>
  }
  return HAL_ERROR;
24015290:	2301      	movs	r3, #1
}
24015292:	4618      	mov	r0, r3
24015294:	3718      	adds	r7, #24
24015296:	46bd      	mov	sp, r7
24015298:	bd80      	pop	{r7, pc}
2401529a:	bf00      	nop
2401529c:	58024400 	.word	0x58024400

240152a0 <HAL_RCCEx_GetPeriphCLKConfig>:
  * @retval None
  *
  *   (*) : Available on some STM32H7 lines only.
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
240152a0:	b480      	push	{r7}
240152a2:	b083      	sub	sp, #12
240152a4:	af00      	add	r7, sp, #0
240152a6:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection =
240152a8:	687b      	ldr	r3, [r7, #4]
240152aa:	4aa3      	ldr	r2, [pc, #652]	; (24015538 <HAL_RCCEx_GetPeriphCLKConfig+0x298>)
240152ac:	601a      	str	r2, [r3, #0]
	         RCC_PERIPHCLK_CKPER;

#if defined(I2C5)
PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C1235;
#else
PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C123;
240152ae:	687b      	ldr	r3, [r7, #4]
240152b0:	681b      	ldr	r3, [r3, #0]
240152b2:	f043 0208 	orr.w	r2, r3, #8
240152b6:	687b      	ldr	r3, [r7, #4]
240152b8:	601a      	str	r2, [r3, #0]
#endif /* RCC_CDCCIP1R_SAI2ASEL */
#if defined(RCC_CDCCIP1R_SAI2BSEL)		 
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2B;
#endif /* RCC_CDCCIP1R_SAI2BSEL */
#if defined(SAI3)	 
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI23;
240152ba:	687b      	ldr	r3, [r7, #4]
240152bc:	681b      	ldr	r3, [r3, #0]
240152be:	f443 7200 	orr.w	r2, r3, #512	; 0x200
240152c2:	687b      	ldr	r3, [r7, #4]
240152c4:	601a      	str	r2, [r3, #0]
#endif /* SAI3 */
#if defined(SAI4)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4A;
240152c6:	687b      	ldr	r3, [r7, #4]
240152c8:	681b      	ldr	r3, [r3, #0]
240152ca:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
240152ce:	687b      	ldr	r3, [r7, #4]
240152d0:	601a      	str	r2, [r3, #0]
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4B;
240152d2:	687b      	ldr	r3, [r7, #4]
240152d4:	681b      	ldr	r3, [r3, #0]
240152d6:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
240152da:	687b      	ldr	r3, [r7, #4]
240152dc:	601a      	str	r2, [r3, #0]
#endif /* SAI4 */
#if defined(DFSDM2_BASE)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DFSDM2;
#endif /* DFSDM2 */
#if defined(QUADSPI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_QSPI;
240152de:	687b      	ldr	r3, [r7, #4]
240152e0:	681b      	ldr	r3, [r3, #0]
240152e2:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
240152e6:	687b      	ldr	r3, [r7, #4]
240152e8:	601a      	str	r2, [r3, #0]
#endif /* QUADSPI */
#if defined(OCTOSPI1) || defined(OCTOSPI2)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_OSPI;
#endif /* OCTOSPI1 || OCTOSPI2 */
#if defined(HRTIM1)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_HRTIM1;
240152ea:	687b      	ldr	r3, [r7, #4]
240152ec:	681b      	ldr	r3, [r3, #0]
240152ee:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
240152f2:	687b      	ldr	r3, [r7, #4]
240152f4:	601a      	str	r2, [r3, #0]
#endif /* HRTIM1 */
#if defined(LTDC)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;
240152f6:	687b      	ldr	r3, [r7, #4]
240152f8:	681b      	ldr	r3, [r3, #0]
240152fa:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
240152fe:	687b      	ldr	r3, [r7, #4]
24015300:	601a      	str	r2, [r3, #0]
#if defined(DSI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DSI;
#endif /* DSI */

  /* Get the PLL3 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> RCC_PLLCKSELR_DIVM3_Pos);
24015302:	4b8e      	ldr	r3, [pc, #568]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015304:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015306:	0d1b      	lsrs	r3, r3, #20
24015308:	f003 023f 	and.w	r2, r3, #63	; 0x3f
2401530c:	687b      	ldr	r3, [r7, #4]
2401530e:	625a      	str	r2, [r3, #36]	; 0x24
  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos)+ 1U;
24015310:	4b8a      	ldr	r3, [pc, #552]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015312:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015314:	f3c3 0308 	ubfx	r3, r3, #0, #9
24015318:	1c5a      	adds	r2, r3, #1
2401531a:	687b      	ldr	r3, [r7, #4]
2401531c:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos)+ 1U;
2401531e:	4b87      	ldr	r3, [pc, #540]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015320:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015322:	0e1b      	lsrs	r3, r3, #24
24015324:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015328:	1c5a      	adds	r2, r3, #1
2401532a:	687b      	ldr	r3, [r7, #4]
2401532c:	635a      	str	r2, [r3, #52]	; 0x34
  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos)+ 1U;
2401532e:	4b83      	ldr	r3, [pc, #524]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015330:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015332:	0a5b      	lsrs	r3, r3, #9
24015334:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015338:	1c5a      	adds	r2, r3, #1
2401533a:	687b      	ldr	r3, [r7, #4]
2401533c:	62da      	str	r2, [r3, #44]	; 0x2c
  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos)+ 1U;
2401533e:	4b7f      	ldr	r3, [pc, #508]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015340:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24015342:	0c1b      	lsrs	r3, r3, #16
24015344:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015348:	1c5a      	adds	r2, r3, #1
2401534a:	687b      	ldr	r3, [r7, #4]
2401534c:	631a      	str	r2, [r3, #48]	; 0x30
  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);
2401534e:	4b7b      	ldr	r3, [pc, #492]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015350:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015352:	0a9b      	lsrs	r3, r3, #10
24015354:	f003 0203 	and.w	r2, r3, #3
24015358:	687b      	ldr	r3, [r7, #4]
2401535a:	639a      	str	r2, [r3, #56]	; 0x38
  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);
2401535c:	4b77      	ldr	r3, [pc, #476]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401535e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015360:	0a5b      	lsrs	r3, r3, #9
24015362:	f003 0201 	and.w	r2, r3, #1
24015366:	687b      	ldr	r3, [r7, #4]
24015368:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Get the PLL2 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> RCC_PLLCKSELR_DIVM2_Pos);
2401536a:	4b74      	ldr	r3, [pc, #464]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401536c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
2401536e:	0b1b      	lsrs	r3, r3, #12
24015370:	f003 023f 	and.w	r2, r3, #63	; 0x3f
24015374:	687b      	ldr	r3, [r7, #4]
24015376:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos)+ 1U;
24015378:	4b70      	ldr	r3, [pc, #448]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401537a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401537c:	f3c3 0308 	ubfx	r3, r3, #0, #9
24015380:	1c5a      	adds	r2, r3, #1
24015382:	687b      	ldr	r3, [r7, #4]
24015384:	609a      	str	r2, [r3, #8]
  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos)+ 1U;
24015386:	4b6d      	ldr	r3, [pc, #436]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015388:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401538a:	0e1b      	lsrs	r3, r3, #24
2401538c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24015390:	1c5a      	adds	r2, r3, #1
24015392:	687b      	ldr	r3, [r7, #4]
24015394:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos)+ 1U;
24015396:	4b69      	ldr	r3, [pc, #420]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015398:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401539a:	0a5b      	lsrs	r3, r3, #9
2401539c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240153a0:	1c5a      	adds	r2, r3, #1
240153a2:	687b      	ldr	r3, [r7, #4]
240153a4:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos)+ 1U;
240153a6:	4b65      	ldr	r3, [pc, #404]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240153a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240153aa:	0c1b      	lsrs	r3, r3, #16
240153ac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240153b0:	1c5a      	adds	r2, r3, #1
240153b2:	687b      	ldr	r3, [r7, #4]
240153b4:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);
240153b6:	4b61      	ldr	r3, [pc, #388]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240153b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240153ba:	099b      	lsrs	r3, r3, #6
240153bc:	f003 0203 	and.w	r2, r3, #3
240153c0:	687b      	ldr	r3, [r7, #4]
240153c2:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);
240153c4:	4b5d      	ldr	r3, [pc, #372]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240153c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240153c8:	095b      	lsrs	r3, r3, #5
240153ca:	f003 0201 	and.w	r2, r3, #1
240153ce:	687b      	ldr	r3, [r7, #4]
240153d0:	61da      	str	r2, [r3, #28]

  /* Get the USART1 configuration --------------------------------------------*/
  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();
240153d2:	4b5a      	ldr	r3, [pc, #360]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240153d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240153d6:	f003 0238 	and.w	r2, r3, #56	; 0x38
240153da:	687b      	ldr	r3, [r7, #4]
240153dc:	679a      	str	r2, [r3, #120]	; 0x78
  /* Get the USART2/3/4/5/7/8 clock source -----------------------------------*/
  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();
240153de:	4b57      	ldr	r3, [pc, #348]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240153e0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240153e2:	f003 0207 	and.w	r2, r3, #7
240153e6:	687b      	ldr	r3, [r7, #4]
240153e8:	675a      	str	r2, [r3, #116]	; 0x74
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();
240153ea:	4b54      	ldr	r3, [pc, #336]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240153ec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240153ee:	f003 0207 	and.w	r2, r3, #7
240153f2:	687b      	ldr	r3, [r7, #4]
240153f4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if defined(I2C5)
  /* Get the I2C1/2/3/5 clock source -----------------------------------------*/
  PeriphClkInit->I2c1235ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
#else
  /* Get the I2C1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
240153f8:	4b50      	ldr	r3, [pc, #320]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240153fa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
240153fc:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
24015400:	687b      	ldr	r3, [r7, #4]
24015402:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif /*I2C5*/
  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();
24015406:	4b4d      	ldr	r3, [pc, #308]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015408:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401540a:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
2401540e:	687b      	ldr	r3, [r7, #4]
24015410:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();
24015414:	4b49      	ldr	r3, [pc, #292]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015416:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015418:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
2401541c:	687b      	ldr	r3, [r7, #4]
2401541e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  /* Get the LPTIM3/4/5 clock source -----------------------------------------*/
  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();
24015422:	4b46      	ldr	r3, [pc, #280]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015424:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015426:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
2401542a:	687b      	ldr	r3, [r7, #4]
2401542c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();
24015430:	4b42      	ldr	r3, [pc, #264]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015432:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015434:	f003 0207 	and.w	r2, r3, #7
24015438:	687b      	ldr	r3, [r7, #4]
2401543a:	655a      	str	r2, [r3, #84]	; 0x54
#if defined(SAI3)
  /* Get the SAI2/3 clock source ---------------------------------------------*/
  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();
2401543c:	4b3f      	ldr	r3, [pc, #252]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401543e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015440:	f403 72e0 	and.w	r2, r3, #448	; 0x1c0
24015444:	687b      	ldr	r3, [r7, #4]
24015446:	659a      	str	r2, [r3, #88]	; 0x58
  /* Get the SAI2B clock source ---------------------------------------------*/
  PeriphClkInit->Sai2BClockSelection        = __HAL_RCC_GET_SAI2B_SOURCE();
#endif  /*SAI2B*/
#if defined(SAI4)
  /* Get the SAI4A clock source ----------------------------------------------*/
  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();
24015448:	4b3c      	ldr	r3, [pc, #240]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401544a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401544c:	f403 0260 	and.w	r2, r3, #14680064	; 0xe00000
24015450:	687b      	ldr	r3, [r7, #4]
24015452:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  /* Get the SAI4B clock source ----------------------------------------------*/
  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();
24015456:	4b39      	ldr	r3, [pc, #228]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015458:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401545a:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
2401545e:	687b      	ldr	r3, [r7, #4]
24015460:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
#endif  /*SAI4*/
  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();
24015464:	4b35      	ldr	r3, [pc, #212]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015466:	6f1b      	ldr	r3, [r3, #112]	; 0x70
24015468:	f403 7240 	and.w	r2, r3, #768	; 0x300
2401546c:	687b      	ldr	r3, [r7, #4]
2401546e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();
24015472:	4b32      	ldr	r3, [pc, #200]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015474:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015476:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
2401547a:	687b      	ldr	r3, [r7, #4]
2401547c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  /* Get the SDMMC clock source ----------------------------------------------*/
  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();
24015480:	4b2e      	ldr	r3, [pc, #184]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015482:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015484:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
24015488:	687b      	ldr	r3, [r7, #4]
2401548a:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();
2401548c:	4b2b      	ldr	r3, [pc, #172]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401548e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
24015490:	f403 7240 	and.w	r2, r3, #768	; 0x300
24015494:	687b      	ldr	r3, [r7, #4]
24015496:	67da      	str	r2, [r3, #124]	; 0x7c
#if defined(HRTIM1)
  /* Get the HRTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();
24015498:	4b28      	ldr	r3, [pc, #160]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401549a:	691b      	ldr	r3, [r3, #16]
2401549c:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
240154a0:	687b      	ldr	r3, [r7, #4]
240154a2:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
#endif /* HRTIM1 */
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();
240154a6:	4b25      	ldr	r3, [pc, #148]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240154a8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240154aa:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
240154ae:	687b      	ldr	r3, [r7, #4]
240154b0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  /* Get the SWPMI1 clock source ---------------------------------------------*/
  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();
240154b4:	4b21      	ldr	r3, [pc, #132]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240154b6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240154b8:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
240154bc:	687b      	ldr	r3, [r7, #4]
240154be:	671a      	str	r2, [r3, #112]	; 0x70
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();
240154c0:	4b1e      	ldr	r3, [pc, #120]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240154c2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240154c4:	f003 7280 	and.w	r2, r3, #16777216	; 0x1000000
240154c8:	687b      	ldr	r3, [r7, #4]
240154ca:	669a      	str	r2, [r3, #104]	; 0x68
#if defined(DFSDM2_BASE)
  /* Get the DFSDM2 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm2ClockSelection       = __HAL_RCC_GET_DFSDM2_SOURCE();
#endif /* DFSDM2 */
  /* Get the SPDIFRX clock source --------------------------------------------*/
  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();
240154cc:	4b1b      	ldr	r3, [pc, #108]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240154ce:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240154d0:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
240154d4:	687b      	ldr	r3, [r7, #4]
240154d6:	665a      	str	r2, [r3, #100]	; 0x64
  /* Get the SPI1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();
240154d8:	4b18      	ldr	r3, [pc, #96]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240154da:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240154dc:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
240154e0:	687b      	ldr	r3, [r7, #4]
240154e2:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Get the SPI4/5 clock source ---------------------------------------------*/
  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();
240154e4:	4b15      	ldr	r3, [pc, #84]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240154e6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240154e8:	f403 22e0 	and.w	r2, r3, #458752	; 0x70000
240154ec:	687b      	ldr	r3, [r7, #4]
240154ee:	661a      	str	r2, [r3, #96]	; 0x60
  /* Get the SPI6 clock source -----------------------------------------------*/
  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();
240154f0:	4b12      	ldr	r3, [pc, #72]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
240154f2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
240154f4:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
240154f8:	687b      	ldr	r3, [r7, #4]
240154fa:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  /* Get the FDCAN clock source ----------------------------------------------*/
  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();
240154fe:	4b0f      	ldr	r3, [pc, #60]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015500:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015502:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
24015506:	687b      	ldr	r3, [r7, #4]
24015508:	66da      	str	r2, [r3, #108]	; 0x6c
  /* Get the CEC clock source ------------------------------------------------*/
  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();
2401550a:	4b0c      	ldr	r3, [pc, #48]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401550c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
2401550e:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
24015512:	687b      	ldr	r3, [r7, #4]
24015514:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Get the FMC clock source ------------------------------------------------*/
  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();
24015518:	4b08      	ldr	r3, [pc, #32]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
2401551a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
2401551c:	f003 0203 	and.w	r2, r3, #3
24015520:	687b      	ldr	r3, [r7, #4]
24015522:	645a      	str	r2, [r3, #68]	; 0x44
#if defined(QUADSPI)
  /* Get the QSPI clock source -----------------------------------------------*/
  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();
24015524:	4b05      	ldr	r3, [pc, #20]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015526:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015528:	f003 0230 	and.w	r2, r3, #48	; 0x30
2401552c:	687b      	ldr	r3, [r7, #4]
2401552e:	649a      	str	r2, [r3, #72]	; 0x48
  /* Get the DSI clock source ------------------------------------------------*/
  PeriphClkInit->DsiClockSelection          = __HAL_RCC_GET_DSI_SOURCE();
#endif /*DSI*/

  /* Get the CKPER clock source ----------------------------------------------*/
  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();
24015530:	4b02      	ldr	r3, [pc, #8]	; (2401553c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
24015532:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015534:	e004      	b.n	24015540 <HAL_RCCEx_GetPeriphCLKConfig+0x2a0>
24015536:	bf00      	nop
24015538:	c9fff1f7 	.word	0xc9fff1f7
2401553c:	58024400 	.word	0x58024400
24015540:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
24015544:	687b      	ldr	r3, [r7, #4]
24015546:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get the TIM Prescaler configuration -------------------------------------*/
  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)
24015548:	4b0a      	ldr	r3, [pc, #40]	; (24015574 <HAL_RCCEx_GetPeriphCLKConfig+0x2d4>)
2401554a:	691b      	ldr	r3, [r3, #16]
2401554c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
24015550:	2b00      	cmp	r3, #0
24015552:	d104      	bne.n	2401555e <HAL_RCCEx_GetPeriphCLKConfig+0x2be>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
24015554:	687b      	ldr	r3, [r7, #4]
24015556:	2200      	movs	r2, #0
24015558:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
2401555c:	e004      	b.n	24015568 <HAL_RCCEx_GetPeriphCLKConfig+0x2c8>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
2401555e:	687b      	ldr	r3, [r7, #4]
24015560:	f44f 4200 	mov.w	r2, #32768	; 0x8000
24015564:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
24015568:	bf00      	nop
2401556a:	370c      	adds	r7, #12
2401556c:	46bd      	mov	sp, r7
2401556e:	f85d 7b04 	ldr.w	r7, [sp], #4
24015572:	4770      	bx	lr
24015574:	58024400 	.word	0x58024400

24015578 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
24015578:	b580      	push	{r7, lr}
2401557a:	b090      	sub	sp, #64	; 0x40
2401557c:	af00      	add	r7, sp, #0
2401557e:	6078      	str	r0, [r7, #4]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
24015580:	687b      	ldr	r3, [r7, #4]
24015582:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015586:	f040 8095 	bne.w	240156b4 <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
    {

      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
2401558a:	4b97      	ldr	r3, [pc, #604]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401558c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
2401558e:	f003 0307 	and.w	r3, r3, #7
24015592:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
24015594:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015596:	2b04      	cmp	r3, #4
24015598:	f200 8088 	bhi.w	240156ac <HAL_RCCEx_GetPeriphCLKFreq+0x134>
2401559c:	a201      	add	r2, pc, #4	; (adr r2, 240155a4 <HAL_RCCEx_GetPeriphCLKFreq+0x2c>)
2401559e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
240155a2:	bf00      	nop
240155a4:	240155b9 	.word	0x240155b9
240155a8:	240155e1 	.word	0x240155e1
240155ac:	24015609 	.word	0x24015609
240155b0:	240156a5 	.word	0x240156a5
240155b4:	24015631 	.word	0x24015631
      {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
240155b8:	4b8b      	ldr	r3, [pc, #556]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
240155ba:	681b      	ldr	r3, [r3, #0]
240155bc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240155c0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240155c4:	d108      	bne.n	240155d8 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
         {
           HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240155c6:	f107 0324 	add.w	r3, r7, #36	; 0x24
240155ca:	4618      	mov	r0, r3
240155cc:	f000 ff7a 	bl	240164c4 <HAL_RCCEx_GetPLL1ClockFreq>
           frequency = pll1_clocks.PLL1_Q_Frequency;
240155d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
240155d2:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
240155d4:	f000 bc94 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
240155d8:	2300      	movs	r3, #0
240155da:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240155dc:	f000 bc90 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
240155e0:	4b81      	ldr	r3, [pc, #516]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
240155e2:	681b      	ldr	r3, [r3, #0]
240155e4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240155e8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
240155ec:	d108      	bne.n	24015600 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240155ee:	f107 0318 	add.w	r3, r7, #24
240155f2:	4618      	mov	r0, r3
240155f4:	f000 fcbe 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240155f8:	69bb      	ldr	r3, [r7, #24]
240155fa:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
240155fc:	f000 bc80 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015600:	2300      	movs	r3, #0
24015602:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015604:	f000 bc7c 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24015608:	4b77      	ldr	r3, [pc, #476]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401560a:	681b      	ldr	r3, [r3, #0]
2401560c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24015610:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015614:	d108      	bne.n	24015628 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24015616:	f107 030c 	add.w	r3, r7, #12
2401561a:	4618      	mov	r0, r3
2401561c:	f000 fdfe 	bl	2401621c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
24015620:	68fb      	ldr	r3, [r7, #12]
24015622:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015624:	f000 bc6c 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015628:	2300      	movs	r3, #0
2401562a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401562c:	f000 bc68 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24015630:	4b6d      	ldr	r3, [pc, #436]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
24015632:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015634:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24015638:	637b      	str	r3, [r7, #52]	; 0x34

          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
2401563a:	4b6b      	ldr	r3, [pc, #428]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401563c:	681b      	ldr	r3, [r3, #0]
2401563e:	f003 0304 	and.w	r3, r3, #4
24015642:	2b04      	cmp	r3, #4
24015644:	d10c      	bne.n	24015660 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
24015646:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015648:	2b00      	cmp	r3, #0
2401564a:	d109      	bne.n	24015660 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2401564c:	4b66      	ldr	r3, [pc, #408]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401564e:	681b      	ldr	r3, [r3, #0]
24015650:	08db      	lsrs	r3, r3, #3
24015652:	f003 0303 	and.w	r3, r3, #3
24015656:	4a65      	ldr	r2, [pc, #404]	; (240157ec <HAL_RCCEx_GetPeriphCLKFreq+0x274>)
24015658:	fa22 f303 	lsr.w	r3, r2, r3
2401565c:	63fb      	str	r3, [r7, #60]	; 0x3c
2401565e:	e01f      	b.n	240156a0 <HAL_RCCEx_GetPeriphCLKFreq+0x128>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
24015660:	4b61      	ldr	r3, [pc, #388]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
24015662:	681b      	ldr	r3, [r3, #0]
24015664:	f403 7380 	and.w	r3, r3, #256	; 0x100
24015668:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
2401566c:	d106      	bne.n	2401567c <HAL_RCCEx_GetPeriphCLKFreq+0x104>
2401566e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015670:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015674:	d102      	bne.n	2401567c <HAL_RCCEx_GetPeriphCLKFreq+0x104>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
24015676:	4b5e      	ldr	r3, [pc, #376]	; (240157f0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
24015678:	63fb      	str	r3, [r7, #60]	; 0x3c
2401567a:	e011      	b.n	240156a0 <HAL_RCCEx_GetPeriphCLKFreq+0x128>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
2401567c:	4b5a      	ldr	r3, [pc, #360]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401567e:	681b      	ldr	r3, [r3, #0]
24015680:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015684:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015688:	d106      	bne.n	24015698 <HAL_RCCEx_GetPeriphCLKFreq+0x120>
2401568a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401568c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015690:	d102      	bne.n	24015698 <HAL_RCCEx_GetPeriphCLKFreq+0x120>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
24015692:	4b58      	ldr	r3, [pc, #352]	; (240157f4 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
24015694:	63fb      	str	r3, [r7, #60]	; 0x3c
24015696:	e003      	b.n	240156a0 <HAL_RCCEx_GetPeriphCLKFreq+0x128>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
24015698:	2300      	movs	r3, #0
2401569a:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
2401569c:	f000 bc30 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
240156a0:	f000 bc2e 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
240156a4:	4b54      	ldr	r3, [pc, #336]	; (240157f8 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
240156a6:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240156a8:	f000 bc2a 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      default :
        {
          frequency = 0;
240156ac:	2300      	movs	r3, #0
240156ae:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240156b0:	f000 bc26 	b.w	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
240156b4:	687b      	ldr	r3, [r7, #4]
240156b6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
240156ba:	f040 809f 	bne.w	240157fc <HAL_RCCEx_GetPeriphCLKFreq+0x284>
    {

      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
240156be:	4b4a      	ldr	r3, [pc, #296]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
240156c0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
240156c2:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
240156c6:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
240156c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156ca:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240156ce:	d04d      	beq.n	2401576c <HAL_RCCEx_GetPeriphCLKFreq+0x1f4>
240156d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156d2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240156d6:	f200 8084 	bhi.w	240157e2 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
240156da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156dc:	2bc0      	cmp	r3, #192	; 0xc0
240156de:	d07d      	beq.n	240157dc <HAL_RCCEx_GetPeriphCLKFreq+0x264>
240156e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156e2:	2bc0      	cmp	r3, #192	; 0xc0
240156e4:	d87d      	bhi.n	240157e2 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
240156e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156e8:	2b80      	cmp	r3, #128	; 0x80
240156ea:	d02d      	beq.n	24015748 <HAL_RCCEx_GetPeriphCLKFreq+0x1d0>
240156ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156ee:	2b80      	cmp	r3, #128	; 0x80
240156f0:	d877      	bhi.n	240157e2 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
240156f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156f4:	2b00      	cmp	r3, #0
240156f6:	d003      	beq.n	24015700 <HAL_RCCEx_GetPeriphCLKFreq+0x188>
240156f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
240156fa:	2b40      	cmp	r3, #64	; 0x40
240156fc:	d012      	beq.n	24015724 <HAL_RCCEx_GetPeriphCLKFreq+0x1ac>
240156fe:	e070      	b.n	240157e2 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
      {
      case RCC_SAI23CLKSOURCE_PLL: /* PLL1 is the clock source for SAI2/3 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24015700:	4b39      	ldr	r3, [pc, #228]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
24015702:	681b      	ldr	r3, [r3, #0]
24015704:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24015708:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2401570c:	d107      	bne.n	2401571e <HAL_RCCEx_GetPeriphCLKFreq+0x1a6>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
2401570e:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015712:	4618      	mov	r0, r3
24015714:	f000 fed6 	bl	240164c4 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24015718:	6abb      	ldr	r3, [r7, #40]	; 0x28
2401571a:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
2401571c:	e3f0      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
2401571e:	2300      	movs	r3, #0
24015720:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015722:	e3ed      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24015724:	4b30      	ldr	r3, [pc, #192]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
24015726:	681b      	ldr	r3, [r3, #0]
24015728:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
2401572c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015730:	d107      	bne.n	24015742 <HAL_RCCEx_GetPeriphCLKFreq+0x1ca>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015732:	f107 0318 	add.w	r3, r7, #24
24015736:	4618      	mov	r0, r3
24015738:	f000 fc1c 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
2401573c:	69bb      	ldr	r3, [r7, #24]
2401573e:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015740:	e3de      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015742:	2300      	movs	r3, #0
24015744:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015746:	e3db      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24015748:	4b27      	ldr	r3, [pc, #156]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401574a:	681b      	ldr	r3, [r3, #0]
2401574c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24015750:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015754:	d107      	bne.n	24015766 <HAL_RCCEx_GetPeriphCLKFreq+0x1ee>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24015756:	f107 030c 	add.w	r3, r7, #12
2401575a:	4618      	mov	r0, r3
2401575c:	f000 fd5e 	bl	2401621c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
24015760:	68fb      	ldr	r3, [r7, #12]
24015762:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015764:	e3cc      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015766:	2300      	movs	r3, #0
24015768:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401576a:	e3c9      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
2401576c:	4b1e      	ldr	r3, [pc, #120]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401576e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015770:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24015774:	637b      	str	r3, [r7, #52]	; 0x34

          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
24015776:	4b1c      	ldr	r3, [pc, #112]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
24015778:	681b      	ldr	r3, [r3, #0]
2401577a:	f003 0304 	and.w	r3, r3, #4
2401577e:	2b04      	cmp	r3, #4
24015780:	d10c      	bne.n	2401579c <HAL_RCCEx_GetPeriphCLKFreq+0x224>
24015782:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015784:	2b00      	cmp	r3, #0
24015786:	d109      	bne.n	2401579c <HAL_RCCEx_GetPeriphCLKFreq+0x224>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24015788:	4b17      	ldr	r3, [pc, #92]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401578a:	681b      	ldr	r3, [r3, #0]
2401578c:	08db      	lsrs	r3, r3, #3
2401578e:	f003 0303 	and.w	r3, r3, #3
24015792:	4a16      	ldr	r2, [pc, #88]	; (240157ec <HAL_RCCEx_GetPeriphCLKFreq+0x274>)
24015794:	fa22 f303 	lsr.w	r3, r2, r3
24015798:	63fb      	str	r3, [r7, #60]	; 0x3c
2401579a:	e01e      	b.n	240157da <HAL_RCCEx_GetPeriphCLKFreq+0x262>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
2401579c:	4b12      	ldr	r3, [pc, #72]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
2401579e:	681b      	ldr	r3, [r3, #0]
240157a0:	f403 7380 	and.w	r3, r3, #256	; 0x100
240157a4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240157a8:	d106      	bne.n	240157b8 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
240157aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240157ac:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
240157b0:	d102      	bne.n	240157b8 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
240157b2:	4b0f      	ldr	r3, [pc, #60]	; (240157f0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
240157b4:	63fb      	str	r3, [r7, #60]	; 0x3c
240157b6:	e010      	b.n	240157da <HAL_RCCEx_GetPeriphCLKFreq+0x262>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
240157b8:	4b0b      	ldr	r3, [pc, #44]	; (240157e8 <HAL_RCCEx_GetPeriphCLKFreq+0x270>)
240157ba:	681b      	ldr	r3, [r3, #0]
240157bc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
240157c0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
240157c4:	d106      	bne.n	240157d4 <HAL_RCCEx_GetPeriphCLKFreq+0x25c>
240157c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240157c8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240157cc:	d102      	bne.n	240157d4 <HAL_RCCEx_GetPeriphCLKFreq+0x25c>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
240157ce:	4b09      	ldr	r3, [pc, #36]	; (240157f4 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
240157d0:	63fb      	str	r3, [r7, #60]	; 0x3c
240157d2:	e002      	b.n	240157da <HAL_RCCEx_GetPeriphCLKFreq+0x262>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
240157d4:	2300      	movs	r3, #0
240157d6:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
240157d8:	e392      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
240157da:	e391      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
240157dc:	4b06      	ldr	r3, [pc, #24]	; (240157f8 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
240157de:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240157e0:	e38e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      default :
        {
          frequency = 0;
240157e2:	2300      	movs	r3, #0
240157e4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240157e6:	e38b      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
240157e8:	58024400 	.word	0x58024400
240157ec:	03d09000 	.word	0x03d09000
240157f0:	003d0900 	.word	0x003d0900
240157f4:	02dc6c00 	.word	0x02dc6c00
240157f8:	00bb8000 	.word	0x00bb8000
      }
    }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
240157fc:	687b      	ldr	r3, [r7, #4]
240157fe:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24015802:	f040 809c 	bne.w	2401593e <HAL_RCCEx_GetPeriphCLKFreq+0x3c6>
    {

      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
24015806:	4b9d      	ldr	r3, [pc, #628]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015808:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401580a:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
2401580e:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
24015810:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015812:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
24015816:	d054      	beq.n	240158c2 <HAL_RCCEx_GetPeriphCLKFreq+0x34a>
24015818:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401581a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
2401581e:	f200 808b 	bhi.w	24015938 <HAL_RCCEx_GetPeriphCLKFreq+0x3c0>
24015822:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015824:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
24015828:	f000 8083 	beq.w	24015932 <HAL_RCCEx_GetPeriphCLKFreq+0x3ba>
2401582c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401582e:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
24015832:	f200 8081 	bhi.w	24015938 <HAL_RCCEx_GetPeriphCLKFreq+0x3c0>
24015836:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015838:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
2401583c:	d02f      	beq.n	2401589e <HAL_RCCEx_GetPeriphCLKFreq+0x326>
2401583e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015840:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
24015844:	d878      	bhi.n	24015938 <HAL_RCCEx_GetPeriphCLKFreq+0x3c0>
24015846:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015848:	2b00      	cmp	r3, #0
2401584a:	d004      	beq.n	24015856 <HAL_RCCEx_GetPeriphCLKFreq+0x2de>
2401584c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401584e:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
24015852:	d012      	beq.n	2401587a <HAL_RCCEx_GetPeriphCLKFreq+0x302>
24015854:	e070      	b.n	24015938 <HAL_RCCEx_GetPeriphCLKFreq+0x3c0>
      {
      case RCC_SAI4ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI4A */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24015856:	4b89      	ldr	r3, [pc, #548]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015858:	681b      	ldr	r3, [r3, #0]
2401585a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2401585e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24015862:	d107      	bne.n	24015874 <HAL_RCCEx_GetPeriphCLKFreq+0x2fc>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24015864:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015868:	4618      	mov	r0, r3
2401586a:	f000 fe2b 	bl	240164c4 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
2401586e:	6abb      	ldr	r3, [r7, #40]	; 0x28
24015870:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015872:	e345      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015874:	2300      	movs	r3, #0
24015876:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015878:	e342      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SAI4ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4A */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
2401587a:	4b80      	ldr	r3, [pc, #512]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
2401587c:	681b      	ldr	r3, [r3, #0]
2401587e:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015882:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015886:	d107      	bne.n	24015898 <HAL_RCCEx_GetPeriphCLKFreq+0x320>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015888:	f107 0318 	add.w	r3, r7, #24
2401588c:	4618      	mov	r0, r3
2401588e:	f000 fb71 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
24015892:	69bb      	ldr	r3, [r7, #24]
24015894:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015896:	e333      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015898:	2300      	movs	r3, #0
2401589a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401589c:	e330      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI4ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4A */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
2401589e:	4b77      	ldr	r3, [pc, #476]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
240158a0:	681b      	ldr	r3, [r3, #0]
240158a2:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240158a6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240158aa:	d107      	bne.n	240158bc <HAL_RCCEx_GetPeriphCLKFreq+0x344>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240158ac:	f107 030c 	add.w	r3, r7, #12
240158b0:	4618      	mov	r0, r3
240158b2:	f000 fcb3 	bl	2401621c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240158b6:	68fb      	ldr	r3, [r7, #12]
240158b8:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
240158ba:	e321      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
240158bc:	2300      	movs	r3, #0
240158be:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240158c0:	e31e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI4ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI4A*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
240158c2:	4b6e      	ldr	r3, [pc, #440]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
240158c4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
240158c6:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
240158ca:	637b      	str	r3, [r7, #52]	; 0x34

          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
240158cc:	4b6b      	ldr	r3, [pc, #428]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
240158ce:	681b      	ldr	r3, [r3, #0]
240158d0:	f003 0304 	and.w	r3, r3, #4
240158d4:	2b04      	cmp	r3, #4
240158d6:	d10c      	bne.n	240158f2 <HAL_RCCEx_GetPeriphCLKFreq+0x37a>
240158d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
240158da:	2b00      	cmp	r3, #0
240158dc:	d109      	bne.n	240158f2 <HAL_RCCEx_GetPeriphCLKFreq+0x37a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
240158de:	4b67      	ldr	r3, [pc, #412]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
240158e0:	681b      	ldr	r3, [r3, #0]
240158e2:	08db      	lsrs	r3, r3, #3
240158e4:	f003 0303 	and.w	r3, r3, #3
240158e8:	4a65      	ldr	r2, [pc, #404]	; (24015a80 <HAL_RCCEx_GetPeriphCLKFreq+0x508>)
240158ea:	fa22 f303 	lsr.w	r3, r2, r3
240158ee:	63fb      	str	r3, [r7, #60]	; 0x3c
240158f0:	e01e      	b.n	24015930 <HAL_RCCEx_GetPeriphCLKFreq+0x3b8>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
240158f2:	4b62      	ldr	r3, [pc, #392]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
240158f4:	681b      	ldr	r3, [r3, #0]
240158f6:	f403 7380 	and.w	r3, r3, #256	; 0x100
240158fa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
240158fe:	d106      	bne.n	2401590e <HAL_RCCEx_GetPeriphCLKFreq+0x396>
24015900:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015902:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015906:	d102      	bne.n	2401590e <HAL_RCCEx_GetPeriphCLKFreq+0x396>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
24015908:	4b5e      	ldr	r3, [pc, #376]	; (24015a84 <HAL_RCCEx_GetPeriphCLKFreq+0x50c>)
2401590a:	63fb      	str	r3, [r7, #60]	; 0x3c
2401590c:	e010      	b.n	24015930 <HAL_RCCEx_GetPeriphCLKFreq+0x3b8>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
2401590e:	4b5b      	ldr	r3, [pc, #364]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015910:	681b      	ldr	r3, [r3, #0]
24015912:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015916:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
2401591a:	d106      	bne.n	2401592a <HAL_RCCEx_GetPeriphCLKFreq+0x3b2>
2401591c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
2401591e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015922:	d102      	bne.n	2401592a <HAL_RCCEx_GetPeriphCLKFreq+0x3b2>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
24015924:	4b58      	ldr	r3, [pc, #352]	; (24015a88 <HAL_RCCEx_GetPeriphCLKFreq+0x510>)
24015926:	63fb      	str	r3, [r7, #60]	; 0x3c
24015928:	e002      	b.n	24015930 <HAL_RCCEx_GetPeriphCLKFreq+0x3b8>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
2401592a:	2300      	movs	r3, #0
2401592c:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
2401592e:	e2e7      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
24015930:	e2e6      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI4ACLKSOURCE_PIN: /* External clock is the clock source for SAI4A */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24015932:	4b56      	ldr	r3, [pc, #344]	; (24015a8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
24015934:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015936:	e2e3      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      default :
        {
          frequency = 0;
24015938:	2300      	movs	r3, #0
2401593a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
2401593c:	e2e0      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
2401593e:	687b      	ldr	r3, [r7, #4]
24015940:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
24015944:	f040 80a7 	bne.w	24015a96 <HAL_RCCEx_GetPeriphCLKFreq+0x51e>
    {

      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
24015948:	4b4c      	ldr	r3, [pc, #304]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
2401594a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
2401594c:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
24015950:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
24015952:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015954:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24015958:	d055      	beq.n	24015a06 <HAL_RCCEx_GetPeriphCLKFreq+0x48e>
2401595a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401595c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
24015960:	f200 8096 	bhi.w	24015a90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>
24015964:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015966:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
2401596a:	f000 8084 	beq.w	24015a76 <HAL_RCCEx_GetPeriphCLKFreq+0x4fe>
2401596e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015970:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
24015974:	f200 808c 	bhi.w	24015a90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>
24015978:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401597a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
2401597e:	d030      	beq.n	240159e2 <HAL_RCCEx_GetPeriphCLKFreq+0x46a>
24015980:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015982:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24015986:	f200 8083 	bhi.w	24015a90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>
2401598a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
2401598c:	2b00      	cmp	r3, #0
2401598e:	d004      	beq.n	2401599a <HAL_RCCEx_GetPeriphCLKFreq+0x422>
24015990:	6b3b      	ldr	r3, [r7, #48]	; 0x30
24015992:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
24015996:	d012      	beq.n	240159be <HAL_RCCEx_GetPeriphCLKFreq+0x446>
24015998:	e07a      	b.n	24015a90 <HAL_RCCEx_GetPeriphCLKFreq+0x518>
      {
      case RCC_SAI4BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI4B */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
2401599a:	4b38      	ldr	r3, [pc, #224]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
2401599c:	681b      	ldr	r3, [r3, #0]
2401599e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
240159a2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
240159a6:	d107      	bne.n	240159b8 <HAL_RCCEx_GetPeriphCLKFreq+0x440>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
240159a8:	f107 0324 	add.w	r3, r7, #36	; 0x24
240159ac:	4618      	mov	r0, r3
240159ae:	f000 fd89 	bl	240164c4 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
240159b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
240159b4:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
240159b6:	e2a3      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
240159b8:	2300      	movs	r3, #0
240159ba:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240159bc:	e2a0      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SAI4BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4B */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
240159be:	4b2f      	ldr	r3, [pc, #188]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
240159c0:	681b      	ldr	r3, [r3, #0]
240159c2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
240159c6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
240159ca:	d107      	bne.n	240159dc <HAL_RCCEx_GetPeriphCLKFreq+0x464>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
240159cc:	f107 0318 	add.w	r3, r7, #24
240159d0:	4618      	mov	r0, r3
240159d2:	f000 facf 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
240159d6:	69bb      	ldr	r3, [r7, #24]
240159d8:	63fb      	str	r3, [r7, #60]	; 0x3c
          }
         else
         {
           frequency = 0;
         }
          break;
240159da:	e291      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
240159dc:	2300      	movs	r3, #0
240159de:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
240159e0:	e28e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI4BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4B */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
240159e2:	4b26      	ldr	r3, [pc, #152]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
240159e4:	681b      	ldr	r3, [r3, #0]
240159e6:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
240159ea:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
240159ee:	d107      	bne.n	24015a00 <HAL_RCCEx_GetPeriphCLKFreq+0x488>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
240159f0:	f107 030c 	add.w	r3, r7, #12
240159f4:	4618      	mov	r0, r3
240159f6:	f000 fc11 	bl	2401621c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
240159fa:	68fb      	ldr	r3, [r7, #12]
240159fc:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
240159fe:	e27f      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015a00:	2300      	movs	r3, #0
24015a02:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015a04:	e27c      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI4BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI4B*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24015a06:	4b1d      	ldr	r3, [pc, #116]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015a08:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015a0a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24015a0e:	637b      	str	r3, [r7, #52]	; 0x34

         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
24015a10:	4b1a      	ldr	r3, [pc, #104]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015a12:	681b      	ldr	r3, [r3, #0]
24015a14:	f003 0304 	and.w	r3, r3, #4
24015a18:	2b04      	cmp	r3, #4
24015a1a:	d10c      	bne.n	24015a36 <HAL_RCCEx_GetPeriphCLKFreq+0x4be>
24015a1c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015a1e:	2b00      	cmp	r3, #0
24015a20:	d109      	bne.n	24015a36 <HAL_RCCEx_GetPeriphCLKFreq+0x4be>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24015a22:	4b16      	ldr	r3, [pc, #88]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015a24:	681b      	ldr	r3, [r3, #0]
24015a26:	08db      	lsrs	r3, r3, #3
24015a28:	f003 0303 	and.w	r3, r3, #3
24015a2c:	4a14      	ldr	r2, [pc, #80]	; (24015a80 <HAL_RCCEx_GetPeriphCLKFreq+0x508>)
24015a2e:	fa22 f303 	lsr.w	r3, r2, r3
24015a32:	63fb      	str	r3, [r7, #60]	; 0x3c
24015a34:	e01e      	b.n	24015a74 <HAL_RCCEx_GetPeriphCLKFreq+0x4fc>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
24015a36:	4b11      	ldr	r3, [pc, #68]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015a38:	681b      	ldr	r3, [r3, #0]
24015a3a:	f403 7380 	and.w	r3, r3, #256	; 0x100
24015a3e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015a42:	d106      	bne.n	24015a52 <HAL_RCCEx_GetPeriphCLKFreq+0x4da>
24015a44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015a46:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015a4a:	d102      	bne.n	24015a52 <HAL_RCCEx_GetPeriphCLKFreq+0x4da>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
24015a4c:	4b0d      	ldr	r3, [pc, #52]	; (24015a84 <HAL_RCCEx_GetPeriphCLKFreq+0x50c>)
24015a4e:	63fb      	str	r3, [r7, #60]	; 0x3c
24015a50:	e010      	b.n	24015a74 <HAL_RCCEx_GetPeriphCLKFreq+0x4fc>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
24015a52:	4b0a      	ldr	r3, [pc, #40]	; (24015a7c <HAL_RCCEx_GetPeriphCLKFreq+0x504>)
24015a54:	681b      	ldr	r3, [r3, #0]
24015a56:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015a5a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015a5e:	d106      	bne.n	24015a6e <HAL_RCCEx_GetPeriphCLKFreq+0x4f6>
24015a60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015a62:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015a66:	d102      	bne.n	24015a6e <HAL_RCCEx_GetPeriphCLKFreq+0x4f6>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
24015a68:	4b07      	ldr	r3, [pc, #28]	; (24015a88 <HAL_RCCEx_GetPeriphCLKFreq+0x510>)
24015a6a:	63fb      	str	r3, [r7, #60]	; 0x3c
24015a6c:	e002      	b.n	24015a74 <HAL_RCCEx_GetPeriphCLKFreq+0x4fc>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
24015a6e:	2300      	movs	r3, #0
24015a70:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
24015a72:	e245      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
24015a74:	e244      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SAI4BCLKSOURCE_PIN: /* External clock is the clock source for SAI4B */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24015a76:	4b05      	ldr	r3, [pc, #20]	; (24015a8c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
24015a78:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015a7a:	e241      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
24015a7c:	58024400 	.word	0x58024400
24015a80:	03d09000 	.word	0x03d09000
24015a84:	003d0900 	.word	0x003d0900
24015a88:	02dc6c00 	.word	0x02dc6c00
24015a8c:	00bb8000 	.word	0x00bb8000
        }

      default :
        {
          frequency = 0;
24015a90:	2300      	movs	r3, #0
24015a92:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015a94:	e234      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
24015a96:	687b      	ldr	r3, [r7, #4]
24015a98:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24015a9c:	f040 809c 	bne.w	24015bd8 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
    {
      /* Get SPI1/2/3 clock source */
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
24015aa0:	4b9b      	ldr	r3, [pc, #620]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015aa2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015aa4:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
24015aa8:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
24015aaa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015aac:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24015ab0:	d054      	beq.n	24015b5c <HAL_RCCEx_GetPeriphCLKFreq+0x5e4>
24015ab2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015ab4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24015ab8:	f200 808b 	bhi.w	24015bd2 <HAL_RCCEx_GetPeriphCLKFreq+0x65a>
24015abc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015abe:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
24015ac2:	f000 8083 	beq.w	24015bcc <HAL_RCCEx_GetPeriphCLKFreq+0x654>
24015ac6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015ac8:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
24015acc:	f200 8081 	bhi.w	24015bd2 <HAL_RCCEx_GetPeriphCLKFreq+0x65a>
24015ad0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015ad2:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24015ad6:	d02f      	beq.n	24015b38 <HAL_RCCEx_GetPeriphCLKFreq+0x5c0>
24015ad8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015ada:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
24015ade:	d878      	bhi.n	24015bd2 <HAL_RCCEx_GetPeriphCLKFreq+0x65a>
24015ae0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015ae2:	2b00      	cmp	r3, #0
24015ae4:	d004      	beq.n	24015af0 <HAL_RCCEx_GetPeriphCLKFreq+0x578>
24015ae6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015ae8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
24015aec:	d012      	beq.n	24015b14 <HAL_RCCEx_GetPeriphCLKFreq+0x59c>
24015aee:	e070      	b.n	24015bd2 <HAL_RCCEx_GetPeriphCLKFreq+0x65a>
      {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24015af0:	4b87      	ldr	r3, [pc, #540]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015af2:	681b      	ldr	r3, [r3, #0]
24015af4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24015af8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24015afc:	d107      	bne.n	24015b0e <HAL_RCCEx_GetPeriphCLKFreq+0x596>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24015afe:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015b02:	4618      	mov	r0, r3
24015b04:	f000 fcde 	bl	240164c4 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24015b08:	6abb      	ldr	r3, [r7, #40]	; 0x28
24015b0a:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015b0c:	e1f8      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015b0e:	2300      	movs	r3, #0
24015b10:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015b12:	e1f5      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24015b14:	4b7e      	ldr	r3, [pc, #504]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015b16:	681b      	ldr	r3, [r3, #0]
24015b18:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015b1c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015b20:	d107      	bne.n	24015b32 <HAL_RCCEx_GetPeriphCLKFreq+0x5ba>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015b22:	f107 0318 	add.w	r3, r7, #24
24015b26:	4618      	mov	r0, r3
24015b28:	f000 fa24 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
24015b2c:	69bb      	ldr	r3, [r7, #24]
24015b2e:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015b30:	e1e6      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015b32:	2300      	movs	r3, #0
24015b34:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015b36:	e1e3      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24015b38:	4b75      	ldr	r3, [pc, #468]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015b3a:	681b      	ldr	r3, [r3, #0]
24015b3c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24015b40:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015b44:	d107      	bne.n	24015b56 <HAL_RCCEx_GetPeriphCLKFreq+0x5de>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24015b46:	f107 030c 	add.w	r3, r7, #12
24015b4a:	4618      	mov	r0, r3
24015b4c:	f000 fb66 	bl	2401621c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
24015b50:	68fb      	ldr	r3, [r7, #12]
24015b52:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015b54:	e1d4      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015b56:	2300      	movs	r3, #0
24015b58:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015b5a:	e1d1      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24015b5c:	4b6c      	ldr	r3, [pc, #432]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015b5e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015b60:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24015b64:	637b      	str	r3, [r7, #52]	; 0x34

         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
24015b66:	4b6a      	ldr	r3, [pc, #424]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015b68:	681b      	ldr	r3, [r3, #0]
24015b6a:	f003 0304 	and.w	r3, r3, #4
24015b6e:	2b04      	cmp	r3, #4
24015b70:	d10c      	bne.n	24015b8c <HAL_RCCEx_GetPeriphCLKFreq+0x614>
24015b72:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015b74:	2b00      	cmp	r3, #0
24015b76:	d109      	bne.n	24015b8c <HAL_RCCEx_GetPeriphCLKFreq+0x614>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24015b78:	4b65      	ldr	r3, [pc, #404]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015b7a:	681b      	ldr	r3, [r3, #0]
24015b7c:	08db      	lsrs	r3, r3, #3
24015b7e:	f003 0303 	and.w	r3, r3, #3
24015b82:	4a64      	ldr	r2, [pc, #400]	; (24015d14 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>)
24015b84:	fa22 f303 	lsr.w	r3, r2, r3
24015b88:	63fb      	str	r3, [r7, #60]	; 0x3c
24015b8a:	e01e      	b.n	24015bca <HAL_RCCEx_GetPeriphCLKFreq+0x652>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
24015b8c:	4b60      	ldr	r3, [pc, #384]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015b8e:	681b      	ldr	r3, [r3, #0]
24015b90:	f403 7380 	and.w	r3, r3, #256	; 0x100
24015b94:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015b98:	d106      	bne.n	24015ba8 <HAL_RCCEx_GetPeriphCLKFreq+0x630>
24015b9a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015b9c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015ba0:	d102      	bne.n	24015ba8 <HAL_RCCEx_GetPeriphCLKFreq+0x630>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
24015ba2:	4b5d      	ldr	r3, [pc, #372]	; (24015d18 <HAL_RCCEx_GetPeriphCLKFreq+0x7a0>)
24015ba4:	63fb      	str	r3, [r7, #60]	; 0x3c
24015ba6:	e010      	b.n	24015bca <HAL_RCCEx_GetPeriphCLKFreq+0x652>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
24015ba8:	4b59      	ldr	r3, [pc, #356]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015baa:	681b      	ldr	r3, [r3, #0]
24015bac:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015bb0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015bb4:	d106      	bne.n	24015bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>
24015bb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015bb8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015bbc:	d102      	bne.n	24015bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x64c>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
24015bbe:	4b57      	ldr	r3, [pc, #348]	; (24015d1c <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>)
24015bc0:	63fb      	str	r3, [r7, #60]	; 0x3c
24015bc2:	e002      	b.n	24015bca <HAL_RCCEx_GetPeriphCLKFreq+0x652>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
24015bc4:	2300      	movs	r3, #0
24015bc6:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
24015bc8:	e19a      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
24015bca:	e199      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
24015bcc:	4b54      	ldr	r3, [pc, #336]	; (24015d20 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
24015bce:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015bd0:	e196      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      default :
        {
          frequency = 0;
24015bd2:	2300      	movs	r3, #0
24015bd4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015bd6:	e193      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
24015bd8:	687b      	ldr	r3, [r7, #4]
24015bda:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
24015bde:	d173      	bne.n	24015cc8 <HAL_RCCEx_GetPeriphCLKFreq+0x750>
    {
      /* Get ADC clock source */
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
24015be0:	4b4b      	ldr	r3, [pc, #300]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015be2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015be4:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
24015be8:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
24015bea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015bec:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015bf0:	d02f      	beq.n	24015c52 <HAL_RCCEx_GetPeriphCLKFreq+0x6da>
24015bf2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015bf4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015bf8:	d863      	bhi.n	24015cc2 <HAL_RCCEx_GetPeriphCLKFreq+0x74a>
24015bfa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015bfc:	2b00      	cmp	r3, #0
24015bfe:	d004      	beq.n	24015c0a <HAL_RCCEx_GetPeriphCLKFreq+0x692>
24015c00:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015c02:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24015c06:	d012      	beq.n	24015c2e <HAL_RCCEx_GetPeriphCLKFreq+0x6b6>
24015c08:	e05b      	b.n	24015cc2 <HAL_RCCEx_GetPeriphCLKFreq+0x74a>
      {
      case RCC_ADCCLKSOURCE_PLL2:
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24015c0a:	4b41      	ldr	r3, [pc, #260]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015c0c:	681b      	ldr	r3, [r3, #0]
24015c0e:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015c12:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015c16:	d107      	bne.n	24015c28 <HAL_RCCEx_GetPeriphCLKFreq+0x6b0>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015c18:	f107 0318 	add.w	r3, r7, #24
24015c1c:	4618      	mov	r0, r3
24015c1e:	f000 f9a9 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
24015c22:	69bb      	ldr	r3, [r7, #24]
24015c24:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015c26:	e16b      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015c28:	2300      	movs	r3, #0
24015c2a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015c2c:	e168      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_ADCCLKSOURCE_PLL3:
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24015c2e:	4b38      	ldr	r3, [pc, #224]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015c30:	681b      	ldr	r3, [r3, #0]
24015c32:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24015c36:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015c3a:	d107      	bne.n	24015c4c <HAL_RCCEx_GetPeriphCLKFreq+0x6d4>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24015c3c:	f107 030c 	add.w	r3, r7, #12
24015c40:	4618      	mov	r0, r3
24015c42:	f000 faeb 	bl	2401621c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
24015c46:	697b      	ldr	r3, [r7, #20]
24015c48:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015c4a:	e159      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015c4c:	2300      	movs	r3, #0
24015c4e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015c50:	e156      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      case RCC_ADCCLKSOURCE_CLKP:
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
24015c52:	4b2f      	ldr	r3, [pc, #188]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015c54:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015c56:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24015c5a:	637b      	str	r3, [r7, #52]	; 0x34

         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
24015c5c:	4b2c      	ldr	r3, [pc, #176]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015c5e:	681b      	ldr	r3, [r3, #0]
24015c60:	f003 0304 	and.w	r3, r3, #4
24015c64:	2b04      	cmp	r3, #4
24015c66:	d10c      	bne.n	24015c82 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
24015c68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015c6a:	2b00      	cmp	r3, #0
24015c6c:	d109      	bne.n	24015c82 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24015c6e:	4b28      	ldr	r3, [pc, #160]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015c70:	681b      	ldr	r3, [r3, #0]
24015c72:	08db      	lsrs	r3, r3, #3
24015c74:	f003 0303 	and.w	r3, r3, #3
24015c78:	4a26      	ldr	r2, [pc, #152]	; (24015d14 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>)
24015c7a:	fa22 f303 	lsr.w	r3, r2, r3
24015c7e:	63fb      	str	r3, [r7, #60]	; 0x3c
24015c80:	e01e      	b.n	24015cc0 <HAL_RCCEx_GetPeriphCLKFreq+0x748>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
24015c82:	4b23      	ldr	r3, [pc, #140]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015c84:	681b      	ldr	r3, [r3, #0]
24015c86:	f403 7380 	and.w	r3, r3, #256	; 0x100
24015c8a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015c8e:	d106      	bne.n	24015c9e <HAL_RCCEx_GetPeriphCLKFreq+0x726>
24015c90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015c92:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015c96:	d102      	bne.n	24015c9e <HAL_RCCEx_GetPeriphCLKFreq+0x726>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
24015c98:	4b1f      	ldr	r3, [pc, #124]	; (24015d18 <HAL_RCCEx_GetPeriphCLKFreq+0x7a0>)
24015c9a:	63fb      	str	r3, [r7, #60]	; 0x3c
24015c9c:	e010      	b.n	24015cc0 <HAL_RCCEx_GetPeriphCLKFreq+0x748>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
24015c9e:	4b1c      	ldr	r3, [pc, #112]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015ca0:	681b      	ldr	r3, [r3, #0]
24015ca2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015ca6:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015caa:	d106      	bne.n	24015cba <HAL_RCCEx_GetPeriphCLKFreq+0x742>
24015cac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
24015cae:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015cb2:	d102      	bne.n	24015cba <HAL_RCCEx_GetPeriphCLKFreq+0x742>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
24015cb4:	4b19      	ldr	r3, [pc, #100]	; (24015d1c <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>)
24015cb6:	63fb      	str	r3, [r7, #60]	; 0x3c
24015cb8:	e002      	b.n	24015cc0 <HAL_RCCEx_GetPeriphCLKFreq+0x748>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
24015cba:	2300      	movs	r3, #0
24015cbc:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
24015cbe:	e11f      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
24015cc0:	e11e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      default :
        {
          frequency = 0;
24015cc2:	2300      	movs	r3, #0
24015cc4:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015cc6:	e11b      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
24015cc8:	687b      	ldr	r3, [r7, #4]
24015cca:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24015cce:	d13e      	bne.n	24015d4e <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
    {
      /* Get SDMMC clock source */
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
24015cd0:	4b0f      	ldr	r3, [pc, #60]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015cd2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
24015cd4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
24015cd8:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
24015cda:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015cdc:	2b00      	cmp	r3, #0
24015cde:	d004      	beq.n	24015cea <HAL_RCCEx_GetPeriphCLKFreq+0x772>
24015ce0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015ce2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
24015ce6:	d01d      	beq.n	24015d24 <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>
24015ce8:	e02e      	b.n	24015d48 <HAL_RCCEx_GetPeriphCLKFreq+0x7d0>
      {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24015cea:	4b09      	ldr	r3, [pc, #36]	; (24015d10 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
24015cec:	681b      	ldr	r3, [r3, #0]
24015cee:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24015cf2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24015cf6:	d107      	bne.n	24015d08 <HAL_RCCEx_GetPeriphCLKFreq+0x790>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24015cf8:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015cfc:	4618      	mov	r0, r3
24015cfe:	f000 fbe1 	bl	240164c4 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24015d02:	6abb      	ldr	r3, [r7, #40]	; 0x28
24015d04:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015d06:	e0fb      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015d08:	2300      	movs	r3, #0
24015d0a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015d0c:	e0f8      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
24015d0e:	bf00      	nop
24015d10:	58024400 	.word	0x58024400
24015d14:	03d09000 	.word	0x03d09000
24015d18:	003d0900 	.word	0x003d0900
24015d1c:	02dc6c00 	.word	0x02dc6c00
24015d20:	00bb8000 	.word	0x00bb8000
        }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24015d24:	4b79      	ldr	r3, [pc, #484]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015d26:	681b      	ldr	r3, [r3, #0]
24015d28:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015d2c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015d30:	d107      	bne.n	24015d42 <HAL_RCCEx_GetPeriphCLKFreq+0x7ca>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015d32:	f107 0318 	add.w	r3, r7, #24
24015d36:	4618      	mov	r0, r3
24015d38:	f000 f91c 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
24015d3c:	6a3b      	ldr	r3, [r7, #32]
24015d3e:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015d40:	e0de      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015d42:	2300      	movs	r3, #0
24015d44:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015d46:	e0db      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }

      default :
        {
          frequency = 0;
24015d48:	2300      	movs	r3, #0
24015d4a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015d4c:	e0d8      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
24015d4e:	687b      	ldr	r3, [r7, #4]
24015d50:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
24015d54:	f040 8085 	bne.w	24015e62 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
    {
      /* Get SPI6 clock source */
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
24015d58:	4b6c      	ldr	r3, [pc, #432]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015d5a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
24015d5c:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
24015d60:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
24015d62:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d64:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24015d68:	d06b      	beq.n	24015e42 <HAL_RCCEx_GetPeriphCLKFreq+0x8ca>
24015d6a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d6c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
24015d70:	d874      	bhi.n	24015e5c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>
24015d72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d74:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24015d78:	d056      	beq.n	24015e28 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>
24015d7a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d7c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
24015d80:	d86c      	bhi.n	24015e5c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>
24015d82:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d84:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24015d88:	d03b      	beq.n	24015e02 <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
24015d8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d8c:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
24015d90:	d864      	bhi.n	24015e5c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>
24015d92:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d94:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015d98:	d021      	beq.n	24015dde <HAL_RCCEx_GetPeriphCLKFreq+0x866>
24015d9a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015d9c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015da0:	d85c      	bhi.n	24015e5c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>
24015da2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015da4:	2b00      	cmp	r3, #0
24015da6:	d004      	beq.n	24015db2 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
24015da8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015daa:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015dae:	d004      	beq.n	24015dba <HAL_RCCEx_GetPeriphCLKFreq+0x842>
24015db0:	e054      	b.n	24015e5c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>
      {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
        {
          frequency = HAL_RCCEx_GetD3PCLK1Freq();
24015db2:	f000 f8c9 	bl	24015f48 <HAL_RCCEx_GetD3PCLK1Freq>
24015db6:	63f8      	str	r0, [r7, #60]	; 0x3c
          break;
24015db8:	e0a2      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24015dba:	4b54      	ldr	r3, [pc, #336]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015dbc:	681b      	ldr	r3, [r3, #0]
24015dbe:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015dc2:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015dc6:	d107      	bne.n	24015dd8 <HAL_RCCEx_GetPeriphCLKFreq+0x860>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015dc8:	f107 0318 	add.w	r3, r7, #24
24015dcc:	4618      	mov	r0, r3
24015dce:	f000 f8d1 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
24015dd2:	69fb      	ldr	r3, [r7, #28]
24015dd4:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015dd6:	e093      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015dd8:	2300      	movs	r3, #0
24015dda:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015ddc:	e090      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
24015dde:	4b4b      	ldr	r3, [pc, #300]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015de0:	681b      	ldr	r3, [r3, #0]
24015de2:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24015de6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015dea:	d107      	bne.n	24015dfc <HAL_RCCEx_GetPeriphCLKFreq+0x884>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
24015dec:	f107 030c 	add.w	r3, r7, #12
24015df0:	4618      	mov	r0, r3
24015df2:	f000 fa13 	bl	2401621c <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
24015df6:	693b      	ldr	r3, [r7, #16]
24015df8:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015dfa:	e081      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015dfc:	2300      	movs	r3, #0
24015dfe:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015e00:	e07e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
24015e02:	4b42      	ldr	r3, [pc, #264]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015e04:	681b      	ldr	r3, [r3, #0]
24015e06:	f003 0304 	and.w	r3, r3, #4
24015e0a:	2b04      	cmp	r3, #4
24015e0c:	d109      	bne.n	24015e22 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
         {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24015e0e:	4b3f      	ldr	r3, [pc, #252]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015e10:	681b      	ldr	r3, [r3, #0]
24015e12:	08db      	lsrs	r3, r3, #3
24015e14:	f003 0303 	and.w	r3, r3, #3
24015e18:	4a3d      	ldr	r2, [pc, #244]	; (24015f10 <HAL_RCCEx_GetPeriphCLKFreq+0x998>)
24015e1a:	fa22 f303 	lsr.w	r3, r2, r3
24015e1e:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015e20:	e06e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015e22:	2300      	movs	r3, #0
24015e24:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015e26:	e06b      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
24015e28:	4b38      	ldr	r3, [pc, #224]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015e2a:	681b      	ldr	r3, [r3, #0]
24015e2c:	f403 7380 	and.w	r3, r3, #256	; 0x100
24015e30:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24015e34:	d102      	bne.n	24015e3c <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>
         {
          frequency = CSI_VALUE;
24015e36:	4b37      	ldr	r3, [pc, #220]	; (24015f14 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
24015e38:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
24015e3a:	e061      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
           frequency = 0;
24015e3c:	2300      	movs	r3, #0
24015e3e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015e40:	e05e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
24015e42:	4b32      	ldr	r3, [pc, #200]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015e44:	681b      	ldr	r3, [r3, #0]
24015e46:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015e4a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015e4e:	d102      	bne.n	24015e56 <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
         {
          frequency = HSE_VALUE;
24015e50:	4b31      	ldr	r3, [pc, #196]	; (24015f18 <HAL_RCCEx_GetPeriphCLKFreq+0x9a0>)
24015e52:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015e54:	e054      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015e56:	2300      	movs	r3, #0
24015e58:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015e5a:	e051      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          break;
        }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
        {
          frequency = 0;
24015e5c:	2300      	movs	r3, #0
24015e5e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015e60:	e04e      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
24015e62:	687b      	ldr	r3, [r7, #4]
24015e64:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
24015e68:	d148      	bne.n	24015efc <HAL_RCCEx_GetPeriphCLKFreq+0x984>
    {
      /* Get FDCAN clock source */
      srcclk= __HAL_RCC_GET_FDCAN_SOURCE();
24015e6a:	4b28      	ldr	r3, [pc, #160]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015e6c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
24015e6e:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
24015e72:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
24015e74:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015e76:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015e7a:	d02a      	beq.n	24015ed2 <HAL_RCCEx_GetPeriphCLKFreq+0x95a>
24015e7c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015e7e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
24015e82:	d838      	bhi.n	24015ef6 <HAL_RCCEx_GetPeriphCLKFreq+0x97e>
24015e84:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015e86:	2b00      	cmp	r3, #0
24015e88:	d004      	beq.n	24015e94 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
24015e8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
24015e8c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
24015e90:	d00d      	beq.n	24015eae <HAL_RCCEx_GetPeriphCLKFreq+0x936>
24015e92:	e030      	b.n	24015ef6 <HAL_RCCEx_GetPeriphCLKFreq+0x97e>
      {
      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
24015e94:	4b1d      	ldr	r3, [pc, #116]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015e96:	681b      	ldr	r3, [r3, #0]
24015e98:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
24015e9c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
24015ea0:	d102      	bne.n	24015ea8 <HAL_RCCEx_GetPeriphCLKFreq+0x930>
         {
          frequency = HSE_VALUE;
24015ea2:	4b1d      	ldr	r3, [pc, #116]	; (24015f18 <HAL_RCCEx_GetPeriphCLKFreq+0x9a0>)
24015ea4:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015ea6:	e02b      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015ea8:	2300      	movs	r3, #0
24015eaa:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015eac:	e028      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
24015eae:	4b17      	ldr	r3, [pc, #92]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015eb0:	681b      	ldr	r3, [r3, #0]
24015eb2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
24015eb6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
24015eba:	d107      	bne.n	24015ecc <HAL_RCCEx_GetPeriphCLKFreq+0x954>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
24015ebc:	f107 0324 	add.w	r3, r7, #36	; 0x24
24015ec0:	4618      	mov	r0, r3
24015ec2:	f000 faff 	bl	240164c4 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
24015ec6:	6abb      	ldr	r3, [r7, #40]	; 0x28
24015ec8:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015eca:	e019      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015ecc:	2300      	movs	r3, #0
24015ece:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015ed0:	e016      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
24015ed2:	4b0e      	ldr	r3, [pc, #56]	; (24015f0c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
24015ed4:	681b      	ldr	r3, [r3, #0]
24015ed6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24015eda:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
24015ede:	d107      	bne.n	24015ef0 <HAL_RCCEx_GetPeriphCLKFreq+0x978>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
24015ee0:	f107 0318 	add.w	r3, r7, #24
24015ee4:	4618      	mov	r0, r3
24015ee6:	f000 f845 	bl	24015f74 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
24015eea:	69fb      	ldr	r3, [r7, #28]
24015eec:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
24015eee:	e007      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
          frequency = 0;
24015ef0:	2300      	movs	r3, #0
24015ef2:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015ef4:	e004      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      default :
        {
          frequency = 0;
24015ef6:	2300      	movs	r3, #0
24015ef8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
24015efa:	e001      	b.n	24015f00 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
        }
      }
    }
  else
    {
      frequency = 0;
24015efc:	2300      	movs	r3, #0
24015efe:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

  return frequency;
24015f00:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
24015f02:	4618      	mov	r0, r3
24015f04:	3740      	adds	r7, #64	; 0x40
24015f06:	46bd      	mov	sp, r7
24015f08:	bd80      	pop	{r7, pc}
24015f0a:	bf00      	nop
24015f0c:	58024400 	.word	0x58024400
24015f10:	03d09000 	.word	0x03d09000
24015f14:	003d0900 	.word	0x003d0900
24015f18:	02dc6c00 	.word	0x02dc6c00

24015f1c <HAL_RCCEx_GetD1PCLK1Freq>:
  * @note   Each time D1PCLK1 changes, this function must be called to update the
  *         right D1PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D1PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD1PCLK1Freq(void)
{
24015f1c:	b580      	push	{r7, lr}
24015f1e:	af00      	add	r7, sp, #0
#if defined(RCC_D1CFGR_D1PPRE)
  /* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1PPRE)>> RCC_D1CFGR_D1PPRE_Pos] & 0x1FU));
24015f20:	f7fe f8d0 	bl	240140c4 <HAL_RCC_GetHCLKFreq>
24015f24:	4602      	mov	r2, r0
24015f26:	4b06      	ldr	r3, [pc, #24]	; (24015f40 <HAL_RCCEx_GetD1PCLK1Freq+0x24>)
24015f28:	699b      	ldr	r3, [r3, #24]
24015f2a:	091b      	lsrs	r3, r3, #4
24015f2c:	f003 0307 	and.w	r3, r3, #7
24015f30:	4904      	ldr	r1, [pc, #16]	; (24015f44 <HAL_RCCEx_GetD1PCLK1Freq+0x28>)
24015f32:	5ccb      	ldrb	r3, [r1, r3]
24015f34:	f003 031f 	and.w	r3, r3, #31
24015f38:	fa22 f303 	lsr.w	r3, r2, r3
#else
/* Get HCLK source and Compute D1PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE)>> RCC_CDCFGR1_CDPPRE_Pos] & 0x1FU));
#endif
}
24015f3c:	4618      	mov	r0, r3
24015f3e:	bd80      	pop	{r7, pc}
24015f40:	58024400 	.word	0x58024400
24015f44:	240178a4 	.word	0x240178a4

24015f48 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
24015f48:	b580      	push	{r7, lr}
24015f4a:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
24015f4c:	f7fe f8ba 	bl	240140c4 <HAL_RCC_GetHCLKFreq>
24015f50:	4602      	mov	r2, r0
24015f52:	4b06      	ldr	r3, [pc, #24]	; (24015f6c <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
24015f54:	6a1b      	ldr	r3, [r3, #32]
24015f56:	091b      	lsrs	r3, r3, #4
24015f58:	f003 0307 	and.w	r3, r3, #7
24015f5c:	4904      	ldr	r1, [pc, #16]	; (24015f70 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
24015f5e:	5ccb      	ldrb	r3, [r1, r3]
24015f60:	f003 031f 	and.w	r3, r3, #31
24015f64:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
24015f68:	4618      	mov	r0, r3
24015f6a:	bd80      	pop	{r7, pc}
24015f6c:	58024400 	.word	0x58024400
24015f70:	240178a4 	.word	0x240178a4

24015f74 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)
{
24015f74:	b480      	push	{r7}
24015f76:	b089      	sub	sp, #36	; 0x24
24015f78:	af00      	add	r7, sp, #0
24015f7a:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24015f7c:	4ba1      	ldr	r3, [pc, #644]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24015f7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015f80:	f003 0303 	and.w	r3, r3, #3
24015f84:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
24015f86:	4b9f      	ldr	r3, [pc, #636]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24015f88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24015f8a:	0b1b      	lsrs	r3, r3, #12
24015f8c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24015f90:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
24015f92:	4b9c      	ldr	r3, [pc, #624]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24015f94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24015f96:	091b      	lsrs	r3, r3, #4
24015f98:	f003 0301 	and.w	r3, r3, #1
24015f9c:	613b      	str	r3, [r7, #16]
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
24015f9e:	4b99      	ldr	r3, [pc, #612]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24015fa0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
24015fa2:	08db      	lsrs	r3, r3, #3
24015fa4:	f3c3 030c 	ubfx	r3, r3, #0, #13
24015fa8:	693a      	ldr	r2, [r7, #16]
24015faa:	fb02 f303 	mul.w	r3, r2, r3
24015fae:	ee07 3a90 	vmov	s15, r3
24015fb2:	eef8 7a67 	vcvt.f32.u32	s15, s15
24015fb6:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
24015fba:	697b      	ldr	r3, [r7, #20]
24015fbc:	2b00      	cmp	r3, #0
24015fbe:	f000 8111 	beq.w	240161e4 <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
24015fc2:	69bb      	ldr	r3, [r7, #24]
24015fc4:	2b02      	cmp	r3, #2
24015fc6:	f000 8083 	beq.w	240160d0 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
24015fca:	69bb      	ldr	r3, [r7, #24]
24015fcc:	2b02      	cmp	r3, #2
24015fce:	f200 80a1 	bhi.w	24016114 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
24015fd2:	69bb      	ldr	r3, [r7, #24]
24015fd4:	2b00      	cmp	r3, #0
24015fd6:	d003      	beq.n	24015fe0 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
24015fd8:	69bb      	ldr	r3, [r7, #24]
24015fda:	2b01      	cmp	r3, #1
24015fdc:	d056      	beq.n	2401608c <HAL_RCCEx_GetPLL2ClockFreq+0x118>
24015fde:	e099      	b.n	24016114 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24015fe0:	4b88      	ldr	r3, [pc, #544]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24015fe2:	681b      	ldr	r3, [r3, #0]
24015fe4:	f003 0320 	and.w	r3, r3, #32
24015fe8:	2b00      	cmp	r3, #0
24015fea:	d02d      	beq.n	24016048 <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24015fec:	4b85      	ldr	r3, [pc, #532]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24015fee:	681b      	ldr	r3, [r3, #0]
24015ff0:	08db      	lsrs	r3, r3, #3
24015ff2:	f003 0303 	and.w	r3, r3, #3
24015ff6:	4a84      	ldr	r2, [pc, #528]	; (24016208 <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
24015ff8:	fa22 f303 	lsr.w	r3, r2, r3
24015ffc:	60bb      	str	r3, [r7, #8]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24015ffe:	68bb      	ldr	r3, [r7, #8]
24016000:	ee07 3a90 	vmov	s15, r3
24016004:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016008:	697b      	ldr	r3, [r7, #20]
2401600a:	ee07 3a90 	vmov	s15, r3
2401600e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016012:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016016:	4b7b      	ldr	r3, [pc, #492]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016018:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401601a:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401601e:	ee07 3a90 	vmov	s15, r3
24016022:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016026:	ed97 6a03 	vldr	s12, [r7, #12]
2401602a:	eddf 5a78 	vldr	s11, [pc, #480]	; 2401620c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
2401602e:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016032:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016036:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401603a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401603e:	ee67 7a27 	vmul.f32	s15, s14, s15
24016042:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
      }
      break;
24016046:	e087      	b.n	24016158 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24016048:	697b      	ldr	r3, [r7, #20]
2401604a:	ee07 3a90 	vmov	s15, r3
2401604e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016052:	eddf 6a6f 	vldr	s13, [pc, #444]	; 24016210 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
24016056:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401605a:	4b6a      	ldr	r3, [pc, #424]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
2401605c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401605e:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016062:	ee07 3a90 	vmov	s15, r3
24016066:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401606a:	ed97 6a03 	vldr	s12, [r7, #12]
2401606e:	eddf 5a67 	vldr	s11, [pc, #412]	; 2401620c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
24016072:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016076:	ee76 7aa7 	vadd.f32	s15, s13, s15
2401607a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401607e:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016082:	ee67 7a27 	vmul.f32	s15, s14, s15
24016086:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2401608a:	e065      	b.n	24016158 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
2401608c:	697b      	ldr	r3, [r7, #20]
2401608e:	ee07 3a90 	vmov	s15, r3
24016092:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016096:	eddf 6a5f 	vldr	s13, [pc, #380]	; 24016214 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
2401609a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401609e:	4b59      	ldr	r3, [pc, #356]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
240160a0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240160a2:	f3c3 0308 	ubfx	r3, r3, #0, #9
240160a6:	ee07 3a90 	vmov	s15, r3
240160aa:	eef8 6a67 	vcvt.f32.u32	s13, s15
240160ae:	ed97 6a03 	vldr	s12, [r7, #12]
240160b2:	eddf 5a56 	vldr	s11, [pc, #344]	; 2401620c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
240160b6:	eec6 7a25 	vdiv.f32	s15, s12, s11
240160ba:	ee76 7aa7 	vadd.f32	s15, s13, s15
240160be:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240160c2:	ee77 7aa6 	vadd.f32	s15, s15, s13
240160c6:	ee67 7a27 	vmul.f32	s15, s14, s15
240160ca:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240160ce:	e043      	b.n	24016158 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
240160d0:	697b      	ldr	r3, [r7, #20]
240160d2:	ee07 3a90 	vmov	s15, r3
240160d6:	eef8 7a67 	vcvt.f32.u32	s15, s15
240160da:	eddf 6a4f 	vldr	s13, [pc, #316]	; 24016218 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
240160de:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240160e2:	4b48      	ldr	r3, [pc, #288]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
240160e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240160e6:	f3c3 0308 	ubfx	r3, r3, #0, #9
240160ea:	ee07 3a90 	vmov	s15, r3
240160ee:	eef8 6a67 	vcvt.f32.u32	s13, s15
240160f2:	ed97 6a03 	vldr	s12, [r7, #12]
240160f6:	eddf 5a45 	vldr	s11, [pc, #276]	; 2401620c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
240160fa:	eec6 7a25 	vdiv.f32	s15, s12, s11
240160fe:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016102:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016106:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401610a:	ee67 7a27 	vmul.f32	s15, s14, s15
2401610e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24016112:	e021      	b.n	24016158 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    default:
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
24016114:	697b      	ldr	r3, [r7, #20]
24016116:	ee07 3a90 	vmov	s15, r3
2401611a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401611e:	eddf 6a3d 	vldr	s13, [pc, #244]	; 24016214 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
24016122:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016126:	4b37      	ldr	r3, [pc, #220]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016128:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401612a:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401612e:	ee07 3a90 	vmov	s15, r3
24016132:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016136:	ed97 6a03 	vldr	s12, [r7, #12]
2401613a:	eddf 5a34 	vldr	s11, [pc, #208]	; 2401620c <HAL_RCCEx_GetPLL2ClockFreq+0x298>
2401613e:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016142:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016146:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401614a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401614e:	ee67 7a27 	vmul.f32	s15, s14, s15
24016152:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24016156:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
24016158:	4b2a      	ldr	r3, [pc, #168]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
2401615a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401615c:	0a5b      	lsrs	r3, r3, #9
2401615e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016162:	ee07 3a90 	vmov	s15, r3
24016166:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401616a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2401616e:	ee37 7a87 	vadd.f32	s14, s15, s14
24016172:	edd7 6a07 	vldr	s13, [r7, #28]
24016176:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401617a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
2401617e:	ee17 2a90 	vmov	r2, s15
24016182:	687b      	ldr	r3, [r7, #4]
24016184:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
24016186:	4b1f      	ldr	r3, [pc, #124]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
24016188:	6b9b      	ldr	r3, [r3, #56]	; 0x38
2401618a:	0c1b      	lsrs	r3, r3, #16
2401618c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016190:	ee07 3a90 	vmov	s15, r3
24016194:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016198:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2401619c:	ee37 7a87 	vadd.f32	s14, s15, s14
240161a0:	edd7 6a07 	vldr	s13, [r7, #28]
240161a4:	eec6 7a87 	vdiv.f32	s15, s13, s14
240161a8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240161ac:	ee17 2a90 	vmov	r2, s15
240161b0:	687b      	ldr	r3, [r7, #4]
240161b2:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
240161b4:	4b13      	ldr	r3, [pc, #76]	; (24016204 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
240161b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
240161b8:	0e1b      	lsrs	r3, r3, #24
240161ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240161be:	ee07 3a90 	vmov	s15, r3
240161c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
240161c6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
240161ca:	ee37 7a87 	vadd.f32	s14, s15, s14
240161ce:	edd7 6a07 	vldr	s13, [r7, #28]
240161d2:	eec6 7a87 	vdiv.f32	s15, s13, s14
240161d6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240161da:	ee17 2a90 	vmov	r2, s15
240161de:	687b      	ldr	r3, [r7, #4]
240161e0:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
240161e2:	e008      	b.n	240161f6 <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
240161e4:	687b      	ldr	r3, [r7, #4]
240161e6:	2200      	movs	r2, #0
240161e8:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
240161ea:	687b      	ldr	r3, [r7, #4]
240161ec:	2200      	movs	r2, #0
240161ee:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
240161f0:	687b      	ldr	r3, [r7, #4]
240161f2:	2200      	movs	r2, #0
240161f4:	609a      	str	r2, [r3, #8]
}
240161f6:	bf00      	nop
240161f8:	3724      	adds	r7, #36	; 0x24
240161fa:	46bd      	mov	sp, r7
240161fc:	f85d 7b04 	ldr.w	r7, [sp], #4
24016200:	4770      	bx	lr
24016202:	bf00      	nop
24016204:	58024400 	.word	0x58024400
24016208:	03d09000 	.word	0x03d09000
2401620c:	46000000 	.word	0x46000000
24016210:	4c742400 	.word	0x4c742400
24016214:	4a742400 	.word	0x4a742400
24016218:	4c371b00 	.word	0x4c371b00

2401621c <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)
{
2401621c:	b480      	push	{r7}
2401621e:	b089      	sub	sp, #36	; 0x24
24016220:	af00      	add	r7, sp, #0
24016222:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
24016224:	4ba1      	ldr	r3, [pc, #644]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016226:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016228:	f003 0303 	and.w	r3, r3, #3
2401622c:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
2401622e:	4b9f      	ldr	r3, [pc, #636]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016230:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016232:	0d1b      	lsrs	r3, r3, #20
24016234:	f003 033f 	and.w	r3, r3, #63	; 0x3f
24016238:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
2401623a:	4b9c      	ldr	r3, [pc, #624]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
2401623c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
2401623e:	0a1b      	lsrs	r3, r3, #8
24016240:	f003 0301 	and.w	r3, r3, #1
24016244:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
24016246:	4b99      	ldr	r3, [pc, #612]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016248:	6c5b      	ldr	r3, [r3, #68]	; 0x44
2401624a:	08db      	lsrs	r3, r3, #3
2401624c:	f3c3 030c 	ubfx	r3, r3, #0, #13
24016250:	693a      	ldr	r2, [r7, #16]
24016252:	fb02 f303 	mul.w	r3, r2, r3
24016256:	ee07 3a90 	vmov	s15, r3
2401625a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401625e:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
24016262:	697b      	ldr	r3, [r7, #20]
24016264:	2b00      	cmp	r3, #0
24016266:	f000 8111 	beq.w	2401648c <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
2401626a:	69bb      	ldr	r3, [r7, #24]
2401626c:	2b02      	cmp	r3, #2
2401626e:	f000 8083 	beq.w	24016378 <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
24016272:	69bb      	ldr	r3, [r7, #24]
24016274:	2b02      	cmp	r3, #2
24016276:	f200 80a1 	bhi.w	240163bc <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
2401627a:	69bb      	ldr	r3, [r7, #24]
2401627c:	2b00      	cmp	r3, #0
2401627e:	d003      	beq.n	24016288 <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
24016280:	69bb      	ldr	r3, [r7, #24]
24016282:	2b01      	cmp	r3, #1
24016284:	d056      	beq.n	24016334 <HAL_RCCEx_GetPLL3ClockFreq+0x118>
24016286:	e099      	b.n	240163bc <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
24016288:	4b88      	ldr	r3, [pc, #544]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
2401628a:	681b      	ldr	r3, [r3, #0]
2401628c:	f003 0320 	and.w	r3, r3, #32
24016290:	2b00      	cmp	r3, #0
24016292:	d02d      	beq.n	240162f0 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
24016294:	4b85      	ldr	r3, [pc, #532]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016296:	681b      	ldr	r3, [r3, #0]
24016298:	08db      	lsrs	r3, r3, #3
2401629a:	f003 0303 	and.w	r3, r3, #3
2401629e:	4a84      	ldr	r2, [pc, #528]	; (240164b0 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
240162a0:	fa22 f303 	lsr.w	r3, r2, r3
240162a4:	60bb      	str	r3, [r7, #8]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
240162a6:	68bb      	ldr	r3, [r7, #8]
240162a8:	ee07 3a90 	vmov	s15, r3
240162ac:	eef8 6a67 	vcvt.f32.u32	s13, s15
240162b0:	697b      	ldr	r3, [r7, #20]
240162b2:	ee07 3a90 	vmov	s15, r3
240162b6:	eef8 7a67 	vcvt.f32.u32	s15, s15
240162ba:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240162be:	4b7b      	ldr	r3, [pc, #492]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
240162c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240162c2:	f3c3 0308 	ubfx	r3, r3, #0, #9
240162c6:	ee07 3a90 	vmov	s15, r3
240162ca:	eef8 6a67 	vcvt.f32.u32	s13, s15
240162ce:	ed97 6a03 	vldr	s12, [r7, #12]
240162d2:	eddf 5a78 	vldr	s11, [pc, #480]	; 240164b4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
240162d6:	eec6 7a25 	vdiv.f32	s15, s12, s11
240162da:	ee76 7aa7 	vadd.f32	s15, s13, s15
240162de:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240162e2:	ee77 7aa6 	vadd.f32	s15, s15, s13
240162e6:	ee67 7a27 	vmul.f32	s15, s14, s15
240162ea:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
      }
      break;
240162ee:	e087      	b.n	24016400 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
240162f0:	697b      	ldr	r3, [r7, #20]
240162f2:	ee07 3a90 	vmov	s15, r3
240162f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
240162fa:	eddf 6a6f 	vldr	s13, [pc, #444]	; 240164b8 <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
240162fe:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016302:	4b6a      	ldr	r3, [pc, #424]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016304:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016306:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401630a:	ee07 3a90 	vmov	s15, r3
2401630e:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016312:	ed97 6a03 	vldr	s12, [r7, #12]
24016316:	eddf 5a67 	vldr	s11, [pc, #412]	; 240164b4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
2401631a:	eec6 7a25 	vdiv.f32	s15, s12, s11
2401631e:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016322:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016326:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401632a:	ee67 7a27 	vmul.f32	s15, s14, s15
2401632e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24016332:	e065      	b.n	24016400 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
24016334:	697b      	ldr	r3, [r7, #20]
24016336:	ee07 3a90 	vmov	s15, r3
2401633a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401633e:	eddf 6a5f 	vldr	s13, [pc, #380]	; 240164bc <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
24016342:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016346:	4b59      	ldr	r3, [pc, #356]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016348:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401634a:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401634e:	ee07 3a90 	vmov	s15, r3
24016352:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016356:	ed97 6a03 	vldr	s12, [r7, #12]
2401635a:	eddf 5a56 	vldr	s11, [pc, #344]	; 240164b4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
2401635e:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016362:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016366:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2401636a:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401636e:	ee67 7a27 	vmul.f32	s15, s14, s15
24016372:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24016376:	e043      	b.n	24016400 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
24016378:	697b      	ldr	r3, [r7, #20]
2401637a:	ee07 3a90 	vmov	s15, r3
2401637e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016382:	eddf 6a4f 	vldr	s13, [pc, #316]	; 240164c0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
24016386:	ee86 7aa7 	vdiv.f32	s14, s13, s15
2401638a:	4b48      	ldr	r3, [pc, #288]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
2401638c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
2401638e:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016392:	ee07 3a90 	vmov	s15, r3
24016396:	eef8 6a67 	vcvt.f32.u32	s13, s15
2401639a:	ed97 6a03 	vldr	s12, [r7, #12]
2401639e:	eddf 5a45 	vldr	s11, [pc, #276]	; 240164b4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
240163a2:	eec6 7a25 	vdiv.f32	s15, s12, s11
240163a6:	ee76 7aa7 	vadd.f32	s15, s13, s15
240163aa:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240163ae:	ee77 7aa6 	vadd.f32	s15, s15, s13
240163b2:	ee67 7a27 	vmul.f32	s15, s14, s15
240163b6:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240163ba:	e021      	b.n	24016400 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    default:
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
240163bc:	697b      	ldr	r3, [r7, #20]
240163be:	ee07 3a90 	vmov	s15, r3
240163c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
240163c6:	eddf 6a3d 	vldr	s13, [pc, #244]	; 240164bc <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
240163ca:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240163ce:	4b37      	ldr	r3, [pc, #220]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
240163d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
240163d2:	f3c3 0308 	ubfx	r3, r3, #0, #9
240163d6:	ee07 3a90 	vmov	s15, r3
240163da:	eef8 6a67 	vcvt.f32.u32	s13, s15
240163de:	ed97 6a03 	vldr	s12, [r7, #12]
240163e2:	eddf 5a34 	vldr	s11, [pc, #208]	; 240164b4 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
240163e6:	eec6 7a25 	vdiv.f32	s15, s12, s11
240163ea:	ee76 7aa7 	vadd.f32	s15, s13, s15
240163ee:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240163f2:	ee77 7aa6 	vadd.f32	s15, s15, s13
240163f6:	ee67 7a27 	vmul.f32	s15, s14, s15
240163fa:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240163fe:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
24016400:	4b2a      	ldr	r3, [pc, #168]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016402:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016404:	0a5b      	lsrs	r3, r3, #9
24016406:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2401640a:	ee07 3a90 	vmov	s15, r3
2401640e:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016412:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016416:	ee37 7a87 	vadd.f32	s14, s15, s14
2401641a:	edd7 6a07 	vldr	s13, [r7, #28]
2401641e:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016422:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016426:	ee17 2a90 	vmov	r2, s15
2401642a:	687b      	ldr	r3, [r7, #4]
2401642c:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
2401642e:	4b1f      	ldr	r3, [pc, #124]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
24016430:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016432:	0c1b      	lsrs	r3, r3, #16
24016434:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016438:	ee07 3a90 	vmov	s15, r3
2401643c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016440:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016444:	ee37 7a87 	vadd.f32	s14, s15, s14
24016448:	edd7 6a07 	vldr	s13, [r7, #28]
2401644c:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016450:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016454:	ee17 2a90 	vmov	r2, s15
24016458:	687b      	ldr	r3, [r7, #4]
2401645a:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
2401645c:	4b13      	ldr	r3, [pc, #76]	; (240164ac <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
2401645e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
24016460:	0e1b      	lsrs	r3, r3, #24
24016462:	f003 037f 	and.w	r3, r3, #127	; 0x7f
24016466:	ee07 3a90 	vmov	s15, r3
2401646a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401646e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016472:	ee37 7a87 	vadd.f32	s14, s15, s14
24016476:	edd7 6a07 	vldr	s13, [r7, #28]
2401647a:	eec6 7a87 	vdiv.f32	s15, s13, s14
2401647e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016482:	ee17 2a90 	vmov	r2, s15
24016486:	687b      	ldr	r3, [r7, #4]
24016488:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
2401648a:	e008      	b.n	2401649e <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
2401648c:	687b      	ldr	r3, [r7, #4]
2401648e:	2200      	movs	r2, #0
24016490:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
24016492:	687b      	ldr	r3, [r7, #4]
24016494:	2200      	movs	r2, #0
24016496:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
24016498:	687b      	ldr	r3, [r7, #4]
2401649a:	2200      	movs	r2, #0
2401649c:	609a      	str	r2, [r3, #8]
}
2401649e:	bf00      	nop
240164a0:	3724      	adds	r7, #36	; 0x24
240164a2:	46bd      	mov	sp, r7
240164a4:	f85d 7b04 	ldr.w	r7, [sp], #4
240164a8:	4770      	bx	lr
240164aa:	bf00      	nop
240164ac:	58024400 	.word	0x58024400
240164b0:	03d09000 	.word	0x03d09000
240164b4:	46000000 	.word	0x46000000
240164b8:	4c742400 	.word	0x4c742400
240164bc:	4a742400 	.word	0x4a742400
240164c0:	4c371b00 	.word	0x4c371b00

240164c4 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef* PLL1_Clocks)
{
240164c4:	b480      	push	{r7}
240164c6:	b089      	sub	sp, #36	; 0x24
240164c8:	af00      	add	r7, sp, #0
240164ca:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
240164cc:	4ba0      	ldr	r3, [pc, #640]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240164ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240164d0:	f003 0303 	and.w	r3, r3, #3
240164d4:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
240164d6:	4b9e      	ldr	r3, [pc, #632]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240164d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
240164da:	091b      	lsrs	r3, r3, #4
240164dc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
240164e0:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
240164e2:	4b9b      	ldr	r3, [pc, #620]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240164e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
240164e6:	f003 0301 	and.w	r3, r3, #1
240164ea:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
240164ec:	4b98      	ldr	r3, [pc, #608]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240164ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
240164f0:	08db      	lsrs	r3, r3, #3
240164f2:	f3c3 030c 	ubfx	r3, r3, #0, #13
240164f6:	693a      	ldr	r2, [r7, #16]
240164f8:	fb02 f303 	mul.w	r3, r2, r3
240164fc:	ee07 3a90 	vmov	s15, r3
24016500:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016504:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
24016508:	697b      	ldr	r3, [r7, #20]
2401650a:	2b00      	cmp	r3, #0
2401650c:	f000 8111 	beq.w	24016732 <HAL_RCCEx_GetPLL1ClockFreq+0x26e>
  {
    switch (pllsource)
24016510:	69bb      	ldr	r3, [r7, #24]
24016512:	2b02      	cmp	r3, #2
24016514:	f000 8083 	beq.w	2401661e <HAL_RCCEx_GetPLL1ClockFreq+0x15a>
24016518:	69bb      	ldr	r3, [r7, #24]
2401651a:	2b02      	cmp	r3, #2
2401651c:	f200 80a1 	bhi.w	24016662 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
24016520:	69bb      	ldr	r3, [r7, #24]
24016522:	2b00      	cmp	r3, #0
24016524:	d003      	beq.n	2401652e <HAL_RCCEx_GetPLL1ClockFreq+0x6a>
24016526:	69bb      	ldr	r3, [r7, #24]
24016528:	2b01      	cmp	r3, #1
2401652a:	d056      	beq.n	240165da <HAL_RCCEx_GetPLL1ClockFreq+0x116>
2401652c:	e099      	b.n	24016662 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
2401652e:	4b88      	ldr	r3, [pc, #544]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016530:	681b      	ldr	r3, [r3, #0]
24016532:	f003 0320 	and.w	r3, r3, #32
24016536:	2b00      	cmp	r3, #0
24016538:	d02d      	beq.n	24016596 <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
2401653a:	4b85      	ldr	r3, [pc, #532]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
2401653c:	681b      	ldr	r3, [r3, #0]
2401653e:	08db      	lsrs	r3, r3, #3
24016540:	f003 0303 	and.w	r3, r3, #3
24016544:	4a83      	ldr	r2, [pc, #524]	; (24016754 <HAL_RCCEx_GetPLL1ClockFreq+0x290>)
24016546:	fa22 f303 	lsr.w	r3, r2, r3
2401654a:	60bb      	str	r3, [r7, #8]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2401654c:	68bb      	ldr	r3, [r7, #8]
2401654e:	ee07 3a90 	vmov	s15, r3
24016552:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016556:	697b      	ldr	r3, [r7, #20]
24016558:	ee07 3a90 	vmov	s15, r3
2401655c:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016560:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016564:	4b7a      	ldr	r3, [pc, #488]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016566:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016568:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401656c:	ee07 3a90 	vmov	s15, r3
24016570:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016574:	ed97 6a03 	vldr	s12, [r7, #12]
24016578:	eddf 5a77 	vldr	s11, [pc, #476]	; 24016758 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
2401657c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016580:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016584:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016588:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401658c:	ee67 7a27 	vmul.f32	s15, s14, s15
24016590:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
      }
      break;
24016594:	e087      	b.n	240166a6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016596:	697b      	ldr	r3, [r7, #20]
24016598:	ee07 3a90 	vmov	s15, r3
2401659c:	eef8 7a67 	vcvt.f32.u32	s15, s15
240165a0:	eddf 6a6e 	vldr	s13, [pc, #440]	; 2401675c <HAL_RCCEx_GetPLL1ClockFreq+0x298>
240165a4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240165a8:	4b69      	ldr	r3, [pc, #420]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240165aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240165ac:	f3c3 0308 	ubfx	r3, r3, #0, #9
240165b0:	ee07 3a90 	vmov	s15, r3
240165b4:	eef8 6a67 	vcvt.f32.u32	s13, s15
240165b8:	ed97 6a03 	vldr	s12, [r7, #12]
240165bc:	eddf 5a66 	vldr	s11, [pc, #408]	; 24016758 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
240165c0:	eec6 7a25 	vdiv.f32	s15, s12, s11
240165c4:	ee76 7aa7 	vadd.f32	s15, s13, s15
240165c8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
240165cc:	ee77 7aa6 	vadd.f32	s15, s15, s13
240165d0:	ee67 7a27 	vmul.f32	s15, s14, s15
240165d4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240165d8:	e065      	b.n	240166a6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
240165da:	697b      	ldr	r3, [r7, #20]
240165dc:	ee07 3a90 	vmov	s15, r3
240165e0:	eef8 7a67 	vcvt.f32.u32	s15, s15
240165e4:	eddf 6a5e 	vldr	s13, [pc, #376]	; 24016760 <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
240165e8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
240165ec:	4b58      	ldr	r3, [pc, #352]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240165ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240165f0:	f3c3 0308 	ubfx	r3, r3, #0, #9
240165f4:	ee07 3a90 	vmov	s15, r3
240165f8:	eef8 6a67 	vcvt.f32.u32	s13, s15
240165fc:	ed97 6a03 	vldr	s12, [r7, #12]
24016600:	eddf 5a55 	vldr	s11, [pc, #340]	; 24016758 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
24016604:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016608:	ee76 7aa7 	vadd.f32	s15, s13, s15
2401660c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016610:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016614:	ee67 7a27 	vmul.f32	s15, s14, s15
24016618:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
2401661c:	e043      	b.n	240166a6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
2401661e:	697b      	ldr	r3, [r7, #20]
24016620:	ee07 3a90 	vmov	s15, r3
24016624:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016628:	eddf 6a4e 	vldr	s13, [pc, #312]	; 24016764 <HAL_RCCEx_GetPLL1ClockFreq+0x2a0>
2401662c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016630:	4b47      	ldr	r3, [pc, #284]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016632:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016634:	f3c3 0308 	ubfx	r3, r3, #0, #9
24016638:	ee07 3a90 	vmov	s15, r3
2401663c:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016640:	ed97 6a03 	vldr	s12, [r7, #12]
24016644:	eddf 5a44 	vldr	s11, [pc, #272]	; 24016758 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
24016648:	eec6 7a25 	vdiv.f32	s15, s12, s11
2401664c:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016650:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016654:	ee77 7aa6 	vadd.f32	s15, s15, s13
24016658:	ee67 7a27 	vmul.f32	s15, s14, s15
2401665c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
24016660:	e021      	b.n	240166a6 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

    default:
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
24016662:	697b      	ldr	r3, [r7, #20]
24016664:	ee07 3a90 	vmov	s15, r3
24016668:	eef8 7a67 	vcvt.f32.u32	s15, s15
2401666c:	eddf 6a3b 	vldr	s13, [pc, #236]	; 2401675c <HAL_RCCEx_GetPLL1ClockFreq+0x298>
24016670:	ee86 7aa7 	vdiv.f32	s14, s13, s15
24016674:	4b36      	ldr	r3, [pc, #216]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016676:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016678:	f3c3 0308 	ubfx	r3, r3, #0, #9
2401667c:	ee07 3a90 	vmov	s15, r3
24016680:	eef8 6a67 	vcvt.f32.u32	s13, s15
24016684:	ed97 6a03 	vldr	s12, [r7, #12]
24016688:	eddf 5a33 	vldr	s11, [pc, #204]	; 24016758 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
2401668c:	eec6 7a25 	vdiv.f32	s15, s12, s11
24016690:	ee76 7aa7 	vadd.f32	s15, s13, s15
24016694:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
24016698:	ee77 7aa6 	vadd.f32	s15, s15, s13
2401669c:	ee67 7a27 	vmul.f32	s15, s14, s15
240166a0:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
240166a4:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
240166a6:	4b2a      	ldr	r3, [pc, #168]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240166a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240166aa:	0a5b      	lsrs	r3, r3, #9
240166ac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240166b0:	ee07 3a90 	vmov	s15, r3
240166b4:	eef8 7a67 	vcvt.f32.u32	s15, s15
240166b8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
240166bc:	ee37 7a87 	vadd.f32	s14, s15, s14
240166c0:	edd7 6a07 	vldr	s13, [r7, #28]
240166c4:	eec6 7a87 	vdiv.f32	s15, s13, s14
240166c8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240166cc:	ee17 2a90 	vmov	r2, s15
240166d0:	687b      	ldr	r3, [r7, #4]
240166d2:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
240166d4:	4b1e      	ldr	r3, [pc, #120]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
240166d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
240166d8:	0c1b      	lsrs	r3, r3, #16
240166da:	f003 037f 	and.w	r3, r3, #127	; 0x7f
240166de:	ee07 3a90 	vmov	s15, r3
240166e2:	eef8 7a67 	vcvt.f32.u32	s15, s15
240166e6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
240166ea:	ee37 7a87 	vadd.f32	s14, s15, s14
240166ee:	edd7 6a07 	vldr	s13, [r7, #28]
240166f2:	eec6 7a87 	vdiv.f32	s15, s13, s14
240166f6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
240166fa:	ee17 2a90 	vmov	r2, s15
240166fe:	687b      	ldr	r3, [r7, #4]
24016700:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
24016702:	4b13      	ldr	r3, [pc, #76]	; (24016750 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
24016704:	6b1b      	ldr	r3, [r3, #48]	; 0x30
24016706:	0e1b      	lsrs	r3, r3, #24
24016708:	f003 037f 	and.w	r3, r3, #127	; 0x7f
2401670c:	ee07 3a90 	vmov	s15, r3
24016710:	eef8 7a67 	vcvt.f32.u32	s15, s15
24016714:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
24016718:	ee37 7a87 	vadd.f32	s14, s15, s14
2401671c:	edd7 6a07 	vldr	s13, [r7, #28]
24016720:	eec6 7a87 	vdiv.f32	s15, s13, s14
24016724:	eefc 7ae7 	vcvt.u32.f32	s15, s15
24016728:	ee17 2a90 	vmov	r2, s15
2401672c:	687b      	ldr	r3, [r7, #4]
2401672e:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
24016730:	e008      	b.n	24016744 <HAL_RCCEx_GetPLL1ClockFreq+0x280>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
24016732:	687b      	ldr	r3, [r7, #4]
24016734:	2200      	movs	r2, #0
24016736:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
24016738:	687b      	ldr	r3, [r7, #4]
2401673a:	2200      	movs	r2, #0
2401673c:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
2401673e:	687b      	ldr	r3, [r7, #4]
24016740:	2200      	movs	r2, #0
24016742:	609a      	str	r2, [r3, #8]
}
24016744:	bf00      	nop
24016746:	3724      	adds	r7, #36	; 0x24
24016748:	46bd      	mov	sp, r7
2401674a:	f85d 7b04 	ldr.w	r7, [sp], #4
2401674e:	4770      	bx	lr
24016750:	58024400 	.word	0x58024400
24016754:	03d09000 	.word	0x03d09000
24016758:	46000000 	.word	0x46000000
2401675c:	4c742400 	.word	0x4c742400
24016760:	4a742400 	.word	0x4a742400
24016764:	4c371b00 	.word	0x4c371b00

24016768 <HAL_RCCEx_GetD1SysClockFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System current Core Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCCEx_GetD1SysClockFreq(void)
{
24016768:	b580      	push	{r7, lr}
2401676a:	b082      	sub	sp, #8
2401676c:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
2401676e:	f7fd fb2f 	bl	24013dd0 <HAL_RCC_GetSysClockFreq>
24016772:	4602      	mov	r2, r0
24016774:	4b10      	ldr	r3, [pc, #64]	; (240167b8 <HAL_RCCEx_GetD1SysClockFreq+0x50>)
24016776:	699b      	ldr	r3, [r3, #24]
24016778:	0a1b      	lsrs	r3, r3, #8
2401677a:	f003 030f 	and.w	r3, r3, #15
2401677e:	490f      	ldr	r1, [pc, #60]	; (240167bc <HAL_RCCEx_GetD1SysClockFreq+0x54>)
24016780:	5ccb      	ldrb	r3, [r1, r3]
24016782:	f003 031f 	and.w	r3, r3, #31
24016786:	fa22 f303 	lsr.w	r3, r2, r3
2401678a:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
2401678c:	4b0a      	ldr	r3, [pc, #40]	; (240167b8 <HAL_RCCEx_GetD1SysClockFreq+0x50>)
2401678e:	699b      	ldr	r3, [r3, #24]
24016790:	f003 030f 	and.w	r3, r3, #15
24016794:	4a09      	ldr	r2, [pc, #36]	; (240167bc <HAL_RCCEx_GetD1SysClockFreq+0x54>)
24016796:	5cd3      	ldrb	r3, [r2, r3]
24016798:	f003 031f 	and.w	r3, r3, #31
2401679c:	687a      	ldr	r2, [r7, #4]
2401679e:	fa22 f303 	lsr.w	r3, r2, r3
240167a2:	4a07      	ldr	r2, [pc, #28]	; (240167c0 <HAL_RCCEx_GetD1SysClockFreq+0x58>)
240167a4:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
240167a6:	4a07      	ldr	r2, [pc, #28]	; (240167c4 <HAL_RCCEx_GetD1SysClockFreq+0x5c>)
240167a8:	687b      	ldr	r3, [r7, #4]
240167aa:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return common_system_clock;
240167ac:	687b      	ldr	r3, [r7, #4]
}
240167ae:	4618      	mov	r0, r3
240167b0:	3708      	adds	r7, #8
240167b2:	46bd      	mov	sp, r7
240167b4:	bd80      	pop	{r7, pc}
240167b6:	bf00      	nop
240167b8:	58024400 	.word	0x58024400
240167bc:	240178a4 	.word	0x240178a4
240167c0:	240004b4 	.word	0x240004b4
240167c4:	240004b0 	.word	0x240004b0

240167c8 <HAL_RCCEx_EnableLSECSS>:
  *         with HAL_RCC_OscConfig() and the LSE oscillator clock is to be selected as RTC
  *         clock with HAL_RCCEx_PeriphCLKConfig().
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS(void)
{
240167c8:	b480      	push	{r7}
240167ca:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
240167cc:	4b05      	ldr	r3, [pc, #20]	; (240167e4 <HAL_RCCEx_EnableLSECSS+0x1c>)
240167ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240167d0:	4a04      	ldr	r2, [pc, #16]	; (240167e4 <HAL_RCCEx_EnableLSECSS+0x1c>)
240167d2:	f043 0320 	orr.w	r3, r3, #32
240167d6:	6713      	str	r3, [r2, #112]	; 0x70
}
240167d8:	bf00      	nop
240167da:	46bd      	mov	sp, r7
240167dc:	f85d 7b04 	ldr.w	r7, [sp], #4
240167e0:	4770      	bx	lr
240167e2:	bf00      	nop
240167e4:	58024400 	.word	0x58024400

240167e8 <HAL_RCCEx_DisableLSECSS>:
  * @brief  Disables the LSE Clock Security System.
  * @note   LSE Clock Security System can only be disabled after a LSE failure detection.
  * @retval None
  */
void HAL_RCCEx_DisableLSECSS(void)
{
240167e8:	b480      	push	{r7}
240167ea:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
240167ec:	4b08      	ldr	r3, [pc, #32]	; (24016810 <HAL_RCCEx_DisableLSECSS+0x28>)
240167ee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
240167f0:	4a07      	ldr	r2, [pc, #28]	; (24016810 <HAL_RCCEx_DisableLSECSS+0x28>)
240167f2:	f023 0320 	bic.w	r3, r3, #32
240167f6:	6713      	str	r3, [r2, #112]	; 0x70
  /* Disable LSE CSS IT if any */
  __HAL_RCC_DISABLE_IT(RCC_IT_LSECSS);
240167f8:	4b05      	ldr	r3, [pc, #20]	; (24016810 <HAL_RCCEx_DisableLSECSS+0x28>)
240167fa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
240167fc:	4a04      	ldr	r2, [pc, #16]	; (24016810 <HAL_RCCEx_DisableLSECSS+0x28>)
240167fe:	f423 7300 	bic.w	r3, r3, #512	; 0x200
24016802:	6613      	str	r3, [r2, #96]	; 0x60
}
24016804:	bf00      	nop
24016806:	46bd      	mov	sp, r7
24016808:	f85d 7b04 	ldr.w	r7, [sp], #4
2401680c:	4770      	bx	lr
2401680e:	bf00      	nop
24016810:	58024400 	.word	0x58024400

24016814 <HAL_RCCEx_EnableLSECSS_IT>:
  * @brief  Enable the LSE Clock Security System Interrupt & corresponding EXTI line.
  * @note   LSE Clock Security System Interrupt is mapped on EXTI line 18
  * @retval None
  */
void HAL_RCCEx_EnableLSECSS_IT(void)
{
24016814:	b480      	push	{r7}
24016816:	af00      	add	r7, sp, #0
  /* Enable LSE CSS */
  SET_BIT(RCC->BDCR, RCC_BDCR_LSECSSON) ;
24016818:	4b11      	ldr	r3, [pc, #68]	; (24016860 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
2401681a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
2401681c:	4a10      	ldr	r2, [pc, #64]	; (24016860 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
2401681e:	f043 0320 	orr.w	r3, r3, #32
24016822:	6713      	str	r3, [r2, #112]	; 0x70

  /* Enable LSE CSS IT */
  __HAL_RCC_ENABLE_IT(RCC_IT_LSECSS);
24016824:	4b0e      	ldr	r3, [pc, #56]	; (24016860 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
24016826:	6e1b      	ldr	r3, [r3, #96]	; 0x60
24016828:	4a0d      	ldr	r2, [pc, #52]	; (24016860 <HAL_RCCEx_EnableLSECSS_IT+0x4c>)
2401682a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
2401682e:	6613      	str	r3, [r2, #96]	; 0x60

  /* Enable IT on EXTI Line 18 */
#if defined(DUAL_CORE) && defined(CORE_CM4)
  __HAL_RCC_C2_LSECSS_EXTI_ENABLE_IT();
#else
  __HAL_RCC_LSECSS_EXTI_ENABLE_IT();
24016830:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24016834:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
24016838:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401683c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24016840:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* DUAL_CORE && CORE_CM4 */
  __HAL_RCC_LSECSS_EXTI_ENABLE_RISING_EDGE();
24016844:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
24016848:	681b      	ldr	r3, [r3, #0]
2401684a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
2401684e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
24016852:	6013      	str	r3, [r2, #0]
}
24016854:	bf00      	nop
24016856:	46bd      	mov	sp, r7
24016858:	f85d 7b04 	ldr.w	r7, [sp], #4
2401685c:	4770      	bx	lr
2401685e:	bf00      	nop
24016860:	58024400 	.word	0x58024400

24016864 <HAL_RCCEx_WakeUpStopCLKConfig>:
  * @note   This function shall not be called after the Clock Security System on HSE has been
  *         enabled.
  * @retval None
  */
void HAL_RCCEx_WakeUpStopCLKConfig(uint32_t WakeUpClk)
{
24016864:	b480      	push	{r7}
24016866:	b083      	sub	sp, #12
24016868:	af00      	add	r7, sp, #0
2401686a:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_WAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(WakeUpClk);
2401686c:	4b06      	ldr	r3, [pc, #24]	; (24016888 <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
2401686e:	691b      	ldr	r3, [r3, #16]
24016870:	f023 0240 	bic.w	r2, r3, #64	; 0x40
24016874:	4904      	ldr	r1, [pc, #16]	; (24016888 <HAL_RCCEx_WakeUpStopCLKConfig+0x24>)
24016876:	687b      	ldr	r3, [r7, #4]
24016878:	4313      	orrs	r3, r2
2401687a:	610b      	str	r3, [r1, #16]
}
2401687c:	bf00      	nop
2401687e:	370c      	adds	r7, #12
24016880:	46bd      	mov	sp, r7
24016882:	f85d 7b04 	ldr.w	r7, [sp], #4
24016886:	4770      	bx	lr
24016888:	58024400 	.word	0x58024400

2401688c <HAL_RCCEx_KerWakeUpStopCLKConfig>:
  *            @arg RCC_STOP_KERWAKEUPCLOCK_CSI: CSI oscillator selection
  *            @arg RCC_STOP_KERWAKEUPCLOCK_HSI: HSI oscillator selection
  * @retval None
  */
void HAL_RCCEx_KerWakeUpStopCLKConfig(uint32_t WakeUpClk)
{
2401688c:	b480      	push	{r7}
2401688e:	b083      	sub	sp, #12
24016890:	af00      	add	r7, sp, #0
24016892:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_STOP_KERWAKEUPCLOCK(WakeUpClk));

  __HAL_RCC_KERWAKEUPSTOP_CLK_CONFIG(WakeUpClk);
24016894:	4b06      	ldr	r3, [pc, #24]	; (240168b0 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
24016896:	691b      	ldr	r3, [r3, #16]
24016898:	f023 0280 	bic.w	r2, r3, #128	; 0x80
2401689c:	4904      	ldr	r1, [pc, #16]	; (240168b0 <HAL_RCCEx_KerWakeUpStopCLKConfig+0x24>)
2401689e:	687b      	ldr	r3, [r7, #4]
240168a0:	4313      	orrs	r3, r2
240168a2:	610b      	str	r3, [r1, #16]
}
240168a4:	bf00      	nop
240168a6:	370c      	adds	r7, #12
240168a8:	46bd      	mov	sp, r7
240168aa:	f85d 7b04 	ldr.w	r7, [sp], #4
240168ae:	4770      	bx	lr
240168b0:	58024400 	.word	0x58024400

240168b4 <HAL_RCCEx_WWDGxSysResetConfig>:
  * @note   This bit can be set by software but is cleared by hardware during a system reset
  *
  * @retval None
  */
void HAL_RCCEx_WWDGxSysResetConfig(uint32_t RCC_WWDGx)
{
240168b4:	b480      	push	{r7}
240168b6:	b083      	sub	sp, #12
240168b8:	af00      	add	r7, sp, #0
240168ba:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_SCOPE_WWDG(RCC_WWDGx));
  SET_BIT(RCC->GCR, RCC_WWDGx) ;
240168bc:	4b06      	ldr	r3, [pc, #24]	; (240168d8 <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
240168be:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
240168c2:	4905      	ldr	r1, [pc, #20]	; (240168d8 <HAL_RCCEx_WWDGxSysResetConfig+0x24>)
240168c4:	687b      	ldr	r3, [r7, #4]
240168c6:	4313      	orrs	r3, r2
240168c8:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
}
240168cc:	bf00      	nop
240168ce:	370c      	adds	r7, #12
240168d0:	46bd      	mov	sp, r7
240168d2:	f85d 7b04 	ldr.w	r7, [sp], #4
240168d6:	4770      	bx	lr
240168d8:	58024400 	.word	0x58024400

240168dc <HAL_RCCEx_CRSConfig>:
  * @brief  Start automatic synchronization for polling mode
  * @param  pInit Pointer on RCC_CRSInitTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSConfig(RCC_CRSInitTypeDef *pInit)
{
240168dc:	b580      	push	{r7, lr}
240168de:	b084      	sub	sp, #16
240168e0:	af00      	add	r7, sp, #0
240168e2:	6078      	str	r0, [r7, #4]
  assert_param(IS_RCC_CRS_HSI48CALIBRATION(pInit->HSI48CalibrationValue));

  /* CONFIGURATION */

  /* Before configuration, reset CRS registers to their default values*/
  __HAL_RCC_CRS_FORCE_RESET();
240168e4:	4b26      	ldr	r3, [pc, #152]	; (24016980 <HAL_RCCEx_CRSConfig+0xa4>)
240168e6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
240168ea:	4a25      	ldr	r2, [pc, #148]	; (24016980 <HAL_RCCEx_CRSConfig+0xa4>)
240168ec:	f043 0302 	orr.w	r3, r3, #2
240168f0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  __HAL_RCC_CRS_RELEASE_RESET();
240168f4:	4b22      	ldr	r3, [pc, #136]	; (24016980 <HAL_RCCEx_CRSConfig+0xa4>)
240168f6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
240168fa:	4a21      	ldr	r2, [pc, #132]	; (24016980 <HAL_RCCEx_CRSConfig+0xa4>)
240168fc:	f023 0302 	bic.w	r3, r3, #2
24016900:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

  /* Set the SYNCDIV[2:0] bits according to Pre-scaler value */
  /* Set the SYNCSRC[1:0] bits according to Source value */
  /* Set the SYNCSPOL bit according to Polarity value */
  if ((HAL_GetREVID() <= REV_ID_Y) && (pInit->Source == RCC_CRS_SYNC_SOURCE_USB2))
24016904:	f7eb fdb8 	bl	24002478 <HAL_GetREVID>
24016908:	4603      	mov	r3, r0
2401690a:	f241 0203 	movw	r2, #4099	; 0x1003
2401690e:	4293      	cmp	r3, r2
24016910:	d80b      	bhi.n	2401692a <HAL_RCCEx_CRSConfig+0x4e>
24016912:	687b      	ldr	r3, [r7, #4]
24016914:	685b      	ldr	r3, [r3, #4]
24016916:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
2401691a:	d106      	bne.n	2401692a <HAL_RCCEx_CRSConfig+0x4e>
  {
    /* Use Rev.Y value of USB2 */
    value = (pInit->Prescaler | RCC_CRS_SYNC_SOURCE_PIN | pInit->Polarity);
2401691c:	687b      	ldr	r3, [r7, #4]
2401691e:	681a      	ldr	r2, [r3, #0]
24016920:	687b      	ldr	r3, [r7, #4]
24016922:	689b      	ldr	r3, [r3, #8]
24016924:	4313      	orrs	r3, r2
24016926:	60fb      	str	r3, [r7, #12]
24016928:	e008      	b.n	2401693c <HAL_RCCEx_CRSConfig+0x60>
  }
  else
  {
    value = (pInit->Prescaler | pInit->Source | pInit->Polarity);
2401692a:	687b      	ldr	r3, [r7, #4]
2401692c:	681a      	ldr	r2, [r3, #0]
2401692e:	687b      	ldr	r3, [r7, #4]
24016930:	685b      	ldr	r3, [r3, #4]
24016932:	431a      	orrs	r2, r3
24016934:	687b      	ldr	r3, [r7, #4]
24016936:	689b      	ldr	r3, [r3, #8]
24016938:	4313      	orrs	r3, r2
2401693a:	60fb      	str	r3, [r7, #12]
  }
  /* Set the RELOAD[15:0] bits according to ReloadValue value */
  value |= pInit->ReloadValue;
2401693c:	687b      	ldr	r3, [r7, #4]
2401693e:	68db      	ldr	r3, [r3, #12]
24016940:	68fa      	ldr	r2, [r7, #12]
24016942:	4313      	orrs	r3, r2
24016944:	60fb      	str	r3, [r7, #12]
  /* Set the FELIM[7:0] bits according to ErrorLimitValue value */
  value |= (pInit->ErrorLimitValue << CRS_CFGR_FELIM_Pos);
24016946:	687b      	ldr	r3, [r7, #4]
24016948:	691b      	ldr	r3, [r3, #16]
2401694a:	041b      	lsls	r3, r3, #16
2401694c:	68fa      	ldr	r2, [r7, #12]
2401694e:	4313      	orrs	r3, r2
24016950:	60fb      	str	r3, [r7, #12]
  WRITE_REG(CRS->CFGR, value);
24016952:	4a0c      	ldr	r2, [pc, #48]	; (24016984 <HAL_RCCEx_CRSConfig+0xa8>)
24016954:	68fb      	ldr	r3, [r7, #12]
24016956:	6053      	str	r3, [r2, #4]

  /* Adjust HSI48 oscillator smooth trimming */
  /* Set the TRIM[5:0] bits according to RCC_CRS_HSI48CalibrationValue value */
  MODIFY_REG(CRS->CR, CRS_CR_TRIM, (pInit->HSI48CalibrationValue << CRS_CR_TRIM_Pos));
24016958:	4b0a      	ldr	r3, [pc, #40]	; (24016984 <HAL_RCCEx_CRSConfig+0xa8>)
2401695a:	681b      	ldr	r3, [r3, #0]
2401695c:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
24016960:	687b      	ldr	r3, [r7, #4]
24016962:	695b      	ldr	r3, [r3, #20]
24016964:	021b      	lsls	r3, r3, #8
24016966:	4907      	ldr	r1, [pc, #28]	; (24016984 <HAL_RCCEx_CRSConfig+0xa8>)
24016968:	4313      	orrs	r3, r2
2401696a:	600b      	str	r3, [r1, #0]

  /* START AUTOMATIC SYNCHRONIZATION*/

  /* Enable Automatic trimming & Frequency error counter */
  SET_BIT(CRS->CR, CRS_CR_AUTOTRIMEN | CRS_CR_CEN);
2401696c:	4b05      	ldr	r3, [pc, #20]	; (24016984 <HAL_RCCEx_CRSConfig+0xa8>)
2401696e:	681b      	ldr	r3, [r3, #0]
24016970:	4a04      	ldr	r2, [pc, #16]	; (24016984 <HAL_RCCEx_CRSConfig+0xa8>)
24016972:	f043 0360 	orr.w	r3, r3, #96	; 0x60
24016976:	6013      	str	r3, [r2, #0]
}
24016978:	bf00      	nop
2401697a:	3710      	adds	r7, #16
2401697c:	46bd      	mov	sp, r7
2401697e:	bd80      	pop	{r7, pc}
24016980:	58024400 	.word	0x58024400
24016984:	40008400 	.word	0x40008400

24016988 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate>:
/**
  * @brief  Generate the software synchronization event
  * @retval None
  */
void HAL_RCCEx_CRSSoftwareSynchronizationGenerate(void)
{
24016988:	b480      	push	{r7}
2401698a:	af00      	add	r7, sp, #0
  SET_BIT(CRS->CR, CRS_CR_SWSYNC);
2401698c:	4b05      	ldr	r3, [pc, #20]	; (240169a4 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
2401698e:	681b      	ldr	r3, [r3, #0]
24016990:	4a04      	ldr	r2, [pc, #16]	; (240169a4 <HAL_RCCEx_CRSSoftwareSynchronizationGenerate+0x1c>)
24016992:	f043 0380 	orr.w	r3, r3, #128	; 0x80
24016996:	6013      	str	r3, [r2, #0]
}
24016998:	bf00      	nop
2401699a:	46bd      	mov	sp, r7
2401699c:	f85d 7b04 	ldr.w	r7, [sp], #4
240169a0:	4770      	bx	lr
240169a2:	bf00      	nop
240169a4:	40008400 	.word	0x40008400

240169a8 <HAL_RCCEx_CRSGetSynchronizationInfo>:
  * @brief  Return synchronization info
  * @param  pSynchroInfo Pointer on RCC_CRSSynchroInfoTypeDef structure
  * @retval None
  */
void HAL_RCCEx_CRSGetSynchronizationInfo(RCC_CRSSynchroInfoTypeDef *pSynchroInfo)
{
240169a8:	b480      	push	{r7}
240169aa:	b083      	sub	sp, #12
240169ac:	af00      	add	r7, sp, #0
240169ae:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(pSynchroInfo != (void *)NULL);

  /* Get the reload value */
  pSynchroInfo->ReloadValue = (uint32_t)(READ_BIT(CRS->CFGR, CRS_CFGR_RELOAD));
240169b0:	4b0e      	ldr	r3, [pc, #56]	; (240169ec <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
240169b2:	685b      	ldr	r3, [r3, #4]
240169b4:	b29a      	uxth	r2, r3
240169b6:	687b      	ldr	r3, [r7, #4]
240169b8:	601a      	str	r2, [r3, #0]

  /* Get HSI48 oscillator smooth trimming */
  pSynchroInfo->HSI48CalibrationValue = (uint32_t)(READ_BIT(CRS->CR, CRS_CR_TRIM) >> CRS_CR_TRIM_Pos);
240169ba:	4b0c      	ldr	r3, [pc, #48]	; (240169ec <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
240169bc:	681b      	ldr	r3, [r3, #0]
240169be:	0a1b      	lsrs	r3, r3, #8
240169c0:	f003 023f 	and.w	r2, r3, #63	; 0x3f
240169c4:	687b      	ldr	r3, [r7, #4]
240169c6:	605a      	str	r2, [r3, #4]

  /* Get Frequency error capture */
  pSynchroInfo->FreqErrorCapture = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FECAP) >> CRS_ISR_FECAP_Pos);
240169c8:	4b08      	ldr	r3, [pc, #32]	; (240169ec <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
240169ca:	689b      	ldr	r3, [r3, #8]
240169cc:	0c1b      	lsrs	r3, r3, #16
240169ce:	b29a      	uxth	r2, r3
240169d0:	687b      	ldr	r3, [r7, #4]
240169d2:	609a      	str	r2, [r3, #8]

  /* Get Frequency error direction */
  pSynchroInfo->FreqErrorDirection = (uint32_t)(READ_BIT(CRS->ISR, CRS_ISR_FEDIR));
240169d4:	4b05      	ldr	r3, [pc, #20]	; (240169ec <HAL_RCCEx_CRSGetSynchronizationInfo+0x44>)
240169d6:	689b      	ldr	r3, [r3, #8]
240169d8:	f403 4200 	and.w	r2, r3, #32768	; 0x8000
240169dc:	687b      	ldr	r3, [r7, #4]
240169de:	60da      	str	r2, [r3, #12]
}
240169e0:	bf00      	nop
240169e2:	370c      	adds	r7, #12
240169e4:	46bd      	mov	sp, r7
240169e6:	f85d 7b04 	ldr.w	r7, [sp], #4
240169ea:	4770      	bx	lr
240169ec:	40008400 	.word	0x40008400

240169f0 <HAL_RCCEx_CRSWaitSynchronization>:
*            @arg @ref RCC_CRS_SYNCERR
*            @arg @ref RCC_CRS_SYNCMISS
*            @arg @ref RCC_CRS_TRIMOVF
*/
uint32_t HAL_RCCEx_CRSWaitSynchronization(uint32_t Timeout)
{
240169f0:	b580      	push	{r7, lr}
240169f2:	b084      	sub	sp, #16
240169f4:	af00      	add	r7, sp, #0
240169f6:	6078      	str	r0, [r7, #4]
  uint32_t crsstatus = RCC_CRS_NONE;
240169f8:	2300      	movs	r3, #0
240169fa:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Get time-out */
  tickstart = HAL_GetTick();
240169fc:	f7eb fca2 	bl	24002344 <HAL_GetTick>
24016a00:	60b8      	str	r0, [r7, #8]

  /* Wait for CRS flag or time-out detection */
  do
  {
    if(Timeout != HAL_MAX_DELAY)
24016a02:	687b      	ldr	r3, [r7, #4]
24016a04:	f1b3 3fff 	cmp.w	r3, #4294967295
24016a08:	d00c      	beq.n	24016a24 <HAL_RCCEx_CRSWaitSynchronization+0x34>
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
24016a0a:	f7eb fc9b 	bl	24002344 <HAL_GetTick>
24016a0e:	4602      	mov	r2, r0
24016a10:	68bb      	ldr	r3, [r7, #8]
24016a12:	1ad3      	subs	r3, r2, r3
24016a14:	687a      	ldr	r2, [r7, #4]
24016a16:	429a      	cmp	r2, r3
24016a18:	d302      	bcc.n	24016a20 <HAL_RCCEx_CRSWaitSynchronization+0x30>
24016a1a:	687b      	ldr	r3, [r7, #4]
24016a1c:	2b00      	cmp	r3, #0
24016a1e:	d101      	bne.n	24016a24 <HAL_RCCEx_CRSWaitSynchronization+0x34>
      {
        crsstatus = RCC_CRS_TIMEOUT;
24016a20:	2301      	movs	r3, #1
24016a22:	60fb      	str	r3, [r7, #12]
      }
    }
    /* Check CRS SYNCOK flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCOK))
24016a24:	4b2a      	ldr	r3, [pc, #168]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a26:	689b      	ldr	r3, [r3, #8]
24016a28:	f003 0301 	and.w	r3, r3, #1
24016a2c:	2b01      	cmp	r3, #1
24016a2e:	d106      	bne.n	24016a3e <HAL_RCCEx_CRSWaitSynchronization+0x4e>
    {
      /* CRS SYNC event OK */
      crsstatus |= RCC_CRS_SYNCOK;
24016a30:	68fb      	ldr	r3, [r7, #12]
24016a32:	f043 0302 	orr.w	r3, r3, #2
24016a36:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC event OK bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCOK);
24016a38:	4b25      	ldr	r3, [pc, #148]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a3a:	2201      	movs	r2, #1
24016a3c:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNCWARN flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCWARN))
24016a3e:	4b24      	ldr	r3, [pc, #144]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a40:	689b      	ldr	r3, [r3, #8]
24016a42:	f003 0302 	and.w	r3, r3, #2
24016a46:	2b02      	cmp	r3, #2
24016a48:	d106      	bne.n	24016a58 <HAL_RCCEx_CRSWaitSynchronization+0x68>
    {
      /* CRS SYNC warning */
      crsstatus |= RCC_CRS_SYNCWARN;
24016a4a:	68fb      	ldr	r3, [r7, #12]
24016a4c:	f043 0304 	orr.w	r3, r3, #4
24016a50:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNCWARN bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCWARN);
24016a52:	4b1f      	ldr	r3, [pc, #124]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a54:	2202      	movs	r2, #2
24016a56:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS TRIM overflow flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_TRIMOVF))
24016a58:	4b1d      	ldr	r3, [pc, #116]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a5a:	689b      	ldr	r3, [r3, #8]
24016a5c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
24016a60:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
24016a64:	d106      	bne.n	24016a74 <HAL_RCCEx_CRSWaitSynchronization+0x84>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_TRIMOVF;
24016a66:	68fb      	ldr	r3, [r7, #12]
24016a68:	f043 0320 	orr.w	r3, r3, #32
24016a6c:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_TRIMOVF);
24016a6e:	4b18      	ldr	r3, [pc, #96]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a70:	2204      	movs	r2, #4
24016a72:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Error flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCERR))
24016a74:	4b16      	ldr	r3, [pc, #88]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a76:	689b      	ldr	r3, [r3, #8]
24016a78:	f403 7380 	and.w	r3, r3, #256	; 0x100
24016a7c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
24016a80:	d106      	bne.n	24016a90 <HAL_RCCEx_CRSWaitSynchronization+0xa0>
    {
      /* CRS SYNC Error */
      crsstatus |= RCC_CRS_SYNCERR;
24016a82:	68fb      	ldr	r3, [r7, #12]
24016a84:	f043 0308 	orr.w	r3, r3, #8
24016a88:	60fb      	str	r3, [r7, #12]

      /* Clear CRS Error bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCERR);
24016a8a:	4b11      	ldr	r3, [pc, #68]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a8c:	2204      	movs	r2, #4
24016a8e:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS SYNC Missed flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_SYNCMISS))
24016a90:	4b0f      	ldr	r3, [pc, #60]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016a92:	689b      	ldr	r3, [r3, #8]
24016a94:	f403 7300 	and.w	r3, r3, #512	; 0x200
24016a98:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24016a9c:	d106      	bne.n	24016aac <HAL_RCCEx_CRSWaitSynchronization+0xbc>
    {
      /* CRS SYNC Missed */
      crsstatus |= RCC_CRS_SYNCMISS;
24016a9e:	68fb      	ldr	r3, [r7, #12]
24016aa0:	f043 0310 	orr.w	r3, r3, #16
24016aa4:	60fb      	str	r3, [r7, #12]

      /* Clear CRS SYNC Missed bit */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_SYNCMISS);
24016aa6:	4b0a      	ldr	r3, [pc, #40]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016aa8:	2204      	movs	r2, #4
24016aaa:	60da      	str	r2, [r3, #12]
    }

    /* Check CRS Expected SYNC flag  */
    if(__HAL_RCC_CRS_GET_FLAG(RCC_CRS_FLAG_ESYNC))
24016aac:	4b08      	ldr	r3, [pc, #32]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016aae:	689b      	ldr	r3, [r3, #8]
24016ab0:	f003 0308 	and.w	r3, r3, #8
24016ab4:	2b08      	cmp	r3, #8
24016ab6:	d102      	bne.n	24016abe <HAL_RCCEx_CRSWaitSynchronization+0xce>
    {
      /* frequency error counter reached a zero value */
      __HAL_RCC_CRS_CLEAR_FLAG(RCC_CRS_FLAG_ESYNC);
24016ab8:	4b05      	ldr	r3, [pc, #20]	; (24016ad0 <HAL_RCCEx_CRSWaitSynchronization+0xe0>)
24016aba:	2208      	movs	r2, #8
24016abc:	60da      	str	r2, [r3, #12]
    }
  } while(RCC_CRS_NONE == crsstatus);
24016abe:	68fb      	ldr	r3, [r7, #12]
24016ac0:	2b00      	cmp	r3, #0
24016ac2:	d09e      	beq.n	24016a02 <HAL_RCCEx_CRSWaitSynchronization+0x12>

  return crsstatus;
24016ac4:	68fb      	ldr	r3, [r7, #12]
}
24016ac6:	4618      	mov	r0, r3
24016ac8:	3710      	adds	r7, #16
24016aca:	46bd      	mov	sp, r7
24016acc:	bd80      	pop	{r7, pc}
24016ace:	bf00      	nop
24016ad0:	40008400 	.word	0x40008400

24016ad4 <HAL_RCCEx_CRS_IRQHandler>:
/**
  * @brief Handle the Clock Recovery System interrupt request.
  * @retval None
  */
void HAL_RCCEx_CRS_IRQHandler(void)
{
24016ad4:	b580      	push	{r7, lr}
24016ad6:	b084      	sub	sp, #16
24016ad8:	af00      	add	r7, sp, #0
  uint32_t crserror = RCC_CRS_NONE;
24016ada:	2300      	movs	r3, #0
24016adc:	60fb      	str	r3, [r7, #12]
  /* Get current IT flags and IT sources values */
  uint32_t itflags = READ_REG(CRS->ISR);
24016ade:	4b33      	ldr	r3, [pc, #204]	; (24016bac <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24016ae0:	689b      	ldr	r3, [r3, #8]
24016ae2:	60bb      	str	r3, [r7, #8]
  uint32_t itsources = READ_REG(CRS->CR);
24016ae4:	4b31      	ldr	r3, [pc, #196]	; (24016bac <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24016ae6:	681b      	ldr	r3, [r3, #0]
24016ae8:	607b      	str	r3, [r7, #4]

  /* Check CRS SYNCOK flag  */
  if(((itflags & RCC_CRS_FLAG_SYNCOK) != 0U) && ((itsources & RCC_CRS_IT_SYNCOK) != 0U))
24016aea:	68bb      	ldr	r3, [r7, #8]
24016aec:	f003 0301 	and.w	r3, r3, #1
24016af0:	2b00      	cmp	r3, #0
24016af2:	d00a      	beq.n	24016b0a <HAL_RCCEx_CRS_IRQHandler+0x36>
24016af4:	687b      	ldr	r3, [r7, #4]
24016af6:	f003 0301 	and.w	r3, r3, #1
24016afa:	2b00      	cmp	r3, #0
24016afc:	d005      	beq.n	24016b0a <HAL_RCCEx_CRS_IRQHandler+0x36>
  {
    /* Clear CRS SYNC event OK flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCOKC);
24016afe:	4b2b      	ldr	r3, [pc, #172]	; (24016bac <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24016b00:	2201      	movs	r2, #1
24016b02:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncOkCallback();
24016b04:	f000 f854 	bl	24016bb0 <HAL_RCCEx_CRS_SyncOkCallback>
24016b08:	e04b      	b.n	24016ba2 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS SYNCWARN flag  */
  else if(((itflags & RCC_CRS_FLAG_SYNCWARN) != 0U) && ((itsources & RCC_CRS_IT_SYNCWARN) != 0U))
24016b0a:	68bb      	ldr	r3, [r7, #8]
24016b0c:	f003 0302 	and.w	r3, r3, #2
24016b10:	2b00      	cmp	r3, #0
24016b12:	d00a      	beq.n	24016b2a <HAL_RCCEx_CRS_IRQHandler+0x56>
24016b14:	687b      	ldr	r3, [r7, #4]
24016b16:	f003 0302 	and.w	r3, r3, #2
24016b1a:	2b00      	cmp	r3, #0
24016b1c:	d005      	beq.n	24016b2a <HAL_RCCEx_CRS_IRQHandler+0x56>
  {
    /* Clear CRS SYNCWARN flag */
    WRITE_REG(CRS->ICR, CRS_ICR_SYNCWARNC);
24016b1e:	4b23      	ldr	r3, [pc, #140]	; (24016bac <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24016b20:	2202      	movs	r2, #2
24016b22:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_SyncWarnCallback();
24016b24:	f000 f84b 	bl	24016bbe <HAL_RCCEx_CRS_SyncWarnCallback>
24016b28:	e03b      	b.n	24016ba2 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Expected SYNC flag  */
  else if(((itflags & RCC_CRS_FLAG_ESYNC) != 0U) && ((itsources & RCC_CRS_IT_ESYNC) != 0U))
24016b2a:	68bb      	ldr	r3, [r7, #8]
24016b2c:	f003 0308 	and.w	r3, r3, #8
24016b30:	2b00      	cmp	r3, #0
24016b32:	d00a      	beq.n	24016b4a <HAL_RCCEx_CRS_IRQHandler+0x76>
24016b34:	687b      	ldr	r3, [r7, #4]
24016b36:	f003 0308 	and.w	r3, r3, #8
24016b3a:	2b00      	cmp	r3, #0
24016b3c:	d005      	beq.n	24016b4a <HAL_RCCEx_CRS_IRQHandler+0x76>
  {
    /* frequency error counter reached a zero value */
    WRITE_REG(CRS->ICR, CRS_ICR_ESYNCC);
24016b3e:	4b1b      	ldr	r3, [pc, #108]	; (24016bac <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24016b40:	2208      	movs	r2, #8
24016b42:	60da      	str	r2, [r3, #12]

    /* user callback */
    HAL_RCCEx_CRS_ExpectedSyncCallback();
24016b44:	f000 f842 	bl	24016bcc <HAL_RCCEx_CRS_ExpectedSyncCallback>
24016b48:	e02b      	b.n	24016ba2 <HAL_RCCEx_CRS_IRQHandler+0xce>
  }
  /* Check CRS Error flags  */
  else
  {
    if(((itflags & RCC_CRS_FLAG_ERR) != 0U) && ((itsources & RCC_CRS_IT_ERR) != 0U))
24016b4a:	68bb      	ldr	r3, [r7, #8]
24016b4c:	f003 0304 	and.w	r3, r3, #4
24016b50:	2b00      	cmp	r3, #0
24016b52:	d026      	beq.n	24016ba2 <HAL_RCCEx_CRS_IRQHandler+0xce>
24016b54:	687b      	ldr	r3, [r7, #4]
24016b56:	f003 0304 	and.w	r3, r3, #4
24016b5a:	2b00      	cmp	r3, #0
24016b5c:	d021      	beq.n	24016ba2 <HAL_RCCEx_CRS_IRQHandler+0xce>
    {
      if((itflags & RCC_CRS_FLAG_SYNCERR) != 0U)
24016b5e:	68bb      	ldr	r3, [r7, #8]
24016b60:	f403 7380 	and.w	r3, r3, #256	; 0x100
24016b64:	2b00      	cmp	r3, #0
24016b66:	d003      	beq.n	24016b70 <HAL_RCCEx_CRS_IRQHandler+0x9c>
      {
        crserror |= RCC_CRS_SYNCERR;
24016b68:	68fb      	ldr	r3, [r7, #12]
24016b6a:	f043 0308 	orr.w	r3, r3, #8
24016b6e:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_SYNCMISS) != 0U)
24016b70:	68bb      	ldr	r3, [r7, #8]
24016b72:	f403 7300 	and.w	r3, r3, #512	; 0x200
24016b76:	2b00      	cmp	r3, #0
24016b78:	d003      	beq.n	24016b82 <HAL_RCCEx_CRS_IRQHandler+0xae>
      {
        crserror |= RCC_CRS_SYNCMISS;
24016b7a:	68fb      	ldr	r3, [r7, #12]
24016b7c:	f043 0310 	orr.w	r3, r3, #16
24016b80:	60fb      	str	r3, [r7, #12]
      }
      if((itflags & RCC_CRS_FLAG_TRIMOVF) != 0U)
24016b82:	68bb      	ldr	r3, [r7, #8]
24016b84:	f403 6380 	and.w	r3, r3, #1024	; 0x400
24016b88:	2b00      	cmp	r3, #0
24016b8a:	d003      	beq.n	24016b94 <HAL_RCCEx_CRS_IRQHandler+0xc0>
      {
        crserror |= RCC_CRS_TRIMOVF;
24016b8c:	68fb      	ldr	r3, [r7, #12]
24016b8e:	f043 0320 	orr.w	r3, r3, #32
24016b92:	60fb      	str	r3, [r7, #12]
      }

      /* Clear CRS Error flags */
      WRITE_REG(CRS->ICR, CRS_ICR_ERRC);
24016b94:	4b05      	ldr	r3, [pc, #20]	; (24016bac <HAL_RCCEx_CRS_IRQHandler+0xd8>)
24016b96:	2204      	movs	r2, #4
24016b98:	60da      	str	r2, [r3, #12]

      /* user error callback */
      HAL_RCCEx_CRS_ErrorCallback(crserror);
24016b9a:	68f8      	ldr	r0, [r7, #12]
24016b9c:	f000 f81d 	bl	24016bda <HAL_RCCEx_CRS_ErrorCallback>
    }
  }
}
24016ba0:	e7ff      	b.n	24016ba2 <HAL_RCCEx_CRS_IRQHandler+0xce>
24016ba2:	bf00      	nop
24016ba4:	3710      	adds	r7, #16
24016ba6:	46bd      	mov	sp, r7
24016ba8:	bd80      	pop	{r7, pc}
24016baa:	bf00      	nop
24016bac:	40008400 	.word	0x40008400

24016bb0 <HAL_RCCEx_CRS_SyncOkCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCOK interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncOkCallback(void)
{
24016bb0:	b480      	push	{r7}
24016bb2:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncOkCallback should be implemented in the user file
   */
}
24016bb4:	bf00      	nop
24016bb6:	46bd      	mov	sp, r7
24016bb8:	f85d 7b04 	ldr.w	r7, [sp], #4
24016bbc:	4770      	bx	lr

24016bbe <HAL_RCCEx_CRS_SyncWarnCallback>:
/**
  * @brief  RCCEx Clock Recovery System SYNCWARN interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_SyncWarnCallback(void)
{
24016bbe:	b480      	push	{r7}
24016bc0:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_SyncWarnCallback should be implemented in the user file
   */
}
24016bc2:	bf00      	nop
24016bc4:	46bd      	mov	sp, r7
24016bc6:	f85d 7b04 	ldr.w	r7, [sp], #4
24016bca:	4770      	bx	lr

24016bcc <HAL_RCCEx_CRS_ExpectedSyncCallback>:
/**
  * @brief  RCCEx Clock Recovery System Expected SYNC interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ExpectedSyncCallback(void)
{
24016bcc:	b480      	push	{r7}
24016bce:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ExpectedSyncCallback should be implemented in the user file
   */
}
24016bd0:	bf00      	nop
24016bd2:	46bd      	mov	sp, r7
24016bd4:	f85d 7b04 	ldr.w	r7, [sp], #4
24016bd8:	4770      	bx	lr

24016bda <HAL_RCCEx_CRS_ErrorCallback>:
  *           @arg @ref RCC_CRS_SYNCMISS
  *           @arg @ref RCC_CRS_TRIMOVF
  * @retval none
  */
__weak void HAL_RCCEx_CRS_ErrorCallback(uint32_t Error)
{
24016bda:	b480      	push	{r7}
24016bdc:	b083      	sub	sp, #12
24016bde:	af00      	add	r7, sp, #0
24016be0:	6078      	str	r0, [r7, #4]
  UNUSED(Error);

  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_CRS_ErrorCallback should be implemented in the user file
   */
}
24016be2:	bf00      	nop
24016be4:	370c      	adds	r7, #12
24016be6:	46bd      	mov	sp, r7
24016be8:	f85d 7b04 	ldr.w	r7, [sp], #4
24016bec:	4770      	bx	lr
	...

24016bf0 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
24016bf0:	b580      	push	{r7, lr}
24016bf2:	b084      	sub	sp, #16
24016bf4:	af00      	add	r7, sp, #0
24016bf6:	6078      	str	r0, [r7, #4]
24016bf8:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
24016bfa:	2300      	movs	r3, #0
24016bfc:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
24016bfe:	4b53      	ldr	r3, [pc, #332]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016c02:	f003 0303 	and.w	r3, r3, #3
24016c06:	2b03      	cmp	r3, #3
24016c08:	d101      	bne.n	24016c0e <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
24016c0a:	2301      	movs	r3, #1
24016c0c:	e099      	b.n	24016d42 <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
24016c0e:	4b4f      	ldr	r3, [pc, #316]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c10:	681b      	ldr	r3, [r3, #0]
24016c12:	4a4e      	ldr	r2, [pc, #312]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c14:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
24016c18:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24016c1a:	f7eb fb93 	bl	24002344 <HAL_GetTick>
24016c1e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
24016c20:	e008      	b.n	24016c34 <RCCEx_PLL2_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
24016c22:	f7eb fb8f 	bl	24002344 <HAL_GetTick>
24016c26:	4602      	mov	r2, r0
24016c28:	68bb      	ldr	r3, [r7, #8]
24016c2a:	1ad3      	subs	r3, r2, r3
24016c2c:	2b02      	cmp	r3, #2
24016c2e:	d901      	bls.n	24016c34 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
24016c30:	2303      	movs	r3, #3
24016c32:	e086      	b.n	24016d42 <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
24016c34:	4b45      	ldr	r3, [pc, #276]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c36:	681b      	ldr	r3, [r3, #0]
24016c38:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24016c3c:	2b00      	cmp	r3, #0
24016c3e:	d1f0      	bne.n	24016c22 <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
24016c40:	4b42      	ldr	r3, [pc, #264]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c42:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016c44:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
24016c48:	687b      	ldr	r3, [r7, #4]
24016c4a:	681b      	ldr	r3, [r3, #0]
24016c4c:	031b      	lsls	r3, r3, #12
24016c4e:	493f      	ldr	r1, [pc, #252]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c50:	4313      	orrs	r3, r2
24016c52:	628b      	str	r3, [r1, #40]	; 0x28
24016c54:	687b      	ldr	r3, [r7, #4]
24016c56:	685b      	ldr	r3, [r3, #4]
24016c58:	3b01      	subs	r3, #1
24016c5a:	f3c3 0208 	ubfx	r2, r3, #0, #9
24016c5e:	687b      	ldr	r3, [r7, #4]
24016c60:	689b      	ldr	r3, [r3, #8]
24016c62:	3b01      	subs	r3, #1
24016c64:	025b      	lsls	r3, r3, #9
24016c66:	b29b      	uxth	r3, r3
24016c68:	431a      	orrs	r2, r3
24016c6a:	687b      	ldr	r3, [r7, #4]
24016c6c:	68db      	ldr	r3, [r3, #12]
24016c6e:	3b01      	subs	r3, #1
24016c70:	041b      	lsls	r3, r3, #16
24016c72:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
24016c76:	431a      	orrs	r2, r3
24016c78:	687b      	ldr	r3, [r7, #4]
24016c7a:	691b      	ldr	r3, [r3, #16]
24016c7c:	3b01      	subs	r3, #1
24016c7e:	061b      	lsls	r3, r3, #24
24016c80:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
24016c84:	4931      	ldr	r1, [pc, #196]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c86:	4313      	orrs	r3, r2
24016c88:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
24016c8a:	4b30      	ldr	r3, [pc, #192]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016c8e:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
24016c92:	687b      	ldr	r3, [r7, #4]
24016c94:	695b      	ldr	r3, [r3, #20]
24016c96:	492d      	ldr	r1, [pc, #180]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c98:	4313      	orrs	r3, r2
24016c9a:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
24016c9c:	4b2b      	ldr	r3, [pc, #172]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016c9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016ca0:	f023 0220 	bic.w	r2, r3, #32
24016ca4:	687b      	ldr	r3, [r7, #4]
24016ca6:	699b      	ldr	r3, [r3, #24]
24016ca8:	4928      	ldr	r1, [pc, #160]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016caa:	4313      	orrs	r3, r2
24016cac:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
24016cae:	4b27      	ldr	r3, [pc, #156]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016cb2:	4a26      	ldr	r2, [pc, #152]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cb4:	f023 0310 	bic.w	r3, r3, #16
24016cb8:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
24016cba:	4b24      	ldr	r3, [pc, #144]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cbc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
24016cbe:	4b24      	ldr	r3, [pc, #144]	; (24016d50 <RCCEx_PLL2_Config+0x160>)
24016cc0:	4013      	ands	r3, r2
24016cc2:	687a      	ldr	r2, [r7, #4]
24016cc4:	69d2      	ldr	r2, [r2, #28]
24016cc6:	00d2      	lsls	r2, r2, #3
24016cc8:	4920      	ldr	r1, [pc, #128]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cca:	4313      	orrs	r3, r2
24016ccc:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
24016cce:	4b1f      	ldr	r3, [pc, #124]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016cd2:	4a1e      	ldr	r2, [pc, #120]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cd4:	f043 0310 	orr.w	r3, r3, #16
24016cd8:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
24016cda:	683b      	ldr	r3, [r7, #0]
24016cdc:	2b00      	cmp	r3, #0
24016cde:	d106      	bne.n	24016cee <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
24016ce0:	4b1a      	ldr	r3, [pc, #104]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016ce2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016ce4:	4a19      	ldr	r2, [pc, #100]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016ce6:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
24016cea:	62d3      	str	r3, [r2, #44]	; 0x2c
24016cec:	e00f      	b.n	24016d0e <RCCEx_PLL2_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
24016cee:	683b      	ldr	r3, [r7, #0]
24016cf0:	2b01      	cmp	r3, #1
24016cf2:	d106      	bne.n	24016d02 <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
24016cf4:	4b15      	ldr	r3, [pc, #84]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cf6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016cf8:	4a14      	ldr	r2, [pc, #80]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016cfa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
24016cfe:	62d3      	str	r3, [r2, #44]	; 0x2c
24016d00:	e005      	b.n	24016d0e <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
24016d02:	4b12      	ldr	r3, [pc, #72]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016d04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016d06:	4a11      	ldr	r2, [pc, #68]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016d08:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
24016d0c:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
24016d0e:	4b0f      	ldr	r3, [pc, #60]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016d10:	681b      	ldr	r3, [r3, #0]
24016d12:	4a0e      	ldr	r2, [pc, #56]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016d14:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
24016d18:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24016d1a:	f7eb fb13 	bl	24002344 <HAL_GetTick>
24016d1e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
24016d20:	e008      	b.n	24016d34 <RCCEx_PLL2_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
24016d22:	f7eb fb0f 	bl	24002344 <HAL_GetTick>
24016d26:	4602      	mov	r2, r0
24016d28:	68bb      	ldr	r3, [r7, #8]
24016d2a:	1ad3      	subs	r3, r2, r3
24016d2c:	2b02      	cmp	r3, #2
24016d2e:	d901      	bls.n	24016d34 <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
24016d30:	2303      	movs	r3, #3
24016d32:	e006      	b.n	24016d42 <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
24016d34:	4b05      	ldr	r3, [pc, #20]	; (24016d4c <RCCEx_PLL2_Config+0x15c>)
24016d36:	681b      	ldr	r3, [r3, #0]
24016d38:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
24016d3c:	2b00      	cmp	r3, #0
24016d3e:	d0f0      	beq.n	24016d22 <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
24016d40:	7bfb      	ldrb	r3, [r7, #15]
}
24016d42:	4618      	mov	r0, r3
24016d44:	3710      	adds	r7, #16
24016d46:	46bd      	mov	sp, r7
24016d48:	bd80      	pop	{r7, pc}
24016d4a:	bf00      	nop
24016d4c:	58024400 	.word	0x58024400
24016d50:	ffff0007 	.word	0xffff0007

24016d54 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
24016d54:	b580      	push	{r7, lr}
24016d56:	b084      	sub	sp, #16
24016d58:	af00      	add	r7, sp, #0
24016d5a:	6078      	str	r0, [r7, #4]
24016d5c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
24016d5e:	2300      	movs	r3, #0
24016d60:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
24016d62:	4b53      	ldr	r3, [pc, #332]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016d64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016d66:	f003 0303 	and.w	r3, r3, #3
24016d6a:	2b03      	cmp	r3, #3
24016d6c:	d101      	bne.n	24016d72 <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
24016d6e:	2301      	movs	r3, #1
24016d70:	e099      	b.n	24016ea6 <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
24016d72:	4b4f      	ldr	r3, [pc, #316]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016d74:	681b      	ldr	r3, [r3, #0]
24016d76:	4a4e      	ldr	r2, [pc, #312]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016d78:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
24016d7c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24016d7e:	f7eb fae1 	bl	24002344 <HAL_GetTick>
24016d82:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
24016d84:	e008      	b.n	24016d98 <RCCEx_PLL3_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
24016d86:	f7eb fadd 	bl	24002344 <HAL_GetTick>
24016d8a:	4602      	mov	r2, r0
24016d8c:	68bb      	ldr	r3, [r7, #8]
24016d8e:	1ad3      	subs	r3, r2, r3
24016d90:	2b02      	cmp	r3, #2
24016d92:	d901      	bls.n	24016d98 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
24016d94:	2303      	movs	r3, #3
24016d96:	e086      	b.n	24016ea6 <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
24016d98:	4b45      	ldr	r3, [pc, #276]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016d9a:	681b      	ldr	r3, [r3, #0]
24016d9c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24016da0:	2b00      	cmp	r3, #0
24016da2:	d1f0      	bne.n	24016d86 <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
24016da4:	4b42      	ldr	r3, [pc, #264]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016da6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
24016da8:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
24016dac:	687b      	ldr	r3, [r7, #4]
24016dae:	681b      	ldr	r3, [r3, #0]
24016db0:	051b      	lsls	r3, r3, #20
24016db2:	493f      	ldr	r1, [pc, #252]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016db4:	4313      	orrs	r3, r2
24016db6:	628b      	str	r3, [r1, #40]	; 0x28
24016db8:	687b      	ldr	r3, [r7, #4]
24016dba:	685b      	ldr	r3, [r3, #4]
24016dbc:	3b01      	subs	r3, #1
24016dbe:	f3c3 0208 	ubfx	r2, r3, #0, #9
24016dc2:	687b      	ldr	r3, [r7, #4]
24016dc4:	689b      	ldr	r3, [r3, #8]
24016dc6:	3b01      	subs	r3, #1
24016dc8:	025b      	lsls	r3, r3, #9
24016dca:	b29b      	uxth	r3, r3
24016dcc:	431a      	orrs	r2, r3
24016dce:	687b      	ldr	r3, [r7, #4]
24016dd0:	68db      	ldr	r3, [r3, #12]
24016dd2:	3b01      	subs	r3, #1
24016dd4:	041b      	lsls	r3, r3, #16
24016dd6:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
24016dda:	431a      	orrs	r2, r3
24016ddc:	687b      	ldr	r3, [r7, #4]
24016dde:	691b      	ldr	r3, [r3, #16]
24016de0:	3b01      	subs	r3, #1
24016de2:	061b      	lsls	r3, r3, #24
24016de4:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
24016de8:	4931      	ldr	r1, [pc, #196]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016dea:	4313      	orrs	r3, r2
24016dec:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
24016dee:	4b30      	ldr	r3, [pc, #192]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016df0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016df2:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
24016df6:	687b      	ldr	r3, [r7, #4]
24016df8:	695b      	ldr	r3, [r3, #20]
24016dfa:	492d      	ldr	r1, [pc, #180]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016dfc:	4313      	orrs	r3, r2
24016dfe:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
24016e00:	4b2b      	ldr	r3, [pc, #172]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016e04:	f423 7200 	bic.w	r2, r3, #512	; 0x200
24016e08:	687b      	ldr	r3, [r7, #4]
24016e0a:	699b      	ldr	r3, [r3, #24]
24016e0c:	4928      	ldr	r1, [pc, #160]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e0e:	4313      	orrs	r3, r2
24016e10:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
24016e12:	4b27      	ldr	r3, [pc, #156]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016e16:	4a26      	ldr	r2, [pc, #152]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e18:	f423 7380 	bic.w	r3, r3, #256	; 0x100
24016e1c:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
24016e1e:	4b24      	ldr	r3, [pc, #144]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e20:	6c5a      	ldr	r2, [r3, #68]	; 0x44
24016e22:	4b24      	ldr	r3, [pc, #144]	; (24016eb4 <RCCEx_PLL3_Config+0x160>)
24016e24:	4013      	ands	r3, r2
24016e26:	687a      	ldr	r2, [r7, #4]
24016e28:	69d2      	ldr	r2, [r2, #28]
24016e2a:	00d2      	lsls	r2, r2, #3
24016e2c:	4920      	ldr	r1, [pc, #128]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e2e:	4313      	orrs	r3, r2
24016e30:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
24016e32:	4b1f      	ldr	r3, [pc, #124]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016e36:	4a1e      	ldr	r2, [pc, #120]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e38:	f443 7380 	orr.w	r3, r3, #256	; 0x100
24016e3c:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
24016e3e:	683b      	ldr	r3, [r7, #0]
24016e40:	2b00      	cmp	r3, #0
24016e42:	d106      	bne.n	24016e52 <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
24016e44:	4b1a      	ldr	r3, [pc, #104]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016e48:	4a19      	ldr	r2, [pc, #100]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e4a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
24016e4e:	62d3      	str	r3, [r2, #44]	; 0x2c
24016e50:	e00f      	b.n	24016e72 <RCCEx_PLL3_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
24016e52:	683b      	ldr	r3, [r7, #0]
24016e54:	2b01      	cmp	r3, #1
24016e56:	d106      	bne.n	24016e66 <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
24016e58:	4b15      	ldr	r3, [pc, #84]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016e5c:	4a14      	ldr	r2, [pc, #80]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e5e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
24016e62:	62d3      	str	r3, [r2, #44]	; 0x2c
24016e64:	e005      	b.n	24016e72 <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
24016e66:	4b12      	ldr	r3, [pc, #72]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
24016e6a:	4a11      	ldr	r2, [pc, #68]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e6c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
24016e70:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
24016e72:	4b0f      	ldr	r3, [pc, #60]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e74:	681b      	ldr	r3, [r3, #0]
24016e76:	4a0e      	ldr	r2, [pc, #56]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e78:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
24016e7c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
24016e7e:	f7eb fa61 	bl	24002344 <HAL_GetTick>
24016e82:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
24016e84:	e008      	b.n	24016e98 <RCCEx_PLL3_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
24016e86:	f7eb fa5d 	bl	24002344 <HAL_GetTick>
24016e8a:	4602      	mov	r2, r0
24016e8c:	68bb      	ldr	r3, [r7, #8]
24016e8e:	1ad3      	subs	r3, r2, r3
24016e90:	2b02      	cmp	r3, #2
24016e92:	d901      	bls.n	24016e98 <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
24016e94:	2303      	movs	r3, #3
24016e96:	e006      	b.n	24016ea6 <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
24016e98:	4b05      	ldr	r3, [pc, #20]	; (24016eb0 <RCCEx_PLL3_Config+0x15c>)
24016e9a:	681b      	ldr	r3, [r3, #0]
24016e9c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
24016ea0:	2b00      	cmp	r3, #0
24016ea2:	d0f0      	beq.n	24016e86 <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
24016ea4:	7bfb      	ldrb	r3, [r7, #15]
}
24016ea6:	4618      	mov	r0, r3
24016ea8:	3710      	adds	r7, #16
24016eaa:	46bd      	mov	sp, r7
24016eac:	bd80      	pop	{r7, pc}
24016eae:	bf00      	nop
24016eb0:	58024400 	.word	0x58024400
24016eb4:	ffff0007 	.word	0xffff0007

24016eb8 <HAL_RCCEx_LSECSS_IRQHandler>:
/**
  * @brief Handle the RCC LSE Clock Security System interrupt request.
  * @retval None
  */
void HAL_RCCEx_LSECSS_IRQHandler(void)
{
24016eb8:	b580      	push	{r7, lr}
24016eba:	af00      	add	r7, sp, #0
  /* Check RCC LSE CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_LSECSS))
24016ebc:	4b07      	ldr	r3, [pc, #28]	; (24016edc <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24016ebe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
24016ec0:	f403 7300 	and.w	r3, r3, #512	; 0x200
24016ec4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
24016ec8:	d105      	bne.n	24016ed6 <HAL_RCCEx_LSECSS_IRQHandler+0x1e>
  {

    /* Clear RCC LSE CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_LSECSS);
24016eca:	4b04      	ldr	r3, [pc, #16]	; (24016edc <HAL_RCCEx_LSECSS_IRQHandler+0x24>)
24016ecc:	f44f 7200 	mov.w	r2, #512	; 0x200
24016ed0:	669a      	str	r2, [r3, #104]	; 0x68

    /* RCC LSE Clock Security System interrupt user callback */
    HAL_RCCEx_LSECSS_Callback();
24016ed2:	f000 f805 	bl	24016ee0 <HAL_RCCEx_LSECSS_Callback>

  }
}
24016ed6:	bf00      	nop
24016ed8:	bd80      	pop	{r7, pc}
24016eda:	bf00      	nop
24016edc:	58024400 	.word	0x58024400

24016ee0 <HAL_RCCEx_LSECSS_Callback>:
/**
  * @brief  RCCEx LSE Clock Security System interrupt callback.
  * @retval none
  */
__weak void HAL_RCCEx_LSECSS_Callback(void)
{
24016ee0:	b480      	push	{r7}
24016ee2:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the @ref HAL_RCCEx_LSECSS_Callback should be implemented in the user file
  */
}
24016ee4:	bf00      	nop
24016ee6:	46bd      	mov	sp, r7
24016ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
24016eec:	4770      	bx	lr
	...

24016ef0 <exit>:
24016ef0:	b508      	push	{r3, lr}
24016ef2:	4b06      	ldr	r3, [pc, #24]	; (24016f0c <exit+0x1c>)
24016ef4:	4604      	mov	r4, r0
24016ef6:	b113      	cbz	r3, 24016efe <exit+0xe>
24016ef8:	2100      	movs	r1, #0
24016efa:	f3af 8000 	nop.w
24016efe:	4b04      	ldr	r3, [pc, #16]	; (24016f10 <exit+0x20>)
24016f00:	681b      	ldr	r3, [r3, #0]
24016f02:	b103      	cbz	r3, 24016f06 <exit+0x16>
24016f04:	4798      	blx	r3
24016f06:	4620      	mov	r0, r4
24016f08:	f7ea fddd 	bl	24001ac6 <_exit>
24016f0c:	00000000 	.word	0x00000000
24016f10:	240006e4 	.word	0x240006e4

24016f14 <std>:
24016f14:	2300      	movs	r3, #0
24016f16:	b510      	push	{r4, lr}
24016f18:	4604      	mov	r4, r0
24016f1a:	e9c0 3300 	strd	r3, r3, [r0]
24016f1e:	e9c0 3304 	strd	r3, r3, [r0, #16]
24016f22:	6083      	str	r3, [r0, #8]
24016f24:	8181      	strh	r1, [r0, #12]
24016f26:	6643      	str	r3, [r0, #100]	; 0x64
24016f28:	81c2      	strh	r2, [r0, #14]
24016f2a:	6183      	str	r3, [r0, #24]
24016f2c:	4619      	mov	r1, r3
24016f2e:	2208      	movs	r2, #8
24016f30:	305c      	adds	r0, #92	; 0x5c
24016f32:	f000 f97c 	bl	2401722e <memset>
24016f36:	4b05      	ldr	r3, [pc, #20]	; (24016f4c <std+0x38>)
24016f38:	6263      	str	r3, [r4, #36]	; 0x24
24016f3a:	4b05      	ldr	r3, [pc, #20]	; (24016f50 <std+0x3c>)
24016f3c:	62a3      	str	r3, [r4, #40]	; 0x28
24016f3e:	4b05      	ldr	r3, [pc, #20]	; (24016f54 <std+0x40>)
24016f40:	62e3      	str	r3, [r4, #44]	; 0x2c
24016f42:	4b05      	ldr	r3, [pc, #20]	; (24016f58 <std+0x44>)
24016f44:	6224      	str	r4, [r4, #32]
24016f46:	6323      	str	r3, [r4, #48]	; 0x30
24016f48:	bd10      	pop	{r4, pc}
24016f4a:	bf00      	nop
24016f4c:	24017185 	.word	0x24017185
24016f50:	240171ab 	.word	0x240171ab
24016f54:	240171e3 	.word	0x240171e3
24016f58:	24017207 	.word	0x24017207

24016f5c <stdio_exit_handler>:
24016f5c:	4a02      	ldr	r2, [pc, #8]	; (24016f68 <stdio_exit_handler+0xc>)
24016f5e:	4903      	ldr	r1, [pc, #12]	; (24016f6c <stdio_exit_handler+0x10>)
24016f60:	4803      	ldr	r0, [pc, #12]	; (24016f70 <stdio_exit_handler+0x14>)
24016f62:	f000 b8f1 	b.w	24017148 <_fwalk_sglue>
24016f66:	bf00      	nop
24016f68:	240004c0 	.word	0x240004c0
24016f6c:	240176e1 	.word	0x240176e1
24016f70:	240004cc 	.word	0x240004cc

24016f74 <cleanup_stdio>:
24016f74:	6841      	ldr	r1, [r0, #4]
24016f76:	4b0c      	ldr	r3, [pc, #48]	; (24016fa8 <cleanup_stdio+0x34>)
24016f78:	4299      	cmp	r1, r3
24016f7a:	b510      	push	{r4, lr}
24016f7c:	4604      	mov	r4, r0
24016f7e:	d001      	beq.n	24016f84 <cleanup_stdio+0x10>
24016f80:	f000 fbae 	bl	240176e0 <_fflush_r>
24016f84:	68a1      	ldr	r1, [r4, #8]
24016f86:	4b09      	ldr	r3, [pc, #36]	; (24016fac <cleanup_stdio+0x38>)
24016f88:	4299      	cmp	r1, r3
24016f8a:	d002      	beq.n	24016f92 <cleanup_stdio+0x1e>
24016f8c:	4620      	mov	r0, r4
24016f8e:	f000 fba7 	bl	240176e0 <_fflush_r>
24016f92:	68e1      	ldr	r1, [r4, #12]
24016f94:	4b06      	ldr	r3, [pc, #24]	; (24016fb0 <cleanup_stdio+0x3c>)
24016f96:	4299      	cmp	r1, r3
24016f98:	d004      	beq.n	24016fa4 <cleanup_stdio+0x30>
24016f9a:	4620      	mov	r0, r4
24016f9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
24016fa0:	f000 bb9e 	b.w	240176e0 <_fflush_r>
24016fa4:	bd10      	pop	{r4, pc}
24016fa6:	bf00      	nop
24016fa8:	240005ac 	.word	0x240005ac
24016fac:	24000614 	.word	0x24000614
24016fb0:	2400067c 	.word	0x2400067c

24016fb4 <__fp_lock>:
24016fb4:	b508      	push	{r3, lr}
24016fb6:	6e4b      	ldr	r3, [r1, #100]	; 0x64
24016fb8:	07da      	lsls	r2, r3, #31
24016fba:	d405      	bmi.n	24016fc8 <__fp_lock+0x14>
24016fbc:	898b      	ldrh	r3, [r1, #12]
24016fbe:	059b      	lsls	r3, r3, #22
24016fc0:	d402      	bmi.n	24016fc8 <__fp_lock+0x14>
24016fc2:	6d88      	ldr	r0, [r1, #88]	; 0x58
24016fc4:	f000 fa07 	bl	240173d6 <__retarget_lock_acquire_recursive>
24016fc8:	2000      	movs	r0, #0
24016fca:	bd08      	pop	{r3, pc}

24016fcc <__fp_unlock>:
24016fcc:	b508      	push	{r3, lr}
24016fce:	6e4b      	ldr	r3, [r1, #100]	; 0x64
24016fd0:	07da      	lsls	r2, r3, #31
24016fd2:	d405      	bmi.n	24016fe0 <__fp_unlock+0x14>
24016fd4:	898b      	ldrh	r3, [r1, #12]
24016fd6:	059b      	lsls	r3, r3, #22
24016fd8:	d402      	bmi.n	24016fe0 <__fp_unlock+0x14>
24016fda:	6d88      	ldr	r0, [r1, #88]	; 0x58
24016fdc:	f000 fa01 	bl	240173e2 <__retarget_lock_release_recursive>
24016fe0:	2000      	movs	r0, #0
24016fe2:	bd08      	pop	{r3, pc}

24016fe4 <global_stdio_init.part.0>:
24016fe4:	b510      	push	{r4, lr}
24016fe6:	4b0b      	ldr	r3, [pc, #44]	; (24017014 <global_stdio_init.part.0+0x30>)
24016fe8:	4c0b      	ldr	r4, [pc, #44]	; (24017018 <global_stdio_init.part.0+0x34>)
24016fea:	4a0c      	ldr	r2, [pc, #48]	; (2401701c <global_stdio_init.part.0+0x38>)
24016fec:	601a      	str	r2, [r3, #0]
24016fee:	4620      	mov	r0, r4
24016ff0:	2200      	movs	r2, #0
24016ff2:	2104      	movs	r1, #4
24016ff4:	f7ff ff8e 	bl	24016f14 <std>
24016ff8:	f104 0068 	add.w	r0, r4, #104	; 0x68
24016ffc:	2201      	movs	r2, #1
24016ffe:	2109      	movs	r1, #9
24017000:	f7ff ff88 	bl	24016f14 <std>
24017004:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
24017008:	2202      	movs	r2, #2
2401700a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
2401700e:	2112      	movs	r1, #18
24017010:	f7ff bf80 	b.w	24016f14 <std>
24017014:	240006e4 	.word	0x240006e4
24017018:	240005ac 	.word	0x240005ac
2401701c:	24016f5d 	.word	0x24016f5d

24017020 <__sfp_lock_acquire>:
24017020:	4801      	ldr	r0, [pc, #4]	; (24017028 <__sfp_lock_acquire+0x8>)
24017022:	f000 b9d8 	b.w	240173d6 <__retarget_lock_acquire_recursive>
24017026:	bf00      	nop
24017028:	240006f2 	.word	0x240006f2

2401702c <__sfp_lock_release>:
2401702c:	4801      	ldr	r0, [pc, #4]	; (24017034 <__sfp_lock_release+0x8>)
2401702e:	f000 b9d8 	b.w	240173e2 <__retarget_lock_release_recursive>
24017032:	bf00      	nop
24017034:	240006f2 	.word	0x240006f2

24017038 <__sfp>:
24017038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2401703c:	4607      	mov	r7, r0
2401703e:	f7ff ffef 	bl	24017020 <__sfp_lock_acquire>
24017042:	4b24      	ldr	r3, [pc, #144]	; (240170d4 <__sfp+0x9c>)
24017044:	681b      	ldr	r3, [r3, #0]
24017046:	b90b      	cbnz	r3, 2401704c <__sfp+0x14>
24017048:	f7ff ffcc 	bl	24016fe4 <global_stdio_init.part.0>
2401704c:	4e22      	ldr	r6, [pc, #136]	; (240170d8 <__sfp+0xa0>)
2401704e:	f04f 0804 	mov.w	r8, #4
24017052:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
24017056:	3b01      	subs	r3, #1
24017058:	d50f      	bpl.n	2401707a <__sfp+0x42>
2401705a:	6835      	ldr	r5, [r6, #0]
2401705c:	2d00      	cmp	r5, #0
2401705e:	d137      	bne.n	240170d0 <__sfp+0x98>
24017060:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
24017064:	4638      	mov	r0, r7
24017066:	f000 fa29 	bl	240174bc <_malloc_r>
2401706a:	4604      	mov	r4, r0
2401706c:	bb30      	cbnz	r0, 240170bc <__sfp+0x84>
2401706e:	6030      	str	r0, [r6, #0]
24017070:	f7ff ffdc 	bl	2401702c <__sfp_lock_release>
24017074:	230c      	movs	r3, #12
24017076:	603b      	str	r3, [r7, #0]
24017078:	e01b      	b.n	240170b2 <__sfp+0x7a>
2401707a:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
2401707e:	b9dd      	cbnz	r5, 240170b8 <__sfp+0x80>
24017080:	4b16      	ldr	r3, [pc, #88]	; (240170dc <__sfp+0xa4>)
24017082:	60e3      	str	r3, [r4, #12]
24017084:	f104 0058 	add.w	r0, r4, #88	; 0x58
24017088:	6665      	str	r5, [r4, #100]	; 0x64
2401708a:	f000 f9a0 	bl	240173ce <__retarget_lock_init_recursive>
2401708e:	f7ff ffcd 	bl	2401702c <__sfp_lock_release>
24017092:	e9c4 5501 	strd	r5, r5, [r4, #4]
24017096:	e9c4 5504 	strd	r5, r5, [r4, #16]
2401709a:	6025      	str	r5, [r4, #0]
2401709c:	61a5      	str	r5, [r4, #24]
2401709e:	2208      	movs	r2, #8
240170a0:	4629      	mov	r1, r5
240170a2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
240170a6:	f000 f8c2 	bl	2401722e <memset>
240170aa:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
240170ae:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
240170b2:	4620      	mov	r0, r4
240170b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
240170b8:	3468      	adds	r4, #104	; 0x68
240170ba:	e7cc      	b.n	24017056 <__sfp+0x1e>
240170bc:	e9c0 5800 	strd	r5, r8, [r0]
240170c0:	300c      	adds	r0, #12
240170c2:	60a0      	str	r0, [r4, #8]
240170c4:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
240170c8:	4629      	mov	r1, r5
240170ca:	f000 f8b0 	bl	2401722e <memset>
240170ce:	6034      	str	r4, [r6, #0]
240170d0:	6836      	ldr	r6, [r6, #0]
240170d2:	e7be      	b.n	24017052 <__sfp+0x1a>
240170d4:	240006e4 	.word	0x240006e4
240170d8:	240004c0 	.word	0x240004c0
240170dc:	ffff0001 	.word	0xffff0001

240170e0 <__sinit>:
240170e0:	b510      	push	{r4, lr}
240170e2:	4604      	mov	r4, r0
240170e4:	f7ff ff9c 	bl	24017020 <__sfp_lock_acquire>
240170e8:	6a23      	ldr	r3, [r4, #32]
240170ea:	b11b      	cbz	r3, 240170f4 <__sinit+0x14>
240170ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
240170f0:	f7ff bf9c 	b.w	2401702c <__sfp_lock_release>
240170f4:	4b04      	ldr	r3, [pc, #16]	; (24017108 <__sinit+0x28>)
240170f6:	6223      	str	r3, [r4, #32]
240170f8:	4b04      	ldr	r3, [pc, #16]	; (2401710c <__sinit+0x2c>)
240170fa:	681b      	ldr	r3, [r3, #0]
240170fc:	2b00      	cmp	r3, #0
240170fe:	d1f5      	bne.n	240170ec <__sinit+0xc>
24017100:	f7ff ff70 	bl	24016fe4 <global_stdio_init.part.0>
24017104:	e7f2      	b.n	240170ec <__sinit+0xc>
24017106:	bf00      	nop
24017108:	24016f75 	.word	0x24016f75
2401710c:	240006e4 	.word	0x240006e4

24017110 <__fp_lock_all>:
24017110:	b508      	push	{r3, lr}
24017112:	f7ff ff85 	bl	24017020 <__sfp_lock_acquire>
24017116:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
2401711a:	4a02      	ldr	r2, [pc, #8]	; (24017124 <__fp_lock_all+0x14>)
2401711c:	4902      	ldr	r1, [pc, #8]	; (24017128 <__fp_lock_all+0x18>)
2401711e:	2000      	movs	r0, #0
24017120:	f000 b812 	b.w	24017148 <_fwalk_sglue>
24017124:	240004c0 	.word	0x240004c0
24017128:	24016fb5 	.word	0x24016fb5

2401712c <__fp_unlock_all>:
2401712c:	b508      	push	{r3, lr}
2401712e:	4a04      	ldr	r2, [pc, #16]	; (24017140 <__fp_unlock_all+0x14>)
24017130:	4904      	ldr	r1, [pc, #16]	; (24017144 <__fp_unlock_all+0x18>)
24017132:	2000      	movs	r0, #0
24017134:	f000 f808 	bl	24017148 <_fwalk_sglue>
24017138:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
2401713c:	f7ff bf76 	b.w	2401702c <__sfp_lock_release>
24017140:	240004c0 	.word	0x240004c0
24017144:	24016fcd 	.word	0x24016fcd

24017148 <_fwalk_sglue>:
24017148:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
2401714c:	4607      	mov	r7, r0
2401714e:	4688      	mov	r8, r1
24017150:	4614      	mov	r4, r2
24017152:	2600      	movs	r6, #0
24017154:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
24017158:	f1b9 0901 	subs.w	r9, r9, #1
2401715c:	d505      	bpl.n	2401716a <_fwalk_sglue+0x22>
2401715e:	6824      	ldr	r4, [r4, #0]
24017160:	2c00      	cmp	r4, #0
24017162:	d1f7      	bne.n	24017154 <_fwalk_sglue+0xc>
24017164:	4630      	mov	r0, r6
24017166:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
2401716a:	89ab      	ldrh	r3, [r5, #12]
2401716c:	2b01      	cmp	r3, #1
2401716e:	d907      	bls.n	24017180 <_fwalk_sglue+0x38>
24017170:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
24017174:	3301      	adds	r3, #1
24017176:	d003      	beq.n	24017180 <_fwalk_sglue+0x38>
24017178:	4629      	mov	r1, r5
2401717a:	4638      	mov	r0, r7
2401717c:	47c0      	blx	r8
2401717e:	4306      	orrs	r6, r0
24017180:	3568      	adds	r5, #104	; 0x68
24017182:	e7e9      	b.n	24017158 <_fwalk_sglue+0x10>

24017184 <__sread>:
24017184:	b510      	push	{r4, lr}
24017186:	460c      	mov	r4, r1
24017188:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
2401718c:	f000 f8d0 	bl	24017330 <_read_r>
24017190:	2800      	cmp	r0, #0
24017192:	bfab      	itete	ge
24017194:	6d63      	ldrge	r3, [r4, #84]	; 0x54
24017196:	89a3      	ldrhlt	r3, [r4, #12]
24017198:	181b      	addge	r3, r3, r0
2401719a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
2401719e:	bfac      	ite	ge
240171a0:	6563      	strge	r3, [r4, #84]	; 0x54
240171a2:	81a3      	strhlt	r3, [r4, #12]
240171a4:	bd10      	pop	{r4, pc}

240171a6 <__seofread>:
240171a6:	2000      	movs	r0, #0
240171a8:	4770      	bx	lr

240171aa <__swrite>:
240171aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
240171ae:	461f      	mov	r7, r3
240171b0:	898b      	ldrh	r3, [r1, #12]
240171b2:	05db      	lsls	r3, r3, #23
240171b4:	4605      	mov	r5, r0
240171b6:	460c      	mov	r4, r1
240171b8:	4616      	mov	r6, r2
240171ba:	d505      	bpl.n	240171c8 <__swrite+0x1e>
240171bc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
240171c0:	2302      	movs	r3, #2
240171c2:	2200      	movs	r2, #0
240171c4:	f000 f8a2 	bl	2401730c <_lseek_r>
240171c8:	89a3      	ldrh	r3, [r4, #12]
240171ca:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
240171ce:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
240171d2:	81a3      	strh	r3, [r4, #12]
240171d4:	4632      	mov	r2, r6
240171d6:	463b      	mov	r3, r7
240171d8:	4628      	mov	r0, r5
240171da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
240171de:	f000 b8b9 	b.w	24017354 <_write_r>

240171e2 <__sseek>:
240171e2:	b510      	push	{r4, lr}
240171e4:	460c      	mov	r4, r1
240171e6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
240171ea:	f000 f88f 	bl	2401730c <_lseek_r>
240171ee:	1c43      	adds	r3, r0, #1
240171f0:	89a3      	ldrh	r3, [r4, #12]
240171f2:	bf15      	itete	ne
240171f4:	6560      	strne	r0, [r4, #84]	; 0x54
240171f6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
240171fa:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
240171fe:	81a3      	strheq	r3, [r4, #12]
24017200:	bf18      	it	ne
24017202:	81a3      	strhne	r3, [r4, #12]
24017204:	bd10      	pop	{r4, pc}

24017206 <__sclose>:
24017206:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
2401720a:	f000 b819 	b.w	24017240 <_close_r>

2401720e <memcmp>:
2401720e:	b510      	push	{r4, lr}
24017210:	3901      	subs	r1, #1
24017212:	4402      	add	r2, r0
24017214:	4290      	cmp	r0, r2
24017216:	d101      	bne.n	2401721c <memcmp+0xe>
24017218:	2000      	movs	r0, #0
2401721a:	e005      	b.n	24017228 <memcmp+0x1a>
2401721c:	7803      	ldrb	r3, [r0, #0]
2401721e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
24017222:	42a3      	cmp	r3, r4
24017224:	d001      	beq.n	2401722a <memcmp+0x1c>
24017226:	1b18      	subs	r0, r3, r4
24017228:	bd10      	pop	{r4, pc}
2401722a:	3001      	adds	r0, #1
2401722c:	e7f2      	b.n	24017214 <memcmp+0x6>

2401722e <memset>:
2401722e:	4402      	add	r2, r0
24017230:	4603      	mov	r3, r0
24017232:	4293      	cmp	r3, r2
24017234:	d100      	bne.n	24017238 <memset+0xa>
24017236:	4770      	bx	lr
24017238:	f803 1b01 	strb.w	r1, [r3], #1
2401723c:	e7f9      	b.n	24017232 <memset+0x4>
	...

24017240 <_close_r>:
24017240:	b538      	push	{r3, r4, r5, lr}
24017242:	4d06      	ldr	r5, [pc, #24]	; (2401725c <_close_r+0x1c>)
24017244:	2300      	movs	r3, #0
24017246:	4604      	mov	r4, r0
24017248:	4608      	mov	r0, r1
2401724a:	602b      	str	r3, [r5, #0]
2401724c:	f7ea fc7e 	bl	24001b4c <_close>
24017250:	1c43      	adds	r3, r0, #1
24017252:	d102      	bne.n	2401725a <_close_r+0x1a>
24017254:	682b      	ldr	r3, [r5, #0]
24017256:	b103      	cbz	r3, 2401725a <_close_r+0x1a>
24017258:	6023      	str	r3, [r4, #0]
2401725a:	bd38      	pop	{r3, r4, r5, pc}
2401725c:	240006e8 	.word	0x240006e8

24017260 <_reclaim_reent>:
24017260:	4b29      	ldr	r3, [pc, #164]	; (24017308 <_reclaim_reent+0xa8>)
24017262:	681b      	ldr	r3, [r3, #0]
24017264:	4283      	cmp	r3, r0
24017266:	b570      	push	{r4, r5, r6, lr}
24017268:	4604      	mov	r4, r0
2401726a:	d04b      	beq.n	24017304 <_reclaim_reent+0xa4>
2401726c:	69c3      	ldr	r3, [r0, #28]
2401726e:	b143      	cbz	r3, 24017282 <_reclaim_reent+0x22>
24017270:	68db      	ldr	r3, [r3, #12]
24017272:	2b00      	cmp	r3, #0
24017274:	d144      	bne.n	24017300 <_reclaim_reent+0xa0>
24017276:	69e3      	ldr	r3, [r4, #28]
24017278:	6819      	ldr	r1, [r3, #0]
2401727a:	b111      	cbz	r1, 24017282 <_reclaim_reent+0x22>
2401727c:	4620      	mov	r0, r4
2401727e:	f000 f8b1 	bl	240173e4 <_free_r>
24017282:	6961      	ldr	r1, [r4, #20]
24017284:	b111      	cbz	r1, 2401728c <_reclaim_reent+0x2c>
24017286:	4620      	mov	r0, r4
24017288:	f000 f8ac 	bl	240173e4 <_free_r>
2401728c:	69e1      	ldr	r1, [r4, #28]
2401728e:	b111      	cbz	r1, 24017296 <_reclaim_reent+0x36>
24017290:	4620      	mov	r0, r4
24017292:	f000 f8a7 	bl	240173e4 <_free_r>
24017296:	6b21      	ldr	r1, [r4, #48]	; 0x30
24017298:	b111      	cbz	r1, 240172a0 <_reclaim_reent+0x40>
2401729a:	4620      	mov	r0, r4
2401729c:	f000 f8a2 	bl	240173e4 <_free_r>
240172a0:	6b61      	ldr	r1, [r4, #52]	; 0x34
240172a2:	b111      	cbz	r1, 240172aa <_reclaim_reent+0x4a>
240172a4:	4620      	mov	r0, r4
240172a6:	f000 f89d 	bl	240173e4 <_free_r>
240172aa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
240172ac:	b111      	cbz	r1, 240172b4 <_reclaim_reent+0x54>
240172ae:	4620      	mov	r0, r4
240172b0:	f000 f898 	bl	240173e4 <_free_r>
240172b4:	6ca1      	ldr	r1, [r4, #72]	; 0x48
240172b6:	b111      	cbz	r1, 240172be <_reclaim_reent+0x5e>
240172b8:	4620      	mov	r0, r4
240172ba:	f000 f893 	bl	240173e4 <_free_r>
240172be:	6c61      	ldr	r1, [r4, #68]	; 0x44
240172c0:	b111      	cbz	r1, 240172c8 <_reclaim_reent+0x68>
240172c2:	4620      	mov	r0, r4
240172c4:	f000 f88e 	bl	240173e4 <_free_r>
240172c8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
240172ca:	b111      	cbz	r1, 240172d2 <_reclaim_reent+0x72>
240172cc:	4620      	mov	r0, r4
240172ce:	f000 f889 	bl	240173e4 <_free_r>
240172d2:	6a23      	ldr	r3, [r4, #32]
240172d4:	b1b3      	cbz	r3, 24017304 <_reclaim_reent+0xa4>
240172d6:	4620      	mov	r0, r4
240172d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
240172dc:	4718      	bx	r3
240172de:	5949      	ldr	r1, [r1, r5]
240172e0:	b941      	cbnz	r1, 240172f4 <_reclaim_reent+0x94>
240172e2:	3504      	adds	r5, #4
240172e4:	69e3      	ldr	r3, [r4, #28]
240172e6:	2d80      	cmp	r5, #128	; 0x80
240172e8:	68d9      	ldr	r1, [r3, #12]
240172ea:	d1f8      	bne.n	240172de <_reclaim_reent+0x7e>
240172ec:	4620      	mov	r0, r4
240172ee:	f000 f879 	bl	240173e4 <_free_r>
240172f2:	e7c0      	b.n	24017276 <_reclaim_reent+0x16>
240172f4:	680e      	ldr	r6, [r1, #0]
240172f6:	4620      	mov	r0, r4
240172f8:	f000 f874 	bl	240173e4 <_free_r>
240172fc:	4631      	mov	r1, r6
240172fe:	e7ef      	b.n	240172e0 <_reclaim_reent+0x80>
24017300:	2500      	movs	r5, #0
24017302:	e7ef      	b.n	240172e4 <_reclaim_reent+0x84>
24017304:	bd70      	pop	{r4, r5, r6, pc}
24017306:	bf00      	nop
24017308:	24000518 	.word	0x24000518

2401730c <_lseek_r>:
2401730c:	b538      	push	{r3, r4, r5, lr}
2401730e:	4d07      	ldr	r5, [pc, #28]	; (2401732c <_lseek_r+0x20>)
24017310:	4604      	mov	r4, r0
24017312:	4608      	mov	r0, r1
24017314:	4611      	mov	r1, r2
24017316:	2200      	movs	r2, #0
24017318:	602a      	str	r2, [r5, #0]
2401731a:	461a      	mov	r2, r3
2401731c:	f7ea fc3d 	bl	24001b9a <_lseek>
24017320:	1c43      	adds	r3, r0, #1
24017322:	d102      	bne.n	2401732a <_lseek_r+0x1e>
24017324:	682b      	ldr	r3, [r5, #0]
24017326:	b103      	cbz	r3, 2401732a <_lseek_r+0x1e>
24017328:	6023      	str	r3, [r4, #0]
2401732a:	bd38      	pop	{r3, r4, r5, pc}
2401732c:	240006e8 	.word	0x240006e8

24017330 <_read_r>:
24017330:	b538      	push	{r3, r4, r5, lr}
24017332:	4d07      	ldr	r5, [pc, #28]	; (24017350 <_read_r+0x20>)
24017334:	4604      	mov	r4, r0
24017336:	4608      	mov	r0, r1
24017338:	4611      	mov	r1, r2
2401733a:	2200      	movs	r2, #0
2401733c:	602a      	str	r2, [r5, #0]
2401733e:	461a      	mov	r2, r3
24017340:	f7ea fbcb 	bl	24001ada <_read>
24017344:	1c43      	adds	r3, r0, #1
24017346:	d102      	bne.n	2401734e <_read_r+0x1e>
24017348:	682b      	ldr	r3, [r5, #0]
2401734a:	b103      	cbz	r3, 2401734e <_read_r+0x1e>
2401734c:	6023      	str	r3, [r4, #0]
2401734e:	bd38      	pop	{r3, r4, r5, pc}
24017350:	240006e8 	.word	0x240006e8

24017354 <_write_r>:
24017354:	b538      	push	{r3, r4, r5, lr}
24017356:	4d07      	ldr	r5, [pc, #28]	; (24017374 <_write_r+0x20>)
24017358:	4604      	mov	r4, r0
2401735a:	4608      	mov	r0, r1
2401735c:	4611      	mov	r1, r2
2401735e:	2200      	movs	r2, #0
24017360:	602a      	str	r2, [r5, #0]
24017362:	461a      	mov	r2, r3
24017364:	f7ea fbd6 	bl	24001b14 <_write>
24017368:	1c43      	adds	r3, r0, #1
2401736a:	d102      	bne.n	24017372 <_write_r+0x1e>
2401736c:	682b      	ldr	r3, [r5, #0]
2401736e:	b103      	cbz	r3, 24017372 <_write_r+0x1e>
24017370:	6023      	str	r3, [r4, #0]
24017372:	bd38      	pop	{r3, r4, r5, pc}
24017374:	240006e8 	.word	0x240006e8

24017378 <__errno>:
24017378:	4b01      	ldr	r3, [pc, #4]	; (24017380 <__errno+0x8>)
2401737a:	6818      	ldr	r0, [r3, #0]
2401737c:	4770      	bx	lr
2401737e:	bf00      	nop
24017380:	24000518 	.word	0x24000518

24017384 <__libc_init_array>:
24017384:	b570      	push	{r4, r5, r6, lr}
24017386:	4d0d      	ldr	r5, [pc, #52]	; (240173bc <__libc_init_array+0x38>)
24017388:	4c0d      	ldr	r4, [pc, #52]	; (240173c0 <__libc_init_array+0x3c>)
2401738a:	1b64      	subs	r4, r4, r5
2401738c:	10a4      	asrs	r4, r4, #2
2401738e:	2600      	movs	r6, #0
24017390:	42a6      	cmp	r6, r4
24017392:	d109      	bne.n	240173a8 <__libc_init_array+0x24>
24017394:	4d0b      	ldr	r5, [pc, #44]	; (240173c4 <__libc_init_array+0x40>)
24017396:	4c0c      	ldr	r4, [pc, #48]	; (240173c8 <__libc_init_array+0x44>)
24017398:	f000 f9f0 	bl	2401777c <_init>
2401739c:	1b64      	subs	r4, r4, r5
2401739e:	10a4      	asrs	r4, r4, #2
240173a0:	2600      	movs	r6, #0
240173a2:	42a6      	cmp	r6, r4
240173a4:	d105      	bne.n	240173b2 <__libc_init_array+0x2e>
240173a6:	bd70      	pop	{r4, r5, r6, pc}
240173a8:	f855 3b04 	ldr.w	r3, [r5], #4
240173ac:	4798      	blx	r3
240173ae:	3601      	adds	r6, #1
240173b0:	e7ee      	b.n	24017390 <__libc_init_array+0xc>
240173b2:	f855 3b04 	ldr.w	r3, [r5], #4
240173b6:	4798      	blx	r3
240173b8:	3601      	adds	r6, #1
240173ba:	e7f2      	b.n	240173a2 <__libc_init_array+0x1e>
240173bc:	240004a0 	.word	0x240004a0
240173c0:	240004a0 	.word	0x240004a0
240173c4:	240004a0 	.word	0x240004a0
240173c8:	240004a4 	.word	0x240004a4

240173cc <__retarget_lock_init>:
240173cc:	4770      	bx	lr

240173ce <__retarget_lock_init_recursive>:
240173ce:	4770      	bx	lr

240173d0 <__retarget_lock_close>:
240173d0:	4770      	bx	lr

240173d2 <__retarget_lock_close_recursive>:
240173d2:	4770      	bx	lr

240173d4 <__retarget_lock_acquire>:
240173d4:	4770      	bx	lr

240173d6 <__retarget_lock_acquire_recursive>:
240173d6:	4770      	bx	lr

240173d8 <__retarget_lock_try_acquire>:
240173d8:	2001      	movs	r0, #1
240173da:	4770      	bx	lr

240173dc <__retarget_lock_try_acquire_recursive>:
240173dc:	2001      	movs	r0, #1
240173de:	4770      	bx	lr

240173e0 <__retarget_lock_release>:
240173e0:	4770      	bx	lr

240173e2 <__retarget_lock_release_recursive>:
240173e2:	4770      	bx	lr

240173e4 <_free_r>:
240173e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
240173e6:	2900      	cmp	r1, #0
240173e8:	d044      	beq.n	24017474 <_free_r+0x90>
240173ea:	f851 3c04 	ldr.w	r3, [r1, #-4]
240173ee:	9001      	str	r0, [sp, #4]
240173f0:	2b00      	cmp	r3, #0
240173f2:	f1a1 0404 	sub.w	r4, r1, #4
240173f6:	bfb8      	it	lt
240173f8:	18e4      	addlt	r4, r4, r3
240173fa:	f000 f8df 	bl	240175bc <__malloc_lock>
240173fe:	4a1e      	ldr	r2, [pc, #120]	; (24017478 <_free_r+0x94>)
24017400:	9801      	ldr	r0, [sp, #4]
24017402:	6813      	ldr	r3, [r2, #0]
24017404:	b933      	cbnz	r3, 24017414 <_free_r+0x30>
24017406:	6063      	str	r3, [r4, #4]
24017408:	6014      	str	r4, [r2, #0]
2401740a:	b003      	add	sp, #12
2401740c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
24017410:	f000 b8da 	b.w	240175c8 <__malloc_unlock>
24017414:	42a3      	cmp	r3, r4
24017416:	d908      	bls.n	2401742a <_free_r+0x46>
24017418:	6825      	ldr	r5, [r4, #0]
2401741a:	1961      	adds	r1, r4, r5
2401741c:	428b      	cmp	r3, r1
2401741e:	bf01      	itttt	eq
24017420:	6819      	ldreq	r1, [r3, #0]
24017422:	685b      	ldreq	r3, [r3, #4]
24017424:	1949      	addeq	r1, r1, r5
24017426:	6021      	streq	r1, [r4, #0]
24017428:	e7ed      	b.n	24017406 <_free_r+0x22>
2401742a:	461a      	mov	r2, r3
2401742c:	685b      	ldr	r3, [r3, #4]
2401742e:	b10b      	cbz	r3, 24017434 <_free_r+0x50>
24017430:	42a3      	cmp	r3, r4
24017432:	d9fa      	bls.n	2401742a <_free_r+0x46>
24017434:	6811      	ldr	r1, [r2, #0]
24017436:	1855      	adds	r5, r2, r1
24017438:	42a5      	cmp	r5, r4
2401743a:	d10b      	bne.n	24017454 <_free_r+0x70>
2401743c:	6824      	ldr	r4, [r4, #0]
2401743e:	4421      	add	r1, r4
24017440:	1854      	adds	r4, r2, r1
24017442:	42a3      	cmp	r3, r4
24017444:	6011      	str	r1, [r2, #0]
24017446:	d1e0      	bne.n	2401740a <_free_r+0x26>
24017448:	681c      	ldr	r4, [r3, #0]
2401744a:	685b      	ldr	r3, [r3, #4]
2401744c:	6053      	str	r3, [r2, #4]
2401744e:	440c      	add	r4, r1
24017450:	6014      	str	r4, [r2, #0]
24017452:	e7da      	b.n	2401740a <_free_r+0x26>
24017454:	d902      	bls.n	2401745c <_free_r+0x78>
24017456:	230c      	movs	r3, #12
24017458:	6003      	str	r3, [r0, #0]
2401745a:	e7d6      	b.n	2401740a <_free_r+0x26>
2401745c:	6825      	ldr	r5, [r4, #0]
2401745e:	1961      	adds	r1, r4, r5
24017460:	428b      	cmp	r3, r1
24017462:	bf04      	itt	eq
24017464:	6819      	ldreq	r1, [r3, #0]
24017466:	685b      	ldreq	r3, [r3, #4]
24017468:	6063      	str	r3, [r4, #4]
2401746a:	bf04      	itt	eq
2401746c:	1949      	addeq	r1, r1, r5
2401746e:	6021      	streq	r1, [r4, #0]
24017470:	6054      	str	r4, [r2, #4]
24017472:	e7ca      	b.n	2401740a <_free_r+0x26>
24017474:	b003      	add	sp, #12
24017476:	bd30      	pop	{r4, r5, pc}
24017478:	240006f4 	.word	0x240006f4

2401747c <sbrk_aligned>:
2401747c:	b570      	push	{r4, r5, r6, lr}
2401747e:	4e0e      	ldr	r6, [pc, #56]	; (240174b8 <sbrk_aligned+0x3c>)
24017480:	460c      	mov	r4, r1
24017482:	6831      	ldr	r1, [r6, #0]
24017484:	4605      	mov	r5, r0
24017486:	b911      	cbnz	r1, 2401748e <sbrk_aligned+0x12>
24017488:	f000 f966 	bl	24017758 <_sbrk_r>
2401748c:	6030      	str	r0, [r6, #0]
2401748e:	4621      	mov	r1, r4
24017490:	4628      	mov	r0, r5
24017492:	f000 f961 	bl	24017758 <_sbrk_r>
24017496:	1c43      	adds	r3, r0, #1
24017498:	d00a      	beq.n	240174b0 <sbrk_aligned+0x34>
2401749a:	1cc4      	adds	r4, r0, #3
2401749c:	f024 0403 	bic.w	r4, r4, #3
240174a0:	42a0      	cmp	r0, r4
240174a2:	d007      	beq.n	240174b4 <sbrk_aligned+0x38>
240174a4:	1a21      	subs	r1, r4, r0
240174a6:	4628      	mov	r0, r5
240174a8:	f000 f956 	bl	24017758 <_sbrk_r>
240174ac:	3001      	adds	r0, #1
240174ae:	d101      	bne.n	240174b4 <sbrk_aligned+0x38>
240174b0:	f04f 34ff 	mov.w	r4, #4294967295
240174b4:	4620      	mov	r0, r4
240174b6:	bd70      	pop	{r4, r5, r6, pc}
240174b8:	240006f8 	.word	0x240006f8

240174bc <_malloc_r>:
240174bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
240174c0:	1ccd      	adds	r5, r1, #3
240174c2:	f025 0503 	bic.w	r5, r5, #3
240174c6:	3508      	adds	r5, #8
240174c8:	2d0c      	cmp	r5, #12
240174ca:	bf38      	it	cc
240174cc:	250c      	movcc	r5, #12
240174ce:	2d00      	cmp	r5, #0
240174d0:	4607      	mov	r7, r0
240174d2:	db01      	blt.n	240174d8 <_malloc_r+0x1c>
240174d4:	42a9      	cmp	r1, r5
240174d6:	d905      	bls.n	240174e4 <_malloc_r+0x28>
240174d8:	230c      	movs	r3, #12
240174da:	603b      	str	r3, [r7, #0]
240174dc:	2600      	movs	r6, #0
240174de:	4630      	mov	r0, r6
240174e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
240174e4:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 240175b8 <_malloc_r+0xfc>
240174e8:	f000 f868 	bl	240175bc <__malloc_lock>
240174ec:	f8d8 3000 	ldr.w	r3, [r8]
240174f0:	461c      	mov	r4, r3
240174f2:	bb5c      	cbnz	r4, 2401754c <_malloc_r+0x90>
240174f4:	4629      	mov	r1, r5
240174f6:	4638      	mov	r0, r7
240174f8:	f7ff ffc0 	bl	2401747c <sbrk_aligned>
240174fc:	1c43      	adds	r3, r0, #1
240174fe:	4604      	mov	r4, r0
24017500:	d155      	bne.n	240175ae <_malloc_r+0xf2>
24017502:	f8d8 4000 	ldr.w	r4, [r8]
24017506:	4626      	mov	r6, r4
24017508:	2e00      	cmp	r6, #0
2401750a:	d145      	bne.n	24017598 <_malloc_r+0xdc>
2401750c:	2c00      	cmp	r4, #0
2401750e:	d048      	beq.n	240175a2 <_malloc_r+0xe6>
24017510:	6823      	ldr	r3, [r4, #0]
24017512:	4631      	mov	r1, r6
24017514:	4638      	mov	r0, r7
24017516:	eb04 0903 	add.w	r9, r4, r3
2401751a:	f000 f91d 	bl	24017758 <_sbrk_r>
2401751e:	4581      	cmp	r9, r0
24017520:	d13f      	bne.n	240175a2 <_malloc_r+0xe6>
24017522:	6821      	ldr	r1, [r4, #0]
24017524:	1a6d      	subs	r5, r5, r1
24017526:	4629      	mov	r1, r5
24017528:	4638      	mov	r0, r7
2401752a:	f7ff ffa7 	bl	2401747c <sbrk_aligned>
2401752e:	3001      	adds	r0, #1
24017530:	d037      	beq.n	240175a2 <_malloc_r+0xe6>
24017532:	6823      	ldr	r3, [r4, #0]
24017534:	442b      	add	r3, r5
24017536:	6023      	str	r3, [r4, #0]
24017538:	f8d8 3000 	ldr.w	r3, [r8]
2401753c:	2b00      	cmp	r3, #0
2401753e:	d038      	beq.n	240175b2 <_malloc_r+0xf6>
24017540:	685a      	ldr	r2, [r3, #4]
24017542:	42a2      	cmp	r2, r4
24017544:	d12b      	bne.n	2401759e <_malloc_r+0xe2>
24017546:	2200      	movs	r2, #0
24017548:	605a      	str	r2, [r3, #4]
2401754a:	e00f      	b.n	2401756c <_malloc_r+0xb0>
2401754c:	6822      	ldr	r2, [r4, #0]
2401754e:	1b52      	subs	r2, r2, r5
24017550:	d41f      	bmi.n	24017592 <_malloc_r+0xd6>
24017552:	2a0b      	cmp	r2, #11
24017554:	d917      	bls.n	24017586 <_malloc_r+0xca>
24017556:	1961      	adds	r1, r4, r5
24017558:	42a3      	cmp	r3, r4
2401755a:	6025      	str	r5, [r4, #0]
2401755c:	bf18      	it	ne
2401755e:	6059      	strne	r1, [r3, #4]
24017560:	6863      	ldr	r3, [r4, #4]
24017562:	bf08      	it	eq
24017564:	f8c8 1000 	streq.w	r1, [r8]
24017568:	5162      	str	r2, [r4, r5]
2401756a:	604b      	str	r3, [r1, #4]
2401756c:	4638      	mov	r0, r7
2401756e:	f104 060b 	add.w	r6, r4, #11
24017572:	f000 f829 	bl	240175c8 <__malloc_unlock>
24017576:	f026 0607 	bic.w	r6, r6, #7
2401757a:	1d23      	adds	r3, r4, #4
2401757c:	1af2      	subs	r2, r6, r3
2401757e:	d0ae      	beq.n	240174de <_malloc_r+0x22>
24017580:	1b9b      	subs	r3, r3, r6
24017582:	50a3      	str	r3, [r4, r2]
24017584:	e7ab      	b.n	240174de <_malloc_r+0x22>
24017586:	42a3      	cmp	r3, r4
24017588:	6862      	ldr	r2, [r4, #4]
2401758a:	d1dd      	bne.n	24017548 <_malloc_r+0x8c>
2401758c:	f8c8 2000 	str.w	r2, [r8]
24017590:	e7ec      	b.n	2401756c <_malloc_r+0xb0>
24017592:	4623      	mov	r3, r4
24017594:	6864      	ldr	r4, [r4, #4]
24017596:	e7ac      	b.n	240174f2 <_malloc_r+0x36>
24017598:	4634      	mov	r4, r6
2401759a:	6876      	ldr	r6, [r6, #4]
2401759c:	e7b4      	b.n	24017508 <_malloc_r+0x4c>
2401759e:	4613      	mov	r3, r2
240175a0:	e7cc      	b.n	2401753c <_malloc_r+0x80>
240175a2:	230c      	movs	r3, #12
240175a4:	603b      	str	r3, [r7, #0]
240175a6:	4638      	mov	r0, r7
240175a8:	f000 f80e 	bl	240175c8 <__malloc_unlock>
240175ac:	e797      	b.n	240174de <_malloc_r+0x22>
240175ae:	6025      	str	r5, [r4, #0]
240175b0:	e7dc      	b.n	2401756c <_malloc_r+0xb0>
240175b2:	605b      	str	r3, [r3, #4]
240175b4:	deff      	udf	#255	; 0xff
240175b6:	bf00      	nop
240175b8:	240006f4 	.word	0x240006f4

240175bc <__malloc_lock>:
240175bc:	4801      	ldr	r0, [pc, #4]	; (240175c4 <__malloc_lock+0x8>)
240175be:	f7ff bf0a 	b.w	240173d6 <__retarget_lock_acquire_recursive>
240175c2:	bf00      	nop
240175c4:	240006f1 	.word	0x240006f1

240175c8 <__malloc_unlock>:
240175c8:	4801      	ldr	r0, [pc, #4]	; (240175d0 <__malloc_unlock+0x8>)
240175ca:	f7ff bf0a 	b.w	240173e2 <__retarget_lock_release_recursive>
240175ce:	bf00      	nop
240175d0:	240006f1 	.word	0x240006f1

240175d4 <__sflush_r>:
240175d4:	898a      	ldrh	r2, [r1, #12]
240175d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
240175da:	4605      	mov	r5, r0
240175dc:	0710      	lsls	r0, r2, #28
240175de:	460c      	mov	r4, r1
240175e0:	d458      	bmi.n	24017694 <__sflush_r+0xc0>
240175e2:	684b      	ldr	r3, [r1, #4]
240175e4:	2b00      	cmp	r3, #0
240175e6:	dc05      	bgt.n	240175f4 <__sflush_r+0x20>
240175e8:	6c0b      	ldr	r3, [r1, #64]	; 0x40
240175ea:	2b00      	cmp	r3, #0
240175ec:	dc02      	bgt.n	240175f4 <__sflush_r+0x20>
240175ee:	2000      	movs	r0, #0
240175f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
240175f4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
240175f6:	2e00      	cmp	r6, #0
240175f8:	d0f9      	beq.n	240175ee <__sflush_r+0x1a>
240175fa:	2300      	movs	r3, #0
240175fc:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
24017600:	682f      	ldr	r7, [r5, #0]
24017602:	6a21      	ldr	r1, [r4, #32]
24017604:	602b      	str	r3, [r5, #0]
24017606:	d032      	beq.n	2401766e <__sflush_r+0x9a>
24017608:	6d60      	ldr	r0, [r4, #84]	; 0x54
2401760a:	89a3      	ldrh	r3, [r4, #12]
2401760c:	075a      	lsls	r2, r3, #29
2401760e:	d505      	bpl.n	2401761c <__sflush_r+0x48>
24017610:	6863      	ldr	r3, [r4, #4]
24017612:	1ac0      	subs	r0, r0, r3
24017614:	6b63      	ldr	r3, [r4, #52]	; 0x34
24017616:	b10b      	cbz	r3, 2401761c <__sflush_r+0x48>
24017618:	6c23      	ldr	r3, [r4, #64]	; 0x40
2401761a:	1ac0      	subs	r0, r0, r3
2401761c:	2300      	movs	r3, #0
2401761e:	4602      	mov	r2, r0
24017620:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
24017622:	6a21      	ldr	r1, [r4, #32]
24017624:	4628      	mov	r0, r5
24017626:	47b0      	blx	r6
24017628:	1c43      	adds	r3, r0, #1
2401762a:	89a3      	ldrh	r3, [r4, #12]
2401762c:	d106      	bne.n	2401763c <__sflush_r+0x68>
2401762e:	6829      	ldr	r1, [r5, #0]
24017630:	291d      	cmp	r1, #29
24017632:	d82b      	bhi.n	2401768c <__sflush_r+0xb8>
24017634:	4a29      	ldr	r2, [pc, #164]	; (240176dc <__sflush_r+0x108>)
24017636:	410a      	asrs	r2, r1
24017638:	07d6      	lsls	r6, r2, #31
2401763a:	d427      	bmi.n	2401768c <__sflush_r+0xb8>
2401763c:	2200      	movs	r2, #0
2401763e:	6062      	str	r2, [r4, #4]
24017640:	04d9      	lsls	r1, r3, #19
24017642:	6922      	ldr	r2, [r4, #16]
24017644:	6022      	str	r2, [r4, #0]
24017646:	d504      	bpl.n	24017652 <__sflush_r+0x7e>
24017648:	1c42      	adds	r2, r0, #1
2401764a:	d101      	bne.n	24017650 <__sflush_r+0x7c>
2401764c:	682b      	ldr	r3, [r5, #0]
2401764e:	b903      	cbnz	r3, 24017652 <__sflush_r+0x7e>
24017650:	6560      	str	r0, [r4, #84]	; 0x54
24017652:	6b61      	ldr	r1, [r4, #52]	; 0x34
24017654:	602f      	str	r7, [r5, #0]
24017656:	2900      	cmp	r1, #0
24017658:	d0c9      	beq.n	240175ee <__sflush_r+0x1a>
2401765a:	f104 0344 	add.w	r3, r4, #68	; 0x44
2401765e:	4299      	cmp	r1, r3
24017660:	d002      	beq.n	24017668 <__sflush_r+0x94>
24017662:	4628      	mov	r0, r5
24017664:	f7ff febe 	bl	240173e4 <_free_r>
24017668:	2000      	movs	r0, #0
2401766a:	6360      	str	r0, [r4, #52]	; 0x34
2401766c:	e7c0      	b.n	240175f0 <__sflush_r+0x1c>
2401766e:	2301      	movs	r3, #1
24017670:	4628      	mov	r0, r5
24017672:	47b0      	blx	r6
24017674:	1c41      	adds	r1, r0, #1
24017676:	d1c8      	bne.n	2401760a <__sflush_r+0x36>
24017678:	682b      	ldr	r3, [r5, #0]
2401767a:	2b00      	cmp	r3, #0
2401767c:	d0c5      	beq.n	2401760a <__sflush_r+0x36>
2401767e:	2b1d      	cmp	r3, #29
24017680:	d001      	beq.n	24017686 <__sflush_r+0xb2>
24017682:	2b16      	cmp	r3, #22
24017684:	d101      	bne.n	2401768a <__sflush_r+0xb6>
24017686:	602f      	str	r7, [r5, #0]
24017688:	e7b1      	b.n	240175ee <__sflush_r+0x1a>
2401768a:	89a3      	ldrh	r3, [r4, #12]
2401768c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
24017690:	81a3      	strh	r3, [r4, #12]
24017692:	e7ad      	b.n	240175f0 <__sflush_r+0x1c>
24017694:	690f      	ldr	r7, [r1, #16]
24017696:	2f00      	cmp	r7, #0
24017698:	d0a9      	beq.n	240175ee <__sflush_r+0x1a>
2401769a:	0793      	lsls	r3, r2, #30
2401769c:	680e      	ldr	r6, [r1, #0]
2401769e:	bf08      	it	eq
240176a0:	694b      	ldreq	r3, [r1, #20]
240176a2:	600f      	str	r7, [r1, #0]
240176a4:	bf18      	it	ne
240176a6:	2300      	movne	r3, #0
240176a8:	eba6 0807 	sub.w	r8, r6, r7
240176ac:	608b      	str	r3, [r1, #8]
240176ae:	f1b8 0f00 	cmp.w	r8, #0
240176b2:	dd9c      	ble.n	240175ee <__sflush_r+0x1a>
240176b4:	6a21      	ldr	r1, [r4, #32]
240176b6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
240176b8:	4643      	mov	r3, r8
240176ba:	463a      	mov	r2, r7
240176bc:	4628      	mov	r0, r5
240176be:	47b0      	blx	r6
240176c0:	2800      	cmp	r0, #0
240176c2:	dc06      	bgt.n	240176d2 <__sflush_r+0xfe>
240176c4:	89a3      	ldrh	r3, [r4, #12]
240176c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
240176ca:	81a3      	strh	r3, [r4, #12]
240176cc:	f04f 30ff 	mov.w	r0, #4294967295
240176d0:	e78e      	b.n	240175f0 <__sflush_r+0x1c>
240176d2:	4407      	add	r7, r0
240176d4:	eba8 0800 	sub.w	r8, r8, r0
240176d8:	e7e9      	b.n	240176ae <__sflush_r+0xda>
240176da:	bf00      	nop
240176dc:	dfbffffe 	.word	0xdfbffffe

240176e0 <_fflush_r>:
240176e0:	b538      	push	{r3, r4, r5, lr}
240176e2:	690b      	ldr	r3, [r1, #16]
240176e4:	4605      	mov	r5, r0
240176e6:	460c      	mov	r4, r1
240176e8:	b913      	cbnz	r3, 240176f0 <_fflush_r+0x10>
240176ea:	2500      	movs	r5, #0
240176ec:	4628      	mov	r0, r5
240176ee:	bd38      	pop	{r3, r4, r5, pc}
240176f0:	b118      	cbz	r0, 240176fa <_fflush_r+0x1a>
240176f2:	6a03      	ldr	r3, [r0, #32]
240176f4:	b90b      	cbnz	r3, 240176fa <_fflush_r+0x1a>
240176f6:	f7ff fcf3 	bl	240170e0 <__sinit>
240176fa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
240176fe:	2b00      	cmp	r3, #0
24017700:	d0f3      	beq.n	240176ea <_fflush_r+0xa>
24017702:	6e62      	ldr	r2, [r4, #100]	; 0x64
24017704:	07d0      	lsls	r0, r2, #31
24017706:	d404      	bmi.n	24017712 <_fflush_r+0x32>
24017708:	0599      	lsls	r1, r3, #22
2401770a:	d402      	bmi.n	24017712 <_fflush_r+0x32>
2401770c:	6da0      	ldr	r0, [r4, #88]	; 0x58
2401770e:	f7ff fe62 	bl	240173d6 <__retarget_lock_acquire_recursive>
24017712:	4628      	mov	r0, r5
24017714:	4621      	mov	r1, r4
24017716:	f7ff ff5d 	bl	240175d4 <__sflush_r>
2401771a:	6e63      	ldr	r3, [r4, #100]	; 0x64
2401771c:	07da      	lsls	r2, r3, #31
2401771e:	4605      	mov	r5, r0
24017720:	d4e4      	bmi.n	240176ec <_fflush_r+0xc>
24017722:	89a3      	ldrh	r3, [r4, #12]
24017724:	059b      	lsls	r3, r3, #22
24017726:	d4e1      	bmi.n	240176ec <_fflush_r+0xc>
24017728:	6da0      	ldr	r0, [r4, #88]	; 0x58
2401772a:	f7ff fe5a 	bl	240173e2 <__retarget_lock_release_recursive>
2401772e:	e7dd      	b.n	240176ec <_fflush_r+0xc>

24017730 <fflush>:
24017730:	4601      	mov	r1, r0
24017732:	b920      	cbnz	r0, 2401773e <fflush+0xe>
24017734:	4a04      	ldr	r2, [pc, #16]	; (24017748 <fflush+0x18>)
24017736:	4905      	ldr	r1, [pc, #20]	; (2401774c <fflush+0x1c>)
24017738:	4805      	ldr	r0, [pc, #20]	; (24017750 <fflush+0x20>)
2401773a:	f7ff bd05 	b.w	24017148 <_fwalk_sglue>
2401773e:	4b05      	ldr	r3, [pc, #20]	; (24017754 <fflush+0x24>)
24017740:	6818      	ldr	r0, [r3, #0]
24017742:	f7ff bfcd 	b.w	240176e0 <_fflush_r>
24017746:	bf00      	nop
24017748:	240004c0 	.word	0x240004c0
2401774c:	240176e1 	.word	0x240176e1
24017750:	240004cc 	.word	0x240004cc
24017754:	24000518 	.word	0x24000518

24017758 <_sbrk_r>:
24017758:	b538      	push	{r3, r4, r5, lr}
2401775a:	4d06      	ldr	r5, [pc, #24]	; (24017774 <_sbrk_r+0x1c>)
2401775c:	2300      	movs	r3, #0
2401775e:	4604      	mov	r4, r0
24017760:	4608      	mov	r0, r1
24017762:	602b      	str	r3, [r5, #0]
24017764:	f7ea fa9a 	bl	24001c9c <_sbrk>
24017768:	1c43      	adds	r3, r0, #1
2401776a:	d102      	bne.n	24017772 <_sbrk_r+0x1a>
2401776c:	682b      	ldr	r3, [r5, #0]
2401776e:	b103      	cbz	r3, 24017772 <_sbrk_r+0x1a>
24017770:	6023      	str	r3, [r4, #0]
24017772:	bd38      	pop	{r3, r4, r5, pc}
24017774:	240006e8 	.word	0x240006e8

24017778 <__EH_FRAME_BEGIN__>:
24017778:	00000000                                ....

2401777c <_init>:
2401777c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2401777e:	bf00      	nop
24017780:	bcf8      	pop	{r3, r4, r5, r6, r7}
24017782:	bc08      	pop	{r3}
24017784:	469e      	mov	lr, r3
24017786:	4770      	bx	lr

24017788 <_fini>:
24017788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
2401778a:	bf00      	nop
2401778c:	bcf8      	pop	{r3, r4, r5, r6, r7}
2401778e:	bc08      	pop	{r3}
24017790:	469e      	mov	lr, r3
24017792:	4770      	bx	lr
